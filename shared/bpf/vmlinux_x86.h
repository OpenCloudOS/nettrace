#ifndef __VMLINUX_H__
#define __VMLINUX_H__

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
#endif

typedef unsigned char __u8;

typedef short int __s16;

typedef short unsigned int __u16;

typedef int __s32;

typedef unsigned int __u32;

typedef long long int __s64;

typedef long long unsigned int __u64;

typedef __u8 u8;

typedef __s16 s16;

typedef __u16 u16;

typedef __s32 s32;

typedef __u32 u32;

typedef __s64 s64;

typedef __u64 u64;

enum {
	false = 0,
	true = 1,
};

typedef long int __kernel_long_t;

typedef long unsigned int __kernel_ulong_t;

typedef int __kernel_pid_t;

typedef unsigned int __kernel_uid32_t;

typedef unsigned int __kernel_gid32_t;

typedef __kernel_ulong_t __kernel_size_t;

typedef __kernel_long_t __kernel_ssize_t;

typedef long long int __kernel_loff_t;

typedef long long int __kernel_time64_t;

typedef __kernel_long_t __kernel_clock_t;

typedef int __kernel_timer_t;

typedef int __kernel_clockid_t;

typedef unsigned int __poll_t;

typedef u32 __kernel_dev_t;

typedef __kernel_dev_t dev_t;

typedef short unsigned int umode_t;

typedef __kernel_pid_t pid_t;

typedef __kernel_clockid_t clockid_t;

typedef _Bool bool;

typedef __kernel_uid32_t uid_t;

typedef __kernel_gid32_t gid_t;

typedef __kernel_loff_t loff_t;

typedef __kernel_size_t size_t;

typedef __kernel_ssize_t ssize_t;

typedef u32 uint32_t;

typedef u64 sector_t;

typedef u64 blkcnt_t;

typedef u64 dma_addr_t;

typedef unsigned int gfp_t;

typedef unsigned int fmode_t;

typedef u64 phys_addr_t;

typedef phys_addr_t resource_size_t;

typedef struct {
	int counter;
} atomic_t;

typedef struct {
	s64 counter;
} atomic64_t;

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

struct hlist_node;

struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next;
	struct hlist_node **pprev;
};

struct callback_head {
	struct callback_head *next;
	void (*func)(struct callback_head *);
};

struct lock_class_key {};

struct fs_context;

struct fs_parameter_description;

struct dentry;

struct super_block;

struct module;

struct file_system_type {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_description *parameters;
	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
	void (*kill_sb)(struct super_block *);
	struct module *owner;
	struct file_system_type *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key i_mutex_dir_key;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

typedef void *fl_owner_t;

struct file;

struct kiocb;

struct iov_iter;

struct dir_context;

struct poll_table_struct;

struct vm_area_struct;

struct inode;

struct file_lock;

struct page;

struct pipe_inode_info;

struct seq_file;

struct file_operations {
	struct module *owner;
	loff_t (*llseek)(struct file *, loff_t, int);
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *, bool);
	int (*iterate)(struct file *, struct dir_context *);
	int (*iterate_shared)(struct file *, struct dir_context *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	long unsigned int mmap_supported_flags;
	int (*open)(struct inode *, struct file *);
	int (*flush)(struct file *, fl_owner_t);
	int (*release)(struct inode *, struct file *);
	int (*fsync)(struct file *, loff_t, loff_t, int);
	int (*fasync)(int, struct file *, int);
	int (*lock)(struct file *, int, struct file_lock *);
	ssize_t (*sendpage)(struct file *, struct page *, int, size_t, loff_t *, int);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*check_flags)(int);
	int (*flock)(struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long int, struct file_lock **, void **);
	long int (*fallocate)(struct file *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file *, struct file *);
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

typedef atomic64_t atomic_long_t;

typedef __s64 time64_t;

struct __kernel_timespec {
	__kernel_time64_t tv_sec;
	long long int tv_nsec;
};

struct timespec64 {
	time64_t tv_sec;
	long int tv_nsec;
};

enum timespec_type {
	TT_NONE = 0,
	TT_NATIVE = 1,
	TT_COMPAT = 2,
};

typedef s32 old_time32_t;

struct old_timespec32 {
	old_time32_t tv_sec;
	s32 tv_nsec;
};

struct pollfd;

struct restart_block {
	long int (*fn)(struct restart_block *);
	union {
		struct {
			u32 *uaddr;
			u32 val;
			u32 flags;
			u32 bitset;
			u64 time;
			u32 *uaddr2;
		} futex;
		struct {
			clockid_t clockid;
			enum timespec_type type;
			union {
				struct __kernel_timespec *rmtp;
				struct old_timespec32 *compat_rmtp;
			};
			u64 expires;
		} nanosleep;
		struct {
			struct pollfd *ufds;
			int nfds;
			int has_timeout;
			long unsigned int tv_sec;
			long unsigned int tv_nsec;
		} poll;
	};
};

struct thread_info {
	long unsigned int flags;
	u32 status;
};

struct refcount_struct {
	atomic_t refs;
};

typedef struct refcount_struct refcount_t;

struct llist_node {
	struct llist_node *next;
};

struct load_weight {
	long unsigned int weight;
	u32 inv_weight;
};

struct rb_node {
	long unsigned int __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
};

struct sched_statistics {
	u64 wait_start;
	u64 wait_max;
	u64 wait_count;
	u64 wait_sum;
	u64 iowait_count;
	u64 iowait_sum;
	u64 sleep_start;
	u64 sleep_max;
	s64 sum_sleep_runtime;
	u64 block_start;
	u64 block_max;
	u64 exec_max;
	u64 slice_max;
	u64 nr_migrations_cold;
	u64 nr_failed_migrations_affine;
	u64 nr_failed_migrations_running;
	u64 nr_failed_migrations_hot;
	u64 nr_forced_migrations;
	u64 nr_wakeups;
	u64 nr_wakeups_sync;
	u64 nr_wakeups_migrate;
	u64 nr_wakeups_local;
	u64 nr_wakeups_remote;
	u64 nr_wakeups_affine;
	u64 nr_wakeups_affine_attempts;
	u64 nr_wakeups_passive;
	u64 nr_wakeups_idle;
};

struct util_est {
	unsigned int enqueued;
	unsigned int ewma;
};

struct sched_avg {
	u64 last_update_time;
	u64 load_sum;
	u64 runnable_load_sum;
	u32 util_sum;
	u32 period_contrib;
	long unsigned int load_avg;
	long unsigned int runnable_load_avg;
	long unsigned int util_avg;
	struct util_est util_est;
};

struct cfs_rq;

struct sched_entity {
	struct load_weight load;
	long unsigned int runnable_weight;
	struct rb_node run_node;
	struct list_head group_node;
	unsigned int on_rq;
	u64 exec_start;
	u64 sum_exec_runtime;
	u64 vruntime;
	u64 prev_sum_exec_runtime;
	u64 nr_migrations;
	struct sched_statistics statistics;
	int depth;
	struct sched_entity *parent;
	struct cfs_rq *cfs_rq;
	struct cfs_rq *my_q;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rt_rq;

struct sched_rt_entity {
	struct list_head run_list;
	long unsigned int timeout;
	long unsigned int watchdog_stamp;
	unsigned int time_slice;
	short unsigned int on_rq;
	short unsigned int on_list;
	struct sched_rt_entity *back;
	struct sched_rt_entity *parent;
	struct rt_rq *rt_rq;
	struct rt_rq *my_q;
};

typedef s64 ktime_t;

struct timerqueue_node {
	struct rb_node node;
	ktime_t expires;
};

enum hrtimer_restart {
	HRTIMER_NORESTART = 0,
	HRTIMER_RESTART = 1,
};

struct hrtimer_clock_base;

struct hrtimer {
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *);
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
};

struct sched_dl_entity {
	struct rb_node rb_node;
	u64 dl_runtime;
	u64 dl_deadline;
	u64 dl_period;
	u64 dl_bw;
	u64 dl_density;
	s64 runtime;
	u64 deadline;
	unsigned int flags;
	unsigned int dl_throttled: 1;
	unsigned int dl_boosted: 1;
	unsigned int dl_yielded: 1;
	unsigned int dl_non_contending: 1;
	unsigned int dl_overrun: 1;
	struct hrtimer dl_timer;
	struct hrtimer inactive_timer;
};

struct cpumask {
	long unsigned int bits[128];
};

typedef struct cpumask cpumask_t;

struct sched_info {
	long unsigned int pcount;
	long long unsigned int run_delay;
	long long unsigned int last_arrival;
	long long unsigned int last_queued;
	long unsigned int task_switch;
	long unsigned int kernel_exec_start;
	long unsigned int utime;
};

struct plist_node {
	int prio;
	struct list_head prio_list;
	struct list_head node_list;
};

struct vmacache {
	u64 seqnum;
	struct vm_area_struct *vmas[4];
};

struct task_rss_stat {
	int events;
	int count[4];
};

struct qspinlock {
	union {
		atomic_t val;
		struct {
			u8 locked;
			u8 pending;
		};
		struct {
			u16 locked_pending;
			u16 tail;
		};
	};
};

typedef struct qspinlock arch_spinlock_t;

struct raw_spinlock {
	arch_spinlock_t raw_lock;
};

typedef struct raw_spinlock raw_spinlock_t;

struct prev_cputime {
	u64 utime;
	u64 stime;
	raw_spinlock_t lock;
};

struct rb_root {
	struct rb_node *rb_node;
};

struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};

struct timerqueue_head {
	struct rb_root_cached rb_root;
};

struct posix_cputimer_base {
	u64 nextevt;
	struct timerqueue_head tqhead;
};

struct posix_cputimers {
	struct posix_cputimer_base bases[3];
	unsigned int timers_active;
	unsigned int expiry_active;
};

struct sem_undo_list;

struct sysv_sem {
	struct sem_undo_list *undo_list;
};

struct sysv_shm {
	struct list_head shm_clist;
};

typedef struct {
	long unsigned int sig[1];
} sigset_t;

struct sigpending {
	struct list_head list;
	sigset_t signal;
};

typedef struct {
	uid_t val;
} kuid_t;

struct seccomp_filter;

struct seccomp {
	int mode;
	struct seccomp_filter *filter;
};

struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
};

typedef struct spinlock spinlock_t;

struct wake_q_node {
	struct wake_q_node *next;
};

struct task_io_accounting {
	u64 rchar;
	u64 wchar;
	u64 syscr;
	u64 syscw;
	u64 read_bytes;
	u64 write_bytes;
	u64 cancelled_write_bytes;
};

typedef struct {
	long unsigned int bits[16];
} nodemask_t;

struct seqcount {
	unsigned int sequence;
};

typedef struct seqcount seqcount_t;

struct optimistic_spin_queue {
	atomic_t tail;
};

struct mutex {
	atomic_long_t owner;
	spinlock_t wait_lock;
	struct optimistic_spin_queue osq;
	struct list_head wait_list;
};

struct arch_tlbflush_unmap_batch {
	struct cpumask cpumask;
};

struct tlbflush_unmap_batch {
	struct arch_tlbflush_unmap_batch arch;
	bool flush_required;
	bool writable;
};

struct page_frag {
	struct page *page;
	__u32 offset;
	__u32 size;
};

struct latency_record {
	long unsigned int backtrace[12];
	unsigned int count;
	long unsigned int time;
	long unsigned int max;
};

struct desc_struct {
	u16 limit0;
	u16 base0;
	u16 base1: 8;
	u16 type: 4;
	u16 s: 1;
	u16 dpl: 2;
	u16 p: 1;
	u16 limit1: 4;
	u16 avl: 1;
	u16 l: 1;
	u16 d: 1;
	u16 g: 1;
	u16 base2: 8;
};

typedef struct {
	long unsigned int seg;
} mm_segment_t;

struct fregs_state {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
	u32 status;
};

struct fxregs_state {
	u16 cwd;
	u16 swd;
	u16 twd;
	u16 fop;
	union {
		struct {
			u64 rip;
			u64 rdp;
		};
		struct {
			u32 fip;
			u32 fcs;
			u32 foo;
			u32 fos;
		};
	};
	u32 mxcsr;
	u32 mxcsr_mask;
	u32 st_space[32];
	u32 xmm_space[64];
	u32 padding[12];
	union {
		u32 padding1[12];
		u32 sw_reserved[12];
	};
};

struct math_emu_info;

struct swregs_state {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
	u8 ftop;
	u8 changed;
	u8 lookahead;
	u8 no_update;
	u8 rm;
	u8 alimit;
	struct math_emu_info *info;
	u32 entry_eip;
};

struct xstate_header {
	u64 xfeatures;
	u64 xcomp_bv;
	u64 reserved[6];
};

struct xregs_state {
	struct fxregs_state i387;
	struct xstate_header header;
	u8 extended_state_area[0];
};

union fpregs_state {
	struct fregs_state fsave;
	struct fxregs_state fxsave;
	struct swregs_state soft;
	struct xregs_state xsave;
	u8 __padding[4096];
};

struct fpu {
	unsigned int last_cpu;
	long unsigned int avx512_timestamp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union fpregs_state state;
};

struct perf_event;

struct thread_struct {
	struct desc_struct tls_array[3];
	long unsigned int sp;
	short unsigned int es;
	short unsigned int ds;
	short unsigned int fsindex;
	short unsigned int gsindex;
	long unsigned int fsbase;
	long unsigned int gsbase;
	struct perf_event *ptrace_bps[4];
	long unsigned int debugreg6;
	long unsigned int ptrace_dr7;
	long unsigned int cr2;
	long unsigned int trap_nr;
	long unsigned int error_code;
	long unsigned int *io_bitmap_ptr;
	long unsigned int iopl;
	unsigned int io_bitmap_max;
	mm_segment_t addr_limit;
	unsigned int sig_on_uaccess_err: 1;
	unsigned int uaccess_err: 1;
	long: 62;
	long: 64;
	long: 64;
	long: 64;
	struct fpu fpu;
};

struct sched_class;

struct task_group;

struct mm_struct;

struct pid;

struct completion;

struct cred;

struct key;

struct nameidata;

struct fs_struct;

struct files_struct;

struct nsproxy;

struct signal_struct;

struct sighand_struct;

struct audit_context;

struct rt_mutex_waiter;

struct bio_list;

struct blk_plug;

struct reclaim_state;

struct backing_dev_info;

struct io_context;

struct capture_control;

struct kernel_siginfo;

typedef struct kernel_siginfo kernel_siginfo_t;

struct css_set;

struct robust_list_head;

struct compat_robust_list_head;

struct futex_pi_state;

struct perf_event_context;

struct mempolicy;

struct numa_group;

struct rseq;

struct task_delay_info;

struct ftrace_ret_stack;

struct mem_cgroup;

struct request_queue;

struct uprobe_task;

struct vm_struct;

struct task_struct {
	struct thread_info thread_info;
	volatile long int state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	struct llist_node wake_entry;
	int on_cpu;
	unsigned int cpu;
	unsigned int wakee_flips;
	long unsigned int wakee_flip_decay_ts;
	struct task_struct *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	const struct sched_class *sched_class;
	struct sched_entity se;
	struct sched_rt_entity rt;
	struct task_group *sched_task_group;
	struct sched_dl_entity dl;
	struct hlist_head preempt_notifiers;
	unsigned int btrace_seq;
	unsigned int policy;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t cpus_mask;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct *mm;
	struct mm_struct *active_mm;
	struct vmacache vmacache;
	struct task_rss_stat rss_stat;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	long unsigned int jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	unsigned int sched_remote_wakeup: 1;
	unsigned int sched_psi_wake_requeue: 1;
	int: 27;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int restore_sigmask: 1;
	unsigned int in_user_fault: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	unsigned int use_memdelay: 1;
	long unsigned int atomic_flags;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	long unsigned int stack_canary;
	struct task_struct *real_parent;
	struct task_struct *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_group;
	struct list_head thread_node;
	struct completion *vfork_done;
	int *set_child_tid;
	int *clear_child_tid;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	u64 start_time;
	u64 real_start_time;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	struct posix_cputimers posix_cputimers;
	const struct cred *ptracer_cred;
	const struct cred *real_cred;
	const struct cred *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	long unsigned int last_switch_count;
	long unsigned int last_switch_time;
	struct fs_struct *fs;
	struct files_struct *files;
	struct nsproxy *nsproxy;
	struct signal_struct *signal;
	struct sighand_struct *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	long unsigned int sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct audit_context *audit_context;
	kuid_t loginuid;
	unsigned int sessionid;
	struct seccomp seccomp;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	struct rb_root_cached pi_waiters;
	struct task_struct *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct backing_dev_info *backing_dev_info;
	struct io_context *io_context;
	struct capture_control *capture_control;
	long unsigned int ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	unsigned int psi_flags;
	u64 acct_rss_mem1;
	u64 acct_vm_mem1;
	u64 acct_timexpd;
	nodemask_t mems_allowed;
	seqcount_t mems_allowed_seq;
	int cpuset_mem_spread_rotor;
	int cpuset_slab_spread_rotor;
	struct css_set *cgroups;
	struct list_head cg_list;
	u32 closid;
	u32 rmid;
	struct robust_list_head *robust_list;
	struct compat_robust_list_head *compat_robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	struct perf_event_context *perf_event_ctxp[2];
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	struct mempolicy *mempolicy;
	short int il_prev;
	short int pref_node_fork;
	int numa_scan_seq;
	unsigned int numa_scan_period;
	unsigned int numa_scan_period_max;
	int numa_preferred_nid;
	long unsigned int numa_migrate_retry;
	u64 node_stamp;
	u64 last_task_numa_placement;
	u64 last_sum_exec_runtime;
	struct callback_head numa_work;
	struct numa_group *numa_group;
	long unsigned int *numa_faults;
	long unsigned int total_numa_faults;
	long unsigned int numa_faults_locality[3];
	long unsigned int numa_pages_migrated;
	struct rseq *rseq;
	u32 rseq_sig;
	long unsigned int rseq_event_mask;
	struct tlbflush_unmap_batch tlb_ubc;
	union {
		refcount_t rcu_users;
		struct callback_head rcu;
	};
	struct pipe_inode_info *splice_pipe;
	struct page_frag task_frag;
	struct task_delay_info *delays;
	int nr_dirtied;
	int nr_dirtied_pause;
	long unsigned int dirty_paused_when;
	int latency_record_count;
	struct latency_record latency_record[32];
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	int curr_ret_stack;
	int curr_ret_depth;
	struct ftrace_ret_stack *ret_stack;
	long long unsigned int ftrace_timestamp;
	atomic_t trace_overrun;
	atomic_t tracing_graph_pause;
	long unsigned int trace;
	long unsigned int trace_recursion;
	struct mem_cgroup *memcg_in_oom;
	gfp_t memcg_oom_gfp_mask;
	int memcg_oom_order;
	unsigned int memcg_nr_pages_over_high;
	struct mem_cgroup *active_memcg;
	struct request_queue *throttle_queue;
	struct uprobe_task *utask;
	unsigned int sequential_io;
	unsigned int sequential_io_avg;
	int pagefault_disabled;
	struct task_struct *oom_reaper_list;
	struct vm_struct *stack_vm_area;
	refcount_t stack_refcount;
	int patch_state;
	void *security;
	void *mce_vaddr;
	__u64 mce_kflags;
	u64 mce_addr;
	__u64 mce_ripv: 1;
	__u64 mce_whole_page: 1;
	__u64 __mce_reserved: 62;
	struct callback_head mce_kill_me;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct thread_struct thread;
};

struct screen_info {
	__u8 orig_x;
	__u8 orig_y;
	__u16 ext_mem_k;
	__u16 orig_video_page;
	__u8 orig_video_mode;
	__u8 orig_video_cols;
	__u8 flags;
	__u8 unused2;
	__u16 orig_video_ega_bx;
	__u16 unused3;
	__u8 orig_video_lines;
	__u8 orig_video_isVGA;
	__u16 orig_video_points;
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u32 lfb_base;
	__u32 lfb_size;
	__u16 cl_magic;
	__u16 cl_offset;
	__u16 lfb_linelength;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
	__u16 vesapm_seg;
	__u16 vesapm_off;
	__u16 pages;
	__u16 vesa_attributes;
	__u32 capabilities;
	__u32 ext_lfb_base;
	__u8 _reserved[2];
} __attribute__((packed));

struct apm_bios_info {
	__u16 version;
	__u16 cseg;
	__u32 offset;
	__u16 cseg_16;
	__u16 dseg;
	__u16 flags;
	__u16 cseg_len;
	__u16 cseg_16_len;
	__u16 dseg_len;
};

struct edd_device_params {
	__u16 length;
	__u16 info_flags;
	__u32 num_default_cylinders;
	__u32 num_default_heads;
	__u32 sectors_per_track;
	__u64 number_of_sectors;
	__u16 bytes_per_sector;
	__u32 dpte_ptr;
	__u16 key;
	__u8 device_path_info_length;
	__u8 reserved2;
	__u16 reserved3;
	__u8 host_bus_type[4];
	__u8 interface_type[8];
	union {
		struct {
			__u16 base_address;
			__u16 reserved1;
			__u32 reserved2;
		} isa;
		struct {
			__u8 bus;
			__u8 slot;
			__u8 function;
			__u8 channel;
			__u32 reserved;
		} pci;
		struct {
			__u64 reserved;
		} ibnd;
		struct {
			__u64 reserved;
		} xprs;
		struct {
			__u64 reserved;
		} htpt;
		struct {
			__u64 reserved;
		} unknown;
	} interface_path;
	union {
		struct {
			__u8 device;
			__u8 reserved1;
			__u16 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} ata;
		struct {
			__u8 device;
			__u8 lun;
			__u8 reserved1;
			__u8 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} atapi;
		struct {
			__u16 id;
			__u64 lun;
			__u16 reserved1;
			__u32 reserved2;
		} __attribute__((packed)) scsi;
		struct {
			__u64 serial_number;
			__u64 reserved;
		} usb;
		struct {
			__u64 eui;
			__u64 reserved;
		} i1394;
		struct {
			__u64 wwid;
			__u64 lun;
		} fibre;
		struct {
			__u64 identity_tag;
			__u64 reserved;
		} i2o;
		struct {
			__u32 array_number;
			__u32 reserved1;
			__u64 reserved2;
		} raid;
		struct {
			__u8 device;
			__u8 reserved1;
			__u16 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} sata;
		struct {
			__u64 reserved1;
			__u64 reserved2;
		} unknown;
	} device_path;
	__u8 reserved4;
	__u8 checksum;
} __attribute__((packed));

struct edd_info {
	__u8 device;
	__u8 version;
	__u16 interface_support;
	__u16 legacy_max_cylinder;
	__u8 legacy_max_head;
	__u8 legacy_sectors_per_track;
	struct edd_device_params params;
} __attribute__((packed));

struct ist_info {
	__u32 signature;
	__u32 command;
	__u32 event;
	__u32 perf_level;
};

struct edid_info {
	unsigned char dummy[128];
};

struct setup_header {
	__u8 setup_sects;
	__u16 root_flags;
	__u32 syssize;
	__u16 ram_size;
	__u16 vid_mode;
	__u16 root_dev;
	__u16 boot_flag;
	__u16 jump;
	__u32 header;
	__u16 version;
	__u32 realmode_swtch;
	__u16 start_sys_seg;
	__u16 kernel_version;
	__u8 type_of_loader;
	__u8 loadflags;
	__u16 setup_move_size;
	__u32 code32_start;
	__u32 ramdisk_image;
	__u32 ramdisk_size;
	__u32 bootsect_kludge;
	__u16 heap_end_ptr;
	__u8 ext_loader_ver;
	__u8 ext_loader_type;
	__u32 cmd_line_ptr;
	__u32 initrd_addr_max;
	__u32 kernel_alignment;
	__u8 relocatable_kernel;
	__u8 min_alignment;
	__u16 xloadflags;
	__u32 cmdline_size;
	__u32 hardware_subarch;
	__u64 hardware_subarch_data;
	__u32 payload_offset;
	__u32 payload_length;
	__u64 setup_data;
	__u64 pref_address;
	__u32 init_size;
	__u32 handover_offset;
} __attribute__((packed));

struct sys_desc_table {
	__u16 length;
	__u8 table[14];
};

struct olpc_ofw_header {
	__u32 ofw_magic;
	__u32 ofw_version;
	__u32 cif_handler;
	__u32 irq_desc_table;
};

struct efi_info {
	__u32 efi_loader_signature;
	__u32 efi_systab;
	__u32 efi_memdesc_size;
	__u32 efi_memdesc_version;
	__u32 efi_memmap;
	__u32 efi_memmap_size;
	__u32 efi_systab_hi;
	__u32 efi_memmap_hi;
};

struct boot_e820_entry {
	__u64 addr;
	__u64 size;
	__u32 type;
} __attribute__((packed));

struct boot_params {
	struct screen_info screen_info;
	struct apm_bios_info apm_bios_info;
	__u8 _pad2[4];
	__u64 tboot_addr;
	struct ist_info ist_info;
	__u64 acpi_rsdp_addr;
	__u8 _pad3[8];
	__u8 hd0_info[16];
	__u8 hd1_info[16];
	struct sys_desc_table sys_desc_table;
	struct olpc_ofw_header olpc_ofw_header;
	__u32 ext_ramdisk_image;
	__u32 ext_ramdisk_size;
	__u32 ext_cmd_line_ptr;
	__u8 _pad4[116];
	struct edid_info edid_info;
	struct efi_info efi_info;
	__u32 alt_mem_k;
	__u32 scratch;
	__u8 e820_entries;
	__u8 eddbuf_entries;
	__u8 edd_mbr_sig_buf_entries;
	__u8 kbd_status;
	__u8 secure_boot;
	__u8 _pad5[2];
	__u8 sentinel;
	__u8 _pad6[1];
	struct setup_header hdr;
	__u8 _pad7[40];
	__u32 edd_mbr_sig_buffer[16];
	struct boot_e820_entry e820_table[128];
	__u8 _pad8[48];
	struct edd_info eddbuf[6];
	__u8 _pad9[276];
} __attribute__((packed));

enum x86_hardware_subarch {
	X86_SUBARCH_PC = 0,
	X86_SUBARCH_LGUEST = 1,
	X86_SUBARCH_XEN = 2,
	X86_SUBARCH_INTEL_MID = 3,
	X86_SUBARCH_CE4100 = 4,
	X86_NR_SUBARCHS = 5,
};

struct pt_regs {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bp;
	long unsigned int bx;
	long unsigned int r11;
	long unsigned int r10;
	long unsigned int r9;
	long unsigned int r8;
	long unsigned int ax;
	long unsigned int cx;
	long unsigned int dx;
	long unsigned int si;
	long unsigned int di;
	long unsigned int orig_ax;
	long unsigned int ip;
	long unsigned int cs;
	long unsigned int flags;
	long unsigned int sp;
	long unsigned int ss;
};

typedef long unsigned int pteval_t;

typedef long unsigned int pmdval_t;

typedef long unsigned int pudval_t;

typedef long unsigned int p4dval_t;

typedef long unsigned int pgdval_t;

typedef long unsigned int pgprotval_t;

typedef struct {
	pteval_t pte;
} pte_t;

struct pgprot {
	pgprotval_t pgprot;
};

typedef struct pgprot pgprot_t;

typedef struct {
	pgdval_t pgd;
} pgd_t;

typedef struct {
	p4dval_t p4d;
} p4d_t;

typedef struct {
	pudval_t pud;
} pud_t;

typedef struct {
	pmdval_t pmd;
} pmd_t;

typedef struct page *pgtable_t;

struct address_space;

struct kmem_cache;

struct dev_pagemap;

struct page {
	long unsigned int flags;
	union {
		struct {
			struct list_head lru;
			struct address_space *mapping;
			long unsigned int index;
			long unsigned int private;
		};
		struct {
			dma_addr_t dma_addr;
		};
		struct {
			union {
				struct list_head slab_list;
				struct {
					struct page *next;
					int pages;
					int pobjects;
				};
			};
			struct kmem_cache *slab_cache;
			void *freelist;
			union {
				void *s_mem;
				long unsigned int counters;
				struct {
					unsigned int inuse: 16;
					unsigned int objects: 15;
					unsigned int frozen: 1;
				};
			};
		};
		struct {
			long unsigned int compound_head;
			unsigned char compound_dtor;
			unsigned char compound_order;
			atomic_t compound_mapcount;
		};
		struct {
			long unsigned int _compound_pad_1;
			long unsigned int _compound_pad_2;
			struct list_head deferred_list;
		};
		struct {
			long unsigned int _pt_pad_1;
			pgtable_t pmd_huge_pte;
			long unsigned int _pt_pad_2;
			union {
				struct mm_struct *pt_mm;
				atomic_t pt_frag_refcount;
			};
			spinlock_t ptl;
		};
		struct {
			struct dev_pagemap *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		atomic_t _mapcount;
		unsigned int page_type;
		unsigned int active;
		int units;
	};
	atomic_t _refcount;
	struct mem_cgroup *mem_cgroup;
};

struct rw_semaphore {
	atomic_long_t count;
	atomic_long_t owner;
	struct optimistic_spin_queue osq;
	raw_spinlock_t wait_lock;
	struct list_head wait_list;
};

struct mm_rss_stat {
	atomic_long_t count[4];
};

struct ldt_struct;

struct vdso_image;

typedef struct {
	u64 ctx_id;
	atomic64_t tlb_gen;
	struct rw_semaphore ldt_usr_sem;
	struct ldt_struct *ldt;
	short unsigned int ia32_compat;
	struct mutex lock;
	void *vdso;
	const struct vdso_image *vdso_image;
	atomic_t perf_rdpmc_allowed;
	u16 pkey_allocation_map;
	s16 execute_only_pkey;
	void *bd_addr;
} mm_context_t;

struct xol_area;

struct uprobes_state {
	struct xol_area *xol_area;
};

struct work_struct;

typedef void (*work_func_t)(struct work_struct *);

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct linux_binfmt;

struct core_state;

struct kioctx_table;

struct user_namespace;

struct mmu_notifier_mm;

struct mm_struct {
	struct {
		struct vm_area_struct *mmap;
		struct rb_root mm_rb;
		u64 vmacache_seqnum;
		long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
		long unsigned int mmap_base;
		long unsigned int mmap_legacy_base;
		long unsigned int mmap_compat_base;
		long unsigned int mmap_compat_legacy_base;
		long unsigned int task_size;
		long unsigned int highest_vm_end;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		atomic_t mm_count;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_sem;
		struct list_head mmlist;
		long unsigned int hiwater_rss;
		long unsigned int hiwater_vm;
		long unsigned int total_vm;
		long unsigned int locked_vm;
		atomic64_t pinned_vm;
		long unsigned int data_vm;
		long unsigned int exec_vm;
		long unsigned int stack_vm;
		long unsigned int def_flags;
		spinlock_t arg_lock;
		long unsigned int start_code;
		long unsigned int end_code;
		long unsigned int start_data;
		long unsigned int end_data;
		long unsigned int start_brk;
		long unsigned int brk;
		long unsigned int start_stack;
		long unsigned int arg_start;
		long unsigned int arg_end;
		long unsigned int env_start;
		long unsigned int env_end;
		long unsigned int saved_auxv[46];
		struct mm_rss_stat rss_stat;
		struct linux_binfmt *binfmt;
		mm_context_t context;
		long unsigned int flags;
		struct core_state *core_state;
		spinlock_t ioctx_lock;
		struct kioctx_table *ioctx_table;
		struct task_struct *owner;
		struct user_namespace *user_ns;
		struct file *exe_file;
		struct mmu_notifier_mm *mmu_notifier_mm;
		long unsigned int numa_next_scan;
		long unsigned int numa_scan_offset;
		int numa_scan_seq;
		atomic_t tlb_flush_pending;
		bool tlb_flush_batched;
		struct uprobes_state uprobes_state;
		atomic_long_t hugetlb_usage;
		struct work_struct async_put_work;
	};
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long unsigned int cpu_bitmap[0];
};

struct qrwlock {
	union {
		atomic_t cnts;
		struct {
			u8 wlocked;
			u8 __lstate[3];
		};
	};
	arch_spinlock_t wait_lock;
};

typedef struct qrwlock arch_rwlock_t;

struct math_emu_info {
	long int ___orig_eip;
	struct pt_regs *regs;
};

typedef struct {
	arch_rwlock_t raw_lock;
} rwlock_t;

struct vdso_image {
	void *data;
	long unsigned int size;
	long unsigned int alt;
	long unsigned int alt_len;
	long unsigned int extable_base;
	long unsigned int extable_len;
	const void *extable;
	long int sym_vvar_start;
	long int sym_vvar_page;
	long int sym_pvclock_page;
	long int sym_hvclock_page;
	long int sym_VDSO32_NOTE_MASK;
	long int sym___kernel_sigreturn;
	long int sym___kernel_rt_sigreturn;
	long int sym___kernel_vsyscall;
	long int sym_int80_landing_pad;
};

struct vm_struct {
	struct vm_struct *next;
	void *addr;
	long unsigned int size;
	long unsigned int flags;
	struct page **pages;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

enum fixed_addresses {
	VSYSCALL_PAGE = 511,
	FIX_DBGP_BASE = 512,
	FIX_EARLYCON_MEM_BASE = 513,
	FIX_OHCI1394_BASE = 514,
	FIX_APIC_BASE = 515,
	FIX_IO_APIC_BASE_0 = 516,
	FIX_IO_APIC_BASE_END = 643,
	FIX_PARAVIRT_BOOTMAP = 644,
	FIX_APEI_GHES_IRQ = 645,
	FIX_APEI_GHES_NMI = 646,
	__end_of_permanent_fixed_addresses = 647,
	FIX_BTMAP_END = 1024,
	FIX_BTMAP_BEGIN = 1535,
	__end_of_fixed_addresses = 1536,
};

struct userfaultfd_ctx;

struct vm_userfaultfd_ctx {
	struct userfaultfd_ctx *ctx;
};

struct anon_vma;

struct vm_operations_struct;

struct vm_area_struct {
	long unsigned int vm_start;
	long unsigned int vm_end;
	struct vm_area_struct *vm_next;
	struct vm_area_struct *vm_prev;
	struct rb_node vm_rb;
	long unsigned int rb_subtree_gap;
	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	long unsigned int vm_flags;
	struct {
		struct rb_node rb;
		long unsigned int rb_subtree_last;
	} shared;
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct *vm_ops;
	long unsigned int vm_pgoff;
	struct file *vm_file;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct mempolicy *vm_policy;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

struct wait_queue_head {
	spinlock_t lock;
	struct list_head head;
};

typedef struct wait_queue_head wait_queue_head_t;

struct completion {
	unsigned int done;
	wait_queue_head_t wait;
};

struct arch_uprobe_task {
	long unsigned int saved_scratch_register;
	unsigned int saved_trap_nr;
	unsigned int saved_tf;
};

enum uprobe_task_state {
	UTASK_RUNNING = 0,
	UTASK_SSTEP = 1,
	UTASK_SSTEP_ACK = 2,
	UTASK_SSTEP_TRAPPED = 3,
};

struct uprobe;

struct return_instance;

struct uprobe_task {
	enum uprobe_task_state state;
	union {
		struct {
			struct arch_uprobe_task autask;
			long unsigned int vaddr;
		};
		struct {
			struct callback_head dup_xol_work;
			long unsigned int dup_xol_addr;
		};
	};
	struct uprobe *active_uprobe;
	long unsigned int xol_vaddr;
	struct return_instance *return_instances;
	unsigned int depth;
};

struct return_instance {
	struct uprobe *uprobe;
	long unsigned int func;
	long unsigned int stack;
	long unsigned int orig_ret_vaddr;
	bool chained;
	struct return_instance *next;
};

struct xarray {
	spinlock_t xa_lock;
	gfp_t xa_flags;
	void *xa_head;
};

typedef u32 errseq_t;

struct address_space_operations;

struct address_space {
	struct inode *host;
	struct xarray i_pages;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	struct rw_semaphore i_mmap_rwsem;
	long unsigned int nrpages;
	long unsigned int nrexceptional;
	long unsigned int writeback_index;
	const struct address_space_operations *a_ops;
	long unsigned int flags;
	errseq_t wb_err;
	spinlock_t private_lock;
	struct list_head private_list;
	void *private_data;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct vmem_altmap {
	const long unsigned int base_pfn;
	const long unsigned int end_pfn;
	const long unsigned int reserve;
	long unsigned int free;
	long unsigned int align;
	long unsigned int alloc;
};

struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	long unsigned int flags;
	long unsigned int desc;
	struct resource *parent;
	struct resource *sibling;
	struct resource *child;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct percpu_ref;

typedef void percpu_ref_func_t(struct percpu_ref *);

struct percpu_ref {
	atomic_long_t count;
	long unsigned int percpu_count_ptr;
	percpu_ref_func_t *release;
	percpu_ref_func_t *confirm_switch;
	bool force_atomic: 1;
	bool allow_reinit: 1;
	struct callback_head rcu;
};

enum memory_type {
	MEMORY_DEVICE_PRIVATE = 1,
	MEMORY_DEVICE_FS_DAX = 2,
	MEMORY_DEVICE_DEVDAX = 3,
	MEMORY_DEVICE_PCI_P2PDMA = 4,
};

struct dev_pagemap_ops;

struct dev_pagemap {
	struct vmem_altmap altmap;
	struct resource res;
	struct percpu_ref *ref;
	struct percpu_ref internal_ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	const struct dev_pagemap_ops *ops;
};

struct vfsmount;

struct path {
	struct vfsmount *mnt;
	struct dentry *dentry;
};

enum rw_hint {
	WRITE_LIFE_NOT_SET = 0,
	WRITE_LIFE_NONE = 1,
	WRITE_LIFE_SHORT = 2,
	WRITE_LIFE_MEDIUM = 3,
	WRITE_LIFE_LONG = 4,
	WRITE_LIFE_EXTREME = 5,
};

enum pid_type {
	PIDTYPE_PID = 0,
	PIDTYPE_TGID = 1,
	PIDTYPE_PGID = 2,
	PIDTYPE_SID = 3,
	PIDTYPE_MAX = 4,
};

struct fown_struct {
	rwlock_t lock;
	struct pid *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct file_ra_state {
	long unsigned int start;
	unsigned int size;
	unsigned int async_size;
	unsigned int ra_pages;
	unsigned int mmap_miss;
	loff_t prev_pos;
};

struct file {
	union {
		struct llist_node fu_llist;
		struct callback_head fu_rcuhead;
	} f_u;
	struct path f_path;
	struct inode *f_inode;
	const struct file_operations *f_op;
	spinlock_t f_lock;
	enum rw_hint f_write_hint;
	atomic_long_t f_count;
	unsigned int f_flags;
	fmode_t f_mode;
	struct mutex f_pos_lock;
	loff_t f_pos;
	struct fown_struct f_owner;
	const struct cred *f_cred;
	struct file_ra_state f_ra;
	u64 f_version;
	void *f_security;
	void *private_data;
	struct list_head f_ep_links;
	struct list_head f_tfile_llink;
	struct address_space *f_mapping;
	errseq_t f_wb_err;
};

typedef unsigned int vm_fault_t;

enum page_entry_size {
	PE_SIZE_PTE = 0,
	PE_SIZE_PMD = 1,
	PE_SIZE_PUD = 2,
};

struct vm_fault;

struct vm_operations_struct {
	void (*open)(struct vm_area_struct *);
	void (*close)(struct vm_area_struct *);
	int (*split)(struct vm_area_struct *, long unsigned int);
	int (*mremap)(struct vm_area_struct *);
	int (*mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);
	vm_fault_t (*fault)(struct vm_fault *);
	vm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size);
	void (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);
	long unsigned int (*pagesize)(struct vm_area_struct *);
	vm_fault_t (*page_mkwrite)(struct vm_fault *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
	int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
	const char * (*name)(struct vm_area_struct *);
	int (*set_policy)(struct vm_area_struct *, struct mempolicy *);
	struct mempolicy * (*get_policy)(struct vm_area_struct *, long unsigned int);
	struct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);
	long unsigned int kabi_reserved1;
};

struct core_thread {
	struct task_struct *task;
	struct core_thread *next;
};

struct core_state {
	atomic_t nr_threads;
	struct core_thread dumper;
	struct completion startup;
};

struct vm_fault {
	struct vm_area_struct *vma;
	unsigned int flags;
	gfp_t gfp_mask;
	long unsigned int pgoff;
	long unsigned int address;
	pmd_t *pmd;
	pud_t *pud;
	pte_t orig_pte;
	struct page *cow_page;
	struct mem_cgroup *memcg;
	struct page *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t prealloc_pte;
};

enum numa_stat_item {
	NUMA_HIT = 0,
	NUMA_MISS = 1,
	NUMA_FOREIGN = 2,
	NUMA_INTERLEAVE_HIT = 3,
	NUMA_LOCAL = 4,
	NUMA_OTHER = 5,
	NR_VM_NUMA_STAT_ITEMS = 6,
};

enum zone_stat_item {
	NR_FREE_PAGES = 0,
	NR_ZONE_LRU_BASE = 1,
	NR_ZONE_INACTIVE_ANON = 1,
	NR_ZONE_ACTIVE_ANON = 2,
	NR_ZONE_INACTIVE_FILE = 3,
	NR_ZONE_ACTIVE_FILE = 4,
	NR_ZONE_UNEVICTABLE = 5,
	NR_ZONE_WRITE_PENDING = 6,
	NR_MLOCK = 7,
	NR_PAGETABLE = 8,
	NR_KERNEL_STACK_KB = 9,
	NR_BOUNCE = 10,
	NR_ZSPAGES = 11,
	NR_FREE_CMA_PAGES = 12,
	NR_VM_ZONE_STAT_ITEMS = 13,
};

enum node_stat_item {
	NR_LRU_BASE = 0,
	NR_INACTIVE_ANON = 0,
	NR_ACTIVE_ANON = 1,
	NR_INACTIVE_FILE = 2,
	NR_ACTIVE_FILE = 3,
	NR_UNEVICTABLE = 4,
	NR_SLAB_RECLAIMABLE = 5,
	NR_SLAB_UNRECLAIMABLE = 6,
	NR_ISOLATED_ANON = 7,
	NR_ISOLATED_FILE = 8,
	WORKINGSET_NODES = 9,
	WORKINGSET_REFAULT = 10,
	WORKINGSET_ACTIVATE = 11,
	WORKINGSET_RESTORE = 12,
	WORKINGSET_NODERECLAIM = 13,
	NR_ANON_MAPPED = 14,
	NR_FILE_MAPPED = 15,
	NR_FILE_PAGES = 16,
	NR_FILE_DIRTY = 17,
	NR_WRITEBACK = 18,
	NR_WRITEBACK_TEMP = 19,
	NR_SHMEM = 20,
	NR_SHMEM_THPS = 21,
	NR_SHMEM_PMDMAPPED = 22,
	NR_FILE_THPS = 23,
	NR_FILE_PMDMAPPED = 24,
	NR_ANON_THPS = 25,
	NR_UNSTABLE_NFS = 26,
	NR_VMSCAN_WRITE = 27,
	NR_VMSCAN_IMMEDIATE = 28,
	NR_DIRTIED = 29,
	NR_WRITTEN = 30,
	NR_KERNEL_MISC_RECLAIMABLE = 31,
	NR_VM_NODE_STAT_ITEMS = 32,
};

typedef unsigned int isolate_mode_t;

struct shrink_control {
	gfp_t gfp_mask;
	int nid;
	long unsigned int nr_to_scan;
	long unsigned int nr_scanned;
	struct mem_cgroup *memcg;
};

struct shrinker {
	long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
	long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
	long int batch;
	int seeks;
	unsigned int flags;
	struct list_head list;
	int id;
	atomic_long_t *nr_deferred;
};

struct dev_pagemap_ops {
	void (*page_free)(struct page *);
	void (*kill)(struct dev_pagemap *);
	void (*cleanup)(struct dev_pagemap *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
};

struct pid_namespace;

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct pid {
	refcount_t count;
	unsigned int level;
	struct hlist_head tasks[4];
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid numbers[1];
};

typedef struct {
	gid_t val;
} kgid_t;

struct hrtimer_cpu_base;

struct hrtimer_clock_base {
	struct hrtimer_cpu_base *cpu_base;
	unsigned int index;
	clockid_t clockid;
	seqcount_t seq;
	struct hrtimer *running;
	struct timerqueue_head active;
	ktime_t (*get_time)();
	ktime_t offset;
};

struct hrtimer_cpu_base {
	raw_spinlock_t lock;
	unsigned int cpu;
	unsigned int active_bases;
	unsigned int clock_was_set_seq;
	unsigned int hres_active: 1;
	unsigned int in_hrtirq: 1;
	unsigned int hang_detected: 1;
	unsigned int softirq_activated: 1;
	unsigned int nr_events;
	short unsigned int nr_retries;
	short unsigned int nr_hangs;
	unsigned int max_hang_time;
	ktime_t expires_next;
	struct hrtimer *next_timer;
	ktime_t softirq_expires_next;
	struct hrtimer *softirq_next_timer;
	struct hrtimer_clock_base clock_base[8];
};

union sigval {
	int sival_int;
	void *sival_ptr;
};

typedef union sigval sigval_t;

union __sifields {
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
	} _kill;
	struct {
		__kernel_timer_t _tid;
		int _overrun;
		sigval_t _sigval;
		int _sys_private;
	} _timer;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		sigval_t _sigval;
	} _rt;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		int _status;
		__kernel_clock_t _utime;
		__kernel_clock_t _stime;
	} _sigchld;
	struct {
		void *_addr;
		union {
			short int _addr_lsb;
			struct {
				char _dummy_bnd[8];
				void *_lower;
				void *_upper;
			} _addr_bnd;
			struct {
				char _dummy_pkey[8];
				__u32 _pkey;
			} _addr_pkey;
		};
	} _sigfault;
	struct {
		long int _band;
		int _fd;
	} _sigpoll;
	struct {
		void *_call_addr;
		int _syscall;
		unsigned int _arch;
	} _sigsys;
};

struct kernel_siginfo {
	struct {
		int si_signo;
		int si_errno;
		int si_code;
		union __sifields _sifields;
	};
};

struct rseq {
	__u32 cpu_id_start;
	__u32 cpu_id;
	union {
		__u64 ptr64;
		__u64 ptr;
	} rseq_cs;
	__u32 flags;
	long: 32;
	long: 64;
};

struct rq;

struct rq_flags;

struct sched_class {
	const struct sched_class *next;
	void (*enqueue_task)(struct rq *, struct task_struct *, int);
	void (*dequeue_task)(struct rq *, struct task_struct *, int);
	void (*yield_task)(struct rq *);
	bool (*yield_to_task)(struct rq *, struct task_struct *, bool);
	void (*check_preempt_curr)(struct rq *, struct task_struct *, int);
	struct task_struct * (*pick_next_task)(struct rq *, struct task_struct *, struct rq_flags *);
	void (*put_prev_task)(struct rq *, struct task_struct *);
	void (*set_next_task)(struct rq *, struct task_struct *, bool);
	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
	int (*select_task_rq)(struct task_struct *, int, int, int);
	void (*migrate_task_rq)(struct task_struct *, int);
	void (*task_woken)(struct rq *, struct task_struct *);
	void (*set_cpus_allowed)(struct task_struct *, const struct cpumask *);
	void (*rq_online)(struct rq *);
	void (*rq_offline)(struct rq *);
	void (*task_tick)(struct rq *, struct task_struct *, int);
	void (*task_fork)(struct task_struct *);
	void (*task_dead)(struct task_struct *);
	void (*switched_from)(struct rq *, struct task_struct *);
	void (*switched_to)(struct rq *, struct task_struct *);
	void (*prio_changed)(struct rq *, struct task_struct *, int);
	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
	void (*update_curr)(struct rq *);
	void (*task_change_group)(struct task_struct *, int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct kernel_cap_struct {
	__u32 cap[2];
};

typedef struct kernel_cap_struct kernel_cap_t;

struct user_struct;

struct group_info;

struct cred {
	atomic_t usage;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	void *security;
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

struct io_cq;

struct io_context {
	atomic_long_t refcount;
	atomic_t active_ref;
	atomic_t nr_tasks;
	spinlock_t lock;
	short unsigned int ioprio;
	int nr_batch_requests;
	long unsigned int last_waited;
	struct xarray icq_tree;
	struct io_cq *icq_hint;
	struct hlist_head icq_list;
	struct work_struct release_work;
};

struct hlist_bl_node;

struct hlist_bl_head {
	struct hlist_bl_node *first;
};

struct hlist_bl_node {
	struct hlist_bl_node *next;
	struct hlist_bl_node **pprev;
};

struct lockref {
	union {
		__u64 lock_count;
		struct {
			spinlock_t lock;
			int count;
		};
	};
};

struct qstr {
	union {
		struct {
			u32 hash;
			u32 len;
		};
		u64 hash_len;
	};
	const unsigned char *name;
};

struct dentry_operations;

struct dentry {
	unsigned int d_flags;
	seqcount_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry *d_parent;
	struct qstr d_name;
	struct inode *d_inode;
	unsigned char d_iname[32];
	struct lockref d_lockref;
	const struct dentry_operations *d_op;
	struct super_block *d_sb;
	long unsigned int d_time;
	void *d_fsdata;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct list_head d_child;
	struct list_head d_subdirs;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct posix_acl;

struct inode_operations;

struct bdi_writeback;

struct file_lock_context;

struct block_device;

struct cdev;

struct fsnotify_mark_connector;

struct fscrypt_info;

struct inode {
	umode_t i_mode;
	short unsigned int i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations *i_op;
	struct super_block *i_sb;
	struct address_space *i_mapping;
	void *i_security;
	long unsigned int i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	struct timespec64 i_atime;
	struct timespec64 i_mtime;
	struct timespec64 i_ctime;
	spinlock_t i_lock;
	short unsigned int i_bytes;
	u8 i_blkbits;
	u8 i_write_hint;
	blkcnt_t i_blocks;
	long unsigned int i_state;
	struct rw_semaphore i_rwsem;
	long unsigned int dirtied_when;
	long unsigned int dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct bdi_writeback *i_wb;
	int i_wb_frn_winner;
	u16 i_wb_frn_avg_time;
	u16 i_wb_frn_history;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations *i_fop;
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context *i_flctx;
	struct address_space i_data;
	struct list_head i_devices;
	union {
		struct pipe_inode_info *i_pipe;
		struct block_device *i_bdev;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_generation;
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector *i_fsnotify_marks;
	struct fscrypt_info *i_crypt_info;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	void *i_private;
};

struct dentry_operations {
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char * (*d_dname)(struct dentry *, char *, int);
	struct vfsmount * (*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry * (*d_real)(struct dentry *, const struct inode *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct mtd_info;

typedef long long int qsize_t;

struct quota_format_type;

struct mem_dqinfo {
	struct quota_format_type *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	long unsigned int dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
};

struct quota_format_ops;

struct quota_info {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode *files[3];
	struct mem_dqinfo info[3];
	const struct quota_format_ops *ops[3];
};

struct rcu_sync {
	int gp_state;
	int gp_count;
	wait_queue_head_t gp_wait;
	struct callback_head cb_head;
};

struct rcuwait {
	struct task_struct *task;
};

struct percpu_rw_semaphore {
	struct rcu_sync rss;
	unsigned int *read_count;
	struct rw_semaphore rw_sem;
	struct rcuwait writer;
	int readers_block;
};

struct sb_writers {
	int frozen;
	wait_queue_head_t wait_unfrozen;
	struct percpu_rw_semaphore rw_sem[3];
};

typedef struct {
	__u8 b[16];
} uuid_t;

struct list_lru_node;

struct list_lru {
	struct list_lru_node *node;
	struct list_head list;
	int shrinker_id;
	bool memcg_aware;
};

struct super_operations;

struct dquot_operations;

struct quotactl_ops;

struct export_operations;

struct xattr_handler;

struct fscrypt_operations;

struct workqueue_struct;

struct super_block {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	long unsigned int s_blocksize;
	loff_t s_maxbytes;
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	const struct dquot_operations *dq_op;
	const struct quotactl_ops *s_qcop;
	const struct export_operations *s_export_op;
	long unsigned int s_flags;
	long unsigned int s_iflags;
	long unsigned int s_magic;
	struct dentry *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	void *s_security;
	const struct xattr_handler **s_xattr;
	const struct fscrypt_operations *s_cop;
	struct key *s_master_keys;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device *s_bdev;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	struct quota_info s_dquot;
	struct sb_writers s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	time64_t s_time_min;
	time64_t s_time_max;
	__u32 s_fsnotify_mask;
	struct fsnotify_mark_connector *s_fsnotify_marks;
	char s_id[32];
	uuid_t s_uuid;
	unsigned int s_max_links;
	fmode_t s_mode;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations *s_d_op;
	int cleancache_poolid;
	struct shrinker s_shrink;
	atomic_long_t s_remove_count;
	atomic_long_t s_fsnotify_inode_refs;
	int s_readonly_remount;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	long: 64;
	long: 64;
};

struct kstat {
	u32 result_mask;
	umode_t mode;
	unsigned int nlink;
	uint32_t blksize;
	u64 attributes;
	u64 attributes_mask;
	u64 ino;
	dev_t dev;
	dev_t rdev;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	struct timespec64 btime;
	u64 blocks;
};

struct list_lru_one {
	struct list_head list;
	long int nr_items;
};

struct list_lru_memcg {
	struct callback_head rcu;
	struct list_lru_one *lru[0];
};

struct list_lru_node {
	spinlock_t lock;
	struct list_lru_one lru;
	struct list_lru_memcg *memcg_lrus;
	long int nr_items;
	long: 64;
	long: 64;
};

struct fiemap_extent {
	__u64 fe_logical;
	__u64 fe_physical;
	__u64 fe_length;
	__u64 fe_reserved64[2];
	__u32 fe_flags;
	__u32 fe_reserved[3];
};

enum migrate_mode {
	MIGRATE_ASYNC = 0,
	MIGRATE_SYNC_LIGHT = 1,
	MIGRATE_SYNC = 2,
	MIGRATE_SYNC_NO_COPY = 3,
};

struct delayed_call {
	void (*fn)(void *);
	void *arg;
};

struct io_cq {
	struct request_queue *q;
	struct io_context *ioc;
	union {
		struct list_head q_node;
		struct kmem_cache *__rcu_icq_cache;
	};
	union {
		struct hlist_node ioc_node;
		struct callback_head __rcu_head;
	};
	unsigned int flags;
};

struct kiocb {
	struct file *ki_filp;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb *, long int, long int);
	void *private;
	int ki_flags;
	u16 ki_hint;
	u16 ki_ioprio;
	unsigned int ki_cookie;
};

struct iattr {
	unsigned int ia_valid;
	umode_t ia_mode;
	kuid_t ia_uid;
	kgid_t ia_gid;
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file *ia_file;
};

typedef __kernel_uid32_t projid_t;

typedef struct {
	projid_t val;
} kprojid_t;

enum quota_type {
	USRQUOTA = 0,
	GRPQUOTA = 1,
	PRJQUOTA = 2,
};

struct kqid {
	union {
		kuid_t uid;
		kgid_t gid;
		kprojid_t projid;
	};
	enum quota_type type;
};

struct mem_dqblk {
	qsize_t dqb_bhardlimit;
	qsize_t dqb_bsoftlimit;
	qsize_t dqb_curspace;
	qsize_t dqb_rsvspace;
	qsize_t dqb_ihardlimit;
	qsize_t dqb_isoftlimit;
	qsize_t dqb_curinodes;
	time64_t dqb_btime;
	time64_t dqb_itime;
};

struct dquot {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	long unsigned int dq_flags;
	struct mem_dqblk dq_dqb;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct quota_format_type {
	int qf_fmt_id;
	const struct quota_format_ops *qf_ops;
	struct module *qf_owner;
	struct quota_format_type *qf_next;
};

struct quota_format_ops {
	int (*check_quota_file)(struct super_block *, int);
	int (*read_file_info)(struct super_block *, int);
	int (*write_file_info)(struct super_block *, int);
	int (*free_file_info)(struct super_block *, int);
	int (*read_dqblk)(struct dquot *);
	int (*commit_dqblk)(struct dquot *);
	int (*release_dqblk)(struct dquot *);
	int (*get_next_id)(struct super_block *, struct kqid *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct dquot_operations {
	int (*write_dquot)(struct dquot *);
	struct dquot * (*alloc_dquot)(struct super_block *, int);
	void (*destroy_dquot)(struct dquot *);
	int (*acquire_dquot)(struct dquot *);
	int (*release_dquot)(struct dquot *);
	int (*mark_dirty)(struct dquot *);
	int (*write_info)(struct super_block *, int);
	qsize_t * (*get_reserved_space)(struct inode *);
	int (*get_projid)(struct inode *, kprojid_t *);
	int (*get_inode_usage)(struct inode *, qsize_t *);
	int (*get_next_id)(struct super_block *, struct kqid *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct qc_dqblk {
	int d_fieldmask;
	u64 d_spc_hardlimit;
	u64 d_spc_softlimit;
	u64 d_ino_hardlimit;
	u64 d_ino_softlimit;
	u64 d_space;
	u64 d_ino_count;
	s64 d_ino_timer;
	s64 d_spc_timer;
	int d_ino_warns;
	int d_spc_warns;
	u64 d_rt_spc_hardlimit;
	u64 d_rt_spc_softlimit;
	u64 d_rt_space;
	s64 d_rt_spc_timer;
	int d_rt_spc_warns;
};

struct qc_type_state {
	unsigned int flags;
	unsigned int spc_timelimit;
	unsigned int ino_timelimit;
	unsigned int rt_spc_timelimit;
	unsigned int spc_warnlimit;
	unsigned int ino_warnlimit;
	unsigned int rt_spc_warnlimit;
	long long unsigned int ino;
	blkcnt_t blocks;
	blkcnt_t nextents;
};

struct qc_state {
	unsigned int s_incoredqs;
	struct qc_type_state s_state[3];
};

struct qc_info {
	int i_fieldmask;
	unsigned int i_flags;
	unsigned int i_spc_timelimit;
	unsigned int i_ino_timelimit;
	unsigned int i_rt_spc_timelimit;
	unsigned int i_spc_warnlimit;
	unsigned int i_ino_warnlimit;
	unsigned int i_rt_spc_warnlimit;
};

struct quotactl_ops {
	int (*quota_on)(struct super_block *, int, int, const struct path *);
	int (*quota_off)(struct super_block *, int);
	int (*quota_enable)(struct super_block *, unsigned int);
	int (*quota_disable)(struct super_block *, unsigned int);
	int (*quota_sync)(struct super_block *, int);
	int (*set_info)(struct super_block *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block *, struct qc_state *);
	int (*rm_xquota)(struct super_block *, unsigned int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct writeback_control;

struct swap_info_struct;

struct address_space_operations {
	int (*writepage)(struct page *, struct writeback_control *);
	int (*readpage)(struct file *, struct page *);
	int (*writepages)(struct address_space *, struct writeback_control *);
	int (*set_page_dirty)(struct page *);
	int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int);
	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page **, void **);
	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
	sector_t (*bmap)(struct address_space *, sector_t);
	void (*invalidatepage)(struct page *, unsigned int, unsigned int);
	int (*releasepage)(struct page *, gfp_t);
	void (*freepage)(struct page *);
	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
	int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode);
	bool (*isolate_page)(struct page *, isolate_mode_t);
	void (*putback_page)(struct page *);
	int (*launder_page)(struct page *);
	int (*is_partially_uptodate)(struct page *, long unsigned int, long unsigned int);
	void (*is_dirty_writeback)(struct page *, bool *, bool *);
	int (*error_remove_page)(struct address_space *, struct page *);
	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
	void (*swap_deactivate)(struct file *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct hd_struct;

struct gendisk;

struct block_device {
	dev_t bd_dev;
	int bd_openers;
	struct inode *bd_inode;
	struct super_block *bd_super;
	struct mutex bd_mutex;
	void *bd_claiming;
	void *bd_holder;
	int bd_holders;
	bool bd_write_holder;
	struct list_head bd_holder_disks;
	struct block_device *bd_contains;
	unsigned int bd_block_size;
	u8 bd_partno;
	struct hd_struct *bd_part;
	unsigned int bd_part_count;
	int bd_invalidated;
	struct gendisk *bd_disk;
	struct request_queue *bd_queue;
	struct backing_dev_info *bd_bdi;
	struct list_head bd_list;
	long unsigned int bd_private;
	int bd_fsfreeze_count;
	struct mutex bd_fsfreeze_mutex;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct fiemap_extent_info;

struct inode_operations {
	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
	int (*permission)(struct inode *, int);
	struct posix_acl * (*get_acl)(struct inode *, int);
	int (*readlink)(struct dentry *, char *, int);
	int (*create)(struct inode *, struct dentry *, umode_t, bool);
	int (*link)(struct dentry *, struct inode *, struct dentry *);
	int (*unlink)(struct inode *, struct dentry *);
	int (*symlink)(struct inode *, struct dentry *, const char *);
	int (*mkdir)(struct inode *, struct dentry *, umode_t);
	int (*rmdir)(struct inode *, struct dentry *);
	int (*mknod)(struct inode *, struct dentry *, umode_t, dev_t);
	int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
	int (*setattr)(struct dentry *, struct iattr *);
	int (*getattr)(const struct path *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode *, struct timespec64 *, int);
	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
	int (*tmpfile)(struct inode *, struct dentry *, umode_t);
	int (*set_acl)(struct inode *, struct posix_acl *, int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct file_lock_context {
	spinlock_t flc_lock;
	struct list_head flc_flock;
	struct list_head flc_posix;
	struct list_head flc_lease;
};

struct file_lock_operations {
	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
	void (*fl_release_private)(struct file_lock *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct nlm_lockowner;

struct nfs_lock_info {
	u32 state;
	struct nlm_lockowner *owner;
	struct list_head list;
};

struct nfs4_lock_state;

struct nfs4_lock_info {
	struct nfs4_lock_state *owner;
};

struct fasync_struct;

struct lock_manager_operations;

struct file_lock {
	struct file_lock *fl_blocker;
	struct list_head fl_list;
	struct hlist_node fl_link;
	struct list_head fl_blocked_requests;
	struct list_head fl_blocked_member;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	unsigned int fl_pid;
	int fl_link_cpu;
	wait_queue_head_t fl_wait;
	struct file *fl_file;
	loff_t fl_start;
	loff_t fl_end;
	struct fasync_struct *fl_fasync;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	const struct file_lock_operations *fl_ops;
	const struct lock_manager_operations *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
	} fl_u;
};

struct lock_manager_operations {
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock *);
	int (*lm_grant)(struct file_lock *, int);
	bool (*lm_break)(struct file_lock *);
	int (*lm_change)(struct file_lock *, int, struct list_head *);
	void (*lm_setup)(struct file_lock *, void **);
	long unsigned int kabi_reserved1;
};

struct fasync_struct {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	struct file *fa_file;
	struct callback_head fa_rcu;
};

struct kstatfs;

struct super_operations {
	struct inode * (*alloc_inode)(struct super_block *);
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *);
	void (*dirty_inode)(struct inode *, int);
	int (*write_inode)(struct inode *, struct writeback_control *);
	int (*drop_inode)(struct inode *);
	void (*evict_inode)(struct inode *);
	void (*put_super)(struct super_block *);
	int (*sync_fs)(struct super_block *, int);
	int (*freeze_super)(struct super_block *);
	int (*freeze_fs)(struct super_block *);
	int (*thaw_super)(struct super_block *);
	int (*unfreeze_fs)(struct super_block *);
	int (*statfs)(struct dentry *, struct kstatfs *);
	int (*remount_fs)(struct super_block *, int *, char *);
	void (*umount_begin)(struct super_block *);
	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
	struct dquot ** (*get_dquots)(struct inode *);
	int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t);
	long int (*nr_cached_objects)(struct super_block *, struct shrink_control *);
	long int (*free_cached_objects)(struct super_block *, struct shrink_control *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct iomap;

struct inode___2;

struct dentry___2;

struct fid;

struct iattr___2;

struct export_operations {
	int (*encode_fh)(struct inode___2 *, __u32 *, int *, struct inode___2 *);
	struct dentry___2 * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
	struct dentry___2 * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
	int (*get_name)(struct dentry___2 *, char *, struct dentry___2 *);
	struct dentry___2 * (*get_parent)(struct dentry___2 *);
	int (*commit_metadata)(struct inode___2 *);
	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
	int (*map_blocks)(struct inode___2 *, loff_t, u64, struct iomap *, bool, u32 *);
	int (*commit_blocks)(struct inode___2 *, struct iomap *, int, struct iattr___2 *);
};

struct xattr_handler {
	const char *name;
	const char *prefix;
	int flags;
	bool (*list)(struct dentry *);
	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);
	int (*set)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
};

struct fscrypt_operations {
	unsigned int flags;
	const char *key_prefix;
	int (*get_context)(struct inode *, void *, size_t);
	int (*set_context)(struct inode *, const void *, size_t, void *);
	bool (*dummy_context)(struct inode *);
	bool (*empty_dir)(struct inode *);
	unsigned int max_namelen;
};

struct fiemap_extent_info {
	unsigned int fi_flags;
	unsigned int fi_extents_mapped;
	unsigned int fi_extents_max;
	struct fiemap_extent *fi_extents_start;
};

typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);

struct dir_context {
	filldir_t actor;
	loff_t pos;
};

struct fs_parameter_spec;

struct fs_parameter_enum;

struct fs_parameter_description {
	const char name[16];
	const struct fs_parameter_spec *specs;
	const struct fs_parameter_enum *enums;
};

enum vm_event_item {
	PGPGIN = 0,
	PGPGOUT = 1,
	PSWPIN = 2,
	PSWPOUT = 3,
	PGALLOC_DMA = 4,
	PGALLOC_DMA32 = 5,
	PGALLOC_NORMAL = 6,
	PGALLOC_MOVABLE = 7,
	ALLOCSTALL_DMA = 8,
	ALLOCSTALL_DMA32 = 9,
	ALLOCSTALL_NORMAL = 10,
	ALLOCSTALL_MOVABLE = 11,
	PGSCAN_SKIP_DMA = 12,
	PGSCAN_SKIP_DMA32 = 13,
	PGSCAN_SKIP_NORMAL = 14,
	PGSCAN_SKIP_MOVABLE = 15,
	PGFREE = 16,
	PGACTIVATE = 17,
	PGDEACTIVATE = 18,
	PGLAZYFREE = 19,
	PGFAULT = 20,
	PGMAJFAULT = 21,
	PGLAZYFREED = 22,
	PGREFILL = 23,
	PGSTEAL_KSWAPD = 24,
	PGSTEAL_DIRECT = 25,
	PGSCAN_KSWAPD = 26,
	PGSCAN_DIRECT = 27,
	PGSCAN_DIRECT_THROTTLE = 28,
	PGSCAN_ZONE_RECLAIM_FAILED = 29,
	PGINODESTEAL = 30,
	SLABS_SCANNED = 31,
	KSWAPD_INODESTEAL = 32,
	KSWAPD_LOW_WMARK_HIT_QUICKLY = 33,
	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 34,
	PAGEOUTRUN = 35,
	PGROTATED = 36,
	DROP_PAGECACHE = 37,
	DROP_SLAB = 38,
	OOM_KILL = 39,
	NUMA_PTE_UPDATES = 40,
	NUMA_HUGE_PTE_UPDATES = 41,
	NUMA_HINT_FAULTS = 42,
	NUMA_HINT_FAULTS_LOCAL = 43,
	NUMA_PAGE_MIGRATE = 44,
	PGMIGRATE_SUCCESS = 45,
	PGMIGRATE_FAIL = 46,
	COMPACTMIGRATE_SCANNED = 47,
	COMPACTFREE_SCANNED = 48,
	COMPACTISOLATED = 49,
	COMPACTSTALL = 50,
	COMPACTFAIL = 51,
	COMPACTSUCCESS = 52,
	KCOMPACTD_WAKE = 53,
	KCOMPACTD_MIGRATE_SCANNED = 54,
	KCOMPACTD_FREE_SCANNED = 55,
	HTLB_BUDDY_PGALLOC = 56,
	HTLB_BUDDY_PGALLOC_FAIL = 57,
	UNEVICTABLE_PGCULLED = 58,
	UNEVICTABLE_PGSCANNED = 59,
	UNEVICTABLE_PGRESCUED = 60,
	UNEVICTABLE_PGMLOCKED = 61,
	UNEVICTABLE_PGMUNLOCKED = 62,
	UNEVICTABLE_PGCLEARED = 63,
	UNEVICTABLE_PGSTRANDED = 64,
	THP_FAULT_ALLOC = 65,
	THP_FAULT_FALLBACK = 66,
	THP_COLLAPSE_ALLOC = 67,
	THP_COLLAPSE_ALLOC_FAILED = 68,
	THP_FILE_ALLOC = 69,
	THP_FILE_MAPPED = 70,
	THP_SPLIT_PAGE = 71,
	THP_SPLIT_PAGE_FAILED = 72,
	THP_DEFERRED_SPLIT_PAGE = 73,
	THP_SPLIT_PMD = 74,
	THP_SPLIT_PUD = 75,
	THP_ZERO_PAGE_ALLOC = 76,
	THP_ZERO_PAGE_ALLOC_FAILED = 77,
	THP_SWPOUT = 78,
	THP_SWPOUT_FALLBACK = 79,
	BALLOON_INFLATE = 80,
	BALLOON_DEFLATE = 81,
	BALLOON_MIGRATE = 82,
	SWAP_RA = 83,
	SWAP_RA_HIT = 84,
	NR_VM_EVENT_ITEMS = 85,
};

struct tlb_context {
	u64 ctx_id;
	u64 tlb_gen;
};

struct tlb_state {
	struct mm_struct *loaded_mm;
	union {
		struct mm_struct *last_user_mm;
		long unsigned int last_user_mm_ibpb;
	};
	u16 loaded_mm_asid;
	u16 next_asid;
	bool is_lazy;
	bool invalidate_other;
	short unsigned int user_pcid_flush_mask;
	long unsigned int cr4;
	struct tlb_context ctxs[6];
};

struct boot_params_to_save {
	unsigned int start;
	unsigned int len;
};

typedef long unsigned int pto_T__;

struct x86_legacy_devices {
	int pnpbios;
};

enum x86_legacy_i8042_state {
	X86_LEGACY_I8042_PLATFORM_ABSENT = 0,
	X86_LEGACY_I8042_FIRMWARE_ABSENT = 1,
	X86_LEGACY_I8042_EXPECTED_PRESENT = 2,
};

struct x86_legacy_features {
	enum x86_legacy_i8042_state i8042;
	int rtc;
	int warm_reset;
	int no_vga;
	int reserve_bios_regions;
	struct x86_legacy_devices devices;
};

struct x86_hyper_runtime {
	void (*pin_vcpu)(int);
};

struct x86_platform_ops {
	long unsigned int (*calibrate_cpu)();
	long unsigned int (*calibrate_tsc)();
	void (*get_wallclock)(struct timespec64 *);
	int (*set_wallclock)(const struct timespec64 *);
	void (*iommu_shutdown)();
	bool (*is_untracked_pat_range)(u64, u64);
	void (*nmi_init)();
	unsigned char (*get_nmi_reason)();
	void (*save_sched_clock_state)();
	void (*restore_sched_clock_state)();
	void (*apic_post_init)();
	struct x86_legacy_features legacy;
	void (*set_legacy_features)();
	struct x86_hyper_runtime hyper;
};

typedef signed char __s8;

typedef __s8 s8;

typedef s32 int32_t;

typedef long unsigned int irq_hw_number_t;

struct __va_list_tag {
	unsigned int gp_offset;
	unsigned int fp_offset;
	void *overflow_arg_area;
	void *reg_save_area;
};

struct kernel_symbol {
	int value_offset;
	int name_offset;
	int namespace_offset;
};

typedef int (*initcall_t)();

typedef int initcall_entry_t;

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

struct _ddebug {
	const char *modname;
	const char *function;
	const char *filename;
	const char *format;
	unsigned int lineno: 18;
	unsigned int flags: 8;
};

enum system_states {
	SYSTEM_BOOTING = 0,
	SYSTEM_SCHEDULING = 1,
	SYSTEM_RUNNING = 2,
	SYSTEM_HALT = 3,
	SYSTEM_POWER_OFF = 4,
	SYSTEM_RESTART = 5,
	SYSTEM_SUSPEND = 6,
};

struct bug_entry {
	int bug_addr_disp;
	int file_disp;
	short unsigned int line;
	short unsigned int flags;
};

struct pollfd {
	int fd;
	short int events;
	short int revents;
};

struct static_key {
	atomic_t enabled;
};

struct static_key_false {
	struct static_key key;
};

struct paravirt_callee_save {
	void *func;
};

struct pv_init_ops {
	unsigned int (*patch)(u8, void *, long unsigned int, unsigned int);
};

struct pv_time_ops {
	long long unsigned int (*sched_clock)();
	long long unsigned int (*steal_clock)(int);
};

struct pv_cpu_ops {
	void (*io_delay)();
};

struct pv_irq_ops {};

struct flush_tlb_info;

struct mmu_gather;

struct pv_mmu_ops {
	void (*flush_tlb_user)();
	void (*flush_tlb_kernel)();
	void (*flush_tlb_one_user)(long unsigned int);
	void (*flush_tlb_others)(const struct cpumask *, const struct flush_tlb_info *);
	void (*tlb_remove_table)(struct mmu_gather *, void *);
	void (*exit_mmap)(struct mm_struct *);
};

struct flush_tlb_info {
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	u64 new_tlb_gen;
	unsigned int stride_shift;
	bool freed_tables;
};

struct pv_lock_ops {
	void (*queued_spin_lock_slowpath)(struct qspinlock *, u32);
	struct paravirt_callee_save queued_spin_unlock;
	void (*wait)(u8 *, u8);
	void (*kick)(int);
	struct paravirt_callee_save vcpu_is_preempted;
};

struct paravirt_patch_template {
	struct pv_init_ops init;
	struct pv_time_ops time;
	struct pv_cpu_ops cpu;
	struct pv_irq_ops irq;
	struct pv_mmu_ops mmu;
	struct pv_lock_ops lock;
};

typedef struct cpumask *cpumask_var_t;

struct tracepoint_func {
	void *func;
	void *data;
	int prio;
};

struct tracepoint {
	const char *name;
	struct static_key key;
	int (*regfunc)();
	void (*unregfunc)();
	struct tracepoint_func *funcs;
};

typedef const int tracepoint_ptr_t;

struct bpf_raw_event_map {
	struct tracepoint *tp;
	void *bpf_func;
	u32 num_args;
	u32 writable_size;
	long: 64;
};

struct seq_operations {
	void * (*start)(struct seq_file *, loff_t *);
	void (*stop)(struct seq_file *, void *);
	void * (*next)(struct seq_file *, void *, loff_t *);
	int (*show)(struct seq_file *, void *);
};

struct fixed_percpu_data {
	char gs_base[40];
	long unsigned int stack_canary;
};

enum perf_event_state {
	PERF_EVENT_STATE_DEAD = 4294967292,
	PERF_EVENT_STATE_EXIT = 4294967293,
	PERF_EVENT_STATE_ERROR = 4294967294,
	PERF_EVENT_STATE_OFF = 4294967295,
	PERF_EVENT_STATE_INACTIVE = 0,
	PERF_EVENT_STATE_ACTIVE = 1,
};

typedef struct {
	atomic_long_t a;
} local_t;

typedef struct {
	local_t a;
} local64_t;

struct perf_event_attr {
	__u32 type;
	__u32 size;
	__u64 config;
	union {
		__u64 sample_period;
		__u64 sample_freq;
	};
	__u64 sample_type;
	__u64 read_format;
	__u64 disabled: 1;
	__u64 inherit: 1;
	__u64 pinned: 1;
	__u64 exclusive: 1;
	__u64 exclude_user: 1;
	__u64 exclude_kernel: 1;
	__u64 exclude_hv: 1;
	__u64 exclude_idle: 1;
	__u64 mmap: 1;
	__u64 comm: 1;
	__u64 freq: 1;
	__u64 inherit_stat: 1;
	__u64 enable_on_exec: 1;
	__u64 task: 1;
	__u64 watermark: 1;
	__u64 precise_ip: 2;
	__u64 mmap_data: 1;
	__u64 sample_id_all: 1;
	__u64 exclude_host: 1;
	__u64 exclude_guest: 1;
	__u64 exclude_callchain_kernel: 1;
	__u64 exclude_callchain_user: 1;
	__u64 mmap2: 1;
	__u64 comm_exec: 1;
	__u64 use_clockid: 1;
	__u64 context_switch: 1;
	__u64 write_backward: 1;
	__u64 namespaces: 1;
	__u64 ksymbol: 1;
	__u64 bpf_event: 1;
	__u64 aux_output: 1;
	__u64 __reserved_1: 32;
	union {
		__u32 wakeup_events;
		__u32 wakeup_watermark;
	};
	__u32 bp_type;
	union {
		__u64 bp_addr;
		__u64 kprobe_func;
		__u64 uprobe_path;
		__u64 config1;
	};
	union {
		__u64 bp_len;
		__u64 kprobe_addr;
		__u64 probe_offset;
		__u64 config2;
	};
	__u64 branch_sample_type;
	__u64 sample_regs_user;
	__u32 sample_stack_user;
	__s32 clockid;
	__u64 sample_regs_intr;
	__u32 aux_watermark;
	__u16 sample_max_stack;
	__u16 __reserved_2;
};

struct hw_perf_event_extra {
	u64 config;
	unsigned int reg;
	int alloc;
	int idx;
};

struct arch_hw_breakpoint {
	long unsigned int address;
	long unsigned int mask;
	u8 len;
	u8 type;
};

struct hw_perf_event {
	union {
		struct {
			u64 config;
			u64 last_tag;
			long unsigned int config_base;
			long unsigned int event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			struct arch_hw_breakpoint info;
			struct list_head bp_list;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct *target;
	void *addr_filters;
	long unsigned int addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

struct irq_work {
	long unsigned int flags;
	struct llist_node llnode;
	void (*func)(struct irq_work *);
};

struct perf_addr_filters_head {
	struct list_head list;
	raw_spinlock_t lock;
	unsigned int nr_file_filters;
};

struct perf_sample_data;

typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);

struct ftrace_ops;

typedef void (*ftrace_func_t)(long unsigned int, long unsigned int, struct ftrace_ops *, struct pt_regs *);

struct ftrace_hash;

struct ftrace_ops_hash {
	struct ftrace_hash *notrace_hash;
	struct ftrace_hash *filter_hash;
	struct mutex regex_lock;
};

struct ftrace_ops {
	ftrace_func_t func;
	struct ftrace_ops *next;
	long unsigned int flags;
	void *private;
	ftrace_func_t saved_func;
	struct ftrace_ops_hash local_hash;
	struct ftrace_ops_hash *func_hash;
	struct ftrace_ops_hash old_hash;
	long unsigned int trampoline;
	long unsigned int trampoline_size;
};

struct pmu;

struct ring_buffer;

struct perf_addr_filter_range;

struct bpf_prog;

struct trace_event_call;

struct event_filter;

struct perf_cgroup;

struct perf_event {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	struct perf_event *group_leader;
	struct pmu *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	u64 shadow_ctx_time;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event hw;
	struct perf_event_context *ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct ring_buffer *rb;
	struct list_head rb_entry;
	long unsigned int rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
	int pending_wakeup;
	int pending_kill;
	int pending_disable;
	struct irq_work pending;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	long unsigned int addr_filters_gen;
	struct perf_event *aux_event;
	void (*destroy)(struct perf_event *);
	struct callback_head callback_head;
	struct pid_namespace *ns;
	u64 id;
	u64 (*clock)();
	perf_overflow_handler_t overflow_handler;
	void *overflow_handler_context;
	perf_overflow_handler_t orig_overflow_handler;
	struct bpf_prog *prog;
	struct trace_event_call *tp_event;
	struct event_filter *filter;
	struct ftrace_ops ftrace_ops;
	struct perf_cgroup *cgrp;
	struct list_head sb_list;
};

struct lockdep_map {};

typedef struct {
	struct seqcount seqcount;
	spinlock_t lock;
} seqlock_t;

struct uid_gid_extent {
	u32 first;
	u32 lower_first;
	u32 count;
};

struct uid_gid_map {
	u32 nr_extents;
	union {
		struct uid_gid_extent extent[5];
		struct {
			struct uid_gid_extent *forward;
			struct uid_gid_extent *reverse;
		};
	};
};

struct proc_ns_operations;

struct ns_common {
	atomic_long_t stashed;
	const struct proc_ns_operations *ops;
	unsigned int inum;
};

struct ctl_table;

struct ctl_table_root;

struct ctl_table_set;

struct ctl_dir;

struct ctl_node;

struct ctl_table_header {
	union {
		struct {
			struct ctl_table *ctl_table;
			int used;
			int count;
			int nreg;
		};
		struct callback_head rcu;
	};
	struct completion *unregistering;
	struct ctl_table *ctl_table_arg;
	struct ctl_table_root *root;
	struct ctl_table_set *set;
	struct ctl_dir *parent;
	struct ctl_node *node;
	struct hlist_head inodes;
};

struct ctl_dir {
	struct ctl_table_header header;
	struct rb_root root;
};

struct ctl_table_set {
	int (*is_seen)(struct ctl_table_set *);
	struct ctl_dir dir;
};

struct ucounts;

struct user_namespace {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	atomic_t count;
	struct user_namespace *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common ns;
	long unsigned int flags;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts *ucounts;
	int ucount_max[9];
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

enum node_states {
	N_POSSIBLE = 0,
	N_ONLINE = 1,
	N_NORMAL_MEMORY = 2,
	N_HIGH_MEMORY = 2,
	N_MEMORY = 3,
	N_CPU = 4,
	NR_NODE_STATES = 5,
};

struct timer_list {
	struct hlist_node entry;
	long unsigned int expires;
	void (*function)(struct timer_list *);
	u32 flags;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

struct delayed_work {
	struct work_struct work;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int cpu;
	long unsigned int kabi_reserved1;
};

struct rcu_work {
	struct work_struct work;
	struct callback_head rcu;
	struct workqueue_struct *wq;
};

struct rcu_segcblist {
	struct callback_head *head;
	struct callback_head **tails[4];
	long unsigned int gp_seq[4];
	long int len;
	long int len_lazy;
	u8 enabled;
	u8 offloaded;
};

struct srcu_node;

struct srcu_struct;

struct srcu_data {
	long unsigned int srcu_lock_count[2];
	long unsigned int srcu_unlock_count[2];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	struct rcu_segcblist srcu_cblist;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	bool srcu_cblist_invoking;
	struct timer_list delay_work;
	struct work_struct work;
	struct callback_head srcu_barrier_head;
	struct srcu_node *mynode;
	long unsigned int grpmask;
	int cpu;
	struct srcu_struct *ssp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct srcu_node {
	spinlock_t lock;
	long unsigned int srcu_have_cbs[4];
	long unsigned int srcu_data_have_cbs[4];
	long unsigned int srcu_gp_seq_needed_exp;
	struct srcu_node *srcu_parent;
	int grplo;
	int grphi;
};

struct srcu_struct {
	struct srcu_node node[521];
	struct srcu_node *level[4];
	struct mutex srcu_cb_mutex;
	spinlock_t lock;
	struct mutex srcu_gp_mutex;
	unsigned int srcu_idx;
	long unsigned int srcu_gp_seq;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	long unsigned int srcu_last_gp_end;
	struct srcu_data *sda;
	long unsigned int srcu_barrier_seq;
	struct mutex srcu_barrier_mutex;
	struct completion srcu_barrier_completion;
	atomic_t srcu_barrier_cpu_cnt;
	struct delayed_work work;
};

struct cgroup;

struct cgroup_subsys;

struct cgroup_subsys_state {
	struct cgroup *cgroup;
	struct cgroup_subsys *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state *parent;
};

struct mem_cgroup_id {
	int id;
	refcount_t ref;
};

struct page_counter {
	atomic_long_t usage;
	long unsigned int min;
	long unsigned int low;
	long unsigned int max;
	struct page_counter *parent;
	long unsigned int emin;
	atomic_long_t min_usage;
	atomic_long_t children_min_usage;
	long unsigned int elow;
	atomic_long_t low_usage;
	atomic_long_t children_low_usage;
	long unsigned int watermark;
	long unsigned int failcnt;
};

struct vmpressure {
	long unsigned int scanned;
	long unsigned int reclaimed;
	long unsigned int tree_scanned;
	long unsigned int tree_reclaimed;
	spinlock_t sr_lock;
	struct list_head events;
	struct mutex events_lock;
	struct work_struct work;
};

struct kernfs_node;

struct cgroup_file {
	struct kernfs_node *kn;
	long unsigned int notified_at;
	struct timer_list notify_timer;
};

struct mem_cgroup_threshold_ary;

struct mem_cgroup_thresholds {
	struct mem_cgroup_threshold_ary *primary;
	struct mem_cgroup_threshold_ary *spare;
};

struct memcg_padding {
	char x[0];
};

enum memcg_kmem_state {
	KMEM_NONE = 0,
	KMEM_ALLOCATED = 1,
	KMEM_ONLINE = 2,
};

struct percpu_counter {
	raw_spinlock_t lock;
	s64 count;
	struct list_head list;
	s32 *counters;
};

struct fprop_global {
	struct percpu_counter events;
	unsigned int period;
	seqcount_t sequence;
};

struct wb_domain {
	spinlock_t lock;
	struct fprop_global completions;
	struct timer_list period_timer;
	long unsigned int period_time;
	long unsigned int dirty_limit_tstamp;
	long unsigned int dirty_limit;
};

struct wb_completion {
	atomic_t cnt;
	wait_queue_head_t *waitq;
};

struct memcg_cgwb_frn {
	u64 bdi_id;
	int memcg_id;
	u64 at;
	struct wb_completion done;
};

struct deferred_split {
	spinlock_t split_queue_lock;
	struct list_head split_queue;
	long unsigned int split_queue_len;
};

struct memcg_vmstats_percpu;

struct mem_cgroup_per_node;

struct mem_cgroup {
	struct cgroup_subsys_state css;
	struct mem_cgroup_id id;
	struct page_counter memory;
	struct page_counter swap;
	struct page_counter pagecache;
	u64 pagecache_reclaim_ratio;
	u32 pagecache_max_ratio;
	struct page_counter memsw;
	struct page_counter kmem;
	struct page_counter tcpmem;
	long unsigned int high;
	struct work_struct high_work;
	long unsigned int soft_limit;
	struct vmpressure vmpressure;
	bool use_hierarchy;
	bool meminfo_recursive;
	bool oom_group;
	bool oom_lock;
	int under_oom;
	int swappiness;
	int oom_kill_disable;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	struct cgroup_file swap_events_file;
	struct mutex thresholds_lock;
	struct mem_cgroup_thresholds thresholds;
	struct mem_cgroup_thresholds memsw_thresholds;
	struct list_head oom_notify;
	long unsigned int move_charge_at_immigrate;
	spinlock_t move_lock;
	long unsigned int move_lock_flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct memcg_padding _pad1_;
	atomic_t moving_account;
	struct task_struct *move_lock_task;
	struct memcg_vmstats_percpu *vmstats_local;
	struct memcg_vmstats_percpu *vmstats_percpu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct memcg_padding _pad2_;
	atomic_long_t vmstats[38];
	atomic_long_t vmevents[85];
	atomic_long_t memory_events[9];
	atomic_long_t memory_events_local[9];
	long unsigned int socket_pressure;
	bool tcpmem_active;
	int tcpmem_pressure;
	int kmemcg_id;
	enum memcg_kmem_state kmem_state;
	struct list_head kmem_caches;
	int last_scanned_node;
	nodemask_t scan_nodes;
	atomic_t numainfo_events;
	atomic_t numainfo_updating;
	struct list_head cgwb_list;
	struct wb_domain cgwb_domain;
	struct memcg_cgwb_frn cgwb_frn[4];
	struct list_head event_list;
	spinlock_t event_list_lock;
	struct deferred_split deferred_split_queue;
	struct cgroup_subsys_state *bind_blkio;
	char *bind_blkio_path;
	struct mem_cgroup_per_node *nodeinfo[0];
	long: 64;
	long: 64;
	long: 64;
};

struct anon_vma {
	struct anon_vma *root;
	struct rw_semaphore rwsem;
	atomic_t refcount;
	unsigned int degree;
	struct anon_vma *parent;
	struct rb_root_cached rb_root;
};

struct mempolicy {
	atomic_t refcnt;
	short unsigned int mode;
	short unsigned int flags;
	union {
		short int preferred_node;
		nodemask_t nodes;
	} v;
	union {
		nodemask_t cpuset_mems_allowed;
		nodemask_t user_nodemask;
	} w;
};

struct linux_binprm;

struct coredump_params;

struct linux_binfmt {
	struct list_head lh;
	struct module *module;
	int (*load_binary)(struct linux_binprm *);
	int (*load_shlib)(struct file *);
	int (*core_dump)(struct coredump_params *);
	long unsigned int min_coredump;
};

struct free_area {
	struct list_head free_list[5];
	long unsigned int nr_free;
};

struct zone_padding {
	char x[0];
};

enum lru_list {
	LRU_INACTIVE_ANON = 0,
	LRU_ACTIVE_ANON = 1,
	LRU_INACTIVE_FILE = 2,
	LRU_ACTIVE_FILE = 3,
	LRU_UNEVICTABLE = 4,
	NR_LRU_LISTS = 5,
};

struct zone_reclaim_stat {
	long unsigned int recent_rotated[2];
	long unsigned int recent_scanned[2];
};

struct pglist_data;

struct lruvec {
	struct list_head lists[5];
	struct zone_reclaim_stat reclaim_stat;
	atomic_long_t inactive_age;
	long unsigned int refaults;
	struct pglist_data *pgdat;
};

struct per_cpu_pageset;

struct zone {
	long unsigned int _watermark[3];
	long unsigned int watermark_boost;
	long unsigned int nr_reserved_highatomic;
	long int lowmem_reserve[5];
	atomic_t pagecache_reclaim;
	int node;
	struct pglist_data *zone_pgdat;
	struct per_cpu_pageset *pageset;
	long unsigned int zone_start_pfn;
	atomic_long_t managed_pages;
	long unsigned int spanned_pages;
	long unsigned int present_pages;
	const char *name;
	long unsigned int nr_isolate_pageblock;
	seqlock_t span_seqlock;
	int initialized;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad1_;
	struct free_area free_area[11];
	long unsigned int flags;
	spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad2_;
	long unsigned int percpu_drift_mark;
	long unsigned int compact_cached_free_pfn;
	long unsigned int compact_cached_migrate_pfn[2];
	long unsigned int compact_init_migrate_pfn;
	long unsigned int compact_init_free_pfn;
	unsigned int compact_considered;
	unsigned int compact_defer_shift;
	int compact_order_failed;
	bool compact_blockskip_flush;
	bool contiguous;
	short: 16;
	struct zone_padding _pad3_;
	atomic_long_t vm_stat[13];
	atomic_long_t vm_numa_stat[6];
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long: 64;
	long: 64;
	long: 64;
};

struct zoneref {
	struct zone *zone;
	int zone_idx;
};

struct zonelist {
	struct zoneref _zonerefs[5121];
};

enum zone_type {
	ZONE_DMA = 0,
	ZONE_DMA32 = 1,
	ZONE_NORMAL = 2,
	ZONE_MOVABLE = 3,
	ZONE_DEVICE = 4,
	__MAX_NR_ZONES = 5,
};

struct per_cpu_nodestat;

struct pglist_data {
	struct zone node_zones[5];
	struct zonelist node_zonelists[2];
	int nr_zones;
	spinlock_t node_size_lock;
	long unsigned int node_start_pfn;
	long unsigned int node_present_pages;
	long unsigned int node_spanned_pages;
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	struct task_struct *kswapd;
	int kswapd_order;
	enum zone_type kswapd_classzone_idx;
	int kswapd_failures;
	int kcompactd_max_order;
	enum zone_type kcompactd_classzone_idx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	long unsigned int totalreserve_pages;
	long unsigned int min_unmapped_pages;
	long unsigned int min_slab_pages;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad1_;
	spinlock_t lru_lock;
	struct deferred_split deferred_split_queue;
	struct lruvec lruvec;
	long unsigned int flags;
	long: 64;
	struct zone_padding _pad2_;
	struct per_cpu_nodestat *per_cpu_nodestats;
	atomic_long_t vm_stat[32];
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct per_cpu_pages {
	int count;
	int high;
	int batch;
	struct list_head lists[3];
};

struct per_cpu_pageset {
	struct per_cpu_pages pcp;
	s8 expire;
	u16 vm_numa_stat_diff[6];
	s8 stat_threshold;
	s8 vm_stat_diff[13];
};

struct per_cpu_nodestat {
	s8 stat_threshold;
	s8 vm_node_stat_diff[32];
};

typedef struct pglist_data pg_data_t;

struct fwnode_operations;

struct fwnode_handle {
	struct fwnode_handle *secondary;
	const struct fwnode_operations *ops;
};

struct device;

struct fwnode_reference_args;

struct fwnode_endpoint;

struct fwnode_operations {
	struct fwnode_handle * (*get)(struct fwnode_handle *);
	void (*put)(struct fwnode_handle *);
	bool (*device_is_available)(const struct fwnode_handle *);
	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
	bool (*property_present)(const struct fwnode_handle *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
};

struct fwnode_endpoint {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle *local_fwnode;
};

struct fwnode_reference_args {
	struct fwnode_handle *fwnode;
	unsigned int nargs;
	u64 args[8];
};

struct kref {
	refcount_t refcount;
};

struct kset;

struct kobj_type;

struct kobject {
	const char *name;
	struct list_head entry;
	struct kobject *parent;
	struct kset *kset;
	struct kobj_type *ktype;
	struct kernfs_node *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

enum dl_dev_state {
	DL_DEV_NO_DRIVER = 0,
	DL_DEV_PROBING = 1,
	DL_DEV_DRIVER_BOUND = 2,
	DL_DEV_UNBINDING = 3,
};

struct dev_links_info {
	struct list_head suppliers;
	struct list_head consumers;
	enum dl_dev_state status;
};

struct pm_message {
	int event;
};

typedef struct pm_message pm_message_t;

enum rpm_request {
	RPM_REQ_NONE = 0,
	RPM_REQ_IDLE = 1,
	RPM_REQ_SUSPEND = 2,
	RPM_REQ_AUTOSUSPEND = 3,
	RPM_REQ_RESUME = 4,
};

enum rpm_status {
	RPM_ACTIVE = 0,
	RPM_RESUMING = 1,
	RPM_SUSPENDED = 2,
	RPM_SUSPENDING = 3,
};

struct wakeup_source;

struct wake_irq;

struct pm_subsys_data;

struct dev_pm_qos;

struct dev_pm_info {
	pm_message_t power_state;
	unsigned int can_wakeup: 1;
	unsigned int async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	struct list_head entry;
	struct completion completion;
	struct wakeup_source *wakeup;
	bool wakeup_path: 1;
	bool syscore: 1;
	bool no_pm_callbacks: 1;
	unsigned int must_resume: 1;
	unsigned int may_skip_resume: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	unsigned int idle_notification: 1;
	unsigned int request_pending: 1;
	unsigned int deferred_resume: 1;
	unsigned int runtime_auto: 1;
	bool ignore_children: 1;
	unsigned int no_callbacks: 1;
	unsigned int irq_safe: 1;
	unsigned int use_autosuspend: 1;
	unsigned int timer_autosuspends: 1;
	unsigned int memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	int runtime_error;
	int autosuspend_delay;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device *, s32);
	struct dev_pm_qos *qos;
};

struct dev_archdata {
	void *iommu;
};

struct device_private;

struct device_type;

struct bus_type;

struct device_driver;

struct dev_pm_domain;

struct irq_domain;

struct dev_pin_info;

struct dma_map_ops;

struct device_dma_parameters;

struct device_node;

struct class;

struct attribute_group;

struct iommu_group;

struct iommu_fwspec;

struct iommu_param;

struct device {
	struct kobject kobj;
	struct device *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type *type;
	struct bus_type *bus;
	struct device_driver *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	struct dev_pm_info power;
	struct dev_pm_domain *pm_domain;
	struct irq_domain *msi_domain;
	struct dev_pin_info *pins;
	struct list_head msi_list;
	const struct dma_map_ops *dma_ops;
	u64 *dma_mask;
	u64 coherent_dma_mask;
	u64 bus_dma_mask;
	long unsigned int dma_pfn_offset;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct dev_archdata archdata;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	int numa_node;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	struct class *class;
	const struct attribute_group **groups;
	void (*release)(struct device *);
	struct iommu_group *iommu_group;
	struct iommu_fwspec *iommu_fwspec;
	struct iommu_param *iommu_param;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
};

struct smp_ops {
	void (*smp_prepare_boot_cpu)();
	void (*smp_prepare_cpus)(unsigned int);
	void (*smp_cpus_done)(unsigned int);
	void (*stop_other_cpus)(int);
	void (*crash_stop_other_cpus)();
	void (*smp_send_reschedule)(int);
	int (*cpu_up)(unsigned int, struct task_struct *);
	int (*cpu_disable)();
	void (*cpu_die)(unsigned int);
	void (*play_dead)();
	void (*send_call_func_ipi)(const struct cpumask *);
	void (*send_call_func_single_ipi)(int);
};

typedef void (*smp_call_func_t)(void *);

struct __call_single_data {
	struct llist_node llist;
	smp_call_func_t func;
	void *info;
	unsigned int flags;
};

typedef int proc_handler(struct ctl_table *, int, void *, size_t *, loff_t *);

struct ctl_table_poll;

struct ctl_table {
	const char *procname;
	void *data;
	int maxlen;
	umode_t mode;
	struct ctl_table *child;
	proc_handler *proc_handler;
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};

struct ctl_table_poll {
	atomic_t event;
	wait_queue_head_t wait;
};

struct ctl_node {
	struct rb_node node;
	struct ctl_table_header *header;
};

struct ctl_table_root {
	struct ctl_table_set default_set;
	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
	void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *);
	int (*permissions)(struct ctl_table_header *, struct ctl_table *);
};

enum umh_disable_depth {
	UMH_ENABLED = 0,
	UMH_FREEZING = 1,
	UMH_DISABLED = 2,
};

typedef __u64 Elf64_Addr;

typedef __u16 Elf64_Half;

typedef __u64 Elf64_Off;

typedef __u32 Elf64_Word;

typedef __u64 Elf64_Xword;

struct elf64_sym {
	Elf64_Word st_name;
	unsigned char st_info;
	unsigned char st_other;
	Elf64_Half st_shndx;
	Elf64_Addr st_value;
	Elf64_Xword st_size;
};

typedef struct elf64_sym Elf64_Sym;

struct elf64_hdr {
	unsigned char e_ident[16];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
};

typedef struct elf64_hdr Elf64_Ehdr;

struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
};

typedef struct elf64_shdr Elf64_Shdr;

struct idr {
	struct xarray idr_rt;
	unsigned int idr_base;
	unsigned int idr_next;
};

struct kernfs_root;

struct kernfs_elem_dir {
	long unsigned int subdirs;
	struct rb_root children;
	struct kernfs_root *root;
};

struct kernfs_syscall_ops;

struct kernfs_root {
	struct kernfs_node *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_ino;
	u32 next_generation;
	struct kernfs_syscall_ops *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
};

struct kernfs_elem_symlink {
	struct kernfs_node *target_kn;
};

struct kernfs_ops;

struct kernfs_open_node;

struct kernfs_elem_attr {
	const struct kernfs_ops *ops;
	struct kernfs_open_node *open;
	loff_t size;
	struct kernfs_node *notify_next;
};

union kernfs_node_id {
	struct {
		u32 ino;
		u32 generation;
	};
	u64 id;
};

struct kernfs_iattrs;

struct kernfs_node {
	atomic_t count;
	atomic_t active;
	struct kernfs_node *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	union {
		struct kernfs_elem_dir dir;
		struct kernfs_elem_symlink symlink;
		struct kernfs_elem_attr attr;
	};
	void *priv;
	union kernfs_node_id id;
	short unsigned int flags;
	umode_t mode;
	struct kernfs_iattrs *iattr;
};

struct kernfs_open_file;

struct kernfs_ops {
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct kernfs_syscall_ops {
	int (*show_options)(struct seq_file *, struct kernfs_root *);
	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node *);
	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

struct seq_file {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	loff_t index;
	loff_t read_pos;
	u64 version;
	struct mutex lock;
	const struct seq_operations *op;
	int poll_event;
	const struct file *file;
	void *private;
};

struct kernfs_open_file {
	struct kernfs_node *kn;
	struct file *file;
	struct seq_file *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct *vm_ops;
};

typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
};

enum kobj_ns_type {
	KOBJ_NS_TYPE_NONE = 0,
	KOBJ_NS_TYPE_NET = 1,
	KOBJ_NS_TYPES = 2,
};

struct sock;

struct kobj_ns_type_operations {
	enum kobj_ns_type type;
	bool (*current_may_mount)();
	void * (*grab_current_ns)();
	const void * (*netlink_ns)(struct sock *);
	const void * (*initial_ns)();
	void (*drop_ns)(void *);
};

struct attribute {
	const char *name;
	umode_t mode;
};

struct bin_attribute;

struct attribute_group {
	const char *name;
	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int);
	struct attribute **attrs;
	struct bin_attribute **bin_attrs;
};

struct bin_attribute {
	struct attribute attr;
	size_t size;
	void *private;
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);
};

struct sysfs_ops {
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

struct kset_uevent_ops;

struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct kobj_type {
	void (*release)(struct kobject *);
	const struct sysfs_ops *sysfs_ops;
	struct attribute **default_attrs;
	const struct attribute_group **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(struct kobject *);
	const void * (*namespace)(struct kobject *);
	void (*get_ownership)(struct kobject *, kuid_t *, kgid_t *);
	long unsigned int kabi_reserved1;
};

struct kobj_uevent_env {
	char *argv[3];
	char *envp[32];
	int envp_idx;
	char buf[2048];
	int buflen;
};

struct kset_uevent_ops {
	int (* const filter)(struct kset *, struct kobject *);
	const char * (* const name)(struct kset *, struct kobject *);
	int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *);
};

struct kernel_param;

struct kernel_param_ops {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param *);
	int (*get)(char *, const struct kernel_param *);
	void (*free)(void *);
};

struct kparam_string;

struct kparam_array;

struct kernel_param {
	const char *name;
	struct module *mod;
	const struct kernel_param_ops *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array *arr;
	};
};

struct kparam_string {
	unsigned int maxlen;
	char *string;
};

struct kparam_array {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops *ops;
	void *elem;
};

enum module_state {
	MODULE_STATE_LIVE = 0,
	MODULE_STATE_COMING = 1,
	MODULE_STATE_GOING = 2,
	MODULE_STATE_UNFORMED = 3,
};

struct module_param_attrs;

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct latch_tree_node {
	struct rb_node node[2];
};

struct mod_tree_node {
	struct module *mod;
	struct latch_tree_node node;
};

struct module_layout {
	void *base;
	unsigned int size;
	unsigned int text_size;
	unsigned int ro_size;
	unsigned int ro_after_init_size;
	struct mod_tree_node mtn;
};

struct mod_arch_specific {};

struct mod_kallsyms {
	Elf64_Sym *symtab;
	unsigned int num_symtab;
	char *strtab;
	char *typetab;
};

struct module_attribute;

struct exception_table_entry;

struct module_sect_attrs;

struct module_notes_attrs;

struct trace_eval_map;

struct klp_modinfo;

struct error_injection_entry;

struct module {
	enum module_state state;
	struct list_head list;
	char name[56];
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject *holders_dir;
	const struct kernel_symbol *syms;
	const s32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const s32 *gpl_crcs;
	bool async_probe_requested;
	const struct kernel_symbol *gpl_future_syms;
	const s32 *gpl_future_crcs;
	unsigned int num_gpl_future_syms;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)();
	long: 64;
	long: 64;
	long: 64;
	struct module_layout core_layout;
	struct module_layout init_layout;
	struct mod_arch_specific arch;
	long unsigned int taints;
	unsigned int num_bugs;
	struct list_head bug_list;
	struct bug_entry *bug_table;
	struct mod_kallsyms *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	void *percpu;
	unsigned int percpu_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	unsigned int num_ftrace_callsites;
	long unsigned int *ftrace_callsites;
	bool klp;
	bool klp_alive;
	struct klp_modinfo *klp_info;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)();
	atomic_t refcnt;
	struct error_injection_entry *ei_funcs;
	unsigned int num_ei_funcs;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
};

struct error_injection_entry {
	long unsigned int addr;
	int etype;
};

struct module_attribute {
	struct attribute attr;
	ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);
	ssize_t (*store)(struct module_attribute *, struct module_kobject *, const char *, size_t);
	void (*setup)(struct module *, const char *);
	int (*test)(struct module *);
	void (*free)(struct module *);
};

struct klp_modinfo {
	Elf64_Ehdr hdr;
	Elf64_Shdr *sechdrs;
	char *secstrings;
	unsigned int symndx;
};

struct exception_table_entry {
	int insn;
	int fixup;
	int handler;
};

struct trace_event_functions;

struct trace_event {
	struct hlist_node node;
	struct list_head list;
	int type;
	struct trace_event_functions *funcs;
};

struct trace_event_class;

struct bpf_prog_array;

struct trace_event_call {
	struct list_head list;
	struct trace_event_class *class;
	union {
		char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	struct event_filter *filter;
	void *mod;
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head *perf_events;
	struct bpf_prog_array *prog_array;
	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
};

struct trace_eval_map {
	const char *system;
	const char *eval_string;
	long unsigned int eval_value;
};

struct fs_pin;

struct pid_namespace {
	struct kref kref;
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	struct pid_namespace *parent;
	struct vfsmount *proc_mnt;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
	struct fs_pin *bacct;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct work_struct proc_work;
	kgid_t pid_gid;
	int hide_pid;
	int reboot;
	struct ns_common ns;
	int max_map_count;
};

typedef struct {
	__u8 b[16];
} guid_t;

struct rlimit {
	__kernel_ulong_t rlim_cur;
	__kernel_ulong_t rlim_max;
};

struct task_cputime {
	u64 stime;
	u64 utime;
	long long unsigned int sum_exec_runtime;
};

typedef void __signalfn_t(int);

typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t();

typedef __restorefn_t *__sigrestore_t;

struct ratelimit_state {
	raw_spinlock_t lock;
	int interval;
	int burst;
	int printed;
	int missed;
	long unsigned int begin;
	long unsigned int flags;
};

struct user_struct {
	refcount_t __count;
	atomic_t processes;
	atomic_t sigpending;
	atomic_t fanotify_listeners;
	atomic_long_t epoll_watches;
	long unsigned int mq_bytes;
	long unsigned int locked_shm;
	long unsigned int unix_inflight;
	atomic_long_t pipe_bufs;
	struct hlist_node uidhash_node;
	kuid_t uid;
	atomic_long_t locked_vm;
	struct ratelimit_state ratelimit;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct sigaction {
	__sighandler_t sa_handler;
	long unsigned int sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
};

struct cpu_itimer {
	u64 expires;
	u64 incr;
};

struct task_cputime_atomic {
	atomic64_t utime;
	atomic64_t stime;
	atomic64_t sum_exec_runtime;
};

struct thread_group_cputimer {
	struct task_cputime_atomic cputime_atomic;
};

struct pacct_struct {
	int ac_flag;
	long int ac_exitcode;
	long unsigned int ac_mem;
	u64 ac_utime;
	u64 ac_stime;
	long unsigned int ac_minflt;
	long unsigned int ac_majflt;
};

struct tty_struct;

struct autogroup;

struct taskstats;

struct tty_audit_buf;

struct signal_struct {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct *group_exit_task;
	int group_stop_count;
	unsigned int flags;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	int posix_timer_id;
	struct list_head posix_timers;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid *pids[4];
	struct pid *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	struct autogroup *autogroup;
	seqlock_t stats_lock;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	long unsigned int cnvcsw;
	long unsigned int cnivcsw;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	long unsigned int cmin_flt;
	long unsigned int cmaj_flt;
	long unsigned int inblock;
	long unsigned int oublock;
	long unsigned int cinblock;
	long unsigned int coublock;
	long unsigned int maxrss;
	long unsigned int cmaxrss;
	struct task_io_accounting ioac;
	long long unsigned int sum_sched_runtime;
	struct rlimit rlim[16];
	struct pacct_struct pacct;
	struct taskstats *stats;
	unsigned int audit_tty;
	struct tty_audit_buf *tty_audit_buf;
	bool oom_flag_origin;
	short int oom_score_adj;
	short int oom_score_adj_min;
	struct mm_struct *oom_mm;
	struct mutex cred_guard_mutex;
	struct rw_semaphore exec_update_lock;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

typedef int32_t key_serial_t;

typedef uint32_t key_perm_t;

struct key_type;

struct key_tag;

struct keyring_index_key {
	long unsigned int hash;
	union {
		struct {
			u16 desc_len;
			char desc[6];
		};
		long unsigned int x;
	};
	struct key_type *type;
	struct key_tag *domain_tag;
	const char *description;
};

union key_payload {
	void *rcu_data0;
	void *data[4];
};

struct assoc_array_ptr;

struct assoc_array {
	struct assoc_array_ptr *root;
	long unsigned int nr_leaves_on_tree;
};

struct key_user;

struct key_restriction;

struct key {
	refcount_t usage;
	key_serial_t serial;
	union {
		struct list_head graveyard_link;
		struct rb_node serial_node;
	};
	struct rw_semaphore sem;
	struct key_user *user;
	void *security;
	union {
		time64_t expiry;
		time64_t revoked_at;
	};
	time64_t last_used_at;
	kuid_t uid;
	kgid_t gid;
	key_perm_t perm;
	short unsigned int quotalen;
	short unsigned int datalen;
	short int state;
	long unsigned int flags;
	union {
		struct keyring_index_key index_key;
		struct {
			long unsigned int hash;
			long unsigned int len_desc;
			struct key_type *type;
			struct key_tag *domain_tag;
			char *description;
		};
	};
	union {
		union key_payload payload;
		struct {
			struct list_head name_link;
			struct assoc_array keys;
		};
	};
	struct key_restriction *restrict_link;
};

struct uts_namespace;

struct ipc_namespace;

struct mnt_namespace;

struct net;

struct cgroup_namespace;

struct nsproxy {
	atomic_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net *net_ns;
	struct cgroup_namespace *cgroup_ns;
};

struct sighand_struct {
	spinlock_t siglock;
	refcount_t count;
	wait_queue_head_t signalfd_wqh;
	struct k_sigaction action[64];
};

struct bio;

struct bio_list {
	struct bio *head;
	struct bio *tail;
};

struct blk_plug {
	struct list_head mq_list;
	struct list_head cb_list;
	short unsigned int rq_count;
	bool multiple_queues;
};

struct reclaim_state {
	long unsigned int reclaimed_slab;
};

typedef int congested_fn(void *, int);

struct fprop_local_percpu {
	struct percpu_counter events;
	unsigned int period;
	raw_spinlock_t lock;
};

enum wb_reason {
	WB_REASON_BACKGROUND = 0,
	WB_REASON_VMSCAN = 1,
	WB_REASON_SYNC = 2,
	WB_REASON_PERIODIC = 3,
	WB_REASON_LAPTOP_TIMER = 4,
	WB_REASON_FREE_MORE_MEM = 5,
	WB_REASON_FS_FREE_SPACE = 6,
	WB_REASON_FORKER_THREAD = 7,
	WB_REASON_FOREIGN_FLUSH = 8,
	WB_REASON_MAX = 9,
};

struct bdi_writeback_congested;

struct bdi_writeback {
	struct backing_dev_info *bdi;
	long unsigned int state;
	long unsigned int last_old_flush;
	struct list_head b_dirty;
	struct list_head b_io;
	struct list_head b_more_io;
	struct list_head b_dirty_time;
	spinlock_t list_lock;
	struct percpu_counter stat[4];
	struct bdi_writeback_congested *congested;
	long unsigned int bw_time_stamp;
	long unsigned int dirtied_stamp;
	long unsigned int written_stamp;
	long unsigned int write_bandwidth;
	long unsigned int avg_write_bandwidth;
	long unsigned int dirty_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	struct fprop_local_percpu completions;
	int dirty_exceeded;
	enum wb_reason start_all_reason;
	spinlock_t work_lock;
	struct list_head work_list;
	struct delayed_work dwork;
	long unsigned int dirty_sleep;
	struct list_head bdi_node;
	struct percpu_ref refcnt;
	struct fprop_local_percpu memcg_completions;
	struct cgroup_subsys_state *memcg_css;
	struct cgroup_subsys_state *blkcg_css;
	struct list_head memcg_node;
	struct list_head blkcg_node;
	union {
		struct work_struct release_work;
		struct callback_head rcu;
	};
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct backing_dev_info {
	u64 id;
	struct rb_node rb_node;
	struct list_head bdi_list;
	long unsigned int ra_pages;
	long unsigned int io_pages;
	congested_fn *congested_fn;
	void *congested_data;
	const char *name;
	struct kref refcnt;
	unsigned int capabilities;
	unsigned int min_ratio;
	unsigned int max_ratio;
	unsigned int max_prop_frac;
	atomic_long_t tot_write_bandwidth;
	struct bdi_writeback wb;
	struct list_head wb_list;
	struct xarray cgwb_tree;
	struct rb_root cgwb_congested_tree;
	struct mutex cgwb_release_mutex;
	struct rw_semaphore wb_switch_rwsem;
	wait_queue_head_t wb_waitq;
	struct device *dev;
	char dev_name[64];
	struct device *owner;
	struct timer_list laptop_mode_wb_timer;
	struct dentry *debug_dir;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct css_set {
	struct cgroup_subsys_state *subsys[12];
	refcount_t refcount;
	struct css_set *dom_cset;
	struct cgroup *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[12];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_preload_node;
	struct list_head mg_node;
	struct cgroup *mg_src_cgrp;
	struct cgroup *mg_dst_cgrp;
	struct css_set *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

typedef u32 compat_uptr_t;

struct compat_robust_list {
	compat_uptr_t next;
};

typedef s32 compat_long_t;

struct compat_robust_list_head {
	struct compat_robust_list list;
	compat_long_t futex_offset;
	compat_uptr_t list_op_pending;
};

struct perf_event_groups {
	struct rb_root tree;
	u64 index;
};

struct perf_event_context {
	struct pmu *pmu;
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head active_ctx_list;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	struct list_head pinned_active;
	struct list_head flexible_active;
	int nr_events;
	int nr_active;
	int is_active;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	int rotate_necessary;
	refcount_t refcount;
	struct task_struct *task;
	u64 time;
	u64 timestamp;
	struct perf_event_context *parent_ctx;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	int nr_cgroups;
	void *task_ctx_data;
	struct callback_head callback_head;
};

struct task_delay_info {
	raw_spinlock_t lock;
	unsigned int flags;
	u64 blkio_start;
	u64 blkio_delay;
	u64 swapin_delay;
	u32 blkio_count;
	u32 swapin_count;
	u64 freepages_start;
	u64 freepages_delay;
	u64 thrashing_start;
	u64 thrashing_delay;
	u32 freepages_count;
	u32 thrashing_count;
};

struct ftrace_ret_stack {
	long unsigned int ret;
	long unsigned int func;
	long long unsigned int calltime;
	long long unsigned int subtime;
	long unsigned int *retp;
};

typedef unsigned int blk_qc_t;

typedef blk_qc_t make_request_fn(struct request_queue *, struct bio *);

struct request;

typedef int dma_drain_needed_fn(struct request *);

struct blk_integrity_profile;

struct blk_integrity {
	const struct blk_integrity_profile *profile;
	unsigned char flags;
	unsigned char tuple_size;
	unsigned char interval_exp;
	unsigned char tag_size;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct blk_rq_stat {
	u64 mean;
	u64 min;
	u64 max;
	u32 nr_samples;
	u64 batch;
};

enum blk_zoned_model {
	BLK_ZONED_NONE = 0,
	BLK_ZONED_HA = 1,
	BLK_ZONED_HM = 2,
};

struct queue_limits {
	long unsigned int bounce_pfn;
	long unsigned int seg_boundary_mask;
	long unsigned int virt_boundary_mask;
	unsigned int max_hw_sectors;
	unsigned int max_dev_sectors;
	unsigned int chunk_sectors;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	unsigned int physical_block_size;
	unsigned int logical_block_size;
	unsigned int alignment_offset;
	unsigned int io_min;
	unsigned int io_opt;
	unsigned int max_discard_sectors;
	unsigned int max_hw_discard_sectors;
	unsigned int max_write_same_sectors;
	unsigned int max_write_zeroes_sectors;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	short unsigned int nbd_ignore_blksize_set;
	short unsigned int max_segments;
	short unsigned int max_integrity_segments;
	short unsigned int max_discard_segments;
	unsigned char misaligned;
	unsigned char discard_misaligned;
	unsigned char raid_partial_stripes_expensive;
	enum blk_zoned_model zoned;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

struct bsg_ops;

struct bsg_class_device {
	struct device *class_dev;
	int minor;
	struct request_queue *queue;
	const struct bsg_ops *ops;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

typedef void *mempool_alloc_t(gfp_t, void *);

typedef void mempool_free_t(void *, void *);

struct mempool_s {
	spinlock_t lock;
	int min_nr;
	int curr_nr;
	void **elements;
	void *pool_data;
	mempool_alloc_t *alloc;
	mempool_free_t *free;
	wait_queue_head_t wait;
};

typedef struct mempool_s mempool_t;

struct bio_set {
	struct kmem_cache *bio_slab;
	unsigned int front_pad;
	mempool_t bio_pool;
	mempool_t bvec_pool;
	mempool_t bio_integrity_pool;
	mempool_t bvec_integrity_pool;
	spinlock_t rescue_lock;
	struct bio_list rescue_list;
	struct work_struct rescue_work;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	struct workqueue_struct *rescue_workqueue;
};

struct elevator_queue;

struct blk_queue_stats;

struct rq_qos;

struct blk_mq_ops;

struct blk_mq_ctx;

struct blk_mq_hw_ctx;

struct blk_stat_callback;

struct blkcg_gq;

struct blk_trace;

struct blk_flush_queue;

struct throtl_data;

struct blk_mq_tag_set;

struct request_queue {
	struct request *last_merge;
	struct elevator_queue *elevator;
	struct blk_queue_stats *stats;
	struct rq_qos *rq_qos;
	make_request_fn *make_request_fn;
	dma_drain_needed_fn *dma_drain_needed;
	const struct blk_mq_ops *mq_ops;
	struct blk_mq_ctx *queue_ctx;
	unsigned int nr_queues;
	unsigned int queue_depth;
	struct blk_mq_hw_ctx **queue_hw_ctx;
	unsigned int nr_hw_queues;
	struct backing_dev_info *backing_dev_info;
	void *queuedata;
	long unsigned int queue_flags;
	atomic_t pm_only;
	int id;
	gfp_t bounce_gfp;
	spinlock_t queue_lock;
	struct kobject kobj;
	struct kobject *mq_kobj;
	struct blk_integrity integrity;
	struct device *dev;
	int rpm_status;
	unsigned int nr_pending;
	long unsigned int nr_requests;
	unsigned int dma_drain_size;
	void *dma_drain_buffer;
	unsigned int dma_pad_mask;
	unsigned int dma_alignment;
	unsigned int rq_timeout;
	int poll_nsec;
	struct blk_stat_callback *poll_cb;
	struct blk_rq_stat poll_stat[16];
	struct timer_list timeout;
	struct work_struct timeout_work;
	struct list_head icq_list;
	long unsigned int blkcg_pols[1];
	struct blkcg_gq *root_blkg;
	struct list_head blkg_list;
	struct queue_limits limits;
	unsigned int required_elevator_features;
	unsigned int sg_timeout;
	unsigned int sg_reserved_size;
	int node;
	struct blk_trace *blk_trace;
	struct mutex blk_trace_mutex;
	struct blk_flush_queue *fq;
	struct list_head requeue_list;
	spinlock_t requeue_lock;
	struct delayed_work requeue_work;
	struct mutex sysfs_lock;
	struct mutex sysfs_dir_lock;
	struct list_head unused_hctx_list;
	spinlock_t unused_hctx_lock;
	int mq_freeze_depth;
	struct bsg_class_device bsg_dev;
	struct throtl_data *td;
	struct callback_head callback_head;
	wait_queue_head_t mq_freeze_wq;
	struct mutex mq_freeze_lock;
	struct percpu_ref q_usage_counter;
	struct blk_mq_tag_set *tag_set;
	struct list_head tag_set_list;
	struct bio_set bio_split;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct dentry *rqos_debugfs_dir;
	bool mq_sysfs_init_done;
	size_t cmd_size;
	struct work_struct release_work;
	u64 write_hints[5];
};

enum writeback_sync_modes {
	WB_SYNC_NONE = 0,
	WB_SYNC_ALL = 1,
};

struct writeback_control {
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	enum writeback_sync_modes sync_mode;
	unsigned int for_kupdate: 1;
	unsigned int for_background: 1;
	unsigned int tagged_writepages: 1;
	unsigned int for_reclaim: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_sync: 1;
	unsigned int no_cgroup_owner: 1;
	unsigned int punt_to_cgroup: 1;
	struct bdi_writeback *wb;
	struct inode *inode;
	int wb_id;
	int wb_lcand_id;
	int wb_tcand_id;
	size_t wb_bytes;
	size_t wb_lcand_bytes;
	size_t wb_tcand_bytes;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct iovec;

struct kvec;

struct bio_vec;

struct iov_iter {
	unsigned int type;
	size_t iov_offset;
	size_t count;
	union {
		const struct iovec *iov;
		const struct kvec *kvec;
		const struct bio_vec *bvec;
		struct pipe_inode_info *pipe;
	};
	union {
		long unsigned int nr_segs;
		struct {
			int idx;
			int start_idx;
		};
	};
};

struct swap_cluster_info {
	spinlock_t lock;
	unsigned int data: 24;
	unsigned int flags: 8;
};

struct swap_cluster_list {
	struct swap_cluster_info head;
	struct swap_cluster_info tail;
};

struct percpu_cluster;

struct swap_info_struct {
	long unsigned int flags;
	short int prio;
	struct plist_node list;
	signed char type;
	unsigned int max;
	unsigned char *swap_map;
	struct swap_cluster_info *cluster_info;
	struct swap_cluster_list free_clusters;
	unsigned int lowest_bit;
	unsigned int highest_bit;
	unsigned int pages;
	unsigned int inuse_pages;
	unsigned int cluster_next;
	unsigned int cluster_nr;
	struct percpu_cluster *percpu_cluster;
	struct rb_root swap_extent_root;
	struct block_device *bdev;
	struct file *swap_file;
	unsigned int old_block_size;
	spinlock_t lock;
	spinlock_t cont_lock;
	struct work_struct discard_work;
	struct swap_cluster_list discard_clusters;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	struct plist_node avail_lists[0];
};

struct partition_meta_info;

struct disk_stats;

struct hd_struct {
	sector_t start_sect;
	sector_t nr_sects;
	seqcount_t nr_sects_seq;
	sector_t alignment_offset;
	unsigned int discard_alignment;
	struct device __dev;
	struct kobject *holder_dir;
	int policy;
	int partno;
	struct partition_meta_info *info;
	long unsigned int stamp;
	struct disk_stats *dkstats;
	struct percpu_ref ref;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	struct rcu_work rcu_work;
};

struct disk_part_tbl;

struct block_device_operations;

struct timer_rand_state;

struct disk_events;

struct badblocks;

struct gendisk {
	int major;
	int first_minor;
	int minors;
	char disk_name[32];
	char * (*devnode)(struct gendisk *, umode_t *);
	short unsigned int events;
	short unsigned int event_flags;
	struct disk_part_tbl *part_tbl;
	struct hd_struct part0;
	const struct block_device_operations *fops;
	struct request_queue *queue;
	void *private_data;
	int flags;
	struct rw_semaphore lookup_sem;
	struct kobject *slave_dir;
	struct timer_rand_state *random;
	atomic_t sync_io;
	struct disk_events *ev;
	struct kobject integrity_kobj;
	int node_id;
	struct badblocks *bb;
	struct lockdep_map lockdep_map;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

struct audit_names;

struct filename {
	const char *name;
	const char *uptr;
	int refcnt;
	struct audit_names *aname;
	const char iname[0];
};

typedef u8 blk_status_t;

struct bvec_iter {
	sector_t bi_sector;
	unsigned int bi_size;
	unsigned int bi_idx;
	unsigned int bi_bvec_done;
};

typedef void bio_end_io_t(struct bio *);

struct bio_issue {
	u64 value;
};

struct bio_vec {
	struct page *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct bio_integrity_payload;

struct bio {
	struct bio *bi_next;
	struct gendisk *bi_disk;
	unsigned int bi_opf;
	short unsigned int bi_flags;
	short unsigned int bi_ioprio;
	short unsigned int bi_write_hint;
	blk_status_t bi_status;
	u8 bi_partno;
	struct bvec_iter bi_iter;
	atomic_t __bi_remaining;
	bio_end_io_t *bi_end_io;
	void *bi_private;
	struct blkcg_gq *bi_blkg;
	struct bio_issue bi_issue;
	u64 bi_iocost_cost;
	union {
		struct bio_integrity_payload *bi_integrity;
	};
	short unsigned int bi_vcnt;
	short unsigned int bi_max_vecs;
	atomic_t __bi_cnt;
	struct bio_vec *bi_io_vec;
	struct bio_set *bi_pool;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	struct bio_vec bi_inline_vecs[0];
};

struct linux_binprm {
	struct vm_area_struct *vma;
	long unsigned int vma_pages;
	struct mm_struct *mm;
	long unsigned int p;
	long unsigned int argmin;
	unsigned int called_set_creds: 1;
	unsigned int cap_elevated: 1;
	unsigned int secureexec: 1;
	unsigned int called_exec_mmap: 1;
	unsigned int recursion_depth;
	struct file *file;
	struct cred *cred;
	int unsafe;
	unsigned int per_clear;
	int argc;
	int envc;
	const char *filename;
	const char *interp;
	unsigned int interp_flags;
	unsigned int interp_data;
	long unsigned int loader;
	long unsigned int exec;
	struct rlimit rlim_stack;
	char buf[256];
};

struct coredump_params {
	const kernel_siginfo_t *siginfo;
	struct pt_regs *regs;
	struct file *file;
	long unsigned int limit;
	long unsigned int mm_flags;
	loff_t written;
	loff_t pos;
};

struct key_tag {
	struct callback_head rcu;
	refcount_t usage;
	bool removed;
};

typedef int (*request_key_actor_t)(struct key *, void *);

struct key_preparsed_payload;

struct key_match_data;

struct kernel_pkey_params;

struct kernel_pkey_query;

struct key_type {
	const char *name;
	size_t def_datalen;
	unsigned int flags;
	int (*vet_description)(const char *);
	int (*preparse)(struct key_preparsed_payload *);
	void (*free_preparse)(struct key_preparsed_payload *);
	int (*instantiate)(struct key *, struct key_preparsed_payload *);
	int (*update)(struct key *, struct key_preparsed_payload *);
	int (*match_preparse)(struct key_match_data *);
	void (*match_free)(struct key_match_data *);
	void (*revoke)(struct key *);
	void (*destroy)(struct key *);
	void (*describe)(const struct key *, struct seq_file *);
	long int (*read)(const struct key *, char *, size_t);
	request_key_actor_t request_key;
	struct key_restriction * (*lookup_restriction)(const char *);
	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
	struct list_head link;
	struct lock_class_key lock_class;
};

typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);

struct key_restriction {
	key_restrict_link_func_t check;
	struct key *key;
	struct key_type *keytype;
};

struct group_info {
	atomic_t usage;
	int ngroups;
	kgid_t gid[0];
};

struct ring_buffer_event {
	u32 type_len: 5;
	u32 time_delta: 27;
	u32 array[0];
};

struct seq_buf {
	char *buffer;
	size_t size;
	size_t len;
	loff_t readpos;
};

struct trace_seq {
	char buffer[4096];
	struct seq_buf seq;
	int full;
};

union perf_mem_data_src {
	__u64 val;
	struct {
		__u64 mem_op: 5;
		__u64 mem_lvl: 14;
		__u64 mem_snoop: 5;
		__u64 mem_lock: 2;
		__u64 mem_dtlb: 7;
		__u64 mem_lvl_num: 4;
		__u64 mem_remote: 1;
		__u64 mem_snoopx: 2;
		__u64 mem_rsvd: 24;
	};
};

struct perf_branch_entry {
	__u64 from;
	__u64 to;
	__u64 mispred: 1;
	__u64 predicted: 1;
	__u64 in_tx: 1;
	__u64 abort: 1;
	__u64 cycles: 16;
	__u64 type: 4;
	__u64 reserved: 40;
};

struct taskstats {
	__u16 version;
	__u32 ac_exitcode;
	__u8 ac_flag;
	__u8 ac_nice;
	__u64 cpu_count;
	__u64 cpu_delay_total;
	__u64 blkio_count;
	__u64 blkio_delay_total;
	__u64 swapin_count;
	__u64 swapin_delay_total;
	__u64 cpu_run_real_total;
	__u64 cpu_run_virtual_total;
	char ac_comm[32];
	__u8 ac_sched;
	__u8 ac_pad[3];
	int: 32;
	__u32 ac_uid;
	__u32 ac_gid;
	__u32 ac_pid;
	__u32 ac_ppid;
	__u32 ac_btime;
	__u64 ac_etime;
	__u64 ac_utime;
	__u64 ac_stime;
	__u64 ac_minflt;
	__u64 ac_majflt;
	__u64 coremem;
	__u64 virtmem;
	__u64 hiwater_rss;
	__u64 hiwater_vm;
	__u64 read_char;
	__u64 write_char;
	__u64 read_syscalls;
	__u64 write_syscalls;
	__u64 read_bytes;
	__u64 write_bytes;
	__u64 cancelled_write_bytes;
	__u64 nvcsw;
	__u64 nivcsw;
	__u64 ac_utimescaled;
	__u64 ac_stimescaled;
	__u64 cpu_scaled_run_real_total;
	__u64 freepages_count;
	__u64 freepages_delay_total;
	__u64 thrashing_count;
	__u64 thrashing_delay_total;
};

struct new_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};

struct uts_namespace {
	struct kref kref;
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

struct cgroup_namespace {
	refcount_t count;
	struct ns_common ns;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct css_set *root_cset;
};

struct proc_ns_operations {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common * (*get)(struct task_struct *);
	void (*put)(struct ns_common *);
	int (*install)(struct nsproxy *, struct ns_common *);
	struct user_namespace * (*owner)(struct ns_common *);
	struct ns_common * (*get_parent)(struct ns_common *);
};

struct ucounts {
	struct hlist_node node;
	struct user_namespace *ns;
	kuid_t uid;
	int count;
	atomic_t ucount[9];
};

struct perf_cpu_context;

struct pmu {
	struct list_head entry;
	struct module *module;
	struct device *dev;
	const struct attribute_group **attr_groups;
	const struct attribute_group **attr_update;
	const char *name;
	int type;
	int capabilities;
	int *pmu_disable_count;
	struct perf_cpu_context *pmu_cpu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu *);
	void (*pmu_disable)(struct pmu *);
	int (*event_init)(struct perf_event *);
	void (*event_mapped)(struct perf_event *, struct mm_struct *);
	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
	int (*add)(struct perf_event *, int);
	void (*del)(struct perf_event *, int);
	void (*start)(struct perf_event *, int);
	void (*stop)(struct perf_event *, int);
	void (*read)(struct perf_event *);
	void (*start_txn)(struct pmu *, unsigned int);
	int (*commit_txn)(struct pmu *);
	void (*cancel_txn)(struct pmu *);
	int (*event_idx)(struct perf_event *);
	void (*sched_task)(struct perf_event_context *, bool);
	size_t task_ctx_size;
	void * (*setup_aux)(struct perf_event *, void **, int, bool);
	void (*free_aux)(void *);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event *);
	int (*aux_output_match)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int (*check_period)(struct perf_event *, u64);
};

struct iovec {
	void *iov_base;
	__kernel_size_t iov_len;
};

struct kvec {
	void *iov_base;
	size_t iov_len;
};

struct dev_pm_ops {
	int (*prepare)(struct device *);
	void (*complete)(struct device *);
	int (*suspend)(struct device *);
	int (*resume)(struct device *);
	int (*freeze)(struct device *);
	int (*thaw)(struct device *);
	int (*poweroff)(struct device *);
	int (*restore)(struct device *);
	int (*suspend_late)(struct device *);
	int (*resume_early)(struct device *);
	int (*freeze_late)(struct device *);
	int (*thaw_early)(struct device *);
	int (*poweroff_late)(struct device *);
	int (*restore_early)(struct device *);
	int (*suspend_noirq)(struct device *);
	int (*resume_noirq)(struct device *);
	int (*freeze_noirq)(struct device *);
	int (*thaw_noirq)(struct device *);
	int (*poweroff_noirq)(struct device *);
	int (*restore_noirq)(struct device *);
	int (*runtime_suspend)(struct device *);
	int (*runtime_resume)(struct device *);
	int (*runtime_idle)(struct device *);
};

struct pm_subsys_data {
	spinlock_t lock;
	unsigned int refcount;
	struct list_head clock_list;
};

struct wakeup_source {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	long unsigned int timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	long unsigned int event_count;
	long unsigned int active_count;
	long unsigned int relax_count;
	long unsigned int expire_count;
	long unsigned int wakeup_count;
	struct device *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
};

struct dev_pm_domain {
	struct dev_pm_ops ops;
	void (*detach)(struct device *, bool);
	int (*activate)(struct device *);
	void (*sync)(struct device *);
	void (*dismiss)(struct device *);
};

enum dma_data_direction {
	DMA_BIDIRECTIONAL = 0,
	DMA_TO_DEVICE = 1,
	DMA_FROM_DEVICE = 2,
	DMA_NONE = 3,
};

struct sg_table;

struct scatterlist;

struct dma_map_ops {
	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);
	void (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);
	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);
	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
	dma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device *, u64);
	u64 (*get_required_mask)(struct device *);
	size_t (*max_mapping_size)(struct device *);
	long unsigned int (*get_merge_boundary)(struct device *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct iommu_ops;

struct subsys_private;

struct bus_type {
	const char *name;
	const char *dev_name;
	struct device *dev_root;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;
	int (*match)(struct device *, struct device_driver *);
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	int (*probe)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*online)(struct device *);
	int (*offline)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	int (*num_vf)(struct device *);
	int (*dma_configure)(struct device *);
	const struct dev_pm_ops *pm;
	const struct iommu_ops *iommu_ops;
	struct subsys_private *p;
	struct lock_class_key lock_key;
	bool need_parent_lock;
};

enum probe_type {
	PROBE_DEFAULT_STRATEGY = 0,
	PROBE_PREFER_ASYNCHRONOUS = 1,
	PROBE_FORCE_SYNCHRONOUS = 2,
};

struct of_device_id;

struct acpi_device_id;

struct driver_private;

struct device_driver {
	const char *name;
	struct bus_type *bus;
	struct module *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	const struct dev_pm_ops *pm;
	void (*coredump)(struct device *);
	struct driver_private *p;
};

enum iommu_cap {
	IOMMU_CAP_CACHE_COHERENCY = 0,
	IOMMU_CAP_INTR_REMAP = 1,
	IOMMU_CAP_NOEXEC = 2,
};

enum iommu_attr {
	DOMAIN_ATTR_GEOMETRY = 0,
	DOMAIN_ATTR_PAGING = 1,
	DOMAIN_ATTR_WINDOWS = 2,
	DOMAIN_ATTR_FSL_PAMU_STASH = 3,
	DOMAIN_ATTR_FSL_PAMU_ENABLE = 4,
	DOMAIN_ATTR_FSL_PAMUV1 = 5,
	DOMAIN_ATTR_NESTING = 6,
	DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE = 7,
	DOMAIN_ATTR_MAX = 8,
};

enum iommu_dev_features {
	IOMMU_DEV_FEAT_AUX = 0,
	IOMMU_DEV_FEAT_SVA = 1,
};

struct iommu_domain;

struct iommu_iotlb_gather;

struct iommu_resv_region;

struct of_phandle_args;

struct iommu_sva;

struct iommu_fault_event;

struct iommu_page_response;

struct iommu_ops {
	bool (*capable)(enum iommu_cap);
	struct iommu_domain * (*domain_alloc)(unsigned int);
	void (*domain_free)(struct iommu_domain *);
	int (*attach_dev)(struct iommu_domain *, struct device *);
	void (*detach_dev)(struct iommu_domain *, struct device *);
	int (*map)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, int);
	size_t (*unmap)(struct iommu_domain *, long unsigned int, size_t, struct iommu_iotlb_gather *);
	void (*flush_iotlb_all)(struct iommu_domain *);
	void (*iotlb_sync_map)(struct iommu_domain *);
	void (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t);
	int (*add_device)(struct device *);
	void (*remove_device)(struct device *);
	struct iommu_group * (*device_group)(struct device *);
	int (*domain_get_attr)(struct iommu_domain *, enum iommu_attr, void *);
	int (*domain_set_attr)(struct iommu_domain *, enum iommu_attr, void *);
	void (*get_resv_regions)(struct device *, struct list_head *);
	void (*put_resv_regions)(struct device *, struct list_head *);
	void (*apply_resv_region)(struct device *, struct iommu_domain *, struct iommu_resv_region *);
	int (*domain_window_enable)(struct iommu_domain *, u32, phys_addr_t, u64, int);
	void (*domain_window_disable)(struct iommu_domain *, u32);
	int (*of_xlate)(struct device *, struct of_phandle_args *);
	bool (*is_attach_deferred)(struct iommu_domain *, struct device *);
	bool (*dev_has_feat)(struct device *, enum iommu_dev_features);
	bool (*dev_feat_enabled)(struct device *, enum iommu_dev_features);
	int (*dev_enable_feat)(struct device *, enum iommu_dev_features);
	int (*dev_disable_feat)(struct device *, enum iommu_dev_features);
	int (*aux_attach_dev)(struct iommu_domain *, struct device *);
	void (*aux_detach_dev)(struct iommu_domain *, struct device *);
	int (*aux_get_pasid)(struct iommu_domain *, struct device *);
	struct iommu_sva * (*sva_bind)(struct device *, struct mm_struct *, void *);
	void (*sva_unbind)(struct iommu_sva *);
	int (*sva_get_pasid)(struct iommu_sva *);
	int (*page_response)(struct device *, struct iommu_fault_event *, struct iommu_page_response *);
	long unsigned int pgsize_bitmap;
};

struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device *);
	const struct dev_pm_ops *pm;
};

struct of_device_id {
	char name[32];
	char type[32];
	char compatible[128];
	const void *data;
};

typedef long unsigned int kernel_ulong_t;

struct acpi_device_id {
	__u8 id[9];
	kernel_ulong_t driver_data;
	__u32 cls;
	__u32 cls_msk;
};

struct class {
	const char *name;
	struct module *owner;
	const struct attribute_group **class_groups;
	const struct attribute_group **dev_groups;
	struct kobject *dev_kobj;
	int (*dev_uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *);
	void (*class_release)(struct class *);
	void (*dev_release)(struct device *);
	int (*shutdown_pre)(struct device *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(struct device *);
	void (*get_ownership)(struct device *, kuid_t *, kgid_t *);
	const struct dev_pm_ops *pm;
	struct subsys_private *p;
	long unsigned int kabi_reserved1;
};

struct device_dma_parameters {
	unsigned int max_segment_size;
	long unsigned int segment_boundary_mask;
};

enum irq_domain_bus_token {
	DOMAIN_BUS_ANY = 0,
	DOMAIN_BUS_WIRED = 1,
	DOMAIN_BUS_GENERIC_MSI = 2,
	DOMAIN_BUS_PCI_MSI = 3,
	DOMAIN_BUS_PLATFORM_MSI = 4,
	DOMAIN_BUS_NEXUS = 5,
	DOMAIN_BUS_IPI = 6,
	DOMAIN_BUS_FSL_MC_MSI = 7,
	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
};

struct irq_domain_ops;

struct irq_domain_chip_generic;

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
	struct irq_domain *parent;
	irq_hw_number_t hwirq_max;
	unsigned int revmap_direct_max_irq;
	unsigned int revmap_size;
	struct xarray revmap_tree;
	struct mutex revmap_tree_mutex;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	unsigned int linear_revmap[0];
};

typedef u32 phandle;

struct property;

struct device_node {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node *parent;
	struct device_node *child;
	struct device_node *sibling;
	long unsigned int _flags;
	void *data;
};

enum cpuhp_state {
	CPUHP_INVALID = 4294967295,
	CPUHP_OFFLINE = 0,
	CPUHP_CREATE_THREADS = 1,
	CPUHP_PERF_PREPARE = 2,
	CPUHP_PERF_X86_PREPARE = 3,
	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
	CPUHP_PERF_POWER = 5,
	CPUHP_PERF_SUPERH = 6,
	CPUHP_X86_HPET_DEAD = 7,
	CPUHP_X86_APB_DEAD = 8,
	CPUHP_X86_MCE_DEAD = 9,
	CPUHP_VIRT_NET_DEAD = 10,
	CPUHP_SLUB_DEAD = 11,
	CPUHP_MM_WRITEBACK_DEAD = 12,
	CPUHP_MM_VMSTAT_DEAD = 13,
	CPUHP_SOFTIRQ_DEAD = 14,
	CPUHP_NET_MVNETA_DEAD = 15,
	CPUHP_CPUIDLE_DEAD = 16,
	CPUHP_ARM64_FPSIMD_DEAD = 17,
	CPUHP_ARM_OMAP_WAKE_DEAD = 18,
	CPUHP_IRQ_POLL_DEAD = 19,
	CPUHP_BLOCK_SOFTIRQ_DEAD = 20,
	CPUHP_ACPI_CPUDRV_DEAD = 21,
	CPUHP_S390_PFAULT_DEAD = 22,
	CPUHP_BLK_MQ_DEAD = 23,
	CPUHP_FS_BUFF_DEAD = 24,
	CPUHP_PRINTK_DEAD = 25,
	CPUHP_MM_MEMCQ_DEAD = 26,
	CPUHP_PERCPU_CNT_DEAD = 27,
	CPUHP_RADIX_DEAD = 28,
	CPUHP_PAGE_ALLOC_DEAD = 29,
	CPUHP_NET_DEV_DEAD = 30,
	CPUHP_PCI_XGENE_DEAD = 31,
	CPUHP_IOMMU_INTEL_DEAD = 32,
	CPUHP_LUSTRE_CFS_DEAD = 33,
	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 34,
	CPUHP_PADATA_DEAD = 35,
	CPUHP_WORKQUEUE_PREP = 36,
	CPUHP_POWER_NUMA_PREPARE = 37,
	CPUHP_HRTIMERS_PREPARE = 38,
	CPUHP_PROFILE_PREPARE = 39,
	CPUHP_X2APIC_PREPARE = 40,
	CPUHP_SMPCFD_PREPARE = 41,
	CPUHP_RELAY_PREPARE = 42,
	CPUHP_SLAB_PREPARE = 43,
	CPUHP_MD_RAID5_PREPARE = 44,
	CPUHP_RCUTREE_PREP = 45,
	CPUHP_CPUIDLE_COUPLED_PREPARE = 46,
	CPUHP_POWERPC_PMAC_PREPARE = 47,
	CPUHP_POWERPC_MMU_CTX_PREPARE = 48,
	CPUHP_XEN_PREPARE = 49,
	CPUHP_XEN_EVTCHN_PREPARE = 50,
	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 51,
	CPUHP_SH_SH3X_PREPARE = 52,
	CPUHP_NET_FLOW_PREPARE = 53,
	CPUHP_TOPOLOGY_PREPARE = 54,
	CPUHP_NET_IUCV_PREPARE = 55,
	CPUHP_ARM_BL_PREPARE = 56,
	CPUHP_TRACE_RB_PREPARE = 57,
	CPUHP_MM_ZS_PREPARE = 58,
	CPUHP_MM_ZSWP_MEM_PREPARE = 59,
	CPUHP_MM_ZSWP_POOL_PREPARE = 60,
	CPUHP_KVM_PPC_BOOK3S_PREPARE = 61,
	CPUHP_ZCOMP_PREPARE = 62,
	CPUHP_TIMERS_PREPARE = 63,
	CPUHP_MIPS_SOC_PREPARE = 64,
	CPUHP_BP_PREPARE_DYN = 65,
	CPUHP_BP_PREPARE_DYN_END = 85,
	CPUHP_BRINGUP_CPU = 86,
	CPUHP_AP_IDLE_DEAD = 87,
	CPUHP_AP_OFFLINE = 88,
	CPUHP_AP_SCHED_STARTING = 89,
	CPUHP_AP_RCUTREE_DYING = 90,
	CPUHP_AP_IRQ_GIC_STARTING = 91,
	CPUHP_AP_IRQ_HIP04_STARTING = 92,
	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 93,
	CPUHP_AP_IRQ_BCM2836_STARTING = 94,
	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 95,
	CPUHP_AP_ARM_MVEBU_COHERENCY = 96,
	CPUHP_AP_MICROCODE_LOADER = 97,
	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 98,
	CPUHP_AP_PERF_X86_STARTING = 99,
	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 100,
	CPUHP_AP_PERF_X86_CQM_STARTING = 101,
	CPUHP_AP_PERF_X86_CSTATE_STARTING = 102,
	CPUHP_AP_PERF_XTENSA_STARTING = 103,
	CPUHP_AP_MIPS_OP_LOONGSON3_STARTING = 104,
	CPUHP_AP_ARM_SDEI_STARTING = 105,
	CPUHP_AP_ARM_VFP_STARTING = 106,
	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 107,
	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 108,
	CPUHP_AP_PERF_ARM_ACPI_STARTING = 109,
	CPUHP_AP_PERF_ARM_STARTING = 110,
	CPUHP_AP_ARM_L2X0_STARTING = 111,
	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 112,
	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 113,
	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 114,
	CPUHP_AP_JCORE_TIMER_STARTING = 115,
	CPUHP_AP_ARM_TWD_STARTING = 116,
	CPUHP_AP_QCOM_TIMER_STARTING = 117,
	CPUHP_AP_TEGRA_TIMER_STARTING = 118,
	CPUHP_AP_ARMADA_TIMER_STARTING = 119,
	CPUHP_AP_MARCO_TIMER_STARTING = 120,
	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 121,
	CPUHP_AP_ARC_TIMER_STARTING = 122,
	CPUHP_AP_RISCV_TIMER_STARTING = 123,
	CPUHP_AP_CSKY_TIMER_STARTING = 124,
	CPUHP_AP_KVM_STARTING = 125,
	CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING = 126,
	CPUHP_AP_KVM_ARM_VGIC_STARTING = 127,
	CPUHP_AP_KVM_ARM_TIMER_STARTING = 128,
	CPUHP_AP_DUMMY_TIMER_STARTING = 129,
	CPUHP_AP_ARM_XEN_STARTING = 130,
	CPUHP_AP_ARM_CORESIGHT_STARTING = 131,
	CPUHP_AP_ARM64_ISNDEP_STARTING = 132,
	CPUHP_AP_SMPCFD_DYING = 133,
	CPUHP_AP_X86_TBOOT_DYING = 134,
	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 135,
	CPUHP_AP_ONLINE = 136,
	CPUHP_TEARDOWN_CPU = 137,
	CPUHP_AP_ONLINE_IDLE = 138,
	CPUHP_AP_SMPBOOT_THREADS = 139,
	CPUHP_AP_X86_VDSO_VMA_ONLINE = 140,
	CPUHP_AP_IRQ_AFFINITY_ONLINE = 141,
	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 142,
	CPUHP_AP_X86_INTEL_EPB_ONLINE = 143,
	CPUHP_AP_PERF_ONLINE = 144,
	CPUHP_AP_PERF_X86_ONLINE = 145,
	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 146,
	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 147,
	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 148,
	CPUHP_AP_PERF_X86_RAPL_ONLINE = 149,
	CPUHP_AP_PERF_X86_CQM_ONLINE = 150,
	CPUHP_AP_PERF_X86_CSTATE_ONLINE = 151,
	CPUHP_AP_PERF_S390_CF_ONLINE = 152,
	CPUHP_AP_PERF_S390_SF_ONLINE = 153,
	CPUHP_AP_PERF_ARM_CCI_ONLINE = 154,
	CPUHP_AP_PERF_ARM_CCN_ONLINE = 155,
	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 156,
	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 157,
	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 158,
	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 159,
	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 160,
	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 161,
	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 162,
	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 163,
	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 164,
	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 165,
	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 166,
	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 167,
	CPUHP_AP_WATCHDOG_ONLINE = 168,
	CPUHP_AP_WORKQUEUE_ONLINE = 169,
	CPUHP_AP_RCUTREE_ONLINE = 170,
	CPUHP_AP_BASE_CACHEINFO_ONLINE = 171,
	CPUHP_AP_ONLINE_DYN = 172,
	CPUHP_AP_ONLINE_DYN_END = 202,
	CPUHP_AP_X86_HPET_ONLINE = 203,
	CPUHP_AP_X86_KVM_CLK_ONLINE = 204,
	CPUHP_AP_ACTIVE = 205,
	CPUHP_ONLINE = 206,
};

struct perf_regs {
	__u64 abi;
	struct pt_regs *regs;
};

struct u64_stats_sync {};

struct bpf_cgroup_storage_key {
	__u64 cgroup_inode_id;
	__u32 attach_type;
};

struct bpf_cgroup_storage;

struct bpf_prog_array_item {
	struct bpf_prog *prog;
	struct bpf_cgroup_storage *cgroup_storage[2];
};

struct bpf_storage_buffer;

struct bpf_cgroup_storage_map;

struct bpf_cgroup_storage {
	union {
		struct bpf_storage_buffer *buf;
		void *percpu_buf;
	};
	struct bpf_cgroup_storage_map *map;
	struct bpf_cgroup_storage_key key;
	struct list_head list;
	struct rb_node node;
	struct callback_head rcu;
};

struct bpf_prog_array {
	struct callback_head rcu;
	struct bpf_prog_array_item items[0];
};

struct bpf_storage_buffer {
	struct callback_head rcu;
	char data[0];
};

struct cgroup_base_stat {
	struct task_cputime cputime;
};

struct kthread_work;

typedef void (*kthread_work_func_t)(struct kthread_work *);

struct kthread_worker;

struct kthread_work {
	struct list_head node;
	kthread_work_func_t func;
	struct kthread_worker *worker;
	int canceling;
};

struct kthread_delayed_work {
	struct kthread_work work;
	struct timer_list timer;
};

struct psi_group_cpu;

struct psi_group {
	struct mutex avgs_lock;
	struct psi_group_cpu *pcpu;
	u64 avg_total[5];
	u64 avg_last_update;
	u64 avg_next_update;
	struct delayed_work avgs_work;
	u64 total[10];
	long unsigned int avg[15];
	atomic_t poll_scheduled;
	struct kthread_worker *poll_kworker;
	struct kthread_delayed_work poll_work;
	struct mutex trigger_lock;
	struct list_head triggers;
	u32 nr_triggers[5];
	u32 poll_states;
	u64 poll_min_period;
	u64 polling_total[5];
	u64 polling_next_update;
	u64 polling_until;
};

struct cgroup_bpf {
	struct bpf_prog_array *effective[45];
	struct list_head progs[45];
	u32 flags[45];
	struct bpf_prog_array *inactive;
	struct percpu_ref refcnt;
	struct work_struct release_work;
};

struct cgroup_freezer_state {
	bool freeze;
	int e_freeze;
	int nr_frozen_descendants;
	int nr_frozen_tasks;
};

struct cgroup_root;

struct cgroup_rstat_cpu;

struct mbuf_slot;

struct sli_memlat_stat;

struct sli_schedlat_stat;

struct sli_event_monitor;

struct sli_notify_ctx;

struct cgroup {
	struct cgroup_subsys_state self;
	long unsigned int flags;
	int id;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	struct kernfs_node *kn;
	struct cgroup_file procs_file;
	struct cgroup_file events_file;
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state *subsys[12];
	struct cgroup_root *root;
	struct list_head cset_links;
	struct list_head e_csets[12];
	struct cgroup *dom_cgrp;
	struct cgroup *old_dom_cgrp;
	struct cgroup_rstat_cpu *rstat_cpu;
	struct list_head rstat_css_list;
	struct cgroup_base_stat pending_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group psi;
	struct cgroup_bpf bpf;
	atomic_t congestion_count;
	struct cgroup_freezer_state freezer;
	struct mbuf_slot *mbuf;
	struct sli_memlat_stat *sli_memlat_stat_percpu;
	struct sli_schedlat_stat *sli_schedlat_stat_percpu;
	struct sli_event_monitor *cgrp_event_monitor;
	struct sli_notify_ctx *sctx;
	spinlock_t cgrp_mbuf_lock;
	int ancestor_ids[0];
};

struct kthread_worker {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct *task;
	struct kthread_work *current_work;
};

struct psi_group_cpu {
	seqcount_t seq;
	unsigned int tasks[3];
	u32 state_mask;
	u32 times[6];
	u64 state_start;
	long: 64;
	u32 times_prev[12];
	long: 64;
	long: 64;
};

struct mbuf_ring {
	u32 base_idx;
	u32 first_idx;
	u64 first_seq;
	u32 next_idx;
	u64 next_seq;
	u32 end_idx;
};

struct mbuf_user_desc {
	u64 user_seq;
	u32 user_idx;
	char buf[1024];
};

struct mbuf_operations;

struct mbuf_slot {
	u32 idx;
	spinlock_t slot_lock;
	struct ratelimit_state ratelimit;
	struct cgroup *owner;
	const struct mbuf_operations *ops;
	struct mbuf_ring *mring;
	struct mbuf_user_desc *udesc;
};

struct mbuf_operations {
	ssize_t (*read)(struct mbuf_slot *, struct mbuf_user_desc *);
	u32 (*next)(struct mbuf_ring *, u32);
	ssize_t (*write)(struct cgroup *, const char *, struct __va_list_tag *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cgroup_taskset;

struct cftype;

struct cgroup_subsys {
	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
	int (*css_online)(struct cgroup_subsys_state *);
	void (*css_offline)(struct cgroup_subsys_state *);
	void (*css_released)(struct cgroup_subsys_state *);
	void (*css_free)(struct cgroup_subsys_state *);
	void (*css_reset)(struct cgroup_subsys_state *);
	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)();
	int (*can_fork)(struct task_struct *);
	void (*cancel_fork)(struct task_struct *);
	void (*fork)(struct task_struct *);
	void (*exit)(struct task_struct *);
	void (*release)(struct task_struct *);
	void (*bind)(struct cgroup_subsys_state *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	bool broken_hierarchy: 1;
	bool warned_broken_hierarchy: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	unsigned int depends_on;
};

struct cgroup_rstat_cpu {
	struct u64_stats_sync bsync;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup *updated_children;
	struct cgroup *updated_next;
};

struct cgroup_root {
	struct kernfs_root *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	struct cgroup cgrp;
	int cgrp_ancestor_id_storage;
	atomic_t nr_cgrps;
	struct list_head root_list;
	unsigned int flags;
	struct idr cgroup_idr;
	char release_agent_path[4096];
	char name[64];
};

struct sli_memlat_stat {
	long unsigned int latency_max[6];
	long unsigned int item[48];
};

struct sli_schedlat_stat {
	long unsigned int latency_max[7];
	long unsigned int item[56];
};

struct sli_event_monitor {
	struct list_head event_head;
	struct work_struct sli_event_work;
	struct cgroup *cgrp;
	int period;
	int mbuf_enable;
	int overrun;
	long long unsigned int last_update;
	long long unsigned int schedlat_threshold[7];
	long long unsigned int schedlat_count[7];
	atomic_long_t schedlat_statistics[7];
	long long unsigned int memlat_threshold[6];
	long long unsigned int memlat_count[6];
	atomic_long_t memlat_statistics[6];
	long long unsigned int longterm_threshold[2];
	atomic_long_t longterm_statistics[2];
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct sli_notify_event {
	u32 notify_vector[48];
};

struct sli_notify_ctx {
	int count;
	spinlock_t notify_lock;
	struct sli_notify_event notify_event;
	wait_queue_head_t wqh;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct cftype {
	char name[64];
	long unsigned int private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys *ss;
	struct list_head node;
	struct kernfs_ops *kf_ops;
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
};

struct perf_callchain_entry {
	__u64 nr;
	__u64 ip[0];
};

typedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);

struct perf_raw_frag {
	union {
		struct perf_raw_frag *next;
		long unsigned int pad;
	};
	perf_copy_f copy;
	void *data;
	u32 size;
} __attribute__((packed));

struct perf_raw_record {
	struct perf_raw_frag frag;
	u32 size;
};

struct perf_branch_stack {
	__u64 nr;
	struct perf_branch_entry entries[0];
};

struct perf_cpu_context {
	struct perf_event_context ctx;
	struct perf_event_context *task_ctx;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
	struct perf_cgroup *cgrp;
	struct list_head cgrp_cpuctx_entry;
	struct list_head sched_cb_entry;
	int sched_cb_usage;
	int online;
};

struct perf_addr_filter_range {
	long unsigned int start;
	long unsigned int size;
};

struct perf_sample_data {
	u64 addr;
	struct perf_raw_record *raw;
	struct perf_branch_stack *br_stack;
	u64 period;
	u64 weight;
	u64 txn;
	union perf_mem_data_src data_src;
	u64 type;
	u64 ip;
	struct {
		u32 pid;
		u32 tid;
	} tid_entry;
	u64 time;
	u64 id;
	u64 stream_id;
	struct {
		u32 cpu;
		u32 reserved;
	} cpu_entry;
	struct perf_callchain_entry *callchain;
	struct perf_regs regs_user;
	struct pt_regs regs_user_copy;
	struct perf_regs regs_intr;
	u64 stack_user_size;
	u64 phys_addr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct perf_cgroup_info;

struct perf_cgroup {
	struct cgroup_subsys_state css;
	struct perf_cgroup_info *info;
};

struct perf_cgroup_info {
	u64 time;
	u64 timestamp;
};

struct trace_entry {
	short unsigned int type;
	unsigned char flags;
	unsigned char preempt_count;
	int pid;
};

struct trace_array;

struct tracer;

struct trace_buffer;

struct ring_buffer_iter;

struct trace_iterator {
	struct trace_array *tr;
	struct tracer *trace;
	struct trace_buffer *trace_buffer;
	void *private;
	int cpu_file;
	struct mutex mutex;
	struct ring_buffer_iter **buffer_iter;
	long unsigned int iter_flags;
	struct trace_seq tmp_seq;
	cpumask_var_t started;
	bool snapshot;
	struct trace_seq seq;
	struct trace_entry *ent;
	long unsigned int lost_events;
	int leftover;
	int ent_size;
	int cpu;
	u64 ts;
	loff_t pos;
	long int idx;
};

enum print_line_t {
	TRACE_TYPE_PARTIAL_LINE = 0,
	TRACE_TYPE_HANDLED = 1,
	TRACE_TYPE_UNHANDLED = 2,
	TRACE_TYPE_NO_CONSUME = 3,
};

typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);

struct trace_event_functions {
	trace_print_func trace;
	trace_print_func raw;
	trace_print_func hex;
	trace_print_func binary;
};

enum trace_reg {
	TRACE_REG_REGISTER = 0,
	TRACE_REG_UNREGISTER = 1,
	TRACE_REG_PERF_REGISTER = 2,
	TRACE_REG_PERF_UNREGISTER = 3,
	TRACE_REG_PERF_OPEN = 4,
	TRACE_REG_PERF_CLOSE = 5,
	TRACE_REG_PERF_ADD = 6,
	TRACE_REG_PERF_DEL = 7,
};

struct trace_event_class {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
	int (*define_fields)(struct trace_event_call *);
	struct list_head * (*get_fields)(struct trace_event_call *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call *);
};

struct trace_event_file;

struct trace_event_buffer {
	struct ring_buffer *buffer;
	struct ring_buffer_event *event;
	struct trace_event_file *trace_file;
	void *entry;
	long unsigned int flags;
	int pc;
};

struct trace_subsystem_dir;

struct trace_event_file {
	struct list_head list;
	struct trace_event_call *event_call;
	struct event_filter *filter;
	struct dentry *dir;
	struct trace_array *tr;
	struct trace_subsystem_dir *system;
	struct list_head triggers;
	long unsigned int flags;
	atomic_t sm_ref;
	atomic_t tm_ref;
};

enum {
	TRACE_EVENT_FL_FILTERED = 1,
	TRACE_EVENT_FL_CAP_ANY = 2,
	TRACE_EVENT_FL_NO_SET_FILTER = 4,
	TRACE_EVENT_FL_IGNORE_ENABLE = 8,
	TRACE_EVENT_FL_TRACEPOINT = 16,
	TRACE_EVENT_FL_KPROBE = 32,
	TRACE_EVENT_FL_UPROBE = 64,
};

enum {
	EVENT_FILE_FL_ENABLED = 1,
	EVENT_FILE_FL_RECORDED_CMD = 2,
	EVENT_FILE_FL_RECORDED_TGID = 4,
	EVENT_FILE_FL_FILTERED = 8,
	EVENT_FILE_FL_NO_SET_FILTER = 16,
	EVENT_FILE_FL_SOFT_MODE = 32,
	EVENT_FILE_FL_SOFT_DISABLED = 64,
	EVENT_FILE_FL_TRIGGER_MODE = 128,
	EVENT_FILE_FL_TRIGGER_COND = 256,
	EVENT_FILE_FL_PID_FILTER = 512,
	EVENT_FILE_FL_WAS_ENABLED = 1024,
};

enum event_trigger_type {
	ETT_NONE = 0,
	ETT_TRACE_ONOFF = 1,
	ETT_SNAPSHOT = 2,
	ETT_STACKTRACE = 4,
	ETT_EVENT_ENABLE = 8,
	ETT_EVENT_HIST = 16,
	ETT_HIST_ENABLE = 32,
};

enum {
	FILTER_OTHER = 0,
	FILTER_STATIC_STRING = 1,
	FILTER_DYN_STRING = 2,
	FILTER_PTR_STRING = 3,
	FILTER_TRACE_FN = 4,
	FILTER_COMM = 5,
	FILTER_CPU = 6,
};

struct property {
	char *name;
	int length;
	void *value;
	struct property *next;
};

struct irq_fwspec {
	struct fwnode_handle *fwnode;
	int param_count;
	u32 param[16];
};

struct irq_data;

struct irq_domain_ops {
	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
	void (*unmap)(struct irq_domain *, unsigned int);
	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);
	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
	void (*free)(struct irq_domain *, unsigned int, unsigned int);
	int (*activate)(struct irq_domain *, struct irq_data *, bool);
	void (*deactivate)(struct irq_domain *, struct irq_data *);
	int (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);
};

enum wb_stat_item {
	WB_RECLAIMABLE = 0,
	WB_WRITEBACK = 1,
	WB_DIRTIED = 2,
	WB_WRITTEN = 3,
	NR_WB_STAT_ITEMS = 4,
};

struct bdi_writeback_congested {
	long unsigned int state;
	refcount_t refcnt;
	struct backing_dev_info *__bdi;
	int blkcg_id;
	struct rb_node rb_node;
};

struct bio_integrity_payload {
	struct bio *bip_bio;
	struct bvec_iter bip_iter;
	short unsigned int bip_slab;
	short unsigned int bip_vcnt;
	short unsigned int bip_max_vcnt;
	short unsigned int bip_flags;
	struct bvec_iter bio_iter;
	struct work_struct bip_work;
	struct bio_vec *bip_vec;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	struct bio_vec bip_inline_vecs[0];
};

struct blkg_rwstat {
	struct percpu_counter cpu_cnt[5];
	atomic64_t aux_cnt[5];
};

struct blkcg;

struct blkg_policy_data;

struct blkcg_gq {
	struct request_queue *q;
	struct list_head q_node;
	struct hlist_node blkcg_node;
	struct blkcg *blkcg;
	struct bdi_writeback_congested *wb_congested;
	struct blkcg_gq *parent;
	struct percpu_ref refcnt;
	bool online;
	struct blkg_rwstat stat_bytes;
	struct blkg_rwstat stat_ios;
	struct blkg_policy_data *pd[5];
	spinlock_t async_bio_lock;
	struct bio_list async_bios;
	struct work_struct async_bio_work;
	atomic_t use_delay;
	atomic64_t delay_nsec;
	atomic64_t delay_start;
	u64 last_delay;
	int last_use;
	struct callback_head callback_head;
};

enum stat_group {
	STAT_READ = 0,
	STAT_WRITE = 1,
	STAT_DISCARD = 2,
	NR_STAT_GROUPS = 3,
};

struct disk_stats {
	u64 nsecs[3];
	long unsigned int sectors[3];
	long unsigned int ios[3];
	long unsigned int merges[3];
	long unsigned int io_ticks;
	long unsigned int time_in_queue;
	local_t in_flight[2];
};

struct partition_meta_info {
	char uuid[37];
	u8 volname[64];
};

struct disk_part_tbl {
	struct callback_head callback_head;
	int len;
	struct hd_struct *last_lookup;
	struct hd_struct *part[0];
};

struct blk_integrity_iter;

typedef blk_status_t integrity_processing_fn(struct blk_integrity_iter *);

typedef void integrity_prepare_fn(struct request *);

typedef void integrity_complete_fn(struct request *, unsigned int);

struct blk_integrity_profile {
	integrity_processing_fn *generate_fn;
	integrity_processing_fn *verify_fn;
	integrity_prepare_fn *prepare_fn;
	integrity_complete_fn *complete_fn;
	const char *name;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct hd_geometry;

struct blk_zone;

struct pr_ops;

struct block_device_operations {
	int (*open)(struct block_device *, fmode_t);
	void (*release)(struct gendisk *, fmode_t);
	int (*rw_page)(struct block_device *, sector_t, struct page *, unsigned int);
	int (*ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	unsigned int (*check_events)(struct gendisk *, unsigned int);
	int (*media_changed)(struct gendisk *);
	void (*unlock_native_capacity)(struct gendisk *);
	int (*revalidate_disk)(struct gendisk *);
	int (*getgeo)(struct block_device *, struct hd_geometry *);
	void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
	int (*report_zones)(struct gendisk *, sector_t, struct blk_zone *, unsigned int *);
	struct module *owner;
	const struct pr_ops *pr_ops;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct sg_io_v4 {
	__s32 guard;
	__u32 protocol;
	__u32 subprotocol;
	__u32 request_len;
	__u64 request;
	__u64 request_tag;
	__u32 request_attr;
	__u32 request_priority;
	__u32 request_extra;
	__u32 max_response_len;
	__u64 response;
	__u32 dout_iovec_count;
	__u32 dout_xfer_len;
	__u32 din_iovec_count;
	__u32 din_xfer_len;
	__u64 dout_xferp;
	__u64 din_xferp;
	__u32 timeout;
	__u32 flags;
	__u64 usr_ptr;
	__u32 spare_in;
	__u32 driver_status;
	__u32 transport_status;
	__u32 device_status;
	__u32 retry_delay;
	__u32 info;
	__u32 duration;
	__u32 response_len;
	__s32 din_resid;
	__s32 dout_resid;
	__u64 generated_tag;
	__u32 spare_out;
	__u32 padding;
};

struct bsg_ops {
	int (*check_proto)(struct sg_io_v4 *);
	int (*fill_hdr)(struct request *, struct sg_io_v4 *, fmode_t);
	int (*complete_rq)(struct request *, struct sg_io_v4 *);
	void (*free_rq)(struct request *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

typedef __u32 req_flags_t;

typedef void rq_end_io_fn(struct request *, blk_status_t);

enum mq_rq_state {
	MQ_RQ_IDLE = 0,
	MQ_RQ_IN_FLIGHT = 1,
	MQ_RQ_COMPLETE = 2,
};

struct request {
	struct request_queue *q;
	struct blk_mq_ctx *mq_ctx;
	struct blk_mq_hw_ctx *mq_hctx;
	unsigned int cmd_flags;
	req_flags_t rq_flags;
	int tag;
	int internal_tag;
	unsigned int __data_len;
	sector_t __sector;
	struct bio *bio;
	struct bio *biotail;
	struct list_head queuelist;
	union {
		struct hlist_node hash;
		struct list_head ipi_list;
	};
	union {
		struct rb_node rb_node;
		struct bio_vec special_vec;
		void *completion_data;
		int error_count;
	};
	union {
		struct {
			struct io_cq *icq;
			void *priv[2];
		} elv;
		struct {
			unsigned int seq;
			struct list_head list;
			rq_end_io_fn *saved_end_io;
		} flush;
	};
	struct gendisk *rq_disk;
	struct hd_struct *part;
	u64 alloc_time_ns;
	u64 start_time_ns;
	u64 io_start_time_ns;
	short unsigned int wbt_flags;
	short unsigned int stats_sectors;
	short unsigned int nr_phys_segments;
	short unsigned int nr_integrity_segments;
	short unsigned int write_hint;
	short unsigned int ioprio;
	unsigned int extra_len;
	enum mq_rq_state state;
	refcount_t ref;
	unsigned int timeout;
	long unsigned int deadline;
	union {
		struct __call_single_data csd;
		u64 fifo_time;
	};
	rq_end_io_fn *end_io;
	void *end_io_data;
};

struct blk_zone {
	__u64 start;
	__u64 len;
	__u64 wp;
	__u8 type;
	__u8 cond;
	__u8 non_seq;
	__u8 reset;
	__u8 reserved[36];
};

enum elv_merge {
	ELEVATOR_NO_MERGE = 0,
	ELEVATOR_FRONT_MERGE = 1,
	ELEVATOR_BACK_MERGE = 2,
	ELEVATOR_DISCARD_MERGE = 3,
};

struct elevator_type;

struct blk_mq_alloc_data;

struct elevator_mq_ops {
	int (*init_sched)(struct request_queue *, struct elevator_type *);
	void (*exit_sched)(struct elevator_queue *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*depth_updated)(struct blk_mq_hw_ctx *);
	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
	bool (*bio_merge)(struct blk_mq_hw_ctx *, struct bio *, unsigned int);
	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
	void (*limit_depth)(unsigned int, struct blk_mq_alloc_data *);
	void (*prepare_request)(struct request *, struct bio *);
	void (*finish_request)(struct request *);
	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool);
	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
	bool (*has_work)(struct blk_mq_hw_ctx *);
	void (*completed_request)(struct request *, u64);
	void (*requeue_request)(struct request *);
	struct request * (*former_request)(struct request_queue *, struct request *);
	struct request * (*next_request)(struct request_queue *, struct request *);
	void (*init_icq)(struct io_cq *);
	void (*exit_icq)(struct io_cq *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct elv_fs_entry;

struct blk_mq_debugfs_attr;

struct elevator_type {
	struct kmem_cache *icq_cache;
	struct elevator_mq_ops ops;
	size_t icq_size;
	size_t icq_align;
	struct elv_fs_entry *elevator_attrs;
	const char *elevator_name;
	const char *elevator_alias;
	const unsigned int elevator_features;
	struct module *elevator_owner;
	const struct blk_mq_debugfs_attr *queue_debugfs_attrs;
	const struct blk_mq_debugfs_attr *hctx_debugfs_attrs;
	char icq_cache_name[22];
	struct list_head list;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct elevator_queue {
	struct elevator_type *type;
	void *elevator_data;
	struct kobject kobj;
	struct mutex sysfs_lock;
	unsigned int registered: 1;
	struct hlist_head hash[64];
};

struct elv_fs_entry {
	struct attribute attr;
	ssize_t (*show)(struct elevator_queue *, char *);
	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};

struct blk_mq_debugfs_attr {
	const char *name;
	umode_t mode;
	int (*show)(void *, struct seq_file *);
	ssize_t (*write)(void *, const char *, size_t, loff_t *);
	const struct seq_operations *seq_ops;
};

struct blk_mq_queue_data;

typedef blk_status_t queue_rq_fn(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);

typedef void commit_rqs_fn(struct blk_mq_hw_ctx *);

typedef bool get_budget_fn(struct blk_mq_hw_ctx *);

typedef void put_budget_fn(struct blk_mq_hw_ctx *);

enum blk_eh_timer_return {
	BLK_EH_DONE = 0,
	BLK_EH_RESET_TIMER = 1,
};

typedef enum blk_eh_timer_return timeout_fn(struct request *, bool);

typedef int poll_fn(struct blk_mq_hw_ctx *);

typedef void complete_fn(struct request *);

typedef int init_hctx_fn(struct blk_mq_hw_ctx *, void *, unsigned int);

typedef void exit_hctx_fn(struct blk_mq_hw_ctx *, unsigned int);

typedef int init_request_fn(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);

typedef void exit_request_fn(struct blk_mq_tag_set *, struct request *, unsigned int);

typedef void cleanup_rq_fn(struct request *);

typedef bool busy_fn(struct request_queue *);

typedef int map_queues_fn(struct blk_mq_tag_set *);

struct blk_mq_ops {
	queue_rq_fn *queue_rq;
	commit_rqs_fn *commit_rqs;
	get_budget_fn *get_budget;
	put_budget_fn *put_budget;
	timeout_fn *timeout;
	poll_fn *poll;
	complete_fn *complete;
	init_hctx_fn *init_hctx;
	exit_hctx_fn *exit_hctx;
	init_request_fn *init_request;
	exit_request_fn *exit_request;
	void (*initialize_rq_fn)(struct request *);
	cleanup_rq_fn *cleanup_rq;
	busy_fn *busy;
	map_queues_fn *map_queues;
	void (*show_rq)(struct seq_file *, struct request *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct blk_integrity_iter {
	void *prot_buf;
	void *data_buf;
	sector_t seed;
	unsigned int data_size;
	short unsigned int interval;
	const char *disk_name;
};

enum pr_type {
	PR_WRITE_EXCLUSIVE = 1,
	PR_EXCLUSIVE_ACCESS = 2,
	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

struct pr_ops {
	int (*pr_register)(struct block_device *, u64, u64, u32);
	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
	int (*pr_release)(struct block_device *, u64, enum pr_type);
	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
	int (*pr_clear)(struct block_device *, u64);
};

enum blkg_rwstat_type {
	BLKG_RWSTAT_READ = 0,
	BLKG_RWSTAT_WRITE = 1,
	BLKG_RWSTAT_SYNC = 2,
	BLKG_RWSTAT_ASYNC = 3,
	BLKG_RWSTAT_DISCARD = 4,
	BLKG_RWSTAT_NR = 5,
	BLKG_RWSTAT_TOTAL = 5,
};

struct blkcg_dkstats {
	struct disk_stats *dkstats;
	struct list_head alloc_node;
	struct hd_struct *part;
	struct list_head list_node;
	struct callback_head callback_head;
};

struct blkcg_policy_data;

struct blkcg {
	struct cgroup_subsys_state css;
	spinlock_t lock;
	struct xarray blkg_tree;
	struct blkcg_gq *blkg_hint;
	struct hlist_head blkg_list;
	struct blkcg_policy_data *cpd[5];
	struct list_head all_blkcgs_node;
	struct list_head cgwb_list;
	refcount_t cgwb_refcnt;
	unsigned int dkstats_on;
	struct list_head dkstats_list;
	struct blkcg_dkstats *dkstats_hint;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct blkcg_policy_data {
	struct blkcg *blkcg;
	int plid;
};

struct blkg_policy_data {
	struct blkcg_gq *blkg;
	int plid;
};

enum cpu_idle_type {
	CPU_IDLE = 0,
	CPU_NOT_IDLE = 1,
	CPU_NEWLY_IDLE = 2,
	CPU_MAX_IDLE_TYPES = 3,
};

typedef long unsigned int efi_status_t;

typedef u8 efi_bool_t;

typedef u16 efi_char16_t;

typedef u64 efi_physical_addr_t;

typedef void *efi_handle_t;

typedef guid_t efi_guid_t;

typedef struct {
	u64 signature;
	u32 revision;
	u32 headersize;
	u32 crc32;
	u32 reserved;
} efi_table_hdr_t;

typedef struct {
	u32 type;
	u32 pad;
	u64 phys_addr;
	u64 virt_addr;
	u64 num_pages;
	u64 attribute;
} efi_memory_desc_t;

typedef struct {
	efi_guid_t guid;
	u32 headersize;
	u32 flags;
	u32 imagesize;
} efi_capsule_header_t;

typedef struct {
	u16 year;
	u8 month;
	u8 day;
	u8 hour;
	u8 minute;
	u8 second;
	u8 pad1;
	u32 nanosecond;
	s16 timezone;
	u8 daylight;
	u8 pad2;
} efi_time_t;

typedef struct {
	u32 resolution;
	u32 accuracy;
	u8 sets_to_zero;
} efi_time_cap_t;

typedef struct {
	efi_table_hdr_t hdr;
	void *raise_tpl;
	void *restore_tpl;
	efi_status_t (*allocate_pages)(int, int, long unsigned int, efi_physical_addr_t *);
	efi_status_t (*free_pages)(efi_physical_addr_t, long unsigned int);
	efi_status_t (*get_memory_map)(long unsigned int *, void *, long unsigned int *, long unsigned int *, u32 *);
	efi_status_t (*allocate_pool)(int, long unsigned int, void **);
	efi_status_t (*free_pool)(void *);
	void *create_event;
	void *set_timer;
	void *wait_for_event;
	void *signal_event;
	void *close_event;
	void *check_event;
	void *install_protocol_interface;
	void *reinstall_protocol_interface;
	void *uninstall_protocol_interface;
	efi_status_t (*handle_protocol)(efi_handle_t, efi_guid_t *, void **);
	void *__reserved;
	void *register_protocol_notify;
	efi_status_t (*locate_handle)(int, efi_guid_t *, void *, long unsigned int *, efi_handle_t *);
	void *locate_device_path;
	efi_status_t (*install_configuration_table)(efi_guid_t *, void *);
	void *load_image;
	void *start_image;
	void *exit;
	void *unload_image;
	efi_status_t (*exit_boot_services)(efi_handle_t, long unsigned int);
	void *get_next_monotonic_count;
	void *stall;
	void *set_watchdog_timer;
	void *connect_controller;
	void *disconnect_controller;
	void *open_protocol;
	void *close_protocol;
	void *open_protocol_information;
	void *protocols_per_handle;
	void *locate_handle_buffer;
	efi_status_t (*locate_protocol)(efi_guid_t *, void *, void **);
	void *install_multiple_protocol_interfaces;
	void *uninstall_multiple_protocol_interfaces;
	void *calculate_crc32;
	void *copy_mem;
	void *set_mem;
	void *create_event_ex;
} efi_boot_services_t;

typedef efi_status_t efi_get_time_t(efi_time_t *, efi_time_cap_t *);

typedef efi_status_t efi_set_time_t(efi_time_t *);

typedef efi_status_t efi_get_wakeup_time_t(efi_bool_t *, efi_bool_t *, efi_time_t *);

typedef efi_status_t efi_set_wakeup_time_t(efi_bool_t, efi_time_t *);

typedef efi_status_t efi_get_variable_t(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);

typedef efi_status_t efi_get_next_variable_t(long unsigned int *, efi_char16_t *, efi_guid_t *);

typedef efi_status_t efi_set_variable_t(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);

typedef efi_status_t efi_get_next_high_mono_count_t(u32 *);

typedef void efi_reset_system_t(int, efi_status_t, long unsigned int, efi_char16_t *);

typedef efi_status_t efi_set_virtual_address_map_t(long unsigned int, long unsigned int, u32, efi_memory_desc_t *);

typedef efi_status_t efi_query_variable_info_t(u32, u64 *, u64 *, u64 *);

typedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **, long unsigned int, long unsigned int);

typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **, long unsigned int, u64 *, int *);

typedef struct {
	efi_table_hdr_t hdr;
	efi_get_time_t *get_time;
	efi_set_time_t *set_time;
	efi_get_wakeup_time_t *get_wakeup_time;
	efi_set_wakeup_time_t *set_wakeup_time;
	efi_set_virtual_address_map_t *set_virtual_address_map;
	void *convert_pointer;
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_get_next_high_mono_count_t *get_next_high_mono_count;
	efi_reset_system_t *reset_system;
	efi_update_capsule_t *update_capsule;
	efi_query_capsule_caps_t *query_capsule_caps;
	efi_query_variable_info_t *query_variable_info;
} efi_runtime_services_t;

typedef struct {
	efi_table_hdr_t hdr;
	long unsigned int fw_vendor;
	u32 fw_revision;
	long unsigned int con_in_handle;
	long unsigned int con_in;
	long unsigned int con_out_handle;
	long unsigned int con_out;
	long unsigned int stderr_handle;
	long unsigned int stderr;
	efi_runtime_services_t *runtime;
	efi_boot_services_t *boottime;
	long unsigned int nr_tables;
	long unsigned int tables;
} efi_system_table_t;

struct efi_memory_map {
	phys_addr_t phys_map;
	void *map;
	void *map_end;
	int nr_map;
	long unsigned int desc_version;
	long unsigned int desc_size;
	bool late;
};

struct efi {
	efi_system_table_t *systab;
	unsigned int runtime_version;
	long unsigned int mps;
	long unsigned int acpi;
	long unsigned int acpi20;
	long unsigned int smbios;
	long unsigned int smbios3;
	long unsigned int boot_info;
	long unsigned int hcdp;
	long unsigned int uga;
	long unsigned int fw_vendor;
	long unsigned int runtime;
	long unsigned int config_table;
	long unsigned int esrt;
	long unsigned int properties_table;
	long unsigned int mem_attr_table;
	long unsigned int rng_seed;
	long unsigned int tpm_log;
	long unsigned int tpm_final_log;
	long unsigned int mem_reserve;
	efi_get_time_t *get_time;
	efi_set_time_t *set_time;
	efi_get_wakeup_time_t *get_wakeup_time;
	efi_set_wakeup_time_t *set_wakeup_time;
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_info_t *query_variable_info;
	efi_query_variable_info_t *query_variable_info_nonblocking;
	efi_update_capsule_t *update_capsule;
	efi_query_capsule_caps_t *query_capsule_caps;
	efi_get_next_high_mono_count_t *get_next_high_mono_count;
	efi_reset_system_t *reset_system;
	efi_set_virtual_address_map_t *set_virtual_address_map;
	struct efi_memory_map memmap;
	long unsigned int flags;
};

enum memcg_stat_item {
	MEMCG_CACHE = 32,
	MEMCG_RSS = 33,
	MEMCG_RSS_HUGE = 34,
	MEMCG_SWAP = 35,
	MEMCG_SOCK = 36,
	MEMCG_KERNEL_STACK_KB = 37,
	MEMCG_NR_STAT = 38,
};

enum memcg_memory_event {
	MEMCG_LOW = 0,
	MEMCG_HIGH = 1,
	MEMCG_MAX = 2,
	MEMCG_OOM = 3,
	MEMCG_OOM_KILL = 4,
	MEMCG_SWAP_MAX = 5,
	MEMCG_SWAP_FAIL = 6,
	MEMCG_PAGECACHE_MAX = 7,
	MEMCG_PAGECACHE_OOM = 8,
	MEMCG_NR_MEMORY_EVENTS = 9,
};

enum mem_cgroup_events_target {
	MEM_CGROUP_TARGET_THRESH = 0,
	MEM_CGROUP_TARGET_SOFTLIMIT = 1,
	MEM_CGROUP_TARGET_NUMAINFO = 2,
	MEM_CGROUP_NTARGETS = 3,
};

struct memcg_vmstats_percpu {
	long int stat[38];
	long unsigned int events[85];
	long unsigned int nr_page_events;
	long unsigned int targets[3];
};

struct mem_cgroup_reclaim_iter {
	struct mem_cgroup *position;
	unsigned int generation;
};

struct lruvec_stat {
	long int count[32];
};

struct memcg_shrinker_map {
	struct callback_head rcu;
	long unsigned int map[0];
};

struct mem_cgroup_per_node {
	struct lruvec lruvec;
	struct lruvec_stat *lruvec_stat_local;
	struct lruvec_stat *lruvec_stat_cpu;
	atomic_long_t lruvec_stat[32];
	long unsigned int lru_zone_size[25];
	struct mem_cgroup_reclaim_iter iter[13];
	struct memcg_shrinker_map *shrinker_map;
	struct rb_node tree_node;
	long unsigned int usage_in_excess;
	bool on_tree;
	bool congested;
	struct mem_cgroup *memcg;
};

struct eventfd_ctx;

struct mem_cgroup_threshold {
	struct eventfd_ctx *eventfd;
	long unsigned int threshold;
};

struct mem_cgroup_threshold_ary {
	int current_threshold;
	unsigned int size;
	struct mem_cgroup_threshold entries[0];
};

struct percpu_cluster {
	struct swap_cluster_info index;
	unsigned int next;
};

struct trace_event_raw_initcall_level {
	struct trace_entry ent;
	u32 __data_loc_level;
	char __data[0];
};

struct trace_event_raw_initcall_start {
	struct trace_entry ent;
	initcall_t func;
	char __data[0];
};

struct trace_event_raw_initcall_finish {
	struct trace_entry ent;
	initcall_t func;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_initcall_level {
	u32 level;
};

struct trace_event_data_offsets_initcall_start {};

struct trace_event_data_offsets_initcall_finish {};

typedef void (*btf_trace_initcall_level)(void *, const char *);

typedef void (*btf_trace_initcall_start)(void *, initcall_t);

typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);

struct blacklist_entry {
	struct list_head next;
	char *buf;
};

enum page_cache_mode {
	_PAGE_CACHE_MODE_WB = 0,
	_PAGE_CACHE_MODE_WC = 1,
	_PAGE_CACHE_MODE_UC_MINUS = 2,
	_PAGE_CACHE_MODE_UC = 3,
	_PAGE_CACHE_MODE_WT = 4,
	_PAGE_CACHE_MODE_WP = 5,
	_PAGE_CACHE_MODE_NUM = 8,
};

enum {
	UNAME26 = 131072,
	ADDR_NO_RANDOMIZE = 262144,
	FDPIC_FUNCPTRS = 524288,
	MMAP_PAGE_ZERO = 1048576,
	ADDR_COMPAT_LAYOUT = 2097152,
	READ_IMPLIES_EXEC = 4194304,
	ADDR_LIMIT_32BIT = 8388608,
	SHORT_INODE = 16777216,
	WHOLE_SECONDS = 33554432,
	STICKY_TIMEOUTS = 67108864,
	ADDR_LIMIT_3GB = 134217728,
};

enum tlb_infos {
	ENTRIES = 0,
	NR_INFO = 1,
};

enum {
	MM_FILEPAGES = 0,
	MM_ANONPAGES = 1,
	MM_SWAPENTS = 2,
	MM_SHMEMPAGES = 3,
	NR_MM_COUNTERS = 4,
};

typedef __u32 Elf32_Word;

struct elf32_note {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
};

enum pcpu_fc {
	PCPU_FC_AUTO = 0,
	PCPU_FC_EMBED = 1,
	PCPU_FC_PAGE = 2,
	PCPU_FC_NR = 3,
};

enum hrtimer_base_type {
	HRTIMER_BASE_MONOTONIC = 0,
	HRTIMER_BASE_REALTIME = 1,
	HRTIMER_BASE_BOOTTIME = 2,
	HRTIMER_BASE_TAI = 3,
	HRTIMER_BASE_MONOTONIC_SOFT = 4,
	HRTIMER_BASE_REALTIME_SOFT = 5,
	HRTIMER_BASE_BOOTTIME_SOFT = 6,
	HRTIMER_BASE_TAI_SOFT = 7,
	HRTIMER_MAX_CLOCK_BASES = 8,
};

enum rseq_cs_flags_bit {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

enum perf_event_task_context {
	perf_invalid_context = 4294967295,
	perf_hw_context = 0,
	perf_sw_context = 1,
	perf_nr_task_contexts = 2,
};

enum rseq_event_mask_bits {
	RSEQ_EVENT_PREEMPT_BIT = 0,
	RSEQ_EVENT_SIGNAL_BIT = 1,
	RSEQ_EVENT_MIGRATE_BIT = 2,
};

enum {
	PROC_ROOT_INO = 1,
	PROC_IPC_INIT_INO = 4026531839,
	PROC_UTS_INIT_INO = 4026531838,
	PROC_USER_INIT_INO = 4026531837,
	PROC_PID_INIT_INO = 4026531836,
	PROC_CGROUP_INIT_INO = 4026531835,
};

typedef __u16 __le16;

typedef __u16 __be16;

typedef __u32 __be32;

typedef __u64 __be64;

typedef __u32 __wsum;

typedef unsigned int slab_flags_t;

struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);

struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block *next;
	int priority;
};

struct llist_head {
	struct llist_node *first;
};

typedef __u64 __addrpair;

typedef __u32 __portpair;

typedef struct {
	struct net *net;
} possible_net_t;

struct in6_addr {
	union {
		__u8 u6_addr8[16];
		__be16 u6_addr16[8];
		__be32 u6_addr32[4];
	} in6_u;
};

struct hlist_nulls_node {
	struct hlist_nulls_node *next;
	struct hlist_nulls_node **pprev;
};

struct proto;

struct inet_timewait_death_row;

struct sock_common {
	union {
		__addrpair skc_addrpair;
		struct {
			__be32 skc_daddr;
			__be32 skc_rcv_saddr;
		};
	};
	union {
		unsigned int skc_hash;
		__u16 skc_u16hashes[2];
	};
	union {
		__portpair skc_portpair;
		struct {
			__be16 skc_dport;
			__u16 skc_num;
		};
	};
	short unsigned int skc_family;
	volatile unsigned char skc_state;
	unsigned char skc_reuse: 4;
	unsigned char skc_reuseport: 1;
	unsigned char skc_ipv6only: 1;
	unsigned char skc_net_refcnt: 1;
	int skc_bound_dev_if;
	union {
		struct hlist_node skc_bind_node;
		struct hlist_node skc_portaddr_node;
	};
	struct proto *skc_prot;
	possible_net_t skc_net;
	struct in6_addr skc_v6_daddr;
	struct in6_addr skc_v6_rcv_saddr;
	atomic64_t skc_cookie;
	union {
		long unsigned int skc_flags;
		struct sock *skc_listener;
		struct inet_timewait_death_row *skc_tw_dr;
	};
	int skc_dontcopy_begin[0];
	union {
		struct hlist_node skc_node;
		struct hlist_nulls_node skc_nulls_node;
	};
	short unsigned int skc_tx_queue_mapping;
	short unsigned int skc_rx_queue_mapping;
	union {
		int skc_incoming_cpu;
		u32 skc_rcv_wnd;
		u32 skc_tw_rcv_nxt;
	};
	refcount_t skc_refcnt;
	int skc_dontcopy_end[0];
	union {
		u32 skc_rxhash;
		u32 skc_window_clamp;
		u32 skc_tw_snd_nxt;
	};
};

typedef struct {
	spinlock_t slock;
	int owned;
	wait_queue_head_t wq;
} socket_lock_t;

struct sk_buff;

struct sk_buff_head {
	struct sk_buff *next;
	struct sk_buff *prev;
	__u32 qlen;
	spinlock_t lock;
};

typedef u64 netdev_features_t;

struct sock_cgroup_data {
	union {
		struct {
			u8 is_data: 1;
			u8 no_refcnt: 1;
			u8 unused: 6;
			u8 padding;
			u16 prioidx;
			u32 classid;
		};
		u64 val;
	};
};

struct tvpc_info {
	u32 vpcid;
	__be32 vmip;
	__be32 vip;
	__be16 sport;
	__be16 vport;
};

struct sk_filter;

struct socket_wq;

struct xfrm_policy;

struct dst_entry;

struct socket;

struct sock_reuseport;

struct bpf_local_storage;

struct sock {
	struct sock_common __sk_common;
	socket_lock_t sk_lock;
	atomic_t sk_drops;
	int sk_rcvlowat;
	struct sk_buff_head sk_error_queue;
	struct sk_buff *sk_rx_skb_cache;
	struct sk_buff_head sk_receive_queue;
	struct {
		atomic_t rmem_alloc;
		int len;
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	int sk_forward_alloc;
	unsigned int sk_ll_usec;
	unsigned int sk_napi_id;
	int sk_rcvbuf;
	struct sk_filter *sk_filter;
	union {
		struct socket_wq *sk_wq;
		struct socket_wq *sk_wq_raw;
	};
	struct xfrm_policy *sk_policy[2];
	struct dst_entry *sk_rx_dst;
	struct dst_entry *sk_dst_cache;
	atomic_t sk_omem_alloc;
	int sk_sndbuf;
	int sk_wmem_queued;
	refcount_t sk_wmem_alloc;
	long unsigned int sk_tsq_flags;
	union {
		struct sk_buff *sk_send_head;
		struct rb_root tcp_rtx_queue;
	};
	struct sk_buff *sk_tx_skb_cache;
	struct sk_buff_head sk_write_queue;
	__s32 sk_peek_off;
	int sk_write_pending;
	__u32 sk_dst_pending_confirm;
	u32 sk_pacing_status;
	long int sk_sndtimeo;
	struct timer_list sk_timer;
	__u32 sk_priority;
	__u32 sk_mark;
	__u32 sk_mark2;
	long unsigned int sk_pacing_rate;
	long unsigned int sk_max_pacing_rate;
	struct page_frag sk_frag;
	netdev_features_t sk_route_caps;
	netdev_features_t sk_route_nocaps;
	netdev_features_t sk_route_forced_caps;
	int sk_gso_type;
	unsigned int sk_gso_max_size;
	gfp_t sk_allocation;
	__u32 sk_txhash;
	u8 sk_padding: 1;
	u8 sk_kern_sock: 1;
	u8 sk_no_check_tx: 1;
	u8 sk_no_check_rx: 1;
	u8 sk_userlocks: 4;
	u8 sk_pacing_shift;
	u16 sk_type;
	u16 sk_protocol;
	u16 sk_gso_max_segs;
	long unsigned int sk_lingertime;
	struct proto *sk_prot_creator;
	rwlock_t sk_callback_lock;
	int sk_err;
	int sk_err_soft;
	u32 sk_ack_backlog;
	u32 sk_max_ack_backlog;
	kuid_t sk_uid;
	struct pid *sk_peer_pid;
	const struct cred *sk_peer_cred;
	long int sk_rcvtimeo;
	ktime_t sk_stamp;
	u16 sk_tsflags;
	u8 sk_shutdown;
	atomic_t sk_tskey;
	atomic_t sk_zckey;
	u8 sk_clockid;
	u8 sk_txtime_deadline_mode: 1;
	u8 sk_txtime_report_errors: 1;
	u8 sk_txtime_unused: 6;
	struct socket *sk_socket;
	void *sk_user_data;
	void *sk_security;
	struct sock_cgroup_data sk_cgrp_data;
	struct mem_cgroup *sk_memcg;
	void (*sk_state_change)(struct sock *);
	void (*sk_data_ready)(struct sock *);
	void (*sk_write_space)(struct sock *);
	void (*sk_error_report)(struct sock *);
	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
	void (*sk_destruct)(struct sock *);
	struct sock_reuseport *sk_reuseport_cb;
	struct bpf_local_storage *sk_bpf_storage;
	struct callback_head sk_rcu;
	struct tvpc_info sk_tvpc_info;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct rhash_head {
	struct rhash_head *next;
};

struct rhashtable;

struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

typedef u32 (*rht_hashfn_t)(const void *, u32, u32);

typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);

typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);

struct rhashtable_params {
	u16 nelem_hint;
	u16 key_len;
	u16 key_offset;
	u16 head_offset;
	unsigned int max_size;
	u16 min_size;
	bool automatic_shrinking;
	rht_hashfn_t hashfn;
	rht_obj_hashfn_t obj_hashfn;
	rht_obj_cmpfn_t obj_cmpfn;
};

struct bucket_table;

struct rhashtable {
	struct bucket_table *tbl;
	unsigned int key_len;
	unsigned int max_elems;
	struct rhashtable_params p;
	bool rhlist;
	struct work_struct run_work;
	struct mutex mutex;
	spinlock_t lock;
	atomic_t nelems;
};

struct rhash_lock_head;

struct bucket_table {
	unsigned int size;
	unsigned int nest;
	u32 hash_rnd;
	struct list_head walkers;
	struct callback_head rcu;
	struct bucket_table *future_tbl;
	struct lockdep_map dep_map;
	long: 64;
	struct rhash_lock_head *buckets[0];
};

struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_t seq;
	int umask;
	int in_exec;
	struct path root;
	struct path pwd;
};

struct pipe_buffer;

struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t wait;
	unsigned int nrbufs;
	unsigned int curbuf;
	unsigned int buffers;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int waiting_writers;
	unsigned int r_counter;
	unsigned int w_counter;
	struct page *tmp_page;
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;
	struct user_struct *user;
};

struct scatterlist {
	long unsigned int page_link;
	unsigned int offset;
	unsigned int length;
	dma_addr_t dma_address;
	unsigned int dma_length;
};

typedef short unsigned int __kernel_sa_family_t;

typedef __kernel_sa_family_t sa_family_t;

struct sockaddr {
	sa_family_t sa_family;
	char sa_data[14];
};

struct msghdr {
	void *msg_name;
	int msg_namelen;
	struct iov_iter msg_iter;
	void *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
	struct kiocb *msg_iocb;
};

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
} sync_serial_settings;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
	unsigned int slot_map;
} te1_settings;

typedef struct {
	short unsigned int encoding;
	short unsigned int parity;
} raw_hdlc_proto;

typedef struct {
	unsigned int t391;
	unsigned int t392;
	unsigned int n391;
	unsigned int n392;
	unsigned int n393;
	short unsigned int lmi;
	short unsigned int dce;
} fr_proto;

typedef struct {
	unsigned int dlci;
} fr_proto_pvc;

typedef struct {
	unsigned int dlci;
	char master[16];
} fr_proto_pvc_info;

typedef struct {
	unsigned int interval;
	unsigned int timeout;
} cisco_proto;

struct ifmap {
	long unsigned int mem_start;
	long unsigned int mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct if_settings {
	unsigned int type;
	unsigned int size;
	union {
		raw_hdlc_proto *raw_hdlc;
		cisco_proto *cisco;
		fr_proto *fr;
		fr_proto_pvc *fr_pvc;
		fr_proto_pvc_info *fr_pvc_info;
		sync_serial_settings *sync;
		te1_settings *te1;
	} ifs_ifsu;
};

struct ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		int ifru_ivalue;
		int ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		void *ifru_data;
		struct if_settings ifru_settings;
	} ifr_ifru;
};

struct vfsmount {
	struct dentry *mnt_root;
	struct super_block *mnt_sb;
	int mnt_flags;
};

typedef struct {
	size_t written;
	size_t count;
	union {
		char *buf;
		void *data;
	} arg;
	int error;
} read_descriptor_t;

struct posix_acl_entry {
	short int e_tag;
	short unsigned int e_perm;
	union {
		kuid_t e_uid;
		kgid_t e_gid;
	};
};

struct posix_acl {
	refcount_t a_refcount;
	struct callback_head a_rcu;
	unsigned int a_count;
	struct posix_acl_entry a_entries[0];
};

typedef unsigned char cc_t;

typedef unsigned int speed_t;

typedef unsigned int tcflag_t;

struct ktermios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct winsize {
	short unsigned int ws_row;
	short unsigned int ws_col;
	short unsigned int ws_xpixel;
	short unsigned int ws_ypixel;
};

struct termiox {
	__u16 x_hflag;
	__u16 x_cflag;
	__u16 x_rflag[5];
	__u16 x_sflag;
};

struct tty_driver;

struct serial_icounter_struct;

struct serial_struct;

struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
	int (*install)(struct tty_driver *, struct tty_struct *);
	void (*remove)(struct tty_driver *, struct tty_struct *);
	int (*open)(struct tty_struct *, struct file *);
	void (*close)(struct tty_struct *, struct file *);
	void (*shutdown)(struct tty_struct *);
	void (*cleanup)(struct tty_struct *);
	int (*write)(struct tty_struct *, const unsigned char *, int);
	int (*put_char)(struct tty_struct *, unsigned char);
	void (*flush_chars)(struct tty_struct *);
	int (*write_room)(struct tty_struct *);
	int (*chars_in_buffer)(struct tty_struct *);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	void (*throttle)(struct tty_struct *);
	void (*unthrottle)(struct tty_struct *);
	void (*stop)(struct tty_struct *);
	void (*start)(struct tty_struct *);
	void (*hangup)(struct tty_struct *);
	int (*break_ctl)(struct tty_struct *, int);
	void (*flush_buffer)(struct tty_struct *);
	void (*set_ldisc)(struct tty_struct *);
	void (*wait_until_sent)(struct tty_struct *, int);
	void (*send_xchar)(struct tty_struct *, char);
	int (*tiocmget)(struct tty_struct *);
	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
	int (*resize)(struct tty_struct *, struct winsize *);
	int (*set_termiox)(struct tty_struct *, struct termiox *);
	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
	int (*get_serial)(struct tty_struct *, struct serial_struct *);
	int (*set_serial)(struct tty_struct *, struct serial_struct *);
	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
	int (*proc_show)(struct seq_file *, void *);
};

struct ld_semaphore {
	atomic_long_t count;
	raw_spinlock_t wait_lock;
	unsigned int wait_readers;
	struct list_head read_wait;
	struct list_head write_wait;
};

struct tty_ldisc;

struct tty_port;

struct tty_struct {
	int magic;
	struct kref kref;
	struct device *dev;
	struct tty_driver *driver;
	const struct tty_operations *ops;
	int index;
	struct ld_semaphore ldisc_sem;
	struct tty_ldisc *ldisc;
	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	spinlock_t ctrl_lock;
	spinlock_t flow_lock;
	struct ktermios termios;
	struct ktermios termios_locked;
	struct termiox *termiox;
	char name[64];
	struct pid *pgrp;
	struct pid *session;
	long unsigned int flags;
	int count;
	struct winsize winsize;
	long unsigned int stopped: 1;
	long unsigned int flow_stopped: 1;
	int: 30;
	long unsigned int unused: 62;
	int hw_stopped;
	long unsigned int ctrl_status: 8;
	long unsigned int packet: 1;
	int: 23;
	long unsigned int unused_ctrl: 55;
	unsigned int receive_room;
	int flow_change;
	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	struct list_head tty_files;
	int closing;
	unsigned char *write_buf;
	int write_cnt;
	struct work_struct SAK_work;
	struct tty_port *port;
};

struct proc_dir_entry;

struct tty_driver {
	int magic;
	struct kref kref;
	struct cdev **cdevs;
	struct module *owner;
	const char *driver_name;
	const char *name;
	int name_base;
	int major;
	int minor_start;
	unsigned int num;
	short int type;
	short int subtype;
	struct ktermios init_termios;
	long unsigned int flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;
	const struct tty_operations *ops;
	struct list_head tty_drivers;
};

struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	int used;
	int size;
	int commit;
	int read;
	int flags;
	long unsigned int data[0];
};

struct tty_bufhead {
	struct tty_buffer *head;
	struct work_struct work;
	struct mutex lock;
	atomic_t priority;
	struct tty_buffer sentinel;
	struct llist_head free;
	atomic_t mem_used;
	int mem_limit;
	struct tty_buffer *tail;
};

struct tty_port_operations;

struct tty_port_client_operations;

struct tty_port {
	struct tty_bufhead buf;
	struct tty_struct *tty;
	struct tty_struct *itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t lock;
	int blocked_open;
	int count;
	wait_queue_head_t open_wait;
	wait_queue_head_t delta_msr_wait;
	long unsigned int flags;
	long unsigned int iflags;
	unsigned char console: 1;
	unsigned char low_latency: 1;
	struct mutex mutex;
	struct mutex buf_mutex;
	unsigned char *xmit_buf;
	unsigned int close_delay;
	unsigned int closing_wait;
	int drain_delay;
	struct kref kref;
	void *client_data;
};

struct tty_ldisc_ops {
	int magic;
	char *name;
	int num;
	int flags;
	int (*open)(struct tty_struct *);
	void (*close)(struct tty_struct *);
	void (*flush_buffer)(struct tty_struct *);
	ssize_t (*read)(struct tty_struct *, struct file *, unsigned char *, size_t);
	ssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t);
	int (*ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
	int (*hangup)(struct tty_struct *);
	void (*receive_buf)(struct tty_struct *, const unsigned char *, char *, int);
	void (*write_wakeup)(struct tty_struct *);
	void (*dcd_change)(struct tty_struct *, unsigned int);
	int (*receive_buf2)(struct tty_struct *, const unsigned char *, char *, int);
	struct module *owner;
	int refcount;
};

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};

struct tty_port_operations {
	int (*carrier_raised)(struct tty_port *);
	void (*dtr_rts)(struct tty_port *, int);
	void (*shutdown)(struct tty_port *);
	int (*activate)(struct tty_port *, struct tty_struct *);
	void (*destruct)(struct tty_port *);
};

struct tty_port_client_operations {
	int (*receive_buf)(struct tty_port *, const unsigned char *, const unsigned char *, size_t);
	void (*write_wakeup)(struct tty_port *);
};

struct prot_inuse;

struct netns_core {
	struct ctl_table_header *sysctl_hdr;
	int sysctl_somaxconn;
	int *sock_inuse;
	struct prot_inuse *prot_inuse;
};

struct tcp_mib;

struct ipstats_mib;

struct linux_mib;

struct linux_drop_mib;

struct udp_mib;

struct icmp_mib;

struct icmpmsg_mib;

struct icmpv6_mib;

struct icmpv6msg_mib;

struct linux_xfrm_mib;

struct mptcp_mib;

struct netns_mib {
	struct tcp_mib *tcp_statistics;
	struct ipstats_mib *ip_statistics;
	struct linux_mib *net_statistics;
	struct linux_drop_mib *netdrop_statistics;
	struct udp_mib *udp_statistics;
	struct udp_mib *udplite_statistics;
	struct icmp_mib *icmp_statistics;
	struct icmpmsg_mib *icmpmsg_statistics;
	struct proc_dir_entry *proc_net_devsnmp6;
	struct udp_mib *udp_stats_in6;
	struct udp_mib *udplite_stats_in6;
	struct ipstats_mib *ipv6_statistics;
	struct icmpv6_mib *icmpv6_statistics;
	struct icmpv6msg_mib *icmpv6msg_statistics;
	struct linux_xfrm_mib *xfrm_statistics;
	struct mptcp_mib *mptcp_statistics;
};

struct netns_packet {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct netns_unix {
	int sysctl_max_dgram_qlen;
	struct ctl_table_header *ctl;
};

struct netns_nexthop {
	struct rb_root rb_root;
	struct hlist_head *devhash;
	unsigned int seq;
	u32 last_id_allocated;
};

struct local_ports {
	seqlock_t lock;
	int range[2];
	bool warned;
};

struct inet_hashinfo;

struct inet_timewait_death_row {
	atomic_t tw_count;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct inet_hashinfo *hashinfo;
	int sysctl_max_tw_buckets;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ping_group_range {
	seqlock_t lock;
	kgid_t range[2];
};

typedef struct {
	u64 key[2];
} siphash_key_t;

struct ipv4_devconf;

struct ip_ra_chain;

struct fib_rules_ops;

struct fib_table;

struct inet_peer_base;

struct fqdir;

struct xt_table;

struct tcp_congestion_ops;

struct tcp_fastopen_context;

struct fib_notifier_ops;

struct netns_ipv4 {
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain *ra_chain;
	struct mutex ra_mutex;
	struct fib_rules_ops *rules_ops;
	bool fib_has_custom_rules;
	unsigned int fib_rules_require_fldissect;
	struct fib_table *fib_main;
	struct fib_table *fib_default;
	bool fib_has_custom_local_routes;
	int fib_num_tclassid_users;
	struct hlist_head *fib_table_hash;
	bool fib_offload_disabled;
	struct sock *fibnl;
	struct sock **icmp_sk;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct sock **tcp_sk;
	struct fqdir *fqdir;
	struct xt_table *iptable_filter;
	struct xt_table *iptable_mangle;
	struct xt_table *iptable_raw;
	struct xt_table *arptable_filter;
	struct xt_table *iptable_security;
	struct xt_table *nat_table;
	int sysctl_icmp_echo_ignore_all;
	int sysctl_icmp_echo_ignore_broadcasts;
	int sysctl_icmp_ignore_bogus_error_responses;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	int sysctl_icmp_errors_use_inbound_ifaddr;
	struct local_ports ip_local_ports;
	int sysctl_tcp_ecn;
	int sysctl_tcp_ecn_fallback;
	int sysctl_ip_default_ttl;
	int sysctl_ip_no_pmtu_disc;
	int sysctl_ip_fwd_use_pmtu;
	int sysctl_ip_fwd_update_priority;
	int sysctl_ip_nonlocal_bind;
	int sysctl_ip_dynaddr;
	int sysctl_ip_early_demux;
	int sysctl_raw_l3mdev_accept;
	int sysctl_tcp_early_demux;
	int sysctl_udp_early_demux;
	int sysctl_fwmark_reflect;
	int sysctl_tcp_fwmark_accept;
	int sysctl_tcp_l3mdev_accept;
	int sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_min_snd_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_probes;
	int sysctl_tcp_keepalive_intvl;
	int sysctl_tcp_syn_retries;
	int sysctl_tcp_synack_retries;
	int sysctl_tcp_syncookies;
	int sysctl_tcp_reordering;
	int sysctl_tcp_retries1;
	int sysctl_tcp_retries2;
	int sysctl_tcp_orphan_retries;
	int sysctl_tcp_fin_timeout;
	unsigned int sysctl_tcp_notsent_lowat;
	int sysctl_tcp_tw_reuse;
	int sysctl_tcp_sack;
	int sysctl_tcp_window_scaling;
	int sysctl_tcp_timestamps;
	int sysctl_tcp_early_retrans;
	int sysctl_tcp_recovery;
	int sysctl_tcp_thin_linear_timeouts;
	int sysctl_tcp_slow_start_after_idle;
	int sysctl_tcp_retrans_collapse;
	int sysctl_tcp_stdurg;
	int sysctl_tcp_rfc1337;
	int sysctl_tcp_abort_on_overflow;
	int sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_dsack;
	int sysctl_tcp_app_win;
	int sysctl_tcp_adv_win_scale;
	int sysctl_tcp_frto;
	int sysctl_tcp_nometrics_save;
	int sysctl_tcp_moderate_rcvbuf;
	int sysctl_tcp_tso_win_divisor;
	int sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_challenge_ack_limit;
	int sysctl_tcp_min_tso_segs;
	int sysctl_tcp_min_rtt_wlen;
	int sysctl_tcp_autocorking;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	int sysctl_tcp_wmem[3];
	int sysctl_tcp_rmem[3];
	int sysctl_tcp_comp_sack_nr;
	long unsigned int sysctl_tcp_comp_sack_delay_ns;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct inet_timewait_death_row tcp_death_row;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops *tcp_congestion_control;
	struct tcp_fastopen_context *tcp_fastopen_ctx;
	spinlock_t tcp_fastopen_ctx_lock;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	long unsigned int tfo_active_disable_stamp;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	int sysctl_udp_l3mdev_accept;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_llm_reports;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	long unsigned int *sysctl_local_reserved_ports;
	int sysctl_ip_prot_sock;
	struct list_head mr_tables;
	struct fib_rules_ops *mr_rules_ops;
	int sysctl_fib_multipath_use_neigh;
	int sysctl_fib_multipath_hash_policy;
	int sysctl_tw_timeout;
	int sysctl_tcp_max_orphans;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	siphash_key_t ip_id_key;
	int sysctl_tcp_wan_timestamps;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_mptcp {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct netns_sysctl_ipv6 {
	struct ctl_table_header *hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *icmp_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *xfrm6_hdr;
	int bindv6only;
	int flush_delay;
	int ip6_rt_max_size;
	int ip6_rt_gc_min_interval;
	int ip6_rt_gc_timeout;
	int ip6_rt_gc_interval;
	int ip6_rt_gc_elasticity;
	int ip6_rt_mtu_expires;
	int ip6_rt_min_advmss;
	int ip6_tunnel_neigh_bypass;
	int multipath_hash_policy;
	int flowlabel_consistency;
	int auto_flowlabels;
	int icmpv6_time;
	int icmpv6_echo_ignore_all;
	int icmpv6_echo_ignore_multicast;
	int icmpv6_echo_ignore_anycast;
	long unsigned int icmpv6_ratemask[4];
	long unsigned int *icmpv6_ratemask_ptr;
	int anycast_src_echo_reply;
	int ip_nonlocal_bind;
	int fwmark_reflect;
	int idgen_retries;
	int idgen_delay;
	int flowlabel_state_ranges;
	int flowlabel_reflect;
	int max_dst_opts_cnt;
	int max_hbh_opts_cnt;
	int max_dst_opts_len;
	int max_hbh_opts_len;
	int seg6_flowlabel;
	bool skip_notify_on_dev_down;
};

struct net_device;

struct neighbour;

struct dst_ops {
	short unsigned int family;
	unsigned int gc_thresh;
	int (*gc)(struct dst_ops *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device *, int);
	struct dst_entry * (*negative_advice)(struct dst_entry *);
	void (*link_failure)(struct sk_buff *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct percpu_counter pcpuc_entries;
	long: 64;
	long: 64;
	long: 64;
};

struct ipv6_devconf;

struct fib6_info;

struct rt6_info;

struct rt6_statistics;

struct fib6_table;

struct seg6_pernet_data;

struct netns_ipv6 {
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	struct xt_table *ip6table_filter;
	struct xt_table *ip6table_mangle;
	struct xt_table *ip6table_raw;
	struct xt_table *ip6table_security;
	struct xt_table *ip6table_nat;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dst_ops ip6_dst_ops;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	unsigned int ip6_rt_gc_expire;
	long unsigned int ip6_rt_last_gc;
	unsigned int fib6_rules_require_fldissect;
	bool fib6_has_custom_rules;
	struct rt6_info *ip6_prohibit_entry;
	struct rt6_info *ip6_blk_hole_entry;
	struct fib6_table *fib6_local_tbl;
	struct fib_rules_ops *fib6_rules_ops;
	struct sock **icmp_sk;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	struct list_head mr6_tables;
	struct fib_rules_ops *mr6_rules_ops;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	long: 64;
};

struct nf_queue_handler;

struct nf_logger;

struct nf_hook_entries;

struct netns_nf {
	struct proc_dir_entry *proc_netfilter;
	const struct nf_queue_handler *queue_handler;
	const struct nf_logger *nf_loggers[13];
	struct ctl_table_header *nf_log_dir_header;
	struct nf_hook_entries *hooks_ipv4[5];
	struct nf_hook_entries *hooks_ipv6[5];
	struct nf_hook_entries *hooks_arp[3];
	struct nf_hook_entries *hooks_bridge[5];
	bool defrag_ipv4;
	bool defrag_ipv6;
};

struct ebt_table;

struct netns_xt {
	struct list_head tables[13];
	bool notrack_deprecated_warning;
	bool clusterip_deprecated_warning;
	struct ebt_table *broute_table;
	struct ebt_table *frame_filter;
	struct ebt_table *frame_nat;
};

struct nf_generic_net {
	unsigned int timeout;
};

struct nf_tcp_net {
	unsigned int timeouts[14];
	int tcp_loose;
	int tcp_be_liberal;
	int tcp_max_retrans;
	unsigned int mptcp_expect_count;
};

struct nf_udp_net {
	unsigned int timeouts[2];
};

struct nf_icmp_net {
	unsigned int timeout;
};

struct nf_gre_net {
	struct list_head keymap_list;
	unsigned int timeouts[2];
};

struct nf_ip_net {
	struct nf_generic_net generic;
	struct nf_tcp_net tcp;
	struct nf_udp_net udp;
	struct nf_icmp_net icmp;
	struct nf_icmp_net icmpv6;
	struct nf_gre_net gre;
};

struct ct_pcpu;

struct ip_conntrack_stat;

struct nf_ct_event_notifier;

struct nf_exp_event_notifier;

struct netns_ct {
	atomic_t count;
	unsigned int expect_count;
	struct delayed_work ecache_dwork;
	bool ecache_dwork_pending;
	bool auto_assign_helper_warned;
	struct ctl_table_header *sysctl_header;
	unsigned int sysctl_log_invalid;
	int sysctl_events;
	int sysctl_acct;
	int sysctl_auto_assign_helper;
	int sysctl_tstamp;
	int sysctl_checksum;
	struct ct_pcpu *pcpu_lists;
	struct ip_conntrack_stat *stat;
	struct nf_ct_event_notifier *nf_conntrack_event_cb;
	struct nf_exp_event_notifier *nf_expect_event_cb;
	struct nf_ip_net nf_ct_proto;
	unsigned int labels_used;
};

struct netns_nftables {
	struct list_head tables;
	struct list_head commit_list;
	struct list_head module_list;
	struct mutex commit_mutex;
	unsigned int base_seq;
	u8 gencursor;
	u8 validate_state;
};

struct netns_nf_frag {
	struct fqdir *fqdir;
};

struct netns_bpf {
	struct bpf_prog_array *run_array[2];
	struct bpf_prog *progs[2];
	struct list_head links[2];
};

struct xfrm_policy_hash {
	struct hlist_head *table;
	unsigned int hmask;
	u8 dbits4;
	u8 sbits4;
	u8 dbits6;
	u8 sbits6;
};

struct xfrm_policy_hthresh {
	struct work_struct work;
	seqlock_t lock;
	u8 lbits4;
	u8 rbits4;
	u8 lbits6;
	u8 rbits6;
};

struct netns_xfrm {
	struct list_head state_all;
	struct hlist_head *state_bydst;
	struct hlist_head *state_bysrc;
	struct hlist_head *state_byspi;
	unsigned int state_hmask;
	unsigned int state_num;
	struct work_struct state_hash_work;
	struct list_head policy_all;
	struct hlist_head *policy_byidx;
	unsigned int policy_idx_hmask;
	struct hlist_head policy_inexact[3];
	struct xfrm_policy_hash policy_bydst[3];
	unsigned int policy_count[6];
	struct work_struct policy_hash_work;
	struct xfrm_policy_hthresh policy_hthresh;
	struct list_head inexact_bins;
	struct sock *nlsk;
	struct sock *nlsk_stash;
	u32 sysctl_aevent_etime;
	u32 sysctl_aevent_rseqth;
	int sysctl_larval_drop;
	u32 sysctl_acq_expires;
	struct ctl_table_header *sysctl_hdr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dst_ops xfrm4_dst_ops;
	struct dst_ops xfrm6_dst_ops;
	spinlock_t xfrm_state_lock;
	seqcount_t xfrm_state_hash_generation;
	spinlock_t xfrm_policy_lock;
	struct mutex xfrm_cfg_mutex;
	long: 64;
	long: 64;
};

struct netns_ipvs;

struct mpls_route;

struct netns_mpls {
	int ip_ttl_propagate;
	int default_ttl;
	size_t platform_labels;
	struct mpls_route **platform_label;
	struct ctl_table_header *ctl;
};

struct netns_xdp {
	struct mutex lock;
	struct hlist_head list;
};

struct uevent_sock;

struct net_generic;

struct net {
	refcount_t passive;
	refcount_t count;
	spinlock_t rules_mod_lock;
	unsigned int dev_unreg_count;
	unsigned int dev_base_seq;
	int ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct idr netns_ids;
	struct ns_common ns;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	u32 hash_mix;
	struct net_device *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct netns_ipv4 ipv4;
	struct netns_mptcp mptcp;
	long: 64;
	long: 64;
	long: 64;
	struct netns_ipv6 ipv6;
	struct netns_nf nf;
	struct netns_xt xt;
	struct netns_ct ct;
	struct netns_nftables nft;
	struct netns_nf_frag nf_frag;
	struct ctl_table_header *nf_frag_frags_hdr;
	struct sock *nfnl;
	struct sock *nfnl_stash;
	struct list_head nfnl_acct_list;
	struct list_head nfct_timeout_list;
	struct net_generic *gen;
	struct netns_bpf bpf;
	struct netns_xfrm xfrm;
	u64 net_cookie;
	struct netns_ipvs *ipvs;
	struct netns_mpls mpls;
	struct netns_xdp xdp;
	struct sock *crypto_nlsk;
	struct sock *diag_nlsk;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_insn {
	__u8 code;
	__u8 dst_reg: 4;
	__u8 src_reg: 4;
	__s16 off;
	__s32 imm;
};

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC = 0,
	BPF_MAP_TYPE_HASH = 1,
	BPF_MAP_TYPE_ARRAY = 2,
	BPF_MAP_TYPE_PROG_ARRAY = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
	BPF_MAP_TYPE_PERCPU_HASH = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
	BPF_MAP_TYPE_STACK_TRACE = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
	BPF_MAP_TYPE_LRU_HASH = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
	BPF_MAP_TYPE_LPM_TRIE = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
	BPF_MAP_TYPE_DEVMAP = 14,
	BPF_MAP_TYPE_SOCKMAP = 15,
	BPF_MAP_TYPE_CPUMAP = 16,
	BPF_MAP_TYPE_XSKMAP = 17,
	BPF_MAP_TYPE_SOCKHASH = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE = 22,
	BPF_MAP_TYPE_STACK = 23,
	BPF_MAP_TYPE_SK_STORAGE = 24,
	BPF_MAP_TYPE_DEVMAP_HASH = 25,
	BPF_MAP_TYPE_STRUCT_OPS = 26,
	BPF_MAP_TYPE_RINGBUF = 27,
	BPF_MAP_TYPE_INODE_STORAGE = 28,
};

enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC = 0,
	BPF_PROG_TYPE_SOCKET_FILTER = 1,
	BPF_PROG_TYPE_KPROBE = 2,
	BPF_PROG_TYPE_SCHED_CLS = 3,
	BPF_PROG_TYPE_SCHED_ACT = 4,
	BPF_PROG_TYPE_TRACEPOINT = 5,
	BPF_PROG_TYPE_XDP = 6,
	BPF_PROG_TYPE_PERF_EVENT = 7,
	BPF_PROG_TYPE_CGROUP_SKB = 8,
	BPF_PROG_TYPE_CGROUP_SOCK = 9,
	BPF_PROG_TYPE_LWT_IN = 10,
	BPF_PROG_TYPE_LWT_OUT = 11,
	BPF_PROG_TYPE_LWT_XMIT = 12,
	BPF_PROG_TYPE_SOCK_OPS = 13,
	BPF_PROG_TYPE_SK_SKB = 14,
	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
	BPF_PROG_TYPE_SK_MSG = 16,
	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
	BPF_PROG_TYPE_LIRC_MODE2 = 20,
	BPF_PROG_TYPE_SK_REUSEPORT = 21,
	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
	BPF_PROG_TYPE_TRACING = 26,
	BPF_PROG_TYPE_STRUCT_OPS = 27,
	BPF_PROG_TYPE_EXT = 28,
	BPF_PROG_TYPE_LSM = 29,
	BPF_PROG_TYPE_SK_LOOKUP = 30,
};

enum bpf_attach_type {
	BPF_CGROUP_INET_INGRESS = 0,
	BPF_CGROUP_INET_EGRESS = 1,
	BPF_CGROUP_INET_SOCK_CREATE = 2,
	BPF_CGROUP_SOCK_OPS = 3,
	BPF_SK_SKB_STREAM_PARSER = 4,
	BPF_SK_SKB_STREAM_VERDICT = 5,
	BPF_CGROUP_DEVICE = 6,
	BPF_SK_MSG_VERDICT = 7,
	BPF_CGROUP_INET4_BIND = 8,
	BPF_CGROUP_INET6_BIND = 9,
	BPF_CGROUP_INET4_CONNECT = 10,
	BPF_CGROUP_INET6_CONNECT = 11,
	BPF_CGROUP_INET4_POST_BIND = 12,
	BPF_CGROUP_INET6_POST_BIND = 13,
	BPF_CGROUP_UDP4_SENDMSG = 14,
	BPF_CGROUP_UDP6_SENDMSG = 15,
	BPF_LIRC_MODE2 = 16,
	BPF_FLOW_DISSECTOR = 17,
	BPF_CGROUP_SYSCTL = 18,
	BPF_CGROUP_UDP4_RECVMSG = 19,
	BPF_CGROUP_UDP6_RECVMSG = 20,
	BPF_CGROUP_GETSOCKOPT = 21,
	BPF_CGROUP_SETSOCKOPT = 22,
	BPF_TRACE_RAW_TP = 23,
	BPF_TRACE_FENTRY = 24,
	BPF_TRACE_FEXIT = 25,
	BPF_MODIFY_RETURN = 26,
	BPF_LSM_MAC = 27,
	BPF_TRACE_ITER = 28,
	BPF_CGROUP_INET4_GETPEERNAME = 29,
	BPF_CGROUP_INET6_GETPEERNAME = 30,
	BPF_CGROUP_INET4_GETSOCKNAME = 31,
	BPF_CGROUP_INET6_GETSOCKNAME = 32,
	BPF_XDP_DEVMAP = 33,
	BPF_CGROUP_INET_SOCK_RELEASE = 34,
	BPF_XDP_CPUMAP = 35,
	BPF_SK_LOOKUP = 36,
	BPF_XDP = 37,
	BPF_SK_SKB_VERDICT = 38,
	BPF_SK_REUSEPORT_SELECT = 39,
	BPF_SK_REUSEPORT_SELECT_OR_MIGRATE = 40,
	BPF_PERF_EVENT = 41,
	BPF_CGROUP_INET_POST_AUTOBIND = 42,
	BPF_CGROUP_TWSK_CLOSE = 43,
	BPF_CGROUP_UDP_UNHASH = 44,
	__MAX_BPF_ATTACH_TYPE = 45,
};

union bpf_attr {
	struct {
		__u32 map_type;
		__u32 key_size;
		__u32 value_size;
		__u32 max_entries;
		__u32 map_flags;
		__u32 inner_map_fd;
		__u32 numa_node;
		char map_name[16];
		__u32 map_ifindex;
		__u32 btf_fd;
		__u32 btf_key_type_id;
		__u32 btf_value_type_id;
		__u32 btf_vmlinux_value_type_id;
	};
	struct {
		__u32 map_fd;
		__u64 key;
		union {
			__u64 value;
			__u64 next_key;
		};
		__u64 flags;
	};
	struct {
		__u32 prog_type;
		__u32 insn_cnt;
		__u64 insns;
		__u64 license;
		__u32 log_level;
		__u32 log_size;
		__u64 log_buf;
		__u32 kern_version;
		__u32 prog_flags;
		char prog_name[16];
		__u32 prog_ifindex;
		__u32 expected_attach_type;
		__u32 prog_btf_fd;
		__u32 func_info_rec_size;
		__u64 func_info;
		__u32 func_info_cnt;
		__u32 line_info_rec_size;
		__u64 line_info;
		__u32 line_info_cnt;
		__u32 attach_btf_id;
		__u32 attach_prog_fd;
	};
	struct {
		__u64 pathname;
		__u32 bpf_fd;
		__u32 file_flags;
	};
	struct {
		__u32 target_fd;
		__u32 attach_bpf_fd;
		__u32 attach_type;
		__u32 attach_flags;
		__u32 replace_bpf_fd;
	};
	struct {
		__u32 prog_fd;
		__u32 retval;
		__u32 data_size_in;
		__u32 data_size_out;
		__u64 data_in;
		__u64 data_out;
		__u32 repeat;
		__u32 duration;
		__u32 ctx_size_in;
		__u32 ctx_size_out;
		__u64 ctx_in;
		__u64 ctx_out;
	} test;
	struct {
		union {
			__u32 start_id;
			__u32 prog_id;
			__u32 map_id;
			__u32 btf_id;
			__u32 link_id;
		};
		__u32 next_id;
		__u32 open_flags;
	};
	struct {
		__u32 bpf_fd;
		__u32 info_len;
		__u64 info;
	} info;
	struct {
		__u32 target_fd;
		__u32 attach_type;
		__u32 query_flags;
		__u32 attach_flags;
		__u64 prog_ids;
		__u32 prog_cnt;
	} query;
	struct {
		__u64 name;
		__u32 prog_fd;
	} raw_tracepoint;
	struct {
		__u64 btf;
		__u64 btf_log_buf;
		__u32 btf_size;
		__u32 btf_log_size;
		__u32 btf_log_level;
	};
	struct {
		__u32 pid;
		__u32 fd;
		__u32 flags;
		__u32 buf_len;
		__u64 buf;
		__u32 prog_id;
		__u32 fd_type;
		__u64 probe_offset;
		__u64 probe_addr;
	} task_fd_query;
	struct {
		__u32 prog_fd;
		__u32 target_fd;
		__u32 attach_type;
		__u32 flags;
		__u64 iter_info;
		__u32 iter_info_len;
	} link_create;
	struct {
		__u32 link_fd;
		__u32 new_prog_fd;
		__u32 flags;
		__u32 old_prog_fd;
	} link_update;
	struct {
		__u32 link_fd;
	} link_detach;
	struct {
		__u32 type;
	} enable_stats;
	struct {
		__u32 link_fd;
		__u32 flags;
	} iter_create;
};

struct bpf_func_info {
	__u32 insn_off;
	__u32 type_id;
};

struct bpf_line_info {
	__u32 insn_off;
	__u32 file_name_off;
	__u32 line_off;
	__u32 line_col;
};

struct bpf_iter_aux_info;

typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);

struct bpf_map;

struct bpf_iter_aux_info {
	struct bpf_map *map;
};

typedef void (*bpf_iter_fini_seq_priv_t)(void *);

struct bpf_iter_seq_info {
	const struct seq_operations *seq_ops;
	bpf_iter_init_seq_priv_t init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct btf;

struct btf_type;

struct bpf_prog_aux;

struct bpf_local_storage_map;

struct bpf_verifier_env;

struct bpf_func_state;

struct bpf_map_ops {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map *, struct file *);
	void (*map_free)(struct bpf_map *);
	int (*map_get_next_key)(struct bpf_map *, void *, void *);
	void (*map_release_uref)(struct bpf_map *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
	void * (*map_lookup_elem)(struct bpf_map *, void *);
	int (*map_update_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_map *, void *);
	int (*map_push_elem)(struct bpf_map *, void *, u64);
	int (*map_pop_elem)(struct bpf_map *, void *);
	int (*map_peek_elem)(struct bpf_map *, void *);
	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
	void (*map_fd_put_ptr)(void *);
	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
	int (*map_set_for_each_callback_args)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *);
	int (*map_for_each_callback)(struct bpf_map *, void *, void *, u64);
	const char * const map_btf_name;
	int *map_btf_id;
	const struct bpf_iter_seq_info *iter_seq_info;
};

struct bpf_map_memory {
	u32 pages;
	struct user_struct *user;
};

struct bpf_map {
	const struct bpf_map_ops *ops;
	struct bpf_map *inner_map_meta;
	void *security;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u32 map_flags;
	int spin_lock_off;
	int timer_off;
	u32 id;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	struct btf *btf;
	struct bpf_map_memory memory;
	char name[16];
	u32 btf_vmlinux_value_type_id;
	bool bypass_spec_v1;
	bool frozen;
	long: 16;
	long: 64;
	atomic64_t refcnt;
	atomic64_t usercnt;
	struct work_struct work;
	struct mutex freeze_mutex;
	u64 writecnt;
	long: 64;
	long: 64;
	long: 64;
};

struct btf_header {
	__u16 magic;
	__u8 version;
	__u8 flags;
	__u32 hdr_len;
	__u32 type_off;
	__u32 type_len;
	__u32 str_off;
	__u32 str_len;
};

struct btf {
	void *data;
	struct btf_type **types;
	u32 *resolved_ids;
	u32 *resolved_sizes;
	const char *strings;
	void *nohdr_data;
	struct btf_header hdr;
	u32 nr_types;
	u32 types_size;
	u32 data_size;
	refcount_t refcnt;
	u32 id;
	struct callback_head rcu;
};

struct btf_type {
	__u32 name_off;
	__u32 info;
	union {
		__u32 size;
		__u32 type;
	};
};

enum bpf_tramp_prog_type {
	BPF_TRAMP_FENTRY = 0,
	BPF_TRAMP_FEXIT = 1,
	BPF_TRAMP_MODIFY_RETURN = 2,
	BPF_TRAMP_MAX = 3,
	BPF_TRAMP_REPLACE = 4,
};

struct bpf_ctx_arg_aux;

struct bpf_trampoline;

struct bpf_jit_poke_descriptor;

struct bpf_prog_ops;

struct bpf_prog_offload;

struct bpf_func_info_aux;

struct bpf_prog_stats;

struct bpf_prog_aux {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	struct bpf_prog *linked_prog;
	bool verifier_zext;
	bool offload_requested;
	bool attach_btf_trace;
	bool func_proto_unreliable;
	enum bpf_tramp_prog_type trampoline_prog_type;
	struct bpf_trampoline *trampoline;
	struct hlist_node tramp_hlist;
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor *poke_tab;
	u32 size_poke_tab;
	struct latch_tree_node ksym_tnode;
	struct list_head ksym_lnode;
	const struct bpf_prog_ops *ops;
	struct bpf_map **used_maps;
	struct bpf_prog *prog;
	struct user_struct *user;
	u64 load_time;
	struct bpf_map *cgroup_storage[2];
	char name[16];
	void *security;
	struct bpf_prog_offload *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	u32 num_exentries;
	struct exception_table_entry *extable;
	struct bpf_prog_stats *stats;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
};

struct sock_filter {
	__u16 code;
	__u8 jt;
	__u8 jf;
	__u32 k;
};

struct sock_fprog_kern;

struct bpf_prog {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_aux *aux;
	struct sock_fprog_kern *orig_prog;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	union {
		struct sock_filter insns[0];
		struct bpf_insn insnsi[0];
	};
};

struct bpf_offloaded_map;

struct bpf_map_dev_ops {
	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
};

struct bpf_offloaded_map {
	struct bpf_map map;
	struct net_device *netdev;
	const struct bpf_map_dev_ops *dev_ops;
	void *dev_priv;
	struct list_head offloads;
	long: 64;
	long: 64;
	long: 64;
};

struct net_device_stats {
	long unsigned int rx_packets;
	long unsigned int tx_packets;
	long unsigned int rx_bytes;
	long unsigned int tx_bytes;
	long unsigned int rx_errors;
	long unsigned int tx_errors;
	long unsigned int rx_dropped;
	long unsigned int tx_dropped;
	long unsigned int multicast;
	long unsigned int collisions;
	long unsigned int rx_length_errors;
	long unsigned int rx_over_errors;
	long unsigned int rx_crc_errors;
	long unsigned int rx_frame_errors;
	long unsigned int rx_fifo_errors;
	long unsigned int rx_missed_errors;
	long unsigned int tx_aborted_errors;
	long unsigned int tx_carrier_errors;
	long unsigned int tx_fifo_errors;
	long unsigned int tx_heartbeat_errors;
	long unsigned int tx_window_errors;
	long unsigned int rx_compressed;
	long unsigned int tx_compressed;
};

struct dev_mib;

struct netdev_mib {
	struct dev_mib *dev_statistics;
};

struct netdev_hw_addr_list {
	struct list_head list;
	int count;
};

struct wireless_dev;

enum rx_handler_result {
	RX_HANDLER_CONSUMED = 0,
	RX_HANDLER_ANOTHER = 1,
	RX_HANDLER_EXACT = 2,
	RX_HANDLER_PASS = 3,
};

typedef enum rx_handler_result rx_handler_result_t;

typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

enum netdev_ml_priv_type {
	ML_PRIV_NONE = 0,
	ML_PRIV_CAN = 1,
};

struct pcpu_dstats;

struct netdev_tc_txq {
	u16 count;
	u16 offset;
};

struct sfp_bus;

struct dev_ifalias;

struct net_device_ops;

struct ethtool_ops;

struct l3mdev_ops;

struct ndisc_ops;

struct xfrmdev_ops;

struct header_ops;

struct vlan_info;

struct in_device;

struct inet6_dev;

struct wpan_dev;

struct netdev_rx_queue;

struct mini_Qdisc;

struct netdev_queue;

struct cpu_rmap;

struct Qdisc;

struct xps_dev_maps;

struct netpoll_info;

struct pcpu_lstats;

struct pcpu_sw_netstats;

struct garp_port;

struct mrp_port;

struct rtnl_link_ops;

struct dcbnl_rtnl_ops;

struct netprio_map;

struct phy_device;

struct net_device {
	char name[16];
	struct hlist_node name_hlist;
	struct dev_ifalias *ifalias;
	long unsigned int mem_end;
	long unsigned int mem_start;
	long unsigned int base_addr;
	int irq;
	long unsigned int state;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct list_head ptype_specific;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	netdev_features_t features;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	netdev_features_t gso_partial_features;
	int ifindex;
	int group;
	struct net_device_stats stats;
	struct netdev_mib mib;
	atomic_long_t rx_dropped;
	atomic_long_t tx_dropped;
	atomic_long_t rx_nohandler;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct net_device_ops *netdev_ops;
	const struct ethtool_ops *ethtool_ops;
	const struct l3mdev_ops *l3mdev_ops;
	const struct ndisc_ops *ndisc_ops;
	const struct xfrmdev_ops *xfrmdev_ops;
	const struct header_ops *header_ops;
	unsigned int flags;
	unsigned int priv_flags;
	short unsigned int gflags;
	short unsigned int padded;
	unsigned char operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned int mtu;
	unsigned int min_mtu;
	unsigned int max_mtu;
	short unsigned int type;
	short unsigned int hard_header_len;
	unsigned char min_header_len;
	short unsigned int needed_headroom;
	short unsigned int needed_tailroom;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	short unsigned int neigh_priv_len;
	short unsigned int dev_id;
	short unsigned int dev_port;
	spinlock_t addr_list_lock;
	unsigned char name_assign_type;
	bool uc_promisc;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	struct kset *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	struct vlan_info *vlan_info;
	struct in_device *ip_ptr;
	struct inet6_dev *ip6_ptr;
	struct wireless_dev *ieee80211_ptr;
	struct wpan_dev *ieee802154_ptr;
	unsigned char *dev_addr;
	struct netdev_rx_queue *_rx;
	unsigned int num_rx_queues;
	unsigned int real_num_rx_queues;
	struct bpf_prog *xdp_prog;
	long unsigned int gro_flush_timeout;
	rx_handler_func_t *rx_handler;
	void *rx_handler_data;
	struct mini_Qdisc *miniq_ingress;
	struct netdev_queue *ingress_queue;
	struct nf_hook_entries *nf_hooks_ingress;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	struct netdev_queue *_tx;
	unsigned int num_tx_queues;
	unsigned int real_num_tx_queues;
	struct Qdisc *qdisc;
	struct hlist_head qdisc_hash[16];
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	int watchdog_timeo;
	struct xps_dev_maps *xps_cpus_map;
	struct xps_dev_maps *xps_rxqs_map;
	struct mini_Qdisc *miniq_egress;
	struct timer_list watchdog_timer;
	int *pcpu_refcnt;
	struct list_head todo_list;
	struct list_head link_watch_list;
	enum {
		NETREG_UNINITIALIZED = 0,
		NETREG_REGISTERED = 1,
		NETREG_UNREGISTERING = 2,
		NETREG_UNREGISTERED = 3,
		NETREG_RELEASED = 4,
		NETREG_DUMMY = 5,
	} reg_state: 8;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED = 0,
		RTNL_LINK_INITIALIZING = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device *);
	struct netpoll_info *npinfo;
	possible_net_t nd_net;
	void *ml_priv;
	enum netdev_ml_priv_type ml_priv_type;
	union {
		struct pcpu_lstats *lstats;
		struct pcpu_sw_netstats *tstats;
		struct pcpu_dstats *dstats;
	};
	struct garp_port *garp_port;
	struct mrp_port *mrp_port;
	struct device dev;
	const struct attribute_group *sysfs_groups[4];
	const struct attribute_group *sysfs_rx_queue_group;
	const struct rtnl_link_ops *rtnl_link_ops;
	unsigned int gso_max_size;
	u16 gso_max_segs;
	const struct dcbnl_rtnl_ops *dcbnl_ops;
	s16 num_tc;
	struct netdev_tc_txq tc_to_txq[16];
	u8 prio_tc_map[16];
	unsigned int fcoe_ddp_xid;
	struct netprio_map *priomap;
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key qdisc_tx_busylock_key;
	struct lock_class_key qdisc_running_key;
	struct lock_class_key qdisc_xmit_lock_key;
	struct lock_class_key addr_list_lock_key;
	bool proto_down;
	unsigned int wol_enabled: 1;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
};

enum bpf_reg_type {
	NOT_INIT = 0,
	SCALAR_VALUE = 1,
	PTR_TO_CTX = 2,
	CONST_PTR_TO_MAP = 3,
	PTR_TO_MAP_VALUE = 4,
	PTR_TO_MAP_VALUE_OR_NULL = 5,
	PTR_TO_STACK = 6,
	PTR_TO_PACKET_META = 7,
	PTR_TO_PACKET = 8,
	PTR_TO_PACKET_END = 9,
	PTR_TO_FLOW_KEYS = 10,
	PTR_TO_SOCKET = 11,
	PTR_TO_SOCKET_OR_NULL = 12,
	PTR_TO_SOCK_COMMON = 13,
	PTR_TO_SOCK_COMMON_OR_NULL = 14,
	PTR_TO_TCP_SOCK = 15,
	PTR_TO_TCP_SOCK_OR_NULL = 16,
	PTR_TO_TP_BUFFER = 17,
	PTR_TO_XDP_SOCK = 18,
	PTR_TO_BTF_ID = 19,
	PTR_TO_BTF_ID_OR_NULL = 20,
	PTR_TO_RDONLY_BUF = 21,
	PTR_TO_RDONLY_BUF_OR_NULL = 22,
	PTR_TO_RDWR_BUF = 23,
	PTR_TO_RDWR_BUF_OR_NULL = 24,
	PTR_TO_MEM = 25,
	PTR_TO_MEM_OR_NULL = 26,
	PTR_TO_FUNC = 27,
	PTR_TO_MAP_KEY = 28,
};

struct bpf_prog_ops {
	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);
};

struct bpf_offload_dev;

struct bpf_prog_offload {
	struct bpf_prog *prog;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct bpf_prog_stats {
	u64 cnt;
	u64 nsecs;
	struct u64_stats_sync syncp;
};

struct btf_func_model {
	u8 ret_size;
	u8 nr_args;
	u8 arg_size[12];
};

struct bpf_trampoline {
	struct hlist_node hlist;
	struct mutex mutex;
	refcount_t refcnt;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
	} func;
	struct bpf_prog *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	void *image;
	u64 selector;
};

struct bpf_func_info_aux {
	u16 linkage;
	bool unreliable;
};

struct bpf_jit_poke_descriptor {
	void *ip;
	union {
		struct {
			struct bpf_map *map;
			u32 key;
		} tail_call;
	};
	bool ip_stable;
	u8 adj_off;
	u16 reason;
};

struct bpf_ctx_arg_aux {
	u32 offset;
	enum bpf_reg_type reg_type;
	u32 btf_id;
};

typedef unsigned int sk_buff_data_t;

struct skb_ext;

struct sk_buff {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
			union {
				struct net_device *dev;
				long unsigned int dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
	};
	union {
		struct sock *sk;
		int ip_defrag_offset;
	};
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			long unsigned int _skb_refdst;
			void (*destructor)(struct sk_buff *);
		};
		struct list_head tcp_tsorted_anchor;
	};
	long unsigned int _nfct;
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u8 active_extensions;
	__u32 headers_start[0];
	__u8 __pkt_type_offset[0];
	__u8 pkt_type: 3;
	__u8 ignore_df: 1;
	__u8 nf_trace: 1;
	__u8 ip_summed: 2;
	__u8 ooo_okay: 1;
	__u8 l4_hash: 1;
	__u8 sw_hash: 1;
	__u8 wifi_acked_valid: 1;
	__u8 wifi_acked: 1;
	__u8 no_fcs: 1;
	__u8 encapsulation: 1;
	__u8 encap_hdr_csum: 1;
	__u8 csum_valid: 1;
	__u8 __pkt_vlan_present_offset[0];
	__u8 vlan_present: 1;
	__u8 csum_complete_sw: 1;
	__u8 csum_level: 2;
	__u8 csum_not_inet: 1;
	__u8 dst_pending_confirm: 1;
	__u8 ndisc_nodetype: 2;
	__u8 ipvs_property: 1;
	__u8 inner_protocol_type: 1;
	__u8 remcsum_offload: 1;
	__u8 tc_skip_classify: 1;
	__u8 tc_at_ingress: 1;
	__u8 redirected: 1;
	__u8 from_ingress: 1;
	__u16 tc_index;
	union {
		__wsum csum;
		struct {
			__u16 csum_start;
			__u16 csum_offset;
		};
	};
	__u32 priority;
	int skb_iif;
	__u32 hash;
	__be16 vlan_proto;
	__u16 vlan_tci;
	union {
		unsigned int napi_id;
		unsigned int sender_cpu;
	};
	__u32 secmark;
	union {
		__u32 mark;
		__u32 reserved_tailroom;
	};
	union {
		__be16 inner_protocol;
		__u8 inner_ipproto;
	};
	__u16 inner_transport_header;
	__u16 inner_network_header;
	__u16 inner_mac_header;
	__be16 protocol;
	__u16 transport_header;
	__u16 network_header;
	__u16 mac_header;
	__u32 headers_end[0];
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
	struct skb_ext *extensions;
};

struct sg_table {
	struct scatterlist *sgl;
	unsigned int nents;
	unsigned int orig_nents;
};

enum {
	Root_NFS = 255,
	Root_CIFS = 254,
	Root_RAM0 = 1048576,
	Root_RAM1 = 1048577,
	Root_FD0 = 2097152,
	Root_HDA1 = 3145729,
	Root_HDA2 = 3145730,
	Root_SDA1 = 8388609,
	Root_SDA2 = 8388610,
	Root_HDC1 = 23068673,
	Root_SR0 = 11534336,
};

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

struct flowi_tunnel {
	__be64 tun_id;
};

struct flowi_common {
	int flowic_oif;
	int flowic_iif;
	__u32 flowic_mark;
	__u8 flowic_tos;
	__u8 flowic_scope;
	__u8 flowic_proto;
	__u8 flowic_flags;
	__u32 flowic_secid;
	kuid_t flowic_uid;
	struct flowi_tunnel flowic_tun_key;
	__u32 flowic_multipath_hash;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

union flowi_uli {
	struct {
		__be16 dport;
		__be16 sport;
	} ports;
	struct {
		__u8 type;
		__u8 code;
	} icmpt;
	struct {
		__le16 dport;
		__le16 sport;
	} dnports;
	__be32 spi;
	__be32 gre_key;
	struct {
		__u8 type;
	} mht;
};

struct flowi4 {
	struct flowi_common __fl_common;
	__be32 saddr;
	__be32 daddr;
	union flowi_uli uli;
	long unsigned int kabi_reserved1;
};

struct flowi6 {
	struct flowi_common __fl_common;
	struct in6_addr daddr;
	struct in6_addr saddr;
	__be32 flowlabel;
	union flowi_uli uli;
	__u32 mp_hash;
	long unsigned int kabi_reserved1;
};

struct flowidn {
	struct flowi_common __fl_common;
	__le16 daddr;
	__le16 saddr;
	union flowi_uli uli;
};

struct flowi {
	union {
		struct flowi_common __fl_common;
		struct flowi4 ip4;
		struct flowi6 ip6;
		struct flowidn dn;
	} u;
};

struct ipstats_mib {
	u64 mibs[37];
	struct u64_stats_sync syncp;
};

struct icmp_mib {
	long unsigned int mibs[28];
};

struct icmpmsg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6_mib {
	long unsigned int mibs[6];
};

struct icmpv6_mib_device {
	atomic_long_t mibs[6];
};

struct icmpv6msg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6msg_mib_device {
	atomic_long_t mibs[512];
};

struct tcp_mib {
	long unsigned int mibs[16];
};

struct udp_mib {
	long unsigned int mibs[10];
};

struct linux_mib {
	long unsigned int mibs[120];
};

struct linux_xfrm_mib {
	long unsigned int mibs[29];
};

struct linux_drop_mib {
	long unsigned int mibs[23];
};

struct inet_frags;

struct fqdir {
	long int high_thresh;
	long int low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags *f;
	struct net *net;
	bool dead;
	long: 56;
	long: 64;
	long: 64;
	struct rhashtable rhashtable;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t mem;
	struct work_struct destroy_work;
	long: 64;
};

struct inet_frag_queue;

struct inet_frags {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue *, const void *);
	void (*destructor)(struct inet_frag_queue *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct frag_v4_compare_key {
	__be32 saddr;
	__be32 daddr;
	u32 user;
	u32 vif;
	__be16 id;
	u16 protocol;
};

struct frag_v6_compare_key {
	struct in6_addr saddr;
	struct in6_addr daddr;
	u32 user;
	__be32 id;
	u32 iif;
};

struct inet_frag_queue {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff *fragments_tail;
	struct sk_buff *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	__u8 flags;
	u16 max_size;
	struct fqdir *fqdir;
	struct callback_head rcu;
};

struct fib_rule;

struct fib_lookup_arg;

struct fib_rule_hdr;

struct nlattr;

struct netlink_ext_ack;

struct nla_policy;

struct fib_rules_ops {
	int family;
	struct list_head list;
	int rule_size;
	int addr_size;
	int unresolved_rules;
	int nr_goto_rules;
	unsigned int fib_rules_seq;
	int (*action)(struct fib_rule *, struct flowi *, int, struct fib_lookup_arg *);
	bool (*suppress)(struct fib_rule *, struct fib_lookup_arg *);
	int (*match)(struct fib_rule *, struct flowi *, int);
	int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *);
	int (*delete)(struct fib_rule *);
	int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **);
	int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *);
	size_t (*nlmsg_payload)(struct fib_rule *);
	void (*flush_cache)(struct fib_rules_ops *);
	int nlgroup;
	const struct nla_policy *policy;
	struct list_head rules_list;
	struct module *owner;
	struct net *fro_net;
	struct callback_head rcu;
};

enum tcp_ca_event {
	CA_EVENT_TX_START = 0,
	CA_EVENT_CWND_RESTART = 1,
	CA_EVENT_COMPLETE_CWR = 2,
	CA_EVENT_LOSS = 3,
	CA_EVENT_ECN_NO_CE = 4,
	CA_EVENT_ECN_IS_CE = 5,
};

struct ack_sample;

struct rate_sample;

union tcp_cc_info;

struct tcp_congestion_ops {
	struct list_head list;
	u32 key;
	u32 flags;
	void (*init)(struct sock *);
	void (*release)(struct sock *);
	u32 (*ssthresh)(struct sock *);
	void (*cong_avoid)(struct sock *, u32, u32);
	void (*set_state)(struct sock *, u8);
	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
	void (*in_ack_event)(struct sock *, u32);
	u32 (*undo_cwnd)(struct sock *);
	void (*pkts_acked)(struct sock *, const struct ack_sample *);
	u32 (*min_tso_segs)(struct sock *);
	u32 (*sndbuf_expand)(struct sock *);
	void (*cong_control)(struct sock *, const struct rate_sample *);
	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
	char name[16];
	struct module *owner;
};

struct fib_notifier_ops {
	int family;
	struct list_head list;
	unsigned int (*fib_seq_read)(struct net *);
	int (*fib_dump)(struct net *, struct notifier_block *);
	struct module *owner;
	struct callback_head rcu;
};

struct xfrm_state;

struct lwtunnel_state;

struct dst_entry {
	struct net_device *dev;
	struct dst_ops *ops;
	long unsigned int _metrics;
	long unsigned int expires;
	struct xfrm_state *xfrm;
	int (*input)(struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	short unsigned int flags;
	short int obsolete;
	short unsigned int header_len;
	short unsigned int trailer_len;
	atomic_t __refcnt;
	int __use;
	long unsigned int lastuse;
	struct lwtunnel_state *lwtstate;
	struct callback_head callback_head;
	short int error;
	short int __pad;
	__u32 tclassid;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct hh_cache {
	unsigned int hh_len;
	seqlock_t hh_lock;
	long unsigned int hh_data[4];
};

struct neigh_table;

struct neigh_parms;

struct neigh_ops;

struct neighbour {
	struct neighbour *next;
	struct neigh_table *tbl;
	struct neigh_parms *parms;
	long unsigned int confirmed;
	long unsigned int updated;
	rwlock_t lock;
	refcount_t refcnt;
	unsigned int arp_queue_len_bytes;
	struct sk_buff_head arp_queue;
	struct timer_list timer;
	long unsigned int used;
	atomic_t probes;
	__u8 flags;
	__u8 nud_state;
	__u8 type;
	__u8 dead;
	u8 protocol;
	seqlock_t ha_lock;
	int: 32;
	unsigned char ha[32];
	struct hh_cache hh;
	int (*output)(struct neighbour *, struct sk_buff *);
	const struct neigh_ops *ops;
	struct list_head gc_list;
	struct callback_head rcu;
	struct net_device *dev;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	u8 primary_key[0];
};

struct ipv6_stable_secret {
	bool initialized;
	struct in6_addr secret;
};

struct ipv6_devconf {
	__s32 forwarding;
	__s32 hop_limit;
	__s32 mtu6;
	__s32 accept_ra;
	__s32 accept_redirects;
	__s32 autoconf;
	__s32 dad_transmits;
	__s32 rtr_solicits;
	__s32 rtr_solicit_interval;
	__s32 rtr_solicit_max_interval;
	__s32 rtr_solicit_delay;
	__s32 force_mld_version;
	__s32 mldv1_unsolicited_report_interval;
	__s32 mldv2_unsolicited_report_interval;
	__s32 use_tempaddr;
	__s32 temp_valid_lft;
	__s32 temp_prefered_lft;
	__s32 regen_max_retry;
	__s32 max_desync_factor;
	__s32 max_addresses;
	__s32 accept_ra_defrtr;
	__s32 accept_ra_min_hop_limit;
	__s32 accept_ra_pinfo;
	__s32 ignore_routes_with_linkdown;
	__s32 accept_ra_rtr_pref;
	__s32 rtr_probe_interval;
	__s32 accept_ra_rt_info_min_plen;
	__s32 accept_ra_rt_info_max_plen;
	__s32 proxy_ndp;
	__s32 accept_source_route;
	__s32 accept_ra_from_local;
	__s32 optimistic_dad;
	__s32 use_optimistic;
	__s32 mc_forwarding;
	__s32 disable_ipv6;
	__s32 drop_unicast_in_l2_multicast;
	__s32 accept_dad;
	__s32 force_tllao;
	__s32 ndisc_notify;
	__s32 suppress_frag_ndisc;
	__s32 accept_ra_mtu;
	__s32 drop_unsolicited_na;
	struct ipv6_stable_secret stable_secret;
	__s32 use_oif_addrs_only;
	__s32 keep_addr_on_down;
	__s32 seg6_enabled;
	__u32 enhanced_dad;
	__u32 addr_gen_mode;
	__s32 disable_policy;
	__s32 ndisc_tclass;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	struct ctl_table_header *sysctl_header;
};

struct nf_queue_entry;

struct net___2;

struct nf_queue_handler {
	int (*outfn)(struct nf_queue_entry *, unsigned int);
	void (*nf_hook_drop)(struct net___2 *);
};

enum nf_log_type {
	NF_LOG_TYPE_LOG = 0,
	NF_LOG_TYPE_ULOG = 1,
	NF_LOG_TYPE_MAX = 2,
};

typedef u8 u_int8_t;

struct nf_loginfo;

typedef void nf_logfn(struct net___2 *, u_int8_t, unsigned int, const struct sk_buff *, const struct net_device *, const struct net_device *, const struct nf_loginfo *, const char *);

struct module___2;

struct nf_logger {
	char *name;
	enum nf_log_type type;
	nf_logfn *logfn;
	struct module___2 *me;
};

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct ct_pcpu {
	spinlock_t lock;
	struct hlist_nulls_head unconfirmed;
	struct hlist_nulls_head dying;
};

struct ip_conntrack_stat {
	unsigned int found;
	unsigned int invalid;
	unsigned int ignore;
	unsigned int insert;
	unsigned int insert_failed;
	unsigned int drop;
	unsigned int early_drop;
	unsigned int error;
	unsigned int expect_new;
	unsigned int expect_create;
	unsigned int expect_delete;
	unsigned int search_restart;
};

typedef enum {
	SS_FREE = 0,
	SS_UNCONNECTED = 1,
	SS_CONNECTING = 2,
	SS_CONNECTED = 3,
	SS_DISCONNECTING = 4,
} socket_state;

struct socket_wq {
	wait_queue_head_t wait;
	struct fasync_struct *fasync_list;
	long unsigned int flags;
	struct callback_head rcu;
	long: 64;
};

struct proto_ops;

struct socket {
	socket_state state;
	short int type;
	long unsigned int flags;
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq wq;
};

typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);

struct proto_ops {
	int family;
	struct module *owner;
	int (*release)(struct socket *);
	int (*bind)(struct socket *, struct sockaddr *, int);
	int (*connect)(struct socket *, struct sockaddr *, int, int);
	int (*socketpair)(struct socket *, struct socket *);
	int (*accept)(struct socket *, struct socket *, int, bool);
	int (*getname)(struct socket *, struct sockaddr *, int);
	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*gettstamp)(struct socket *, void *, bool, bool);
	int (*listen)(struct socket *, int);
	int (*shutdown)(struct socket *, int);
	int (*setsockopt)(struct socket *, int, int, char *, unsigned int);
	int (*getsockopt)(struct socket *, int, int, char *, int *);
	int (*compat_setsockopt)(struct socket *, int, int, char *, unsigned int);
	int (*compat_getsockopt)(struct socket *, int, int, char *, int *);
	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*set_peek_off)(struct sock *, int);
	int (*peek_len)(struct socket *);
	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
	int (*sendpage_locked)(struct sock *, struct page *, int, size_t, int);
	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
	int (*set_rcvlowat)(struct sock *, int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

struct pipe_buf_operations;

struct pipe_buffer {
	struct page *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	long unsigned int private;
};

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	int (*steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};

struct skb_ext {
	refcount_t refcnt;
	u8 offset[3];
	u8 chunks;
	char data[0];
};

struct dql {
	unsigned int num_queued;
	unsigned int adj_limit;
	unsigned int last_obj_cnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int limit;
	unsigned int num_completed;
	unsigned int prev_ovlimit;
	unsigned int prev_num_queued;
	unsigned int prev_last_obj_cnt;
	unsigned int lowest_slack;
	long unsigned int slack_start_time;
	unsigned int max_limit;
	unsigned int min_limit;
	unsigned int slack_hold_time;
	long: 32;
	long: 64;
	long: 64;
};

struct ethtool_drvinfo {
	__u32 cmd;
	char driver[32];
	char version[32];
	char fw_version[32];
	char bus_info[32];
	char erom_version[32];
	char reserved2[12];
	__u32 n_priv_flags;
	__u32 n_stats;
	__u32 testinfo_len;
	__u32 eedump_len;
	__u32 regdump_len;
};

struct ethtool_wolinfo {
	__u32 cmd;
	__u32 supported;
	__u32 wolopts;
	__u8 sopass[6];
};

struct ethtool_tunable {
	__u32 cmd;
	__u32 id;
	__u32 type_id;
	__u32 len;
	void *data[0];
};

struct ethtool_regs {
	__u32 cmd;
	__u32 version;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eeprom {
	__u32 cmd;
	__u32 magic;
	__u32 offset;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eee {
	__u32 cmd;
	__u32 supported;
	__u32 advertised;
	__u32 lp_advertised;
	__u32 eee_active;
	__u32 eee_enabled;
	__u32 tx_lpi_enabled;
	__u32 tx_lpi_timer;
	__u32 reserved[2];
};

struct ethtool_modinfo {
	__u32 cmd;
	__u32 type;
	__u32 eeprom_len;
	__u32 reserved[8];
};

struct ethtool_coalesce {
	__u32 cmd;
	__u32 rx_coalesce_usecs;
	__u32 rx_max_coalesced_frames;
	__u32 rx_coalesce_usecs_irq;
	__u32 rx_max_coalesced_frames_irq;
	__u32 tx_coalesce_usecs;
	__u32 tx_max_coalesced_frames;
	__u32 tx_coalesce_usecs_irq;
	__u32 tx_max_coalesced_frames_irq;
	__u32 stats_block_coalesce_usecs;
	__u32 use_adaptive_rx_coalesce;
	__u32 use_adaptive_tx_coalesce;
	__u32 pkt_rate_low;
	__u32 rx_coalesce_usecs_low;
	__u32 rx_max_coalesced_frames_low;
	__u32 tx_coalesce_usecs_low;
	__u32 tx_max_coalesced_frames_low;
	__u32 pkt_rate_high;
	__u32 rx_coalesce_usecs_high;
	__u32 rx_max_coalesced_frames_high;
	__u32 tx_coalesce_usecs_high;
	__u32 tx_max_coalesced_frames_high;
	__u32 rate_sample_interval;
};

struct ethtool_ringparam {
	__u32 cmd;
	__u32 rx_max_pending;
	__u32 rx_mini_max_pending;
	__u32 rx_jumbo_max_pending;
	__u32 tx_max_pending;
	__u32 rx_pending;
	__u32 rx_mini_pending;
	__u32 rx_jumbo_pending;
	__u32 tx_pending;
};

struct ethtool_channels {
	__u32 cmd;
	__u32 max_rx;
	__u32 max_tx;
	__u32 max_other;
	__u32 max_combined;
	__u32 rx_count;
	__u32 tx_count;
	__u32 other_count;
	__u32 combined_count;
};

struct ethtool_pauseparam {
	__u32 cmd;
	__u32 autoneg;
	__u32 rx_pause;
	__u32 tx_pause;
};

struct ethtool_test {
	__u32 cmd;
	__u32 flags;
	__u32 reserved;
	__u32 len;
	__u64 data[0];
};

struct ethtool_stats {
	__u32 cmd;
	__u32 n_stats;
	__u64 data[0];
};

struct ethtool_tcpip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be16 psrc;
	__be16 pdst;
	__u8 tos;
};

struct ethtool_ah_espip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 spi;
	__u8 tos;
};

struct ethtool_usrip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 l4_4_bytes;
	__u8 tos;
	__u8 ip_ver;
	__u8 proto;
};

struct ethtool_tcpip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be16 psrc;
	__be16 pdst;
	__u8 tclass;
};

struct ethtool_ah_espip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 spi;
	__u8 tclass;
};

struct ethtool_usrip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 l4_4_bytes;
	__u8 tclass;
	__u8 l4_proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec tcp_ip4_spec;
	struct ethtool_tcpip4_spec udp_ip4_spec;
	struct ethtool_tcpip4_spec sctp_ip4_spec;
	struct ethtool_ah_espip4_spec ah_ip4_spec;
	struct ethtool_ah_espip4_spec esp_ip4_spec;
	struct ethtool_usrip4_spec usr_ip4_spec;
	struct ethtool_tcpip6_spec tcp_ip6_spec;
	struct ethtool_tcpip6_spec udp_ip6_spec;
	struct ethtool_tcpip6_spec sctp_ip6_spec;
	struct ethtool_ah_espip6_spec ah_ip6_spec;
	struct ethtool_ah_espip6_spec esp_ip6_spec;
	struct ethtool_usrip6_spec usr_ip6_spec;
	struct ethhdr ether_spec;
	__u8 hdata[52];
};

struct ethtool_flow_ext {
	__u8 padding[2];
	unsigned char h_dest[6];
	__be16 vlan_etype;
	__be16 vlan_tci;
	__be32 data[2];
};

struct ethtool_rx_flow_spec {
	__u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	__u64 ring_cookie;
	__u32 location;
};

struct ethtool_rxnfc {
	__u32 cmd;
	__u32 flow_type;
	__u64 data;
	struct ethtool_rx_flow_spec fs;
	union {
		__u32 rule_cnt;
		__u32 rss_context;
	};
	__u32 rule_locs[0];
};

struct ethtool_flash {
	__u32 cmd;
	__u32 region;
	char data[128];
};

struct ethtool_dump {
	__u32 cmd;
	__u32 version;
	__u32 flag;
	__u32 len;
	__u8 data[0];
};

struct ethtool_ts_info {
	__u32 cmd;
	__u32 so_timestamping;
	__s32 phc_index;
	__u32 tx_types;
	__u32 tx_reserved[3];
	__u32 rx_filters;
	__u32 rx_reserved[3];
};

struct ethtool_fecparam {
	__u32 cmd;
	__u32 active_fec;
	__u32 fec;
	__u32 reserved;
};

struct ethtool_link_settings {
	__u32 cmd;
	__u32 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 autoneg;
	__u8 mdio_support;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__s8 link_mode_masks_nwords;
	__u8 transceiver;
	__u8 reserved1[3];
	__u32 reserved[7];
	__u32 link_mode_masks[0];
};

enum ethtool_phys_id_state {
	ETHTOOL_ID_INACTIVE = 0,
	ETHTOOL_ID_ACTIVE = 1,
	ETHTOOL_ID_ON = 2,
	ETHTOOL_ID_OFF = 3,
};

struct ethtool_link_ksettings {
	struct ethtool_link_settings base;
	struct {
		long unsigned int supported[2];
		long unsigned int advertising[2];
		long unsigned int lp_advertising[2];
	} link_modes;
};

struct ethtool_ops {
	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device *);
	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device *);
	void (*set_msglevel)(struct net_device *, u32);
	int (*nway_reset)(struct net_device *);
	u32 (*get_link)(struct net_device *);
	int (*get_eeprom_len)(struct net_device *);
	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device *, u32, u8 *);
	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device *);
	void (*complete)(struct net_device *);
	u32 (*get_priv_flags)(struct net_device *);
	int (*set_priv_flags)(struct net_device *, u32);
	int (*get_sset_count)(struct net_device *, int);
	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device *, struct ethtool_flash *);
	int (*reset)(struct net_device *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device *);
	u32 (*get_rxfh_indir_size)(struct net_device *);
	int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *);
	int (*set_rxfh)(struct net_device *, const u32 *, const u8 *, const u8);
	int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32);
	int (*set_rxfh_context)(struct net_device *, const u32 *, const u8 *, const u8, u32 *, bool);
	void (*get_channels)(struct net_device *, struct ethtool_channels *);
	int (*set_channels)(struct net_device *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device *, struct ethtool_eee *);
	int (*set_eee)(struct net_device *, struct ethtool_eee *);
	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct ieee_ets {
	__u8 willing;
	__u8 ets_cap;
	__u8 cbs;
	__u8 tc_tx_bw[8];
	__u8 tc_rx_bw[8];
	__u8 tc_tsa[8];
	__u8 prio_tc[8];
	__u8 tc_reco_bw[8];
	__u8 tc_reco_tsa[8];
	__u8 reco_prio_tc[8];
};

struct ieee_maxrate {
	__u64 tc_maxrate[8];
};

struct ieee_qcn {
	__u8 rpg_enable[8];
	__u32 rppp_max_rps[8];
	__u32 rpg_time_reset[8];
	__u32 rpg_byte_reset[8];
	__u32 rpg_threshold[8];
	__u32 rpg_max_rate[8];
	__u32 rpg_ai_rate[8];
	__u32 rpg_hai_rate[8];
	__u32 rpg_gd[8];
	__u32 rpg_min_dec_fac[8];
	__u32 rpg_min_rate[8];
	__u32 cndd_state_machine[8];
};

struct ieee_qcn_stats {
	__u64 rppp_rp_centiseconds[8];
	__u32 rppp_created_rps[8];
};

struct ieee_pfc {
	__u8 pfc_cap;
	__u8 pfc_en;
	__u8 mbc;
	__u16 delay;
	__u64 requests[8];
	__u64 indications[8];
};

struct dcbnl_buffer {
	__u8 prio2buffer[8];
	__u32 buffer_size[8];
	__u32 total_size;
};

struct cee_pg {
	__u8 willing;
	__u8 error;
	__u8 pg_en;
	__u8 tcs_supported;
	__u8 pg_bw[8];
	__u8 prio_pg[8];
};

struct cee_pfc {
	__u8 willing;
	__u8 error;
	__u8 pfc_en;
	__u8 tcs_supported;
};

struct dcb_app {
	__u8 selector;
	__u8 priority;
	__u16 protocol;
};

struct dcb_peer_app_info {
	__u8 willing;
	__u8 error;
};

struct dcbnl_rtnl_ops {
	int (*ieee_getets)(struct net_device *, struct ieee_ets *);
	int (*ieee_setets)(struct net_device *, struct ieee_ets *);
	int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *);
	int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *);
	int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *);
	int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *);
	int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *);
	int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *);
	int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *);
	int (*ieee_getapp)(struct net_device *, struct dcb_app *);
	int (*ieee_setapp)(struct net_device *, struct dcb_app *);
	int (*ieee_delapp)(struct net_device *, struct dcb_app *);
	int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *);
	int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *);
	u8 (*getstate)(struct net_device *);
	u8 (*setstate)(struct net_device *, u8);
	void (*getpermhwaddr)(struct net_device *, u8 *);
	void (*setpgtccfgtx)(struct net_device *, int, u8, u8, u8, u8);
	void (*setpgbwgcfgtx)(struct net_device *, int, u8);
	void (*setpgtccfgrx)(struct net_device *, int, u8, u8, u8, u8);
	void (*setpgbwgcfgrx)(struct net_device *, int, u8);
	void (*getpgtccfgtx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);
	void (*getpgbwgcfgtx)(struct net_device *, int, u8 *);
	void (*getpgtccfgrx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);
	void (*getpgbwgcfgrx)(struct net_device *, int, u8 *);
	void (*setpfccfg)(struct net_device *, int, u8);
	void (*getpfccfg)(struct net_device *, int, u8 *);
	u8 (*setall)(struct net_device *);
	u8 (*getcap)(struct net_device *, int, u8 *);
	int (*getnumtcs)(struct net_device *, int, u8 *);
	int (*setnumtcs)(struct net_device *, int, u8);
	u8 (*getpfcstate)(struct net_device *);
	void (*setpfcstate)(struct net_device *, u8);
	void (*getbcncfg)(struct net_device *, int, u32 *);
	void (*setbcncfg)(struct net_device *, int, u32);
	void (*getbcnrp)(struct net_device *, int, u8 *);
	void (*setbcnrp)(struct net_device *, int, u8);
	int (*setapp)(struct net_device *, u8, u16, u8);
	int (*getapp)(struct net_device *, u8, u16);
	u8 (*getfeatcfg)(struct net_device *, int, u8 *);
	u8 (*setfeatcfg)(struct net_device *, int, u8);
	u8 (*getdcbx)(struct net_device *);
	u8 (*setdcbx)(struct net_device *, u8);
	int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *);
	int (*peer_getapptable)(struct net_device *, struct dcb_app *);
	int (*cee_peer_getpg)(struct net_device *, struct cee_pg *);
	int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *);
	int (*dcbnl_getbuffer)(struct net_device *, struct dcbnl_buffer *);
	int (*dcbnl_setbuffer)(struct net_device *, struct dcbnl_buffer *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct netprio_map {
	struct callback_head rcu;
	u32 priomap_len;
	u32 priomap[0];
};

struct xdp_mem_info {
	u32 type;
	u32 id;
};

struct xdp_rxq_info {
	struct net_device *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
};

struct xdp_frame {
	void *data;
	u16 len;
	u16 headroom;
	u16 metasize;
	struct xdp_mem_info mem;
	struct net_device *dev_rx;
};

struct nlmsghdr {
	__u32 nlmsg_len;
	__u16 nlmsg_type;
	__u16 nlmsg_flags;
	__u32 nlmsg_seq;
	__u32 nlmsg_pid;
};

struct nlattr {
	__u16 nla_len;
	__u16 nla_type;
};

struct netlink_ext_ack {
	const char *_msg;
	const struct nlattr *bad_attr;
	u8 cookie[20];
	u8 cookie_len;
};

struct netlink_callback {
	struct sk_buff *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	bool strict_check;
	union {
		u8 ctx[48];
		long int args[6];
	};
};

struct ndmsg {
	__u8 ndm_family;
	__u8 ndm_pad1;
	__u16 ndm_pad2;
	__s32 ndm_ifindex;
	__u16 ndm_state;
	__u8 ndm_flags;
	__u8 ndm_type;
};

struct rtnl_link_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
	__u64 collisions;
	__u64 rx_length_errors;
	__u64 rx_over_errors;
	__u64 rx_crc_errors;
	__u64 rx_frame_errors;
	__u64 rx_fifo_errors;
	__u64 rx_missed_errors;
	__u64 tx_aborted_errors;
	__u64 tx_carrier_errors;
	__u64 tx_fifo_errors;
	__u64 tx_heartbeat_errors;
	__u64 tx_window_errors;
	__u64 rx_compressed;
	__u64 tx_compressed;
	__u64 rx_nohandler;
};

struct ifla_vf_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 broadcast;
	__u64 multicast;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct ifla_vf_info {
	__u32 vf;
	__u8 mac[32];
	__u32 vlan;
	__u32 qos;
	__u32 spoofchk;
	__u32 linkstate;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
	__u32 rss_query_en;
	__u32 trusted;
	__be16 vlan_proto;
};

struct tc_stats {
	__u64 bytes;
	__u32 packets;
	__u32 drops;
	__u32 overlimits;
	__u32 bps;
	__u32 pps;
	__u32 qlen;
	__u32 backlog;
};

struct tc_sizespec {
	unsigned char cell_log;
	unsigned char size_log;
	short int cell_align;
	int overhead;
	unsigned int linklayer;
	unsigned int mpu;
	unsigned int mtu;
	unsigned int tsize;
};

enum netdev_tx {
	__NETDEV_TX_MIN = 2147483648,
	NETDEV_TX_OK = 0,
	NETDEV_TX_BUSY = 16,
};

typedef enum netdev_tx netdev_tx_t;

struct header_ops {
	int (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct xdp_umem;

struct netdev_queue {
	struct net_device *dev;
	struct Qdisc *qdisc;
	struct Qdisc *qdisc_sleeping;
	struct kobject kobj;
	int numa_node;
	long unsigned int tx_maxrate;
	long unsigned int trans_timeout;
	struct net_device *sb_dev;
	struct xdp_umem *umem;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	long unsigned int trans_start;
	long unsigned int state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dql dql;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct qdisc_skb_head {
	struct sk_buff *head;
	struct sk_buff *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct gnet_stats_basic_packed {
	__u64 bytes;
	__u32 packets;
} __attribute__((packed));

struct gnet_stats_queue {
	__u32 qlen;
	__u32 backlog;
	__u32 drops;
	__u32 requeues;
	__u32 overlimits;
};

struct Qdisc_ops;

struct qdisc_size_table;

struct net_rate_estimator;

struct gnet_stats_basic_cpu;

struct Qdisc {
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops *ops;
	struct qdisc_size_table *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue *dev_queue;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	int padded;
	refcount_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head gso_skb;
	struct qdisc_skb_head q;
	struct gnet_stats_basic_packed bstats;
	seqcount_t running;
	struct gnet_stats_queue qstats;
	long unsigned int state;
	struct Qdisc *next_sched;
	struct sk_buff_head skb_bad_txq;
	spinlock_t busylock;
	spinlock_t seqlock;
	bool empty;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rps_map {
	unsigned int len;
	struct callback_head rcu;
	u16 cpus[0];
};

struct rps_dev_flow {
	u16 cpu;
	u16 filter;
	unsigned int last_qtail;
};

struct rps_dev_flow_table {
	unsigned int mask;
	struct callback_head rcu;
	struct rps_dev_flow flows[0];
};

struct netdev_rx_queue {
	struct rps_map *rps_map;
	struct rps_dev_flow_table *rps_flow_table;
	struct kobject kobj;
	struct net_device *dev;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	struct xdp_umem *umem;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
};

struct xps_map {
	unsigned int len;
	unsigned int alloc_len;
	struct callback_head rcu;
	u16 queues[0];
};

struct xps_dev_maps {
	struct callback_head rcu;
	struct xps_map *attr_map[0];
};

struct netdev_fcoe_hbainfo {
	char manufacturer[64];
	char serial_number[64];
	char hardware_version[64];
	char driver_version[64];
	char optionrom_version[64];
	char firmware_version[64];
	char model[256];
	char model_description[256];
};

struct netdev_phys_item_id {
	unsigned char id[32];
	unsigned char id_len;
};

enum tc_setup_type {
	TC_SETUP_QDISC_MQPRIO = 0,
	TC_SETUP_CLSU32 = 1,
	TC_SETUP_CLSFLOWER = 2,
	TC_SETUP_CLSMATCHALL = 3,
	TC_SETUP_CLSBPF = 4,
	TC_SETUP_BLOCK = 5,
	TC_SETUP_QDISC_CBS = 6,
	TC_SETUP_QDISC_RED = 7,
	TC_SETUP_QDISC_PRIO = 8,
	TC_SETUP_QDISC_MQ = 9,
	TC_SETUP_QDISC_ETF = 10,
	TC_SETUP_ROOT_QDISC = 11,
	TC_SETUP_QDISC_GRED = 12,
	TC_SETUP_QDISC_TAPRIO = 13,
};

enum bpf_netdev_command {
	XDP_SETUP_PROG = 0,
	XDP_SETUP_PROG_HW = 1,
	XDP_QUERY_PROG = 2,
	XDP_QUERY_PROG_HW = 3,
	BPF_OFFLOAD_MAP_ALLOC = 4,
	BPF_OFFLOAD_MAP_FREE = 5,
	XDP_SETUP_XSK_UMEM = 6,
};

struct netdev_bpf {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			u32 prog_id;
			u32 prog_flags;
		};
		struct {
			struct bpf_offloaded_map *offmap;
		};
		struct {
			struct xdp_umem *umem;
			u16 queue_id;
		} xsk;
	};
};

struct xfrmdev_ops {
	int (*xdo_dev_state_add)(struct xfrm_state *);
	void (*xdo_dev_state_delete)(struct xfrm_state *);
	void (*xdo_dev_state_free)(struct xfrm_state *);
	bool (*xdo_dev_offload_ok)(struct sk_buff *, struct xfrm_state *);
	void (*xdo_dev_state_advance_esn)(struct xfrm_state *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

struct dev_ifalias {
	struct callback_head rcuhead;
	char ifalias[0];
};

struct udp_tunnel_info;

struct devlink_port;

struct net_device_ops {
	int (*ndo_init)(struct net_device *);
	void (*ndo_uninit)(struct net_device *);
	int (*ndo_open)(struct net_device *);
	int (*ndo_stop)(struct net_device *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
	void (*ndo_change_rx_flags)(struct net_device *, int);
	void (*ndo_set_rx_mode)(struct net_device *);
	int (*ndo_set_mac_address)(struct net_device *, void *);
	int (*ndo_validate_addr)(struct net_device *);
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_set_config)(struct net_device *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device *, int);
	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device *);
	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
	void (*ndo_poll_controller)(struct net_device *);
	int (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *);
	void (*ndo_netpoll_cleanup)(struct net_device *);
	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
	int (*ndo_fcoe_enable)(struct net_device *);
	int (*ndo_fcoe_disable)(struct net_device *);
	int (*ndo_fcoe_ddp_setup)(struct net_device *, u16, struct scatterlist *, unsigned int);
	int (*ndo_fcoe_ddp_done)(struct net_device *, u16);
	int (*ndo_fcoe_ddp_target)(struct net_device *, u16, struct scatterlist *, unsigned int);
	int (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *);
	int (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int);
	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device *, struct net_device *);
	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
	int (*ndo_set_features)(struct net_device *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16);
	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device *, bool);
	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
	void (*ndo_udp_tunnel_add)(struct net_device *, struct udp_tunnel_info *);
	void (*ndo_udp_tunnel_del)(struct net_device *, struct udp_tunnel_info *);
	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
	void (*ndo_dfwd_del_station)(struct net_device *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
	int (*ndo_get_iflink)(const struct net_device *);
	int (*ndo_change_proto_down)(struct net_device *, bool);
	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
	void (*ndo_set_rx_headroom)(struct net_device *, int);
	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
	struct devlink_port * (*ndo_get_devlink_port)(struct net_device *);
	long unsigned int kabi_reserved1;
	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct neigh_parms {
	possible_net_t net;
	struct net_device *dev;
	struct list_head list;
	int (*neigh_setup)(struct neighbour *);
	struct neigh_table *tbl;
	void *sysctl_table;
	int dead;
	refcount_t refcnt;
	struct callback_head callback_head;
	int reachable_time;
	int data[13];
	long unsigned int data_state[1];
};

struct dev_mib {
	long unsigned int mibs[9];
};

struct pcpu_lstats {
	u64 packets;
	u64 bytes;
	struct u64_stats_sync syncp;
};

struct pcpu_sw_netstats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
};

struct l3mdev_ops {
	u32 (*l3mdev_fib_table)(const struct net_device *);
	struct sk_buff * (*l3mdev_l3_rcv)(struct net_device *, struct sk_buff *, u16);
	struct sk_buff * (*l3mdev_l3_out)(struct net_device *, struct sock *, struct sk_buff *, u16);
	struct dst_entry * (*l3mdev_link_scope_lookup)(const struct net_device *, struct flowi6 *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct nd_opt_hdr;

struct ndisc_options;

struct prefix_info;

struct ndisc_ops {
	int (*is_useropt)(u8);
	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
};

struct ipv6_devstat {
	struct proc_dir_entry *proc_dir_entry;
	struct ipstats_mib *ipv6;
	struct icmpv6_mib_device *icmpv6dev;
	struct icmpv6msg_mib_device *icmpv6msgdev;
};

struct ifmcaddr6;

struct ifacaddr6;

struct inet6_dev {
	struct net_device *dev;
	struct list_head addr_list;
	struct ifmcaddr6 *mc_list;
	struct ifmcaddr6 *mc_tomb;
	spinlock_t mc_lock;
	unsigned char mc_qrv;
	unsigned char mc_gq_running;
	unsigned char mc_ifc_count;
	unsigned char mc_dad_count;
	long unsigned int mc_v1_seen;
	long unsigned int mc_qi;
	long unsigned int mc_qri;
	long unsigned int mc_maxdelay;
	struct timer_list mc_gq_timer;
	struct timer_list mc_ifc_timer;
	struct timer_list mc_dad_timer;
	struct ifacaddr6 *ac_list;
	rwlock_t lock;
	refcount_t refcnt;
	__u32 if_flags;
	int dead;
	u32 desync_factor;
	u8 rndid[8];
	struct list_head tempaddr_list;
	struct in6_addr token;
	struct neigh_parms *nd_parms;
	struct ipv6_devconf cnf;
	struct ipv6_devstat stats;
	struct timer_list rs_timer;
	__s32 rs_interval;
	__u8 rs_probes;
	long unsigned int tstamp;
	struct callback_head rcu;
};

struct tcf_proto;

struct mini_Qdisc {
	struct tcf_proto *filter_list;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	struct callback_head rcu;
};

struct rtnl_link_ops {
	struct list_head list;
	const char *kind;
	size_t priv_size;
	void (*setup)(struct net_device *);
	bool netns_refund;
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device *, struct list_head *);
	size_t (*get_size)(const struct net_device *);
	int (*fill_info)(struct sk_buff *, const struct net_device *);
	size_t (*get_xstats_size)(const struct net_device *);
	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
	unsigned int (*get_num_tx_queues)();
	unsigned int (*get_num_rx_queues)();
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
	struct net * (*get_link_net)(const struct net_device *);
	size_t (*get_linkxstats_size)(const struct net_device *, int);
	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

enum {
	RTAX_UNSPEC = 0,
	RTAX_LOCK = 1,
	RTAX_MTU = 2,
	RTAX_WINDOW = 3,
	RTAX_RTT = 4,
	RTAX_RTTVAR = 5,
	RTAX_SSTHRESH = 6,
	RTAX_CWND = 7,
	RTAX_ADVMSS = 8,
	RTAX_REORDERING = 9,
	RTAX_HOPLIMIT = 10,
	RTAX_INITCWND = 11,
	RTAX_FEATURES = 12,
	RTAX_RTO_MIN = 13,
	RTAX_INITRWND = 14,
	RTAX_QUICKACK = 15,
	RTAX_CC_ALGO = 16,
	RTAX_FASTOPEN_NO_COOKIE = 17,
	__RTAX_MAX = 18,
};

struct tcmsg {
	unsigned char tcm_family;
	unsigned char tcm__pad1;
	short unsigned int tcm__pad2;
	int tcm_ifindex;
	__u32 tcm_handle;
	__u32 tcm_parent;
	__u32 tcm_info;
};

struct gnet_stats_basic_cpu {
	struct gnet_stats_basic_packed bstats;
	struct u64_stats_sync syncp;
};

struct gnet_dump {
	spinlock_t *lock;
	struct sk_buff *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

struct nla_policy {
	u8 type;
	u8 validation_type;
	u16 len;
	union {
		const void *validation_data;
		struct {
			s16 min;
			s16 max;
		};
		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
		u16 strict_start_type;
	};
};

struct rhash_lock_head {};

struct flow_block {
	struct list_head cb_list;
};

typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);

struct qdisc_size_table {
	struct callback_head rcu;
	struct list_head list;
	struct tc_sizespec szopts;
	int refcnt;
	u16 data[0];
};

struct Qdisc_class_ops;

struct Qdisc_ops {
	struct Qdisc_ops *next;
	const struct Qdisc_class_ops *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct sk_buff * (*peek)(struct Qdisc *);
	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc *);
	void (*destroy)(struct Qdisc *);
	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc *);
	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
	int (*dump)(struct Qdisc *, struct sk_buff *);
	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
	void (*ingress_block_set)(struct Qdisc *, u32);
	void (*egress_block_set)(struct Qdisc *, u32);
	u32 (*ingress_block_get)(struct Qdisc *);
	u32 (*egress_block_get)(struct Qdisc *);
	struct module *owner;
};

struct qdisc_walker;

struct tcf_block;

struct Qdisc_class_ops {
	unsigned int flags;
	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
	int (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
	struct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);
	void (*qlen_notify)(struct Qdisc *, long unsigned int);
	long unsigned int (*find)(struct Qdisc *, u32);
	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc *, long unsigned int);
	void (*walk)(struct Qdisc *, struct qdisc_walker *);
	struct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	long unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);
	void (*unbind_tcf)(struct Qdisc *, long unsigned int);
	int (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);
};

struct tcf_chain;

struct tcf_block {
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net *net;
	struct Qdisc *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

struct tcf_result;

struct tcf_proto_ops;

struct tcf_proto {
	struct tcf_proto *next;
	void *root;
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops *ops;
	struct tcf_chain *chain;
	spinlock_t lock;
	bool deleting;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

struct tcf_result {
	union {
		struct {
			long unsigned int class;
			u32 classid;
		};
		const struct tcf_proto *goto_tp;
		struct {
			bool ingress;
			struct gnet_stats_queue *qstats;
		};
	};
};

struct tcf_walker;

struct tcf_proto_ops {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	int (*init)(struct tcf_proto *);
	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto *, u32);
	void (*put)(struct tcf_proto *, void *);
	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, bool, bool, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto *);
	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto *, void *);
	void (*hw_del)(struct tcf_proto *, void *);
	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
	struct module *owner;
	int flags;
};

struct tcf_chain {
	struct mutex filter_chain_lock;
	struct tcf_proto *filter_chain;
	struct list_head list;
	struct tcf_block *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct sock_fprog_kern {
	u16 len;
	struct sock_filter *filter;
};

struct sk_filter {
	refcount_t refcnt;
	struct callback_head rcu;
	struct bpf_prog *prog;
};

enum {
	NEIGH_VAR_MCAST_PROBES = 0,
	NEIGH_VAR_UCAST_PROBES = 1,
	NEIGH_VAR_APP_PROBES = 2,
	NEIGH_VAR_MCAST_REPROBES = 3,
	NEIGH_VAR_RETRANS_TIME = 4,
	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
	NEIGH_VAR_DELAY_PROBE_TIME = 6,
	NEIGH_VAR_GC_STALETIME = 7,
	NEIGH_VAR_QUEUE_LEN_BYTES = 8,
	NEIGH_VAR_PROXY_QLEN = 9,
	NEIGH_VAR_ANYCAST_DELAY = 10,
	NEIGH_VAR_PROXY_DELAY = 11,
	NEIGH_VAR_LOCKTIME = 12,
	NEIGH_VAR_QUEUE_LEN = 13,
	NEIGH_VAR_RETRANS_TIME_MS = 14,
	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 15,
	NEIGH_VAR_GC_INTERVAL = 16,
	NEIGH_VAR_GC_THRESH1 = 17,
	NEIGH_VAR_GC_THRESH2 = 18,
	NEIGH_VAR_GC_THRESH3 = 19,
	NEIGH_VAR_MAX = 20,
};

struct pneigh_entry;

struct neigh_statistics;

struct neigh_hash_table;

struct neigh_table {
	int family;
	unsigned int entry_size;
	unsigned int key_len;
	__be16 protocol;
	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
	bool (*key_eq)(const struct neighbour *, const void *);
	int (*constructor)(struct neighbour *);
	int (*pconstructor)(struct pneigh_entry *);
	void (*pdestructor)(struct pneigh_entry *);
	void (*proxy_redo)(struct sk_buff *);
	int (*is_multicast)(const void *);
	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
	char *id;
	struct neigh_parms parms;
	struct list_head parms_list;
	int gc_interval;
	int gc_thresh1;
	int gc_thresh2;
	int gc_thresh3;
	long unsigned int last_flush;
	struct delayed_work gc_work;
	struct timer_list proxy_timer;
	struct sk_buff_head proxy_queue;
	atomic_t entries;
	atomic_t gc_entries;
	struct list_head gc_list;
	rwlock_t lock;
	long unsigned int last_rand;
	struct neigh_statistics *stats;
	struct neigh_hash_table *nht;
	struct pneigh_entry **phash_buckets;
};

struct neigh_statistics {
	long unsigned int allocs;
	long unsigned int destroys;
	long unsigned int hash_grows;
	long unsigned int res_failed;
	long unsigned int lookups;
	long unsigned int hits;
	long unsigned int rcv_probes_mcast;
	long unsigned int rcv_probes_ucast;
	long unsigned int periodic_gc_runs;
	long unsigned int forced_gc_runs;
	long unsigned int unres_discards;
	long unsigned int table_fulls;
};

struct neigh_ops {
	int family;
	void (*solicit)(struct neighbour *, struct sk_buff *);
	void (*error_report)(struct neighbour *, struct sk_buff *);
	int (*output)(struct neighbour *, struct sk_buff *);
	int (*connected_output)(struct neighbour *, struct sk_buff *);
};

struct pneigh_entry {
	struct pneigh_entry *next;
	possible_net_t net;
	struct net_device *dev;
	u8 flags;
	u8 protocol;
	u8 key[0];
};

struct neigh_hash_table {
	struct neighbour **hash_buckets;
	unsigned int hash_shift;
	__u32 hash_rnd[4];
	struct callback_head rcu;
};

enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT = 2,
	TCP_SYN_RECV = 3,
	TCP_FIN_WAIT1 = 4,
	TCP_FIN_WAIT2 = 5,
	TCP_TIME_WAIT = 6,
	TCP_CLOSE = 7,
	TCP_CLOSE_WAIT = 8,
	TCP_LAST_ACK = 9,
	TCP_LISTEN = 10,
	TCP_CLOSING = 11,
	TCP_NEW_SYN_RECV = 12,
	TCP_MAX_STATES = 13,
};

struct smc_hashinfo {
	rwlock_t lock;
	struct hlist_head ht;
};

struct fib_rule_hdr {
	__u8 family;
	__u8 dst_len;
	__u8 src_len;
	__u8 tos;
	__u8 table;
	__u8 res1;
	__u8 res2;
	__u8 action;
	__u32 flags;
};

struct fib_rule_port_range {
	__u16 start;
	__u16 end;
};

struct fib_kuid_range {
	kuid_t start;
	kuid_t end;
};

struct fib_rule {
	struct list_head list;
	int iifindex;
	int oifindex;
	u32 mark;
	u32 mark_mask;
	u32 flags;
	u32 table;
	u8 action;
	u8 l3mdev;
	u8 proto;
	u8 ip_proto;
	u32 target;
	__be64 tun_id;
	struct fib_rule *ctarget;
	struct net *fr_net;
	refcount_t refcnt;
	u32 pref;
	int suppress_ifgroup;
	int suppress_prefixlen;
	char iifname[16];
	char oifname[16];
	struct fib_kuid_range uid_range;
	struct fib_rule_port_range sport_range;
	struct fib_rule_port_range dport_range;
	struct callback_head rcu;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct fib_lookup_arg {
	void *lookup_ptr;
	const void *lookup_data;
	void *result;
	struct fib_rule *rule;
	u32 table;
	int flags;
};

struct request_sock_ops;

struct timewait_sock_ops;

struct udp_table;

struct raw_hashinfo;

struct proto {
	void (*close)(struct sock *, long int);
	int (*pre_connect)(struct sock *, struct sockaddr *, int);
	int (*connect)(struct sock *, struct sockaddr *, int);
	int (*disconnect)(struct sock *, int);
	struct sock * (*accept)(struct sock *, int, int *, bool);
	int (*ioctl)(struct sock *, int, long unsigned int);
	int (*init)(struct sock *);
	void (*destroy)(struct sock *);
	void (*shutdown)(struct sock *, int);
	int (*setsockopt)(struct sock *, int, int, char *, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*keepalive)(struct sock *, int);
	int (*compat_setsockopt)(struct sock *, int, int, char *, unsigned int);
	int (*compat_getsockopt)(struct sock *, int, int, char *, int *);
	int (*compat_ioctl)(struct sock *, unsigned int, long unsigned int);
	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int, int *);
	int (*sendpage)(struct sock *, struct page *, int, size_t, int);
	int (*bind)(struct sock *, struct sockaddr *, int);
	int (*backlog_rcv)(struct sock *, struct sk_buff *);
	void (*release_cb)(struct sock *);
	int (*hash)(struct sock *);
	void (*unhash)(struct sock *);
	void (*rehash)(struct sock *);
	int (*get_port)(struct sock *, short unsigned int);
	void (*put_port)(struct sock *);
	unsigned int inuse_idx;
	bool (*stream_memory_free)(const struct sock *, int);
	bool (*stream_memory_read)(const struct sock *);
	void (*enter_memory_pressure)(struct sock *);
	void (*leave_memory_pressure)(struct sock *);
	atomic_long_t *memory_allocated;
	struct percpu_counter *sockets_allocated;
	long unsigned int *memory_pressure;
	long int *sysctl_mem;
	int *sysctl_wmem;
	int *sysctl_rmem;
	u32 sysctl_wmem_offset;
	u32 sysctl_rmem_offset;
	int max_header;
	bool no_autobind;
	struct kmem_cache *slab;
	unsigned int obj_size;
	slab_flags_t slab_flags;
	unsigned int useroffset;
	unsigned int usersize;
	struct percpu_counter *orphan_count;
	struct request_sock_ops *rsk_prot;
	struct timewait_sock_ops *twsk_prot;
	union {
		struct inet_hashinfo *hashinfo;
		struct udp_table *udp_table;
		struct raw_hashinfo *raw_hash;
		struct smc_hashinfo *smc_hash;
	} h;
	struct module *owner;
	char name[32];
	struct list_head node;
	int (*diag_destroy)(struct sock *, int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct request_sock;

struct request_sock_ops {
	int family;
	unsigned int obj_size;
	struct kmem_cache *slab;
	char *slab_name;
	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*send_reset)(const struct sock *, struct sk_buff *);
	void (*destructor)(struct request_sock *);
	void (*syn_ack_timeout)(const struct request_sock *);
};

struct timewait_sock_ops {
	struct kmem_cache *twsk_slab;
	char *twsk_slab_name;
	unsigned int twsk_obj_size;
	int (*twsk_unique)(struct sock *, struct sock *, void *);
	void (*twsk_destructor)(struct sock *);
};

struct request_sock {
	struct sock_common __req_common;
	struct request_sock *dl_next;
	u16 mss;
	u8 num_retrans;
	u8 syncookie: 1;
	u8 num_timeout: 7;
	u32 ts_recent;
	struct timer_list rsk_timer;
	const struct request_sock_ops *rsk_ops;
	struct sock *sk;
	u32 *saved_syn;
	u32 secid;
	u32 peer_secid;
	u32 mark;
};

enum tsq_enum {
	TSQ_THROTTLED = 0,
	TSQ_QUEUED = 1,
	TCP_TSQ_DEFERRED = 2,
	TCP_WRITE_TIMER_DEFERRED = 3,
	TCP_DELACK_TIMER_DEFERRED = 4,
	TCP_MTU_REDUCED_DEFERRED = 5,
};

struct ip6_sf_list {
	struct ip6_sf_list *sf_next;
	struct in6_addr sf_addr;
	long unsigned int sf_count[2];
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ifmcaddr6 {
	struct in6_addr mca_addr;
	struct inet6_dev *idev;
	struct ifmcaddr6 *next;
	struct ip6_sf_list *mca_sources;
	struct ip6_sf_list *mca_tomb;
	unsigned int mca_sfmode;
	unsigned char mca_crcount;
	long unsigned int mca_sfcount[2];
	struct timer_list mca_timer;
	unsigned int mca_flags;
	int mca_users;
	refcount_t mca_refcnt;
	spinlock_t mca_lock;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
};

struct ifacaddr6 {
	struct in6_addr aca_addr;
	struct fib6_info *aca_rt;
	struct ifacaddr6 *aca_next;
	struct hlist_node aca_addr_lst;
	int aca_users;
	refcount_t aca_refcnt;
	long unsigned int aca_cstamp;
	long unsigned int aca_tstamp;
	struct callback_head rcu;
};

enum {
	__ND_OPT_PREFIX_INFO_END = 0,
	ND_OPT_SOURCE_LL_ADDR = 1,
	ND_OPT_TARGET_LL_ADDR = 2,
	ND_OPT_PREFIX_INFO = 3,
	ND_OPT_REDIRECT_HDR = 4,
	ND_OPT_MTU = 5,
	ND_OPT_NONCE = 14,
	__ND_OPT_ARRAY_MAX = 15,
	ND_OPT_ROUTE_INFO = 24,
	ND_OPT_RDNSS = 25,
	ND_OPT_DNSSL = 31,
	ND_OPT_6CO = 34,
	ND_OPT_CAPTIVE_PORTAL = 37,
	__ND_OPT_MAX = 38,
};

struct nd_opt_hdr {
	__u8 nd_opt_type;
	__u8 nd_opt_len;
};

struct ndisc_options {
	struct nd_opt_hdr *nd_opt_array[15];
	struct nd_opt_hdr *nd_opts_ri;
	struct nd_opt_hdr *nd_opts_ri_end;
	struct nd_opt_hdr *nd_useropts;
	struct nd_opt_hdr *nd_useropts_end;
};

struct prefix_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved: 6;
	__u8 autoconf: 1;
	__u8 onlink: 1;
	__be32 valid;
	__be32 prefered;
	__be32 reserved2;
	struct in6_addr prefix;
};

enum nfs_opnum4 {
	OP_ACCESS = 3,
	OP_CLOSE = 4,
	OP_COMMIT = 5,
	OP_CREATE = 6,
	OP_DELEGPURGE = 7,
	OP_DELEGRETURN = 8,
	OP_GETATTR = 9,
	OP_GETFH = 10,
	OP_LINK = 11,
	OP_LOCK = 12,
	OP_LOCKT = 13,
	OP_LOCKU = 14,
	OP_LOOKUP = 15,
	OP_LOOKUPP = 16,
	OP_NVERIFY = 17,
	OP_OPEN = 18,
	OP_OPENATTR = 19,
	OP_OPEN_CONFIRM = 20,
	OP_OPEN_DOWNGRADE = 21,
	OP_PUTFH = 22,
	OP_PUTPUBFH = 23,
	OP_PUTROOTFH = 24,
	OP_READ = 25,
	OP_READDIR = 26,
	OP_READLINK = 27,
	OP_REMOVE = 28,
	OP_RENAME = 29,
	OP_RENEW = 30,
	OP_RESTOREFH = 31,
	OP_SAVEFH = 32,
	OP_SECINFO = 33,
	OP_SETATTR = 34,
	OP_SETCLIENTID = 35,
	OP_SETCLIENTID_CONFIRM = 36,
	OP_VERIFY = 37,
	OP_WRITE = 38,
	OP_RELEASE_LOCKOWNER = 39,
	OP_BACKCHANNEL_CTL = 40,
	OP_BIND_CONN_TO_SESSION = 41,
	OP_EXCHANGE_ID = 42,
	OP_CREATE_SESSION = 43,
	OP_DESTROY_SESSION = 44,
	OP_FREE_STATEID = 45,
	OP_GET_DIR_DELEGATION = 46,
	OP_GETDEVICEINFO = 47,
	OP_GETDEVICELIST = 48,
	OP_LAYOUTCOMMIT = 49,
	OP_LAYOUTGET = 50,
	OP_LAYOUTRETURN = 51,
	OP_SECINFO_NO_NAME = 52,
	OP_SEQUENCE = 53,
	OP_SET_SSV = 54,
	OP_TEST_STATEID = 55,
	OP_WANT_DELEGATION = 56,
	OP_DESTROY_CLIENTID = 57,
	OP_RECLAIM_COMPLETE = 58,
	OP_ALLOCATE = 59,
	OP_COPY = 60,
	OP_COPY_NOTIFY = 61,
	OP_DEALLOCATE = 62,
	OP_IO_ADVISE = 63,
	OP_LAYOUTERROR = 64,
	OP_LAYOUTSTATS = 65,
	OP_OFFLOAD_CANCEL = 66,
	OP_OFFLOAD_STATUS = 67,
	OP_READ_PLUS = 68,
	OP_SEEK = 69,
	OP_WRITE_SAME = 70,
	OP_CLONE = 71,
	OP_ILLEGAL = 10044,
};

enum perf_sw_ids {
	PERF_COUNT_SW_CPU_CLOCK = 0,
	PERF_COUNT_SW_TASK_CLOCK = 1,
	PERF_COUNT_SW_PAGE_FAULTS = 2,
	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
	PERF_COUNT_SW_EMULATION_FAULTS = 8,
	PERF_COUNT_SW_DUMMY = 9,
	PERF_COUNT_SW_BPF_OUTPUT = 10,
	PERF_COUNT_SW_MAX = 11,
};

enum perf_branch_sample_type_shift {
	PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
	PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
	PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
	PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
	PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
	PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
	PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
	PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,
	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,
	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,
	PERF_SAMPLE_BRANCH_MAX_SHIFT = 17,
};

enum exception_stack_ordering {
	ESTACK_DF = 0,
	ESTACK_NMI = 1,
	ESTACK_DB2 = 2,
	ESTACK_DB1 = 3,
	ESTACK_DB = 4,
	ESTACK_MCE = 5,
	N_EXCEPTION_STACKS = 6,
};

enum {
	TSK_TRACE_FL_TRACE_BIT = 0,
	TSK_TRACE_FL_GRAPH_BIT = 1,
};

enum {
	TRACE_EVENT_FL_FILTERED_BIT = 0,
	TRACE_EVENT_FL_CAP_ANY_BIT = 1,
	TRACE_EVENT_FL_NO_SET_FILTER_BIT = 2,
	TRACE_EVENT_FL_IGNORE_ENABLE_BIT = 3,
	TRACE_EVENT_FL_TRACEPOINT_BIT = 4,
	TRACE_EVENT_FL_KPROBE_BIT = 5,
	TRACE_EVENT_FL_UPROBE_BIT = 6,
};

enum {
	EVENT_FILE_FL_ENABLED_BIT = 0,
	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
	EVENT_FILE_FL_FILTERED_BIT = 3,
	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
	EVENT_FILE_FL_PID_FILTER_BIT = 9,
	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
};

struct uuidcmp {
	const char *uuid;
	int len;
};

struct subprocess_info {
	struct work_struct work;
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	struct file *file;
	int wait;
	int retval;
	pid_t pid;
	int (*init)(struct subprocess_info *, struct cred *);
	void (*cleanup)(struct subprocess_info *);
	void *data;
};

enum kmalloc_cache_type {
	KMALLOC_NORMAL = 0,
	KMALLOC_RECLAIM = 1,
	KMALLOC_DMA = 2,
	NR_KMALLOC_TYPES = 3,
};

enum {
	TASKSTATS_CMD_UNSPEC = 0,
	TASKSTATS_CMD_GET = 1,
	TASKSTATS_CMD_NEW = 2,
	__TASKSTATS_CMD_MAX = 3,
};

enum ucount_type {
	UCOUNT_USER_NAMESPACES = 0,
	UCOUNT_PID_NAMESPACES = 1,
	UCOUNT_UTS_NAMESPACES = 2,
	UCOUNT_IPC_NAMESPACES = 3,
	UCOUNT_NET_NAMESPACES = 4,
	UCOUNT_MNT_NAMESPACES = 5,
	UCOUNT_CGROUP_NAMESPACES = 6,
	UCOUNT_INOTIFY_INSTANCES = 7,
	UCOUNT_INOTIFY_WATCHES = 8,
	UCOUNT_COUNTS = 9,
};

enum {
	HI_SOFTIRQ = 0,
	TIMER_SOFTIRQ = 1,
	NET_TX_SOFTIRQ = 2,
	NET_RX_SOFTIRQ = 3,
	BLOCK_SOFTIRQ = 4,
	IRQ_POLL_SOFTIRQ = 5,
	TASKLET_SOFTIRQ = 6,
	SCHED_SOFTIRQ = 7,
	HRTIMER_SOFTIRQ = 8,
	RCU_SOFTIRQ = 9,
	NR_SOFTIRQS = 10,
};

enum cpu_usage_stat {
	CPUTIME_USER = 0,
	CPUTIME_NICE = 1,
	CPUTIME_SYSTEM = 2,
	CPUTIME_SOFTIRQ = 3,
	CPUTIME_IRQ = 4,
	CPUTIME_IDLE = 5,
	CPUTIME_IOWAIT = 6,
	CPUTIME_STEAL = 7,
	CPUTIME_GUEST = 8,
	CPUTIME_GUEST_NICE = 9,
	NR_STATS = 10,
};

enum bpf_cgroup_storage_type {
	BPF_CGROUP_STORAGE_SHARED = 0,
	BPF_CGROUP_STORAGE_PERCPU = 1,
	__BPF_CGROUP_STORAGE_MAX = 2,
};

enum psi_task_count {
	NR_IOWAIT = 0,
	NR_MEMSTALL = 1,
	NR_RUNNING = 2,
	NR_PSI_TASK_COUNTS = 3,
};

enum psi_states {
	PSI_IO_SOME = 0,
	PSI_IO_FULL = 1,
	PSI_MEM_SOME = 2,
	PSI_MEM_FULL = 3,
	PSI_CPU_SOME = 4,
	PSI_NONIDLE = 5,
	NR_PSI_STATES = 6,
};

enum psi_aggregators {
	PSI_AVGS = 0,
	PSI_POLL = 1,
	NR_PSI_AGGREGATORS = 2,
};

enum cgroup_subsys_id {
	cpuset_cgrp_id = 0,
	cpu_cgrp_id = 1,
	cpuacct_cgrp_id = 2,
	io_cgrp_id = 3,
	memory_cgrp_id = 4,
	devices_cgrp_id = 5,
	freezer_cgrp_id = 6,
	net_cls_cgrp_id = 7,
	perf_event_cgrp_id = 8,
	net_prio_cgrp_id = 9,
	hugetlb_cgrp_id = 10,
	pids_cgrp_id = 11,
	CGROUP_SUBSYS_COUNT = 12,
};

enum sli_memlat_stat_item {
	MEM_LAT_GLOBAL_DIRECT_RECLAIM = 0,
	MEM_LAT_MEMCG_DIRECT_RECLAIM = 1,
	MEM_LAT_DIRECT_COMPACT = 2,
	MEM_LAT_GLOBAL_DIRECT_SWAPOUT = 3,
	MEM_LAT_MEMCG_DIRECT_SWAPOUT = 4,
	MEM_LAT_DIRECT_SWAPIN = 5,
	MEM_LAT_STAT_NR = 6,
};

enum sli_lat_count {
	LAT_0_1 = 0,
	LAT_1_4 = 1,
	LAT_4_8 = 2,
	LAT_8_16 = 3,
	LAT_16_32 = 4,
	LAT_32_64 = 5,
	LAT_64_128 = 6,
	LAT_128_INF = 7,
	LAT_COUNT_NR = 8,
};

enum sli_schedlat_stat_item {
	SCHEDLAT_WAIT = 0,
	SCHEDLAT_BLOCK = 1,
	SCHEDLAT_IOBLOCK = 2,
	SCHEDLAT_SLEEP = 3,
	SCHEDLAT_LONGSYS = 4,
	SCHEDLAT_RUNDELAY = 5,
	SCHEDLAT_IRQTIME = 6,
	SCHEDLAT_STAT_NR = 7,
};

enum sli_event_type {
	SLI_SCHED_EVENT = 0,
	SLI_MEM_EVENT = 1,
	SLI_LONGTERM_EVENT = 2,
	SLI_EVENT_NR = 3,
};

enum sli_longterm_event {
	SLI_LONGTERM_RUNDELAY = 0,
	SLI_LONGTERM_IRQTIME = 1,
	SLI_LONGTERM_NR = 2,
};

struct mdu_array_info_s {
	int major_version;
	int minor_version;
	int patch_version;
	unsigned int ctime;
	int level;
	int size;
	int nr_disks;
	int raid_disks;
	int md_minor;
	int not_persistent;
	unsigned int utime;
	int state;
	int active_disks;
	int working_disks;
	int failed_disks;
	int spare_disks;
	int layout;
	int chunk_size;
};

typedef struct mdu_array_info_s mdu_array_info_t;

struct mdu_disk_info_s {
	int number;
	int major;
	int minor;
	int raid_disk;
	int state;
};

typedef struct mdu_disk_info_s mdu_disk_info_t;

struct hash {
	int ino;
	int minor;
	int major;
	umode_t mode;
	struct hash *next;
	char name[4098];
};

struct dir_entry {
	struct list_head list;
	char *name;
	time64_t mtime;
};

enum state {
	Start = 0,
	Collect = 1,
	GotHeader = 2,
	SkipIt = 3,
	GotName = 4,
	CopyFile = 5,
	GotSymlink = 6,
	Reset = 7,
};

typedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));

enum flow_dissector_key_id {
	FLOW_DISSECTOR_KEY_CONTROL = 0,
	FLOW_DISSECTOR_KEY_BASIC = 1,
	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
	FLOW_DISSECTOR_KEY_PORTS = 4,
	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
	FLOW_DISSECTOR_KEY_ICMP = 6,
	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
	FLOW_DISSECTOR_KEY_TIPC = 8,
	FLOW_DISSECTOR_KEY_ARP = 9,
	FLOW_DISSECTOR_KEY_VLAN = 10,
	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
	FLOW_DISSECTOR_KEY_MPLS = 19,
	FLOW_DISSECTOR_KEY_TCP = 20,
	FLOW_DISSECTOR_KEY_IP = 21,
	FLOW_DISSECTOR_KEY_CVLAN = 22,
	FLOW_DISSECTOR_KEY_ENC_IP = 23,
	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
	FLOW_DISSECTOR_KEY_META = 25,
	FLOW_DISSECTOR_KEY_CT = 26,
	FLOW_DISSECTOR_KEY_MAX = 27,
};

enum {
	IPSTATS_MIB_NUM = 0,
	IPSTATS_MIB_INPKTS = 1,
	IPSTATS_MIB_INOCTETS = 2,
	IPSTATS_MIB_INDELIVERS = 3,
	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
	IPSTATS_MIB_OUTPKTS = 5,
	IPSTATS_MIB_OUTOCTETS = 6,
	IPSTATS_MIB_INHDRERRORS = 7,
	IPSTATS_MIB_INTOOBIGERRORS = 8,
	IPSTATS_MIB_INNOROUTES = 9,
	IPSTATS_MIB_INADDRERRORS = 10,
	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
	IPSTATS_MIB_INDISCARDS = 13,
	IPSTATS_MIB_OUTDISCARDS = 14,
	IPSTATS_MIB_OUTNOROUTES = 15,
	IPSTATS_MIB_REASMTIMEOUT = 16,
	IPSTATS_MIB_REASMREQDS = 17,
	IPSTATS_MIB_REASMOKS = 18,
	IPSTATS_MIB_REASMFAILS = 19,
	IPSTATS_MIB_FRAGOKS = 20,
	IPSTATS_MIB_FRAGFAILS = 21,
	IPSTATS_MIB_FRAGCREATES = 22,
	IPSTATS_MIB_INMCASTPKTS = 23,
	IPSTATS_MIB_OUTMCASTPKTS = 24,
	IPSTATS_MIB_INBCASTPKTS = 25,
	IPSTATS_MIB_OUTBCASTPKTS = 26,
	IPSTATS_MIB_INMCASTOCTETS = 27,
	IPSTATS_MIB_OUTMCASTOCTETS = 28,
	IPSTATS_MIB_INBCASTOCTETS = 29,
	IPSTATS_MIB_OUTBCASTOCTETS = 30,
	IPSTATS_MIB_CSUMERRORS = 31,
	IPSTATS_MIB_NOECTPKTS = 32,
	IPSTATS_MIB_ECT1PKTS = 33,
	IPSTATS_MIB_ECT0PKTS = 34,
	IPSTATS_MIB_CEPKTS = 35,
	IPSTATS_MIB_REASM_OVERLAPS = 36,
	__IPSTATS_MIB_MAX = 37,
};

enum {
	ICMP_MIB_NUM = 0,
	ICMP_MIB_INMSGS = 1,
	ICMP_MIB_INERRORS = 2,
	ICMP_MIB_INDESTUNREACHS = 3,
	ICMP_MIB_INTIMEEXCDS = 4,
	ICMP_MIB_INPARMPROBS = 5,
	ICMP_MIB_INSRCQUENCHS = 6,
	ICMP_MIB_INREDIRECTS = 7,
	ICMP_MIB_INECHOS = 8,
	ICMP_MIB_INECHOREPS = 9,
	ICMP_MIB_INTIMESTAMPS = 10,
	ICMP_MIB_INTIMESTAMPREPS = 11,
	ICMP_MIB_INADDRMASKS = 12,
	ICMP_MIB_INADDRMASKREPS = 13,
	ICMP_MIB_OUTMSGS = 14,
	ICMP_MIB_OUTERRORS = 15,
	ICMP_MIB_OUTDESTUNREACHS = 16,
	ICMP_MIB_OUTTIMEEXCDS = 17,
	ICMP_MIB_OUTPARMPROBS = 18,
	ICMP_MIB_OUTSRCQUENCHS = 19,
	ICMP_MIB_OUTREDIRECTS = 20,
	ICMP_MIB_OUTECHOS = 21,
	ICMP_MIB_OUTECHOREPS = 22,
	ICMP_MIB_OUTTIMESTAMPS = 23,
	ICMP_MIB_OUTTIMESTAMPREPS = 24,
	ICMP_MIB_OUTADDRMASKS = 25,
	ICMP_MIB_OUTADDRMASKREPS = 26,
	ICMP_MIB_CSUMERRORS = 27,
	__ICMP_MIB_MAX = 28,
};

enum {
	ICMP6_MIB_NUM = 0,
	ICMP6_MIB_INMSGS = 1,
	ICMP6_MIB_INERRORS = 2,
	ICMP6_MIB_OUTMSGS = 3,
	ICMP6_MIB_OUTERRORS = 4,
	ICMP6_MIB_CSUMERRORS = 5,
	__ICMP6_MIB_MAX = 6,
};

enum {
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM = 1,
	TCP_MIB_RTOMIN = 2,
	TCP_MIB_RTOMAX = 3,
	TCP_MIB_MAXCONN = 4,
	TCP_MIB_ACTIVEOPENS = 5,
	TCP_MIB_PASSIVEOPENS = 6,
	TCP_MIB_ATTEMPTFAILS = 7,
	TCP_MIB_ESTABRESETS = 8,
	TCP_MIB_CURRESTAB = 9,
	TCP_MIB_INSEGS = 10,
	TCP_MIB_OUTSEGS = 11,
	TCP_MIB_RETRANSSEGS = 12,
	TCP_MIB_INERRS = 13,
	TCP_MIB_OUTRSTS = 14,
	TCP_MIB_CSUMERRORS = 15,
	__TCP_MIB_MAX = 16,
};

enum {
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS = 1,
	UDP_MIB_NOPORTS = 2,
	UDP_MIB_INERRORS = 3,
	UDP_MIB_OUTDATAGRAMS = 4,
	UDP_MIB_RCVBUFERRORS = 5,
	UDP_MIB_SNDBUFERRORS = 6,
	UDP_MIB_CSUMERRORS = 7,
	UDP_MIB_IGNOREDMULTI = 8,
	UDP_MIB_MEMERRORS = 9,
	__UDP_MIB_MAX = 10,
};

enum {
	LINUX_MIB_NUM = 0,
	LINUX_MIB_SYNCOOKIESSENT = 1,
	LINUX_MIB_SYNCOOKIESRECV = 2,
	LINUX_MIB_SYNCOOKIESFAILED = 3,
	LINUX_MIB_EMBRYONICRSTS = 4,
	LINUX_MIB_PRUNECALLED = 5,
	LINUX_MIB_RCVPRUNED = 6,
	LINUX_MIB_OFOPRUNED = 7,
	LINUX_MIB_OUTOFWINDOWICMPS = 8,
	LINUX_MIB_LOCKDROPPEDICMPS = 9,
	LINUX_MIB_ARPFILTER = 10,
	LINUX_MIB_TIMEWAITED = 11,
	LINUX_MIB_TIMEWAITRECYCLED = 12,
	LINUX_MIB_TIMEWAITKILLED = 13,
	LINUX_MIB_PAWSACTIVEREJECTED = 14,
	LINUX_MIB_PAWSESTABREJECTED = 15,
	LINUX_MIB_DELAYEDACKS = 16,
	LINUX_MIB_DELAYEDACKLOCKED = 17,
	LINUX_MIB_DELAYEDACKLOST = 18,
	LINUX_MIB_LISTENOVERFLOWS = 19,
	LINUX_MIB_LISTENDROPS = 20,
	LINUX_MIB_TCPHPHITS = 21,
	LINUX_MIB_TCPPUREACKS = 22,
	LINUX_MIB_TCPHPACKS = 23,
	LINUX_MIB_TCPRENORECOVERY = 24,
	LINUX_MIB_TCPSACKRECOVERY = 25,
	LINUX_MIB_TCPSACKRENEGING = 26,
	LINUX_MIB_TCPSACKREORDER = 27,
	LINUX_MIB_TCPRENOREORDER = 28,
	LINUX_MIB_TCPTSREORDER = 29,
	LINUX_MIB_TCPFULLUNDO = 30,
	LINUX_MIB_TCPPARTIALUNDO = 31,
	LINUX_MIB_TCPDSACKUNDO = 32,
	LINUX_MIB_TCPLOSSUNDO = 33,
	LINUX_MIB_TCPLOSTRETRANSMIT = 34,
	LINUX_MIB_TCPRENOFAILURES = 35,
	LINUX_MIB_TCPSACKFAILURES = 36,
	LINUX_MIB_TCPLOSSFAILURES = 37,
	LINUX_MIB_TCPFASTRETRANS = 38,
	LINUX_MIB_TCPSLOWSTARTRETRANS = 39,
	LINUX_MIB_TCPTIMEOUTS = 40,
	LINUX_MIB_TCPLOSSPROBES = 41,
	LINUX_MIB_TCPLOSSPROBERECOVERY = 42,
	LINUX_MIB_TCPRENORECOVERYFAIL = 43,
	LINUX_MIB_TCPSACKRECOVERYFAIL = 44,
	LINUX_MIB_TCPRCVCOLLAPSED = 45,
	LINUX_MIB_TCPDSACKOLDSENT = 46,
	LINUX_MIB_TCPDSACKOFOSENT = 47,
	LINUX_MIB_TCPDSACKRECV = 48,
	LINUX_MIB_TCPDSACKOFORECV = 49,
	LINUX_MIB_TCPABORTONDATA = 50,
	LINUX_MIB_TCPABORTONCLOSE = 51,
	LINUX_MIB_TCPABORTONMEMORY = 52,
	LINUX_MIB_TCPABORTONTIMEOUT = 53,
	LINUX_MIB_TCPABORTONLINGER = 54,
	LINUX_MIB_TCPABORTFAILED = 55,
	LINUX_MIB_TCPMEMORYPRESSURES = 56,
	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 57,
	LINUX_MIB_TCPSACKDISCARD = 58,
	LINUX_MIB_TCPDSACKIGNOREDOLD = 59,
	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 60,
	LINUX_MIB_TCPSPURIOUSRTOS = 61,
	LINUX_MIB_TCPMD5NOTFOUND = 62,
	LINUX_MIB_TCPMD5UNEXPECTED = 63,
	LINUX_MIB_TCPMD5FAILURE = 64,
	LINUX_MIB_SACKSHIFTED = 65,
	LINUX_MIB_SACKMERGED = 66,
	LINUX_MIB_SACKSHIFTFALLBACK = 67,
	LINUX_MIB_TCPBACKLOGDROP = 68,
	LINUX_MIB_PFMEMALLOCDROP = 69,
	LINUX_MIB_TCPMINTTLDROP = 70,
	LINUX_MIB_TCPDEFERACCEPTDROP = 71,
	LINUX_MIB_IPRPFILTER = 72,
	LINUX_MIB_TCPTIMEWAITOVERFLOW = 73,
	LINUX_MIB_TCPREQQFULLDOCOOKIES = 74,
	LINUX_MIB_TCPREQQFULLDROP = 75,
	LINUX_MIB_TCPRETRANSFAIL = 76,
	LINUX_MIB_TCPRCVCOALESCE = 77,
	LINUX_MIB_TCPBACKLOGCOALESCE = 78,
	LINUX_MIB_TCPOFOQUEUE = 79,
	LINUX_MIB_TCPOFODROP = 80,
	LINUX_MIB_TCPOFOMERGE = 81,
	LINUX_MIB_TCPCHALLENGEACK = 82,
	LINUX_MIB_TCPSYNCHALLENGE = 83,
	LINUX_MIB_TCPFASTOPENACTIVE = 84,
	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 85,
	LINUX_MIB_TCPFASTOPENPASSIVE = 86,
	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 87,
	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 88,
	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 89,
	LINUX_MIB_TCPFASTOPENBLACKHOLE = 90,
	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 91,
	LINUX_MIB_BUSYPOLLRXPACKETS = 92,
	LINUX_MIB_TCPAUTOCORKING = 93,
	LINUX_MIB_TCPFROMZEROWINDOWADV = 94,
	LINUX_MIB_TCPTOZEROWINDOWADV = 95,
	LINUX_MIB_TCPWANTZEROWINDOWADV = 96,
	LINUX_MIB_TCPSYNRETRANS = 97,
	LINUX_MIB_TCPORIGDATASENT = 98,
	LINUX_MIB_TCPHYSTARTTRAINDETECT = 99,
	LINUX_MIB_TCPHYSTARTTRAINCWND = 100,
	LINUX_MIB_TCPHYSTARTDELAYDETECT = 101,
	LINUX_MIB_TCPHYSTARTDELAYCWND = 102,
	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 103,
	LINUX_MIB_TCPACKSKIPPEDPAWS = 104,
	LINUX_MIB_TCPACKSKIPPEDSEQ = 105,
	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 106,
	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 107,
	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 108,
	LINUX_MIB_TCPWINPROBE = 109,
	LINUX_MIB_TCPKEEPALIVE = 110,
	LINUX_MIB_TCPMTUPFAIL = 111,
	LINUX_MIB_TCPMTUPSUCCESS = 112,
	LINUX_MIB_TCPDELIVERED = 113,
	LINUX_MIB_TCPDELIVEREDCE = 114,
	LINUX_MIB_TCPACKCOMPRESSED = 115,
	LINUX_MIB_TCPZEROWINDOWDROP = 116,
	LINUX_MIB_TCPRCVQDROP = 117,
	LINUX_MIB_TCPWQUEUETOOBIG = 118,
	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 119,
	__LINUX_MIB_MAX = 120,
};

enum {
	LINUX_MIB_XFRMNUM = 0,
	LINUX_MIB_XFRMINERROR = 1,
	LINUX_MIB_XFRMINBUFFERERROR = 2,
	LINUX_MIB_XFRMINHDRERROR = 3,
	LINUX_MIB_XFRMINNOSTATES = 4,
	LINUX_MIB_XFRMINSTATEPROTOERROR = 5,
	LINUX_MIB_XFRMINSTATEMODEERROR = 6,
	LINUX_MIB_XFRMINSTATESEQERROR = 7,
	LINUX_MIB_XFRMINSTATEEXPIRED = 8,
	LINUX_MIB_XFRMINSTATEMISMATCH = 9,
	LINUX_MIB_XFRMINSTATEINVALID = 10,
	LINUX_MIB_XFRMINTMPLMISMATCH = 11,
	LINUX_MIB_XFRMINNOPOLS = 12,
	LINUX_MIB_XFRMINPOLBLOCK = 13,
	LINUX_MIB_XFRMINPOLERROR = 14,
	LINUX_MIB_XFRMOUTERROR = 15,
	LINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,
	LINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,
	LINUX_MIB_XFRMOUTNOSTATES = 18,
	LINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,
	LINUX_MIB_XFRMOUTSTATEMODEERROR = 20,
	LINUX_MIB_XFRMOUTSTATESEQERROR = 21,
	LINUX_MIB_XFRMOUTSTATEEXPIRED = 22,
	LINUX_MIB_XFRMOUTPOLBLOCK = 23,
	LINUX_MIB_XFRMOUTPOLDEAD = 24,
	LINUX_MIB_XFRMOUTPOLERROR = 25,
	LINUX_MIB_XFRMFWDHDRERROR = 26,
	LINUX_MIB_XFRMOUTSTATEINVALID = 27,
	LINUX_MIB_XFRMACQUIREERROR = 28,
	__LINUX_MIB_XFRMMAX = 29,
};

enum {
	LINUX_MIB_DROPSTAT_NUM = 0,
	LINUX_MIB_TCPDQNODATADROP = 1,
	LINUX_MIB_TCPDQNOMEMDROP = 2,
	LINUX_MIB_TCPCHECKSEQDROP = 3,
	LINUX_MIB_TCPCHECKRSTDROP = 4,
	LINUX_MIB_TCPNOACKDROP = 5,
	LINUX_MIB_TCPINVALIDACKDROP = 6,
	LINUX_MIB_TCPRSTDROP = 7,
	LINUX_MIB_TCPNOSYNDROP = 8,
	LINUX_MIB_TCPPAWSDROP = 9,
	LINUX_MIB_TCPBADPKTDROP = 10,
	LINUX_MIB_TCPNOSOCKETDROP = 11,
	LINUX_MIB_TCPXFRMDROP = 12,
	LINUX_MIB_TCPFILTERDROP = 13,
	LINUX_MIB_TCPMD5DROP = 14,
	LINUX_MIB_TCPTWDROP = 15,
	LINUX_MIB_TCPRCVESTDROP = 16,
	LINUX_MIB_TCPNSKDROP = 17,
	LINUX_MIB_TCPCHILDPROCDROP = 18,
	LINUX_MIB_TCPRCVSTATEPROCDROP = 19,
	LINUX_MIB_TCPOFODUPDROP = 20,
	LINUX_MIB_TCPURGDROP = 21,
	LINUX_MIB_TCPOOWDROP = 22,
	__LINUX_DROPSTAT_MIB_MAX = 23,
};

enum nf_inet_hooks {
	NF_INET_PRE_ROUTING = 0,
	NF_INET_LOCAL_IN = 1,
	NF_INET_FORWARD = 2,
	NF_INET_LOCAL_OUT = 3,
	NF_INET_POST_ROUTING = 4,
	NF_INET_NUMHOOKS = 5,
};

enum {
	NFPROTO_UNSPEC = 0,
	NFPROTO_INET = 1,
	NFPROTO_IPV4 = 2,
	NFPROTO_ARP = 3,
	NFPROTO_NETDEV = 5,
	NFPROTO_BRIDGE = 7,
	NFPROTO_IPV6 = 10,
	NFPROTO_DECNET = 12,
	NFPROTO_NUMPROTO = 13,
};

enum tcp_conntrack {
	TCP_CONNTRACK_NONE = 0,
	TCP_CONNTRACK_SYN_SENT = 1,
	TCP_CONNTRACK_SYN_RECV = 2,
	TCP_CONNTRACK_ESTABLISHED = 3,
	TCP_CONNTRACK_FIN_WAIT = 4,
	TCP_CONNTRACK_CLOSE_WAIT = 5,
	TCP_CONNTRACK_LAST_ACK = 6,
	TCP_CONNTRACK_TIME_WAIT = 7,
	TCP_CONNTRACK_CLOSE = 8,
	TCP_CONNTRACK_LISTEN = 9,
	TCP_CONNTRACK_MAX = 10,
	TCP_CONNTRACK_IGNORE = 11,
	TCP_CONNTRACK_RETRANS = 12,
	TCP_CONNTRACK_UNACK = 13,
	TCP_CONNTRACK_TIMEOUT_MAX = 14,
};

enum udp_conntrack {
	UDP_CT_UNREPLIED = 0,
	UDP_CT_REPLIED = 1,
	UDP_CT_MAX = 2,
};

enum gre_conntrack {
	GRE_CT_UNREPLIED = 0,
	GRE_CT_REPLIED = 1,
	GRE_CT_MAX = 2,
};

enum {
	XFRM_POLICY_IN = 0,
	XFRM_POLICY_OUT = 1,
	XFRM_POLICY_FWD = 2,
	XFRM_POLICY_MASK = 3,
	XFRM_POLICY_MAX = 3,
};

enum netns_bpf_attach_type {
	NETNS_BPF_INVALID = 4294967295,
	NETNS_BPF_FLOW_DISSECTOR = 0,
	NETNS_BPF_SK_LOOKUP = 1,
	MAX_NETNS_BPF_ATTACH_TYPE = 2,
};

enum skb_ext_id {
	SKB_EXT_BRIDGE_NF = 0,
	SKB_EXT_SEC_PATH = 1,
	SKB_EXT_MPTCP = 2,
	SKB_EXT_NUM = 3,
};

enum audit_ntp_type {
	AUDIT_NTP_OFFSET = 0,
	AUDIT_NTP_FREQ = 1,
	AUDIT_NTP_STATUS = 2,
	AUDIT_NTP_TAI = 3,
	AUDIT_NTP_TICK = 4,
	AUDIT_NTP_ADJUST = 5,
	AUDIT_NTP_NVALS = 6,
};

enum {
	EI_ETYPE_NONE = 0,
	EI_ETYPE_NULL = 1,
	EI_ETYPE_ERRNO = 2,
	EI_ETYPE_ERRNO_NULL = 3,
	EI_ETYPE_TRUE = 4,
};

struct syscall_metadata {
	const char *name;
	int syscall_nr;
	int nb_args;
	const char **types;
	const char **args;
	struct list_head enter_fields;
	struct trace_event_call *enter_event;
	struct trace_event_call *exit_event;
};

typedef long int (*sys_call_ptr_t)(const struct pt_regs *);

struct cpuinfo_x86 {
	__u8 x86;
	__u8 x86_vendor;
	__u8 x86_model;
	__u8 x86_stepping;
	int x86_tlbsize;
	__u8 x86_virt_bits;
	__u8 x86_phys_bits;
	__u8 x86_coreid_bits;
	__u8 cu_id;
	__u32 extended_cpuid_level;
	int cpuid_level;
	__u32 x86_capability[20];
	char x86_vendor_id[16];
	char x86_model_id[64];
	unsigned int x86_cache_size;
	int x86_cache_alignment;
	int x86_cache_max_rmid;
	int x86_cache_occ_scale;
	int x86_power;
	long unsigned int loops_per_jiffy;
	u16 x86_max_cores;
	u16 apicid;
	u16 initial_apicid;
	u16 x86_clflush_size;
	u16 booted_cores;
	u16 phys_proc_id;
	u16 logical_proc_id;
	u16 cpu_core_id;
	u16 cpu_die_id;
	u16 logical_die_id;
	u16 cpu_index;
	u32 microcode;
	u8 x86_cache_bits;
	unsigned int initialized: 1;
};

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

struct ksignal {
	struct k_sigaction ka;
	kernel_siginfo_t info;
	int sig;
};

struct __large_struct {
	long unsigned int buf[100];
};

enum ctx_state {
	CONTEXT_DISABLED = 4294967295,
	CONTEXT_KERNEL = 0,
	CONTEXT_USER = 1,
	CONTEXT_GUEST = 2,
};

struct trace_event_raw_sys_enter {
	struct trace_entry ent;
	long int id;
	long unsigned int args[6];
	char __data[0];
};

struct trace_event_raw_sys_exit {
	struct trace_entry ent;
	long int id;
	long int ret;
	char __data[0];
};

struct trace_event_data_offsets_sys_enter {};

struct trace_event_data_offsets_sys_exit {};

typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long int);

struct alt_instr {
	s32 instr_offset;
	s32 repl_offset;
	u16 cpuid;
	u8 instrlen;
	u8 replacementlen;
	u8 padlen;
} __attribute__((packed));

enum vm_fault_reason {
	VM_FAULT_OOM = 1,
	VM_FAULT_SIGBUS = 2,
	VM_FAULT_MAJOR = 4,
	VM_FAULT_WRITE = 8,
	VM_FAULT_HWPOISON = 16,
	VM_FAULT_HWPOISON_LARGE = 32,
	VM_FAULT_SIGSEGV = 64,
	VM_FAULT_NOPAGE = 256,
	VM_FAULT_LOCKED = 512,
	VM_FAULT_RETRY = 1024,
	VM_FAULT_FALLBACK = 2048,
	VM_FAULT_DONE_COW = 4096,
	VM_FAULT_NEEDDSYNC = 8192,
	VM_FAULT_HINDEX_MASK = 983040,
};

struct vm_special_mapping {
	const char *name;
	struct page **pages;
	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
};

struct pvclock_vcpu_time_info {
	u32 version;
	u32 pad0;
	u64 tsc_timestamp;
	u64 system_time;
	u32 tsc_to_system_mul;
	s8 tsc_shift;
	u8 flags;
	u8 pad[2];
};

struct pvclock_vsyscall_time_info {
	struct pvclock_vcpu_time_info pvti;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ms_hyperv_tsc_page {
	volatile u32 tsc_sequence;
	u32 reserved1;
	volatile u64 tsc_scale;
	volatile s64 tsc_offset;
	u64 reserved2[509];
};

enum {
	X86_TRAP_DE = 0,
	X86_TRAP_DB = 1,
	X86_TRAP_NMI = 2,
	X86_TRAP_BP = 3,
	X86_TRAP_OF = 4,
	X86_TRAP_BR = 5,
	X86_TRAP_UD = 6,
	X86_TRAP_NM = 7,
	X86_TRAP_DF = 8,
	X86_TRAP_OLD_MF = 9,
	X86_TRAP_TS = 10,
	X86_TRAP_NP = 11,
	X86_TRAP_SS = 12,
	X86_TRAP_GP = 13,
	X86_TRAP_PF = 14,
	X86_TRAP_SPURIOUS = 15,
	X86_TRAP_MF = 16,
	X86_TRAP_AC = 17,
	X86_TRAP_MC = 18,
	X86_TRAP_XF = 19,
	X86_TRAP_IRET = 32,
};

struct vdso_exception_table_entry {
	int insn;
	int fixup;
};

enum x86_pf_error_code {
	X86_PF_PROT = 1,
	X86_PF_WRITE = 2,
	X86_PF_USER = 4,
	X86_PF_RSVD = 8,
	X86_PF_INSTR = 16,
	X86_PF_PK = 32,
	X86_PF_SGX = 32768,
};

struct trace_event_raw_emulate_vsyscall {
	struct trace_entry ent;
	int nr;
	char __data[0];
};

struct trace_event_data_offsets_emulate_vsyscall {};

typedef void (*btf_trace_emulate_vsyscall)(void *, int);

enum {
	EMULATE = 0,
	XONLY = 1,
	NONE = 2,
};

enum perf_type_id {
	PERF_TYPE_HARDWARE = 0,
	PERF_TYPE_SOFTWARE = 1,
	PERF_TYPE_TRACEPOINT = 2,
	PERF_TYPE_HW_CACHE = 3,
	PERF_TYPE_RAW = 4,
	PERF_TYPE_BREAKPOINT = 5,
	PERF_TYPE_MAX = 6,
};

enum perf_hw_id {
	PERF_COUNT_HW_CPU_CYCLES = 0,
	PERF_COUNT_HW_INSTRUCTIONS = 1,
	PERF_COUNT_HW_CACHE_REFERENCES = 2,
	PERF_COUNT_HW_CACHE_MISSES = 3,
	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
	PERF_COUNT_HW_BRANCH_MISSES = 5,
	PERF_COUNT_HW_BUS_CYCLES = 6,
	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
	PERF_COUNT_HW_MAX = 10,
};

enum perf_hw_cache_id {
	PERF_COUNT_HW_CACHE_L1D = 0,
	PERF_COUNT_HW_CACHE_L1I = 1,
	PERF_COUNT_HW_CACHE_LL = 2,
	PERF_COUNT_HW_CACHE_DTLB = 3,
	PERF_COUNT_HW_CACHE_ITLB = 4,
	PERF_COUNT_HW_CACHE_BPU = 5,
	PERF_COUNT_HW_CACHE_NODE = 6,
	PERF_COUNT_HW_CACHE_MAX = 7,
};

enum perf_hw_cache_op_id {
	PERF_COUNT_HW_CACHE_OP_READ = 0,
	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
	PERF_COUNT_HW_CACHE_OP_MAX = 3,
};

enum perf_hw_cache_op_result_id {
	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
};

enum perf_event_sample_format {
	PERF_SAMPLE_IP = 1,
	PERF_SAMPLE_TID = 2,
	PERF_SAMPLE_TIME = 4,
	PERF_SAMPLE_ADDR = 8,
	PERF_SAMPLE_READ = 16,
	PERF_SAMPLE_CALLCHAIN = 32,
	PERF_SAMPLE_ID = 64,
	PERF_SAMPLE_CPU = 128,
	PERF_SAMPLE_PERIOD = 256,
	PERF_SAMPLE_STREAM_ID = 512,
	PERF_SAMPLE_RAW = 1024,
	PERF_SAMPLE_BRANCH_STACK = 2048,
	PERF_SAMPLE_REGS_USER = 4096,
	PERF_SAMPLE_STACK_USER = 8192,
	PERF_SAMPLE_WEIGHT = 16384,
	PERF_SAMPLE_DATA_SRC = 32768,
	PERF_SAMPLE_IDENTIFIER = 65536,
	PERF_SAMPLE_TRANSACTION = 131072,
	PERF_SAMPLE_REGS_INTR = 262144,
	PERF_SAMPLE_PHYS_ADDR = 524288,
	PERF_SAMPLE_MAX = 1048576,
	__PERF_SAMPLE_CALLCHAIN_EARLY = 0,
};

enum perf_branch_sample_type {
	PERF_SAMPLE_BRANCH_USER = 1,
	PERF_SAMPLE_BRANCH_KERNEL = 2,
	PERF_SAMPLE_BRANCH_HV = 4,
	PERF_SAMPLE_BRANCH_ANY = 8,
	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
	PERF_SAMPLE_BRANCH_IND_CALL = 64,
	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
	PERF_SAMPLE_BRANCH_IN_TX = 256,
	PERF_SAMPLE_BRANCH_NO_TX = 512,
	PERF_SAMPLE_BRANCH_COND = 1024,
	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
	PERF_SAMPLE_BRANCH_CALL = 8192,
	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
	PERF_SAMPLE_BRANCH_MAX = 131072,
};

struct perf_event_mmap_page {
	__u32 version;
	__u32 compat_version;
	__u32 lock;
	__u32 index;
	__s64 offset;
	__u64 time_enabled;
	__u64 time_running;
	union {
		__u64 capabilities;
		struct {
			__u64 cap_bit0: 1;
			__u64 cap_bit0_is_deprecated: 1;
			__u64 cap_user_rdpmc: 1;
			__u64 cap_user_time: 1;
			__u64 cap_user_time_zero: 1;
			__u64 cap_____res: 59;
		};
	};
	__u16 pmc_width;
	__u16 time_shift;
	__u32 time_mult;
	__u64 time_offset;
	__u64 time_zero;
	__u32 size;
	__u8 __reserved[948];
	__u64 data_head;
	__u64 data_tail;
	__u64 data_offset;
	__u64 data_size;
	__u64 aux_head;
	__u64 aux_tail;
	__u64 aux_offset;
	__u64 aux_size;
};

struct physid_mask {
	long unsigned int mask[512];
};

typedef struct physid_mask physid_mask_t;

struct ldt_struct {
	struct desc_struct *entries;
	unsigned int nr_entries;
	int slot;
};

typedef struct {
	u16 __softirq_pending;
	u8 kvm_cpu_l1tf_flush_l1d;
	unsigned int __nmi_count;
	unsigned int apic_timer_irqs;
	unsigned int irq_spurious_count;
	unsigned int icr_read_retry_count;
	unsigned int kvm_posted_intr_ipis;
	unsigned int kvm_posted_intr_wakeup_ipis;
	unsigned int kvm_posted_intr_nested_ipis;
	unsigned int x86_platform_ipis;
	unsigned int apic_perf_irqs;
	unsigned int apic_irq_work_irqs;
	unsigned int irq_resched_count;
	unsigned int irq_call_count;
	unsigned int irq_tlb_count;
	unsigned int irq_thermal_count;
	unsigned int irq_threshold_count;
	unsigned int irq_deferred_error_count;
	unsigned int irq_hv_callback_count;
	unsigned int irq_hv_reenlightenment_count;
	unsigned int hyperv_stimer0_count;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
} irq_cpustat_t;

struct apic {
	void (*eoi_write)(u32, u32);
	void (*native_eoi_write)(u32, u32);
	void (*write)(u32, u32);
	u32 (*read)(u32);
	void (*wait_icr_idle)();
	u32 (*safe_wait_icr_idle)();
	void (*send_IPI)(int, int);
	void (*send_IPI_mask)(const struct cpumask *, int);
	void (*send_IPI_mask_allbutself)(const struct cpumask *, int);
	void (*send_IPI_allbutself)(int);
	void (*send_IPI_all)(int);
	void (*send_IPI_self)(int);
	u32 dest_logical;
	u32 disable_esr;
	u32 irq_delivery_mode;
	u32 irq_dest_mode;
	u32 (*calc_dest_apicid)(unsigned int);
	u64 (*icr_read)();
	void (*icr_write)(u32, u32);
	int (*probe)();
	int (*acpi_madt_oem_check)(char *, char *);
	int (*apic_id_valid)(u32);
	int (*apic_id_registered)();
	bool (*check_apicid_used)(physid_mask_t *, int);
	void (*init_apic_ldr)();
	void (*ioapic_phys_id_map)(physid_mask_t *, physid_mask_t *);
	void (*setup_apic_routing)();
	int (*cpu_present_to_apicid)(int);
	void (*apicid_to_cpu_present)(int, physid_mask_t *);
	int (*check_phys_apicid_present)(int);
	int (*phys_pkg_id)(int, int);
	u32 (*get_apic_id)(long unsigned int);
	u32 (*set_apic_id)(unsigned int);
	int (*wakeup_secondary_cpu)(int, long unsigned int);
	void (*inquire_remote_apic)(int);
	char *name;
};

struct x86_pmu_capability {
	int version;
	int num_counters_gp;
	int num_counters_fixed;
	int bit_width_gp;
	int bit_width_fixed;
	unsigned int events_mask;
	int events_mask_len;
};

struct debug_store {
	u64 bts_buffer_base;
	u64 bts_index;
	u64 bts_absolute_maximum;
	u64 bts_interrupt_threshold;
	u64 pebs_buffer_base;
	u64 pebs_index;
	u64 pebs_absolute_maximum;
	u64 pebs_interrupt_threshold;
	u64 pebs_event_reset[12];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum stack_type {
	STACK_TYPE_UNKNOWN = 0,
	STACK_TYPE_TASK = 1,
	STACK_TYPE_IRQ = 2,
	STACK_TYPE_SOFTIRQ = 3,
	STACK_TYPE_ENTRY = 4,
	STACK_TYPE_EXCEPTION = 5,
	STACK_TYPE_EXCEPTION_LAST = 10,
};

struct stack_info {
	enum stack_type type;
	long unsigned int *begin;
	long unsigned int *end;
	long unsigned int *next_sp;
};

struct stack_frame {
	struct stack_frame *next_frame;
	long unsigned int return_address;
};

struct stack_frame_ia32 {
	u32 next_frame;
	u32 return_address;
};

struct perf_guest_switch_msr {
	unsigned int msr;
	u64 host;
	u64 guest;
};

struct perf_guest_info_callbacks {
	int (*is_in_guest)();
	int (*is_user_mode)();
	long unsigned int (*get_guest_ip)();
	void (*handle_intel_pt_intr)();
};

struct device_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device *, struct device_attribute *, char *);
	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
};

enum perf_event_x86_regs {
	PERF_REG_X86_AX = 0,
	PERF_REG_X86_BX = 1,
	PERF_REG_X86_CX = 2,
	PERF_REG_X86_DX = 3,
	PERF_REG_X86_SI = 4,
	PERF_REG_X86_DI = 5,
	PERF_REG_X86_BP = 6,
	PERF_REG_X86_SP = 7,
	PERF_REG_X86_IP = 8,
	PERF_REG_X86_FLAGS = 9,
	PERF_REG_X86_CS = 10,
	PERF_REG_X86_SS = 11,
	PERF_REG_X86_DS = 12,
	PERF_REG_X86_ES = 13,
	PERF_REG_X86_FS = 14,
	PERF_REG_X86_GS = 15,
	PERF_REG_X86_R8 = 16,
	PERF_REG_X86_R9 = 17,
	PERF_REG_X86_R10 = 18,
	PERF_REG_X86_R11 = 19,
	PERF_REG_X86_R12 = 20,
	PERF_REG_X86_R13 = 21,
	PERF_REG_X86_R14 = 22,
	PERF_REG_X86_R15 = 23,
	PERF_REG_X86_32_MAX = 16,
	PERF_REG_X86_64_MAX = 24,
	PERF_REG_X86_XMM0 = 32,
	PERF_REG_X86_XMM1 = 34,
	PERF_REG_X86_XMM2 = 36,
	PERF_REG_X86_XMM3 = 38,
	PERF_REG_X86_XMM4 = 40,
	PERF_REG_X86_XMM5 = 42,
	PERF_REG_X86_XMM6 = 44,
	PERF_REG_X86_XMM7 = 46,
	PERF_REG_X86_XMM8 = 48,
	PERF_REG_X86_XMM9 = 50,
	PERF_REG_X86_XMM10 = 52,
	PERF_REG_X86_XMM11 = 54,
	PERF_REG_X86_XMM12 = 56,
	PERF_REG_X86_XMM13 = 58,
	PERF_REG_X86_XMM14 = 60,
	PERF_REG_X86_XMM15 = 62,
	PERF_REG_X86_XMM_MAX = 64,
};

struct perf_callchain_entry_ctx {
	struct perf_callchain_entry *entry;
	u32 max_stack;
	u32 nr;
	short int contexts;
	bool contexts_maxed;
};

struct perf_pmu_events_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
};

struct perf_pmu_events_ht_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str_ht;
	const char *event_str_noht;
};

enum {
	NMI_LOCAL = 0,
	NMI_UNKNOWN = 1,
	NMI_SERR = 2,
	NMI_IO_CHECK = 3,
	NMI_MAX = 4,
};

typedef int (*nmi_handler_t)(unsigned int, struct pt_regs *);

struct nmiaction {
	struct list_head list;
	nmi_handler_t handler;
	u64 max_duration;
	long unsigned int flags;
	const char *name;
};

struct gdt_page {
	struct desc_struct gdt[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cyc2ns_data {
	u32 cyc2ns_mul;
	u32 cyc2ns_shift;
	u64 cyc2ns_offset;
};

struct unwind_state {
	struct stack_info stack_info;
	long unsigned int stack_mask;
	struct task_struct *task;
	int graph_idx;
	bool error;
	bool got_irq;
	long unsigned int *bp;
	long unsigned int *orig_sp;
	long unsigned int ip;
	long unsigned int *next_bp;
	struct pt_regs *regs;
};

enum extra_reg_type {
	EXTRA_REG_NONE = 4294967295,
	EXTRA_REG_RSP_0 = 0,
	EXTRA_REG_RSP_1 = 1,
	EXTRA_REG_LBR = 2,
	EXTRA_REG_LDLAT = 3,
	EXTRA_REG_FE = 4,
	EXTRA_REG_MAX = 5,
};

struct event_constraint {
	union {
		long unsigned int idxmsk[1];
		u64 idxmsk64;
	};
	u64 code;
	u64 cmask;
	int weight;
	int overlap;
	int flags;
	unsigned int size;
};

struct amd_nb {
	int nb_id;
	int refcnt;
	struct perf_event *owners[64];
	struct event_constraint event_constraints[64];
};

struct er_account {
	raw_spinlock_t lock;
	u64 config;
	u64 reg;
	atomic_t ref;
};

struct intel_shared_regs {
	struct er_account regs[5];
	int refcnt;
	unsigned int core_id;
};

enum intel_excl_state_type {
	INTEL_EXCL_UNUSED = 0,
	INTEL_EXCL_SHARED = 1,
	INTEL_EXCL_EXCLUSIVE = 2,
};

struct intel_excl_states {
	enum intel_excl_state_type state[64];
	bool sched_started;
};

struct intel_excl_cntrs {
	raw_spinlock_t lock;
	struct intel_excl_states states[2];
	union {
		u16 has_exclusive[2];
		u32 exclusive_present;
	};
	int refcnt;
	unsigned int core_id;
};

enum {
	X86_PERF_KFREE_SHARED = 0,
	X86_PERF_KFREE_EXCL = 1,
	X86_PERF_KFREE_MAX = 2,
};

struct x86_perf_task_context;

struct cpu_hw_events {
	struct perf_event *events[64];
	long unsigned int active_mask[1];
	long unsigned int running[1];
	int enabled;
	int n_events;
	int n_added;
	int n_txn;
	int n_txn_metric;
	int assign[64];
	u64 tags[64];
	struct perf_event *event_list[64];
	struct event_constraint *event_constraint[64];
	int n_excl;
	unsigned int txn_flags;
	int is_fake;
	struct debug_store *ds;
	void *ds_pebs_vaddr;
	void *ds_bts_vaddr;
	u64 pebs_enabled;
	int n_pebs;
	int n_large_pebs;
	int n_pebs_via_pt;
	int pebs_output;
	u64 pebs_data_cfg;
	u64 active_pebs_data_cfg;
	int pebs_record_size;
	int lbr_users;
	int lbr_pebs_users;
	struct perf_branch_stack lbr_stack;
	struct perf_branch_entry lbr_entries[32];
	struct er_account *lbr_sel;
	u64 br_sel;
	struct x86_perf_task_context *last_task_ctx;
	int last_log_id;
	int lbr_select;
	u64 intel_ctrl_guest_mask;
	u64 intel_ctrl_host_mask;
	struct perf_guest_switch_msr guest_switch_msrs[64];
	u64 intel_cp_status;
	struct intel_shared_regs *shared_regs;
	struct event_constraint *constraint_list;
	struct intel_excl_cntrs *excl_cntrs;
	int excl_thread_id;
	u64 tfa_shadow;
	int n_metric;
	struct amd_nb *amd_nb;
	u64 perf_ctr_virt_mask;
	int n_pair;
	void *kfree_on_online[2];
};

struct x86_perf_task_context {
	u64 lbr_from[32];
	u64 lbr_to[32];
	u64 lbr_info[32];
	u64 lbr_sel;
	int tos;
	int valid_lbrs;
	int lbr_callstack_users;
	int lbr_stack_state;
	int log_id;
};

struct extra_reg {
	unsigned int event;
	unsigned int msr;
	u64 config_mask;
	u64 valid_mask;
	int idx;
	bool extra_msr_access;
};

union perf_capabilities {
	struct {
		u64 lbr_format: 6;
		u64 pebs_trap: 1;
		u64 pebs_arch_reg: 1;
		u64 pebs_format: 4;
		u64 smm_freeze: 1;
		u64 full_width_write: 1;
		u64 pebs_baseline: 1;
		u64 perf_metrics: 1;
		u64 pebs_output_pt_available: 1;
	};
	u64 capabilities;
};

struct x86_pmu_quirk {
	struct x86_pmu_quirk *next;
	void (*func)();
};

enum {
	x86_lbr_exclusive_lbr = 0,
	x86_lbr_exclusive_bts = 1,
	x86_lbr_exclusive_pt = 2,
	x86_lbr_exclusive_max = 3,
};

struct x86_pmu {
	const char *name;
	int version;
	int (*handle_irq)(struct pt_regs *);
	void (*disable_all)();
	void (*enable_all)(int);
	void (*enable)(struct perf_event *);
	void (*disable)(struct perf_event *);
	void (*add)(struct perf_event *);
	void (*del)(struct perf_event *);
	void (*read)(struct perf_event *);
	int (*hw_config)(struct perf_event *);
	int (*schedule_events)(struct cpu_hw_events *, int, int *);
	unsigned int eventsel;
	unsigned int perfctr;
	int (*addr_offset)(int, bool);
	int (*rdpmc_index)(int);
	u64 (*event_map)(int);
	int max_events;
	int num_counters;
	int num_counters_fixed;
	int cntval_bits;
	u64 cntval_mask;
	union {
		long unsigned int events_maskl;
		long unsigned int events_mask[1];
	};
	int events_mask_len;
	int apic;
	u64 max_period;
	struct event_constraint * (*get_event_constraints)(struct cpu_hw_events *, int, struct perf_event *);
	void (*put_event_constraints)(struct cpu_hw_events *, struct perf_event *);
	void (*start_scheduling)(struct cpu_hw_events *);
	void (*commit_scheduling)(struct cpu_hw_events *, int, int);
	void (*stop_scheduling)(struct cpu_hw_events *);
	struct event_constraint *event_constraints;
	struct x86_pmu_quirk *quirks;
	int perfctr_second_write;
	u64 (*limit_period)(struct perf_event *, u64);
	unsigned int late_ack: 1;
	unsigned int counter_freezing: 1;
	int attr_rdpmc_broken;
	int attr_rdpmc;
	struct attribute **format_attrs;
	ssize_t (*events_sysfs_show)(char *, u64);
	const struct attribute_group **attr_update;
	long unsigned int attr_freeze_on_smi;
	int (*cpu_prepare)(int);
	void (*cpu_starting)(int);
	void (*cpu_dying)(int);
	void (*cpu_dead)(int);
	void (*check_microcode)();
	void (*sched_task)(struct perf_event_context *, bool);
	u64 intel_ctrl;
	union perf_capabilities intel_cap;
	unsigned int bts: 1;
	unsigned int bts_active: 1;
	unsigned int pebs: 1;
	unsigned int pebs_active: 1;
	unsigned int pebs_broken: 1;
	unsigned int pebs_prec_dist: 1;
	unsigned int pebs_no_tlb: 1;
	unsigned int pebs_no_isolation: 1;
	int pebs_record_size;
	int pebs_buffer_size;
	int max_pebs_events;
	void (*drain_pebs)(struct pt_regs *);
	struct event_constraint *pebs_constraints;
	void (*pebs_aliases)(struct perf_event *);
	long unsigned int large_pebs_flags;
	u64 rtm_abort_event;
	unsigned int lbr_tos;
	unsigned int lbr_from;
	unsigned int lbr_to;
	unsigned int lbr_nr;
	u64 lbr_sel_mask;
	const int *lbr_sel_map;
	bool lbr_double_abort;
	bool lbr_pt_coexist;
	atomic_t lbr_exclusive[3];
	u64 (*update_topdown_event)(struct perf_event *);
	int (*set_topdown_event_period)(struct perf_event *);
	unsigned int amd_nb_constraints: 1;
	u64 perf_ctr_pair_en;
	struct extra_reg *extra_regs;
	unsigned int flags;
	struct perf_guest_switch_msr * (*guest_get_msrs)(int *);
	int (*check_period)(struct perf_event *, u64);
	int (*aux_output_match)(struct perf_event *);
};

struct sched_state {
	int weight;
	int event;
	int counter;
	int unassigned;
	int nr_gp;
	u64 used;
};

struct perf_sched {
	int max_weight;
	int max_events;
	int max_gp;
	int saved_states;
	struct event_constraint **constraints;
	struct sched_state state;
	struct sched_state saved[2];
};

typedef int pao_T__;

typedef int pto_T_____2;

typedef unsigned int pao_T_____2;

enum migratetype {
	MIGRATE_UNMOVABLE = 0,
	MIGRATE_MOVABLE = 1,
	MIGRATE_RECLAIMABLE = 2,
	MIGRATE_PCPTYPES = 3,
	MIGRATE_HIGHATOMIC = 3,
	MIGRATE_ISOLATE = 4,
	MIGRATE_TYPES = 5,
};

enum zone_watermarks {
	WMARK_MIN = 0,
	WMARK_LOW = 1,
	WMARK_HIGH = 2,
	NR_WMARK = 3,
};

enum {
	ZONELIST_FALLBACK = 0,
	ZONELIST_NOFALLBACK = 1,
	MAX_ZONELISTS = 2,
};

struct perf_msr {
	u64 msr;
	struct attribute_group *grp;
	bool (*test)(int, void *);
	bool no_check;
};

typedef void (*exitcall_t)();

enum hrtimer_mode {
	HRTIMER_MODE_ABS = 0,
	HRTIMER_MODE_REL = 1,
	HRTIMER_MODE_PINNED = 2,
	HRTIMER_MODE_SOFT = 4,
	HRTIMER_MODE_HARD = 8,
	HRTIMER_MODE_ABS_PINNED = 2,
	HRTIMER_MODE_REL_PINNED = 3,
	HRTIMER_MODE_ABS_SOFT = 4,
	HRTIMER_MODE_REL_SOFT = 5,
	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
	HRTIMER_MODE_REL_PINNED_SOFT = 7,
	HRTIMER_MODE_ABS_HARD = 8,
	HRTIMER_MODE_REL_HARD = 9,
	HRTIMER_MODE_ABS_PINNED_HARD = 10,
	HRTIMER_MODE_REL_PINNED_HARD = 11,
};

struct x86_cpu_id {
	__u16 vendor;
	__u16 family;
	__u16 model;
	__u16 feature;
	kernel_ulong_t driver_data;
	__u16 steppings;
};

enum perf_rapl_events {
	PERF_RAPL_PP0 = 0,
	PERF_RAPL_PKG = 1,
	PERF_RAPL_RAM = 2,
	PERF_RAPL_PP1 = 3,
	PERF_RAPL_PSYS = 4,
	PERF_RAPL_MAX = 5,
	NR_RAPL_DOMAINS = 5,
};

struct rapl_pmu {
	raw_spinlock_t lock;
	int n_active;
	int cpu;
	struct list_head active_list;
	struct pmu *pmu;
	ktime_t timer_interval;
	struct hrtimer hrtimer;
};

struct rapl_pmus {
	struct pmu pmu;
	unsigned int maxdie;
	struct rapl_pmu *pmus[0];
};

struct rapl_model {
	long unsigned int events;
	bool apply_quirk;
};

struct amd_uncore {
	int id;
	int refcnt;
	int cpu;
	int num_counters;
	int rdpmc_base;
	u32 msr_base;
	cpumask_t *active_mask;
	struct pmu *pmu;
	struct perf_event *events[6];
	struct hlist_node node;
};

typedef u64 uint64_t;

typedef int pci_power_t;

typedef unsigned int pci_channel_state_t;

typedef short unsigned int pci_dev_flags_t;

struct pci_bus;

struct pci_slot;

struct aer_stats;

struct pci_driver;

struct pcie_link_state;

struct pci_vpd;

struct pci_sriov;

struct pci_dev {
	struct list_head bus_list;
	struct pci_bus *bus;
	struct pci_bus *subordinate;
	void *sysdata;
	struct proc_dir_entry *procent;
	struct pci_slot *slot;
	unsigned int devfn;
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int subsystem_vendor;
	short unsigned int subsystem_device;
	unsigned int class;
	u8 revision;
	u8 hdr_type;
	u16 aer_cap;
	struct aer_stats *aer_stats;
	u8 pcie_cap;
	u8 msi_cap;
	u8 msix_cap;
	u8 pcie_mpss: 3;
	u8 rom_base_reg;
	u8 pin;
	u16 pcie_flags_reg;
	long unsigned int *dma_alias_mask;
	struct pci_driver *driver;
	u64 dma_mask;
	struct device_dma_parameters dma_parms;
	pci_power_t current_state;
	unsigned int imm_ready: 1;
	u8 pm_cap;
	unsigned int pme_support: 5;
	unsigned int pme_poll: 1;
	unsigned int d1_support: 1;
	unsigned int d2_support: 1;
	unsigned int no_d1d2: 1;
	unsigned int no_d3cold: 1;
	unsigned int bridge_d3: 1;
	unsigned int d3cold_allowed: 1;
	unsigned int mmio_always_on: 1;
	unsigned int wakeup_prepared: 1;
	unsigned int runtime_d3cold: 1;
	unsigned int skip_bus_pm: 1;
	unsigned int ignore_hotplug: 1;
	unsigned int hotplug_user_indicators: 1;
	unsigned int clear_retrain_link: 1;
	unsigned int d3_delay;
	unsigned int d3cold_delay;
	struct pcie_link_state *link_state;
	unsigned int ltr_path: 1;
	unsigned int eetlp_prefix_path: 1;
	pci_channel_state_t error_state;
	struct device dev;
	int cfg_size;
	unsigned int irq;
	struct resource resource[17];
	bool match_driver;
	unsigned int transparent: 1;
	unsigned int io_window: 1;
	unsigned int pref_window: 1;
	unsigned int pref_64_window: 1;
	unsigned int multifunction: 1;
	unsigned int is_busmaster: 1;
	unsigned int no_msi: 1;
	unsigned int no_64bit_msi: 1;
	unsigned int block_cfg_access: 1;
	unsigned int broken_parity_status: 1;
	unsigned int irq_reroute_variant: 2;
	unsigned int msi_enabled: 1;
	unsigned int msix_enabled: 1;
	unsigned int ari_enabled: 1;
	unsigned int ats_enabled: 1;
	unsigned int pasid_enabled: 1;
	unsigned int pri_enabled: 1;
	unsigned int is_managed: 1;
	unsigned int needs_freset: 1;
	unsigned int state_saved: 1;
	unsigned int is_physfn: 1;
	unsigned int is_virtfn: 1;
	unsigned int reset_fn: 1;
	unsigned int is_hotplug_bridge: 1;
	unsigned int shpc_managed: 1;
	unsigned int is_thunderbolt: 1;
	unsigned int untrusted: 1;
	unsigned int __aer_firmware_first_valid: 1;
	unsigned int __aer_firmware_first: 1;
	unsigned int broken_intx_masking: 1;
	unsigned int io_window_1k: 1;
	unsigned int irq_managed: 1;
	unsigned int non_compliant_bars: 1;
	unsigned int is_probed: 1;
	unsigned int link_active_reporting: 1;
	unsigned int no_vf_scan: 1;
	unsigned int no_command_memory: 1;
	pci_dev_flags_t dev_flags;
	atomic_t enable_cnt;
	u32 saved_config_space[16];
	struct hlist_head saved_cap_space;
	struct bin_attribute *rom_attr;
	int rom_attr_enabled;
	struct bin_attribute *res_attr[17];
	struct bin_attribute *res_attr_wc[17];
	unsigned int broken_cmd_compl: 1;
	const struct attribute_group **msi_irq_groups;
	struct pci_vpd *vpd;
	union {
		struct pci_sriov *sriov;
		struct pci_dev *physfn;
	};
	u16 ats_cap;
	u8 ats_stu;
	atomic_t ats_ref_cnt;
	u32 pri_reqs_alloc;
	u16 pasid_features;
	phys_addr_t rom;
	size_t romlen;
	char *driver_override;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long unsigned int priv_flags;
};

struct pci_device_id {
	__u32 vendor;
	__u32 device;
	__u32 subvendor;
	__u32 subdevice;
	__u32 class;
	__u32 class_mask;
	kernel_ulong_t driver_data;
};

struct hotplug_slot;

struct pci_slot {
	struct pci_bus *bus;
	struct list_head list;
	struct hotplug_slot *hotplug;
	unsigned char number;
	struct kobject kobj;
};

typedef short unsigned int pci_bus_flags_t;

struct pci_ops;

struct msi_controller;

struct pci_bus {
	struct list_head node;
	struct pci_bus *parent;
	struct list_head children;
	struct list_head devices;
	struct pci_dev *self;
	struct list_head slots;
	struct resource *resource[4];
	struct list_head resources;
	struct resource busn_res;
	struct pci_ops *ops;
	struct msi_controller *msi;
	void *sysdata;
	struct proc_dir_entry *procdir;
	unsigned char number;
	unsigned char primary;
	unsigned char max_bus_speed;
	unsigned char cur_bus_speed;
	char name[48];
	short unsigned int bridge_ctl;
	pci_bus_flags_t bus_flags;
	struct device *bridge;
	struct device dev;
	struct bin_attribute *legacy_io;
	struct bin_attribute *legacy_mem;
	unsigned int is_added: 1;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

enum {
	PCI_STD_RESOURCES = 0,
	PCI_STD_RESOURCE_END = 5,
	PCI_ROM_RESOURCE = 6,
	PCI_IOV_RESOURCES = 7,
	PCI_IOV_RESOURCE_END = 12,
	PCI_BRIDGE_RESOURCES = 13,
	PCI_BRIDGE_RESOURCE_END = 16,
	PCI_NUM_RESOURCES = 17,
	DEVICE_COUNT_RESOURCE = 17,
};

enum pci_channel_state {
	pci_channel_io_normal = 1,
	pci_channel_io_frozen = 2,
	pci_channel_io_perm_failure = 3,
};

typedef unsigned int pcie_reset_state_t;

struct pci_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct pci_error_handlers;

struct pci_driver {
	struct list_head node;
	const char *name;
	const struct pci_device_id *id_table;
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
	int (*suspend)(struct pci_dev *, pm_message_t);
	int (*suspend_late)(struct pci_dev *, pm_message_t);
	int (*resume_early)(struct pci_dev *);
	int (*resume)(struct pci_dev *);
	void (*shutdown)(struct pci_dev *);
	int (*sriov_configure)(struct pci_dev *, int);
	const struct pci_error_handlers *err_handler;
	const struct attribute_group **groups;
	struct device_driver driver;
	struct pci_dynids dynids;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

struct pci_ops {
	int (*add_bus)(struct pci_bus *);
	void (*remove_bus)(struct pci_bus *);
	void * (*map_bus)(struct pci_bus *, unsigned int, int);
	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
};

typedef unsigned int pci_ers_result_t;

struct pci_error_handlers {
	pci_ers_result_t (*error_detected)(struct pci_dev *, enum pci_channel_state);
	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
	pci_ers_result_t (*slot_reset)(struct pci_dev *);
	void (*reset_prepare)(struct pci_dev *);
	void (*reset_done)(struct pci_dev *);
	void (*resume)(struct pci_dev *);
};

struct syscore_ops {
	struct list_head node;
	int (*suspend)();
	void (*resume)();
	void (*shutdown)();
};

enum ibs_states {
	IBS_ENABLED = 0,
	IBS_STARTED = 1,
	IBS_STOPPING = 2,
	IBS_STOPPED = 3,
	IBS_MAX_STATES = 4,
};

struct cpu_perf_ibs {
	struct perf_event *event;
	long unsigned int state[1];
};

struct perf_ibs {
	struct pmu pmu;
	unsigned int msr;
	u64 config_mask;
	u64 cnt_mask;
	u64 enable_mask;
	u64 valid_mask;
	u64 max_period;
	long unsigned int offset_mask[1];
	int offset_max;
	unsigned int fetch_count_reset_broken: 1;
	struct cpu_perf_ibs *pcpu;
	struct attribute **format_attrs;
	struct attribute_group format_group;
	const struct attribute_group *attr_groups[2];
	u64 (*get_count)(u64);
};

struct perf_ibs_data {
	u32 size;
	union {
		u32 data[0];
		u32 caps;
	};
	u64 regs[8];
};

struct amd_iommu;

struct perf_amd_iommu {
	struct list_head list;
	struct pmu pmu;
	struct amd_iommu *iommu;
	char name[16];
	u8 max_banks;
	u8 max_counters;
	u64 cntr_assign_mask;
	raw_spinlock_t lock;
};

struct amd_iommu_event_desc {
	struct device_attribute attr;
	const char *event;
};

enum perf_msr_id {
	PERF_MSR_TSC = 0,
	PERF_MSR_APERF = 1,
	PERF_MSR_MPERF = 2,
	PERF_MSR_PPERF = 3,
	PERF_MSR_SMI = 4,
	PERF_MSR_PTSC = 5,
	PERF_MSR_IRPERF = 6,
	PERF_MSR_THERM = 7,
	PERF_MSR_EVENT_MAX = 8,
};

struct x86_cpu_desc {
	u8 x86_family;
	u8 x86_vendor;
	u8 x86_model;
	u8 x86_stepping;
	u32 x86_microcode_rev;
};

union cpuid10_eax {
	struct {
		unsigned int version_id: 8;
		unsigned int num_counters: 8;
		unsigned int bit_width: 8;
		unsigned int mask_length: 8;
	} split;
	unsigned int full;
};

union cpuid10_ebx {
	struct {
		unsigned int no_unhalted_core_cycles: 1;
		unsigned int no_instructions_retired: 1;
		unsigned int no_unhalted_reference_cycles: 1;
		unsigned int no_llc_reference: 1;
		unsigned int no_llc_misses: 1;
		unsigned int no_branch_instruction_retired: 1;
		unsigned int no_branch_misses_retired: 1;
	} split;
	unsigned int full;
};

union cpuid10_edx {
	struct {
		unsigned int num_counters_fixed: 5;
		unsigned int bit_width_fixed: 8;
		unsigned int reserved: 19;
	} split;
	unsigned int full;
};

union x86_pmu_config {
	struct {
		u64 event: 8;
		u64 umask: 8;
		u64 usr: 1;
		u64 os: 1;
		u64 edge: 1;
		u64 pc: 1;
		u64 interrupt: 1;
		u64 __reserved1: 1;
		u64 en: 1;
		u64 inv: 1;
		u64 cmask: 8;
		u64 event2: 4;
		u64 __reserved2: 4;
		u64 go: 1;
		u64 ho: 1;
	} bits;
	u64 value;
};

enum pageflags {
	PG_locked = 0,
	PG_referenced = 1,
	PG_uptodate = 2,
	PG_dirty = 3,
	PG_lru = 4,
	PG_active = 5,
	PG_workingset = 6,
	PG_waiters = 7,
	PG_error = 8,
	PG_slab = 9,
	PG_owner_priv_1 = 10,
	PG_arch_1 = 11,
	PG_reserved = 12,
	PG_private = 13,
	PG_private_2 = 14,
	PG_writeback = 15,
	PG_head = 16,
	PG_mappedtodisk = 17,
	PG_reclaim = 18,
	PG_swapbacked = 19,
	PG_unevictable = 20,
	PG_mlocked = 21,
	PG_uncached = 22,
	PG_hwpoison = 23,
	__NR_PAGEFLAGS = 24,
	PG_checked = 10,
	PG_swapcache = 10,
	PG_fscache = 14,
	PG_pinned = 10,
	PG_savepinned = 3,
	PG_foreign = 10,
	PG_xen_remapped = 10,
	PG_slob_free = 13,
	PG_double_map = 14,
	PG_isolated = 18,
};

struct perf_output_handle {
	struct perf_event *event;
	struct ring_buffer *rb;
	long unsigned int wakeup;
	long unsigned int size;
	u64 aux_flags;
	union {
		void *addr;
		long unsigned int head;
	};
	int page;
};

struct bts_ctx {
	struct perf_output_handle handle;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct debug_store ds_back;
	int state;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	BTS_STATE_STOPPED = 0,
	BTS_STATE_INACTIVE = 1,
	BTS_STATE_ACTIVE = 2,
};

struct bts_phys {
	struct page *page;
	long unsigned int size;
	long unsigned int offset;
	long unsigned int displacement;
};

struct bts_buffer {
	size_t real_size;
	unsigned int nr_pages;
	unsigned int nr_bufs;
	unsigned int cur_buf;
	bool snapshot;
	local_t data_size;
	local_t head;
	long unsigned int end;
	void **data_pages;
	struct bts_phys buf[0];
};

struct x86_hw_tss {
	u32 reserved1;
	u64 sp0;
	u64 sp1;
	u64 sp2;
	u64 reserved2;
	u64 ist[7];
	u32 reserved3;
	u32 reserved4;
	u16 reserved5;
	u16 io_bitmap_base;
} __attribute__((packed));

struct entry_stack {
	char stack[4096];
};

struct entry_stack_page {
	struct entry_stack stack;
};

struct tss_struct {
	struct x86_hw_tss x86_tss;
	long unsigned int io_bitmap[1025];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct debug_store_buffers {
	char bts_buffer[65536];
	char pebs_buffer[65536];
};

struct cea_exception_stacks {
	char DF_stack_guard[4096];
	char DF_stack[4096];
	char NMI_stack_guard[4096];
	char NMI_stack[4096];
	char DB2_stack_guard[4096];
	char DB2_stack[4096];
	char DB1_stack_guard[4096];
	char DB1_stack[4096];
	char DB_stack_guard[4096];
	char DB_stack[4096];
	char MCE_stack_guard[4096];
	char MCE_stack[4096];
	char IST_top_guard[4096];
};

struct cpu_entry_area {
	char gdt[4096];
	struct entry_stack_page entry_stack_page;
	struct tss_struct tss;
	struct cea_exception_stacks estacks;
	struct debug_store cpu_debug_store;
	struct debug_store_buffers cpu_debug_buffers;
};

struct pebs_basic {
	u64 format_size;
	u64 ip;
	u64 applicable_counters;
	u64 tsc;
};

struct pebs_meminfo {
	u64 address;
	u64 aux;
	u64 latency;
	u64 tsx_tuning;
};

struct pebs_gprs {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 cx;
	u64 dx;
	u64 bx;
	u64 sp;
	u64 bp;
	u64 si;
	u64 di;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
};

struct pebs_xmm {
	u64 xmm[32];
};

struct pebs_lbr_entry {
	u64 from;
	u64 to;
	u64 info;
};

struct pebs_lbr {
	struct pebs_lbr_entry lbr[0];
};

struct x86_perf_regs {
	struct pt_regs regs;
	u64 *xmm_regs;
};

typedef unsigned int insn_attr_t;

typedef unsigned char insn_byte_t;

typedef int insn_value_t;

struct insn_field {
	union {
		insn_value_t value;
		insn_byte_t bytes[4];
	};
	unsigned char got;
	unsigned char nbytes;
};

struct insn {
	struct insn_field prefixes;
	struct insn_field rex_prefix;
	struct insn_field vex_prefix;
	struct insn_field opcode;
	struct insn_field modrm;
	struct insn_field sib;
	struct insn_field displacement;
	union {
		struct insn_field immediate;
		struct insn_field moffset1;
		struct insn_field immediate1;
	};
	union {
		struct insn_field moffset2;
		struct insn_field immediate2;
	};
	insn_attr_t attr;
	unsigned char opnd_bytes;
	unsigned char addr_bytes;
	unsigned char length;
	unsigned char x86_64;
	const insn_byte_t *kaddr;
	const insn_byte_t *end_kaddr;
	const insn_byte_t *next_byte;
};

enum {
	PERF_TXN_ELISION = 1,
	PERF_TXN_TRANSACTION = 2,
	PERF_TXN_SYNC = 4,
	PERF_TXN_ASYNC = 8,
	PERF_TXN_RETRY = 16,
	PERF_TXN_CONFLICT = 32,
	PERF_TXN_CAPACITY_WRITE = 64,
	PERF_TXN_CAPACITY_READ = 128,
	PERF_TXN_MAX = 256,
	PERF_TXN_ABORT_MASK = 0,
	PERF_TXN_ABORT_SHIFT = 32,
};

struct perf_event_header {
	__u32 type;
	__u16 misc;
	__u16 size;
};

union intel_x86_pebs_dse {
	u64 val;
	struct {
		unsigned int ld_dse: 4;
		unsigned int ld_stlb_miss: 1;
		unsigned int ld_locked: 1;
		unsigned int ld_reserved: 26;
	};
	struct {
		unsigned int st_l1d_hit: 1;
		unsigned int st_reserved1: 3;
		unsigned int st_stlb_miss: 1;
		unsigned int st_locked: 1;
		unsigned int st_reserved2: 26;
	};
};

struct pebs_record_core {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
};

struct pebs_record_nhm {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u64 status;
	u64 dla;
	u64 dse;
	u64 lat;
};

union hsw_tsx_tuning {
	struct {
		u32 cycles_last_block: 32;
		u32 hle_abort: 1;
		u32 rtm_abort: 1;
		u32 instruction_abort: 1;
		u32 non_instruction_abort: 1;
		u32 retry: 1;
		u32 data_conflict: 1;
		u32 capacity_writes: 1;
		u32 capacity_reads: 1;
	};
	u64 value;
};

struct pebs_record_skl {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u64 status;
	u64 dla;
	u64 dse;
	u64 lat;
	u64 real_ip;
	u64 tsx_tuning;
	u64 tsc;
};

struct bts_record {
	u64 from;
	u64 to;
	u64 flags;
};

enum {
	PERF_BR_UNKNOWN = 0,
	PERF_BR_COND = 1,
	PERF_BR_UNCOND = 2,
	PERF_BR_IND = 3,
	PERF_BR_CALL = 4,
	PERF_BR_IND_CALL = 5,
	PERF_BR_RET = 6,
	PERF_BR_SYSCALL = 7,
	PERF_BR_SYSRET = 8,
	PERF_BR_COND_CALL = 9,
	PERF_BR_COND_RET = 10,
	PERF_BR_MAX = 11,
};

struct x86_pmu_lbr {
	unsigned int nr;
	unsigned int from;
	unsigned int to;
	unsigned int info;
};

enum {
	LBR_FORMAT_32 = 0,
	LBR_FORMAT_LIP = 1,
	LBR_FORMAT_EIP = 2,
	LBR_FORMAT_EIP_FLAGS = 3,
	LBR_FORMAT_EIP_FLAGS2 = 4,
	LBR_FORMAT_INFO = 5,
	LBR_FORMAT_TIME = 6,
	LBR_FORMAT_MAX_KNOWN = 6,
};

enum {
	X86_BR_NONE = 0,
	X86_BR_USER = 1,
	X86_BR_KERNEL = 2,
	X86_BR_CALL = 4,
	X86_BR_RET = 8,
	X86_BR_SYSCALL = 16,
	X86_BR_SYSRET = 32,
	X86_BR_INT = 64,
	X86_BR_IRET = 128,
	X86_BR_JCC = 256,
	X86_BR_JMP = 512,
	X86_BR_IRQ = 1024,
	X86_BR_IND_CALL = 2048,
	X86_BR_ABORT = 4096,
	X86_BR_IN_TX = 8192,
	X86_BR_NO_TX = 16384,
	X86_BR_ZERO_CALL = 32768,
	X86_BR_CALL_STACK = 65536,
	X86_BR_IND_JMP = 131072,
	X86_BR_TYPE_SAVE = 262144,
};

enum {
	LBR_NONE = 0,
	LBR_VALID = 1,
};

enum P4_EVENTS {
	P4_EVENT_TC_DELIVER_MODE = 0,
	P4_EVENT_BPU_FETCH_REQUEST = 1,
	P4_EVENT_ITLB_REFERENCE = 2,
	P4_EVENT_MEMORY_CANCEL = 3,
	P4_EVENT_MEMORY_COMPLETE = 4,
	P4_EVENT_LOAD_PORT_REPLAY = 5,
	P4_EVENT_STORE_PORT_REPLAY = 6,
	P4_EVENT_MOB_LOAD_REPLAY = 7,
	P4_EVENT_PAGE_WALK_TYPE = 8,
	P4_EVENT_BSQ_CACHE_REFERENCE = 9,
	P4_EVENT_IOQ_ALLOCATION = 10,
	P4_EVENT_IOQ_ACTIVE_ENTRIES = 11,
	P4_EVENT_FSB_DATA_ACTIVITY = 12,
	P4_EVENT_BSQ_ALLOCATION = 13,
	P4_EVENT_BSQ_ACTIVE_ENTRIES = 14,
	P4_EVENT_SSE_INPUT_ASSIST = 15,
	P4_EVENT_PACKED_SP_UOP = 16,
	P4_EVENT_PACKED_DP_UOP = 17,
	P4_EVENT_SCALAR_SP_UOP = 18,
	P4_EVENT_SCALAR_DP_UOP = 19,
	P4_EVENT_64BIT_MMX_UOP = 20,
	P4_EVENT_128BIT_MMX_UOP = 21,
	P4_EVENT_X87_FP_UOP = 22,
	P4_EVENT_TC_MISC = 23,
	P4_EVENT_GLOBAL_POWER_EVENTS = 24,
	P4_EVENT_TC_MS_XFER = 25,
	P4_EVENT_UOP_QUEUE_WRITES = 26,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE = 27,
	P4_EVENT_RETIRED_BRANCH_TYPE = 28,
	P4_EVENT_RESOURCE_STALL = 29,
	P4_EVENT_WC_BUFFER = 30,
	P4_EVENT_B2B_CYCLES = 31,
	P4_EVENT_BNR = 32,
	P4_EVENT_SNOOP = 33,
	P4_EVENT_RESPONSE = 34,
	P4_EVENT_FRONT_END_EVENT = 35,
	P4_EVENT_EXECUTION_EVENT = 36,
	P4_EVENT_REPLAY_EVENT = 37,
	P4_EVENT_INSTR_RETIRED = 38,
	P4_EVENT_UOPS_RETIRED = 39,
	P4_EVENT_UOP_TYPE = 40,
	P4_EVENT_BRANCH_RETIRED = 41,
	P4_EVENT_MISPRED_BRANCH_RETIRED = 42,
	P4_EVENT_X87_ASSIST = 43,
	P4_EVENT_MACHINE_CLEAR = 44,
	P4_EVENT_INSTR_COMPLETED = 45,
};

enum P4_EVENT_OPCODES {
	P4_EVENT_TC_DELIVER_MODE_OPCODE = 257,
	P4_EVENT_BPU_FETCH_REQUEST_OPCODE = 768,
	P4_EVENT_ITLB_REFERENCE_OPCODE = 6147,
	P4_EVENT_MEMORY_CANCEL_OPCODE = 517,
	P4_EVENT_MEMORY_COMPLETE_OPCODE = 2050,
	P4_EVENT_LOAD_PORT_REPLAY_OPCODE = 1026,
	P4_EVENT_STORE_PORT_REPLAY_OPCODE = 1282,
	P4_EVENT_MOB_LOAD_REPLAY_OPCODE = 770,
	P4_EVENT_PAGE_WALK_TYPE_OPCODE = 260,
	P4_EVENT_BSQ_CACHE_REFERENCE_OPCODE = 3079,
	P4_EVENT_IOQ_ALLOCATION_OPCODE = 774,
	P4_EVENT_IOQ_ACTIVE_ENTRIES_OPCODE = 6662,
	P4_EVENT_FSB_DATA_ACTIVITY_OPCODE = 5894,
	P4_EVENT_BSQ_ALLOCATION_OPCODE = 1287,
	P4_EVENT_BSQ_ACTIVE_ENTRIES_OPCODE = 1543,
	P4_EVENT_SSE_INPUT_ASSIST_OPCODE = 13313,
	P4_EVENT_PACKED_SP_UOP_OPCODE = 2049,
	P4_EVENT_PACKED_DP_UOP_OPCODE = 3073,
	P4_EVENT_SCALAR_SP_UOP_OPCODE = 2561,
	P4_EVENT_SCALAR_DP_UOP_OPCODE = 3585,
	P4_EVENT_64BIT_MMX_UOP_OPCODE = 513,
	P4_EVENT_128BIT_MMX_UOP_OPCODE = 6657,
	P4_EVENT_X87_FP_UOP_OPCODE = 1025,
	P4_EVENT_TC_MISC_OPCODE = 1537,
	P4_EVENT_GLOBAL_POWER_EVENTS_OPCODE = 4870,
	P4_EVENT_TC_MS_XFER_OPCODE = 1280,
	P4_EVENT_UOP_QUEUE_WRITES_OPCODE = 2304,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE_OPCODE = 1282,
	P4_EVENT_RETIRED_BRANCH_TYPE_OPCODE = 1026,
	P4_EVENT_RESOURCE_STALL_OPCODE = 257,
	P4_EVENT_WC_BUFFER_OPCODE = 1285,
	P4_EVENT_B2B_CYCLES_OPCODE = 5635,
	P4_EVENT_BNR_OPCODE = 2051,
	P4_EVENT_SNOOP_OPCODE = 1539,
	P4_EVENT_RESPONSE_OPCODE = 1027,
	P4_EVENT_FRONT_END_EVENT_OPCODE = 2053,
	P4_EVENT_EXECUTION_EVENT_OPCODE = 3077,
	P4_EVENT_REPLAY_EVENT_OPCODE = 2309,
	P4_EVENT_INSTR_RETIRED_OPCODE = 516,
	P4_EVENT_UOPS_RETIRED_OPCODE = 260,
	P4_EVENT_UOP_TYPE_OPCODE = 514,
	P4_EVENT_BRANCH_RETIRED_OPCODE = 1541,
	P4_EVENT_MISPRED_BRANCH_RETIRED_OPCODE = 772,
	P4_EVENT_X87_ASSIST_OPCODE = 773,
	P4_EVENT_MACHINE_CLEAR_OPCODE = 517,
	P4_EVENT_INSTR_COMPLETED_OPCODE = 1796,
};

enum P4_ESCR_EMASKS {
	P4_EVENT_TC_DELIVER_MODE__DD = 512,
	P4_EVENT_TC_DELIVER_MODE__DB = 1024,
	P4_EVENT_TC_DELIVER_MODE__DI = 2048,
	P4_EVENT_TC_DELIVER_MODE__BD = 4096,
	P4_EVENT_TC_DELIVER_MODE__BB = 8192,
	P4_EVENT_TC_DELIVER_MODE__BI = 16384,
	P4_EVENT_TC_DELIVER_MODE__ID = 32768,
	P4_EVENT_BPU_FETCH_REQUEST__TCMISS = 512,
	P4_EVENT_ITLB_REFERENCE__HIT = 512,
	P4_EVENT_ITLB_REFERENCE__MISS = 1024,
	P4_EVENT_ITLB_REFERENCE__HIT_UK = 2048,
	P4_EVENT_MEMORY_CANCEL__ST_RB_FULL = 2048,
	P4_EVENT_MEMORY_CANCEL__64K_CONF = 4096,
	P4_EVENT_MEMORY_COMPLETE__LSC = 512,
	P4_EVENT_MEMORY_COMPLETE__SSC = 1024,
	P4_EVENT_LOAD_PORT_REPLAY__SPLIT_LD = 1024,
	P4_EVENT_STORE_PORT_REPLAY__SPLIT_ST = 1024,
	P4_EVENT_MOB_LOAD_REPLAY__NO_STA = 1024,
	P4_EVENT_MOB_LOAD_REPLAY__NO_STD = 4096,
	P4_EVENT_MOB_LOAD_REPLAY__PARTIAL_DATA = 8192,
	P4_EVENT_MOB_LOAD_REPLAY__UNALGN_ADDR = 16384,
	P4_EVENT_PAGE_WALK_TYPE__DTMISS = 512,
	P4_EVENT_PAGE_WALK_TYPE__ITMISS = 1024,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITS = 512,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITE = 1024,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITM = 2048,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITS = 4096,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITE = 8192,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITM = 16384,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_MISS = 131072,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_MISS = 262144,
	P4_EVENT_BSQ_CACHE_REFERENCE__WR_2ndL_MISS = 524288,
	P4_EVENT_IOQ_ALLOCATION__DEFAULT = 512,
	P4_EVENT_IOQ_ALLOCATION__ALL_READ = 16384,
	P4_EVENT_IOQ_ALLOCATION__ALL_WRITE = 32768,
	P4_EVENT_IOQ_ALLOCATION__MEM_UC = 65536,
	P4_EVENT_IOQ_ALLOCATION__MEM_WC = 131072,
	P4_EVENT_IOQ_ALLOCATION__MEM_WT = 262144,
	P4_EVENT_IOQ_ALLOCATION__MEM_WP = 524288,
	P4_EVENT_IOQ_ALLOCATION__MEM_WB = 1048576,
	P4_EVENT_IOQ_ALLOCATION__OWN = 4194304,
	P4_EVENT_IOQ_ALLOCATION__OTHER = 8388608,
	P4_EVENT_IOQ_ALLOCATION__PREFETCH = 16777216,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__DEFAULT = 512,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__ALL_READ = 16384,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__ALL_WRITE = 32768,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_UC = 65536,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WC = 131072,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WT = 262144,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WP = 524288,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WB = 1048576,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__OWN = 4194304,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__OTHER = 8388608,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__PREFETCH = 16777216,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_DRV = 512,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_OWN = 1024,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_OTHER = 2048,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_DRV = 4096,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_OWN = 8192,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_OTHER = 16384,
	P4_EVENT_BSQ_ALLOCATION__REQ_TYPE0 = 512,
	P4_EVENT_BSQ_ALLOCATION__REQ_TYPE1 = 1024,
	P4_EVENT_BSQ_ALLOCATION__REQ_LEN0 = 2048,
	P4_EVENT_BSQ_ALLOCATION__REQ_LEN1 = 4096,
	P4_EVENT_BSQ_ALLOCATION__REQ_IO_TYPE = 16384,
	P4_EVENT_BSQ_ALLOCATION__REQ_LOCK_TYPE = 32768,
	P4_EVENT_BSQ_ALLOCATION__REQ_CACHE_TYPE = 65536,
	P4_EVENT_BSQ_ALLOCATION__REQ_SPLIT_TYPE = 131072,
	P4_EVENT_BSQ_ALLOCATION__REQ_DEM_TYPE = 262144,
	P4_EVENT_BSQ_ALLOCATION__REQ_ORD_TYPE = 524288,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE0 = 1048576,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE1 = 2097152,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE2 = 4194304,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_TYPE0 = 512,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_TYPE1 = 1024,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LEN0 = 2048,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LEN1 = 4096,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_IO_TYPE = 16384,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LOCK_TYPE = 32768,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_CACHE_TYPE = 65536,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_SPLIT_TYPE = 131072,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_DEM_TYPE = 262144,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_ORD_TYPE = 524288,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE0 = 1048576,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE1 = 2097152,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE2 = 4194304,
	P4_EVENT_SSE_INPUT_ASSIST__ALL = 16777216,
	P4_EVENT_PACKED_SP_UOP__ALL = 16777216,
	P4_EVENT_PACKED_DP_UOP__ALL = 16777216,
	P4_EVENT_SCALAR_SP_UOP__ALL = 16777216,
	P4_EVENT_SCALAR_DP_UOP__ALL = 16777216,
	P4_EVENT_64BIT_MMX_UOP__ALL = 16777216,
	P4_EVENT_128BIT_MMX_UOP__ALL = 16777216,
	P4_EVENT_X87_FP_UOP__ALL = 16777216,
	P4_EVENT_TC_MISC__FLUSH = 8192,
	P4_EVENT_GLOBAL_POWER_EVENTS__RUNNING = 512,
	P4_EVENT_TC_MS_XFER__CISC = 512,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_TC_BUILD = 512,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_TC_DELIVER = 1024,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_ROM = 2048,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__CONDITIONAL = 1024,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__CALL = 2048,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__RETURN = 4096,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__INDIRECT = 8192,
	P4_EVENT_RETIRED_BRANCH_TYPE__CONDITIONAL = 1024,
	P4_EVENT_RETIRED_BRANCH_TYPE__CALL = 2048,
	P4_EVENT_RETIRED_BRANCH_TYPE__RETURN = 4096,
	P4_EVENT_RETIRED_BRANCH_TYPE__INDIRECT = 8192,
	P4_EVENT_RESOURCE_STALL__SBFULL = 16384,
	P4_EVENT_WC_BUFFER__WCB_EVICTS = 512,
	P4_EVENT_WC_BUFFER__WCB_FULL_EVICTS = 1024,
	P4_EVENT_FRONT_END_EVENT__NBOGUS = 512,
	P4_EVENT_FRONT_END_EVENT__BOGUS = 1024,
	P4_EVENT_EXECUTION_EVENT__NBOGUS0 = 512,
	P4_EVENT_EXECUTION_EVENT__NBOGUS1 = 1024,
	P4_EVENT_EXECUTION_EVENT__NBOGUS2 = 2048,
	P4_EVENT_EXECUTION_EVENT__NBOGUS3 = 4096,
	P4_EVENT_EXECUTION_EVENT__BOGUS0 = 8192,
	P4_EVENT_EXECUTION_EVENT__BOGUS1 = 16384,
	P4_EVENT_EXECUTION_EVENT__BOGUS2 = 32768,
	P4_EVENT_EXECUTION_EVENT__BOGUS3 = 65536,
	P4_EVENT_REPLAY_EVENT__NBOGUS = 512,
	P4_EVENT_REPLAY_EVENT__BOGUS = 1024,
	P4_EVENT_INSTR_RETIRED__NBOGUSNTAG = 512,
	P4_EVENT_INSTR_RETIRED__NBOGUSTAG = 1024,
	P4_EVENT_INSTR_RETIRED__BOGUSNTAG = 2048,
	P4_EVENT_INSTR_RETIRED__BOGUSTAG = 4096,
	P4_EVENT_UOPS_RETIRED__NBOGUS = 512,
	P4_EVENT_UOPS_RETIRED__BOGUS = 1024,
	P4_EVENT_UOP_TYPE__TAGLOADS = 1024,
	P4_EVENT_UOP_TYPE__TAGSTORES = 2048,
	P4_EVENT_BRANCH_RETIRED__MMNP = 512,
	P4_EVENT_BRANCH_RETIRED__MMNM = 1024,
	P4_EVENT_BRANCH_RETIRED__MMTP = 2048,
	P4_EVENT_BRANCH_RETIRED__MMTM = 4096,
	P4_EVENT_MISPRED_BRANCH_RETIRED__NBOGUS = 512,
	P4_EVENT_X87_ASSIST__FPSU = 512,
	P4_EVENT_X87_ASSIST__FPSO = 1024,
	P4_EVENT_X87_ASSIST__POAO = 2048,
	P4_EVENT_X87_ASSIST__POAU = 4096,
	P4_EVENT_X87_ASSIST__PREA = 8192,
	P4_EVENT_MACHINE_CLEAR__CLEAR = 512,
	P4_EVENT_MACHINE_CLEAR__MOCLEAR = 1024,
	P4_EVENT_MACHINE_CLEAR__SMCLEAR = 2048,
	P4_EVENT_INSTR_COMPLETED__NBOGUS = 512,
	P4_EVENT_INSTR_COMPLETED__BOGUS = 1024,
};

enum P4_PEBS_METRIC {
	P4_PEBS_METRIC__none = 0,
	P4_PEBS_METRIC__1stl_cache_load_miss_retired = 1,
	P4_PEBS_METRIC__2ndl_cache_load_miss_retired = 2,
	P4_PEBS_METRIC__dtlb_load_miss_retired = 3,
	P4_PEBS_METRIC__dtlb_store_miss_retired = 4,
	P4_PEBS_METRIC__dtlb_all_miss_retired = 5,
	P4_PEBS_METRIC__tagged_mispred_branch = 6,
	P4_PEBS_METRIC__mob_load_replay_retired = 7,
	P4_PEBS_METRIC__split_load_retired = 8,
	P4_PEBS_METRIC__split_store_retired = 9,
	P4_PEBS_METRIC__max = 10,
};

struct p4_event_bind {
	unsigned int opcode;
	unsigned int escr_msr[2];
	unsigned int escr_emask;
	unsigned int shared;
	char cntr[6];
};

struct p4_pebs_bind {
	unsigned int metric_pebs;
	unsigned int metric_vert;
};

struct p4_event_alias {
	u64 original;
	u64 alternative;
};

enum cpuid_regs_idx {
	CPUID_EAX = 0,
	CPUID_EBX = 1,
	CPUID_ECX = 2,
	CPUID_EDX = 3,
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

enum pt_capabilities {
	PT_CAP_max_subleaf = 0,
	PT_CAP_cr3_filtering = 1,
	PT_CAP_psb_cyc = 2,
	PT_CAP_ip_filtering = 3,
	PT_CAP_mtc = 4,
	PT_CAP_ptwrite = 5,
	PT_CAP_power_event_trace = 6,
	PT_CAP_topa_output = 7,
	PT_CAP_topa_multiple_entries = 8,
	PT_CAP_single_range_output = 9,
	PT_CAP_output_subsys = 10,
	PT_CAP_payloads_lip = 11,
	PT_CAP_num_address_ranges = 12,
	PT_CAP_mtc_periods = 13,
	PT_CAP_cycle_thresholds = 14,
	PT_CAP_psb_periods = 15,
};

enum perf_addr_filter_action_t {
	PERF_ADDR_FILTER_ACTION_STOP = 0,
	PERF_ADDR_FILTER_ACTION_START = 1,
	PERF_ADDR_FILTER_ACTION_FILTER = 2,
};

struct perf_addr_filter {
	struct list_head entry;
	struct path path;
	long unsigned int offset;
	long unsigned int size;
	enum perf_addr_filter_action_t action;
};

struct topa_entry {
	u64 end: 1;
	u64 rsvd0: 1;
	u64 intr: 1;
	u64 rsvd1: 1;
	u64 stop: 1;
	u64 rsvd2: 1;
	u64 size: 4;
	u64 rsvd3: 2;
	u64 base: 36;
	u64 rsvd4: 16;
};

struct pt_pmu {
	struct pmu pmu;
	u32 caps[8];
	bool vmx;
	bool branch_en_always_on;
	long unsigned int max_nonturbo_ratio;
	unsigned int tsc_art_num;
	unsigned int tsc_art_den;
};

struct topa;

struct pt_buffer {
	struct list_head tables;
	struct topa *first;
	struct topa *last;
	struct topa *cur;
	unsigned int cur_idx;
	size_t output_off;
	long unsigned int nr_pages;
	local_t data_size;
	local64_t head;
	bool snapshot;
	long int stop_pos;
	long int intr_pos;
	struct topa_entry *stop_te;
	struct topa_entry *intr_te;
	void **data_pages;
};

struct topa {
	struct list_head list;
	u64 offset;
	size_t size;
	int last;
	unsigned int z_count;
};

struct pt_filter {
	long unsigned int msr_a;
	long unsigned int msr_b;
	long unsigned int config;
};

struct pt_filters {
	struct pt_filter filter[4];
	unsigned int nr_filters;
};

struct pt {
	struct perf_output_handle handle;
	struct pt_filters filters;
	int handle_nmi;
	int vmx_on;
};

struct pt_cap_desc {
	const char *name;
	u32 leaf;
	u8 reg;
	u32 mask;
};

struct pt_address_range {
	long unsigned int msr_a;
	long unsigned int msr_b;
	unsigned int reg_off;
};

struct topa_page {
	struct topa_entry table[507];
	struct topa topa;
};

struct acpi_device;

struct pci_sysdata {
	int domain;
	int node;
	struct acpi_device *companion;
	void *iommu;
	void *fwnode;
	bool vmd_domain;
};

struct pci_extra_dev {
	struct pci_dev *dev[4];
};

struct intel_uncore_pmu;

struct intel_uncore_ops;

struct uncore_event_desc;

struct freerunning_counters;

struct intel_uncore_type {
	const char *name;
	int num_counters;
	int num_boxes;
	int perf_ctr_bits;
	int fixed_ctr_bits;
	int num_freerunning_types;
	unsigned int perf_ctr;
	unsigned int event_ctl;
	unsigned int event_mask;
	unsigned int event_mask_ext;
	unsigned int fixed_ctr;
	unsigned int fixed_ctl;
	unsigned int box_ctl;
	union {
		unsigned int msr_offset;
		unsigned int mmio_offset;
	};
	unsigned int num_shared_regs: 8;
	unsigned int single_fixed: 1;
	unsigned int pair_ctr_ctl: 1;
	unsigned int *msr_offsets;
	struct event_constraint unconstrainted;
	struct event_constraint *constraints;
	struct intel_uncore_pmu *pmus;
	struct intel_uncore_ops *ops;
	struct uncore_event_desc *event_descs;
	struct freerunning_counters *freerunning;
	const struct attribute_group *attr_groups[4];
	struct pmu *pmu;
};

struct intel_uncore_box;

struct intel_uncore_pmu {
	struct pmu pmu;
	char name[32];
	int pmu_idx;
	int func_id;
	bool registered;
	atomic_t activeboxes;
	struct intel_uncore_type *type;
	struct intel_uncore_box **boxes;
};

struct intel_uncore_ops {
	void (*init_box)(struct intel_uncore_box *);
	void (*exit_box)(struct intel_uncore_box *);
	void (*disable_box)(struct intel_uncore_box *);
	void (*enable_box)(struct intel_uncore_box *);
	void (*disable_event)(struct intel_uncore_box *, struct perf_event *);
	void (*enable_event)(struct intel_uncore_box *, struct perf_event *);
	u64 (*read_counter)(struct intel_uncore_box *, struct perf_event *);
	int (*hw_config)(struct intel_uncore_box *, struct perf_event *);
	struct event_constraint * (*get_constraint)(struct intel_uncore_box *, struct perf_event *);
	void (*put_constraint)(struct intel_uncore_box *, struct perf_event *);
};

struct uncore_event_desc {
	struct device_attribute attr;
	const char *config;
};

struct freerunning_counters {
	unsigned int counter_base;
	unsigned int counter_offset;
	unsigned int box_offset;
	unsigned int num_counters;
	unsigned int bits;
	unsigned int *box_offsets;
};

struct intel_uncore_extra_reg {
	raw_spinlock_t lock;
	u64 config;
	u64 config1;
	u64 config2;
	atomic_t ref;
};

struct intel_uncore_box {
	int pci_phys_id;
	int dieid;
	int n_active;
	int n_events;
	int cpu;
	long unsigned int flags;
	atomic_t refcnt;
	struct perf_event *events[10];
	struct perf_event *event_list[10];
	struct event_constraint *event_constraint[10];
	long unsigned int active_mask[1];
	u64 tags[10];
	struct pci_dev *pci_dev;
	struct intel_uncore_pmu *pmu;
	u64 hrtimer_duration;
	struct hrtimer hrtimer;
	struct list_head list;
	struct list_head active_list;
	void *io_addr;
	struct intel_uncore_extra_reg shared_regs[0];
};

struct pci2phy_map {
	struct list_head list;
	int segment;
	int pbus_to_physid[256];
};

struct intel_uncore_init_fun {
	void (*cpu_init)();
	int (*pci_init)();
	void (*mmio_init)();
};

enum {
	EXTRA_REG_NHMEX_M_FILTER = 0,
	EXTRA_REG_NHMEX_M_DSP = 1,
	EXTRA_REG_NHMEX_M_ISS = 2,
	EXTRA_REG_NHMEX_M_MAP = 3,
	EXTRA_REG_NHMEX_M_MSC_THR = 4,
	EXTRA_REG_NHMEX_M_PGT = 5,
	EXTRA_REG_NHMEX_M_PLD = 6,
	EXTRA_REG_NHMEX_M_ZDP_CTL_FVC = 7,
};

enum {
	SNB_PCI_UNCORE_IMC = 0,
};

enum perf_snb_uncore_imc_freerunning_types {
	SNB_PCI_UNCORE_IMC_DATA = 0,
	SNB_PCI_UNCORE_IMC_FREERUNNING_TYPE_MAX = 1,
};

struct imc_uncore_pci_dev {
	__u32 pci_id;
	struct pci_driver *driver;
};

enum {
	SNBEP_PCI_QPI_PORT0_FILTER = 0,
	SNBEP_PCI_QPI_PORT1_FILTER = 1,
	BDX_PCI_QPI_PORT2_FILTER = 2,
};

enum {
	SNBEP_PCI_UNCORE_HA = 0,
	SNBEP_PCI_UNCORE_IMC = 1,
	SNBEP_PCI_UNCORE_QPI = 2,
	SNBEP_PCI_UNCORE_R2PCIE = 3,
	SNBEP_PCI_UNCORE_R3QPI = 4,
};

enum {
	IVBEP_PCI_UNCORE_HA = 0,
	IVBEP_PCI_UNCORE_IMC = 1,
	IVBEP_PCI_UNCORE_IRP = 2,
	IVBEP_PCI_UNCORE_QPI = 3,
	IVBEP_PCI_UNCORE_R2PCIE = 4,
	IVBEP_PCI_UNCORE_R3QPI = 5,
};

enum {
	KNL_PCI_UNCORE_MC_UCLK = 0,
	KNL_PCI_UNCORE_MC_DCLK = 1,
	KNL_PCI_UNCORE_EDC_UCLK = 2,
	KNL_PCI_UNCORE_EDC_ECLK = 3,
	KNL_PCI_UNCORE_M2PCIE = 4,
	KNL_PCI_UNCORE_IRP = 5,
};

enum {
	HSWEP_PCI_UNCORE_HA = 0,
	HSWEP_PCI_UNCORE_IMC = 1,
	HSWEP_PCI_UNCORE_IRP = 2,
	HSWEP_PCI_UNCORE_QPI = 3,
	HSWEP_PCI_UNCORE_R2PCIE = 4,
	HSWEP_PCI_UNCORE_R3QPI = 5,
};

enum {
	BDX_PCI_UNCORE_HA = 0,
	BDX_PCI_UNCORE_IMC = 1,
	BDX_PCI_UNCORE_IRP = 2,
	BDX_PCI_UNCORE_QPI = 3,
	BDX_PCI_UNCORE_R2PCIE = 4,
	BDX_PCI_UNCORE_R3QPI = 5,
};

enum perf_uncore_iio_freerunning_type_id {
	SKX_IIO_MSR_IOCLK = 0,
	SKX_IIO_MSR_BW = 1,
	SKX_IIO_MSR_UTIL = 2,
	SKX_IIO_FREERUNNING_TYPE_MAX = 3,
};

enum {
	SKX_PCI_UNCORE_IMC = 0,
	SKX_PCI_UNCORE_M2M = 1,
	SKX_PCI_UNCORE_UPI = 2,
	SKX_PCI_UNCORE_M2PCIE = 3,
	SKX_PCI_UNCORE_M3UPI = 4,
};

enum perf_uncore_snr_iio_freerunning_type_id {
	SNR_IIO_MSR_IOCLK = 0,
	SNR_IIO_MSR_BW_IN = 1,
	SNR_IIO_FREERUNNING_TYPE_MAX = 2,
};

enum {
	SNR_PCI_UNCORE_M2M = 0,
};

enum perf_uncore_snr_imc_freerunning_type_id {
	SNR_IMC_DCLK = 0,
	SNR_IMC_DDR = 1,
	SNR_IMC_FREERUNNING_TYPE_MAX = 2,
};

enum perf_uncore_icx_iio_freerunning_type_id {
	ICX_IIO_MSR_IOCLK = 0,
	ICX_IIO_MSR_BW_IN = 1,
	ICX_IIO_FREERUNNING_TYPE_MAX = 2,
};

enum {
	ICX_PCI_UNCORE_M2M = 0,
	ICX_PCI_UNCORE_UPI = 1,
	ICX_PCI_UNCORE_M3UPI = 2,
};

enum perf_uncore_icx_imc_freerunning_type_id {
	ICX_IMC_DCLK = 0,
	ICX_IMC_DDR = 1,
	ICX_IMC_DDRT = 2,
	ICX_IMC_FREERUNNING_TYPE_MAX = 3,
};

struct cstate_model {
	long unsigned int core_events;
	long unsigned int pkg_events;
	long unsigned int quirks;
};

enum perf_cstate_core_events {
	PERF_CSTATE_CORE_C1_RES = 0,
	PERF_CSTATE_CORE_C3_RES = 1,
	PERF_CSTATE_CORE_C6_RES = 2,
	PERF_CSTATE_CORE_C7_RES = 3,
	PERF_CSTATE_CORE_EVENT_MAX = 4,
};

enum perf_cstate_pkg_events {
	PERF_CSTATE_PKG_C2_RES = 0,
	PERF_CSTATE_PKG_C3_RES = 1,
	PERF_CSTATE_PKG_C6_RES = 2,
	PERF_CSTATE_PKG_C7_RES = 3,
	PERF_CSTATE_PKG_C8_RES = 4,
	PERF_CSTATE_PKG_C9_RES = 5,
	PERF_CSTATE_PKG_C10_RES = 6,
	PERF_CSTATE_PKG_EVENT_MAX = 7,
};

struct mpc_table {
	char signature[4];
	short unsigned int length;
	char spec;
	char checksum;
	char oem[8];
	char productid[12];
	unsigned int oemptr;
	short unsigned int oemsize;
	short unsigned int oemcount;
	unsigned int lapic;
	unsigned int reserved;
};

struct mpc_cpu {
	unsigned char type;
	unsigned char apicid;
	unsigned char apicver;
	unsigned char cpuflag;
	unsigned int cpufeature;
	unsigned int featureflag;
	unsigned int reserved[2];
};

struct mpc_bus {
	unsigned char type;
	unsigned char busid;
	unsigned char bustype[6];
};

struct x86_init_mpparse {
	void (*mpc_record)(unsigned int);
	void (*setup_ioapic_ids)();
	int (*mpc_apic_id)(struct mpc_cpu *);
	void (*smp_read_mpc_oem)(struct mpc_table *);
	void (*mpc_oem_pci_bus)(struct mpc_bus *);
	void (*mpc_oem_bus_info)(struct mpc_bus *, char *);
	void (*find_smp_config)();
	void (*get_smp_config)(unsigned int);
};

struct x86_init_resources {
	void (*probe_roms)();
	void (*reserve_resources)();
	char * (*memory_setup)();
};

struct x86_init_irqs {
	void (*pre_vector_init)();
	void (*intr_init)();
	void (*trap_init)();
	void (*intr_mode_select)();
	void (*intr_mode_init)();
};

struct x86_init_oem {
	void (*arch_setup)();
	void (*banner)();
};

struct x86_init_paging {
	void (*pagetable_init)();
};

struct x86_init_timers {
	void (*setup_percpu_clockev)();
	void (*timer_init)();
	void (*wallclock_init)();
};

struct x86_init_iommu {
	int (*iommu_init)();
};

struct x86_init_pci {
	int (*arch_init)();
	int (*init)();
	void (*init_irq)();
	void (*fixup_irqs)();
};

struct x86_hyper_init {
	void (*init_platform)();
	void (*guest_late_init)();
	bool (*x2apic_available)();
	void (*init_mem_mapping)();
	void (*init_after_bootmem)();
};

struct x86_init_acpi {
	void (*set_root_pointer)(u64);
	u64 (*get_root_pointer)();
	void (*reduced_hw_early_init)();
};

struct x86_init_ops {
	struct x86_init_resources resources;
	struct x86_init_mpparse mpparse;
	struct x86_init_irqs irqs;
	struct x86_init_oem oem;
	struct x86_init_paging paging;
	struct x86_init_timers timers;
	struct x86_init_iommu iommu;
	struct x86_init_pci pci;
	struct x86_hyper_init hyper;
	struct x86_init_acpi acpi;
};

enum e820_type {
	E820_TYPE_RAM = 1,
	E820_TYPE_RESERVED = 2,
	E820_TYPE_ACPI = 3,
	E820_TYPE_NVS = 4,
	E820_TYPE_UNUSABLE = 5,
	E820_TYPE_PMEM = 7,
	E820_TYPE_PRAM = 12,
	E820_TYPE_RESERVED_KERN = 128,
};

struct hvm_start_info {
	uint32_t magic;
	uint32_t version;
	uint32_t flags;
	uint32_t nr_modules;
	uint64_t modlist_paddr;
	uint64_t cmdline_paddr;
	uint64_t rsdp_paddr;
	uint64_t memmap_paddr;
	uint32_t memmap_entries;
	uint32_t reserved;
};

struct hvm_modlist_entry {
	uint64_t paddr;
	uint64_t size;
	uint64_t cmdline_paddr;
	uint64_t reserved;
};

struct hvm_memmap_table_entry {
	uint64_t addr;
	uint64_t size;
	uint32_t type;
	uint32_t reserved;
};

enum {
	WORK_STRUCT_PENDING_BIT = 0,
	WORK_STRUCT_DELAYED_BIT = 1,
	WORK_STRUCT_PWQ_BIT = 2,
	WORK_STRUCT_LINKED_BIT = 3,
	WORK_STRUCT_COLOR_SHIFT = 4,
	WORK_STRUCT_COLOR_BITS = 4,
	WORK_STRUCT_PENDING = 1,
	WORK_STRUCT_DELAYED = 2,
	WORK_STRUCT_PWQ = 4,
	WORK_STRUCT_LINKED = 8,
	WORK_STRUCT_STATIC = 0,
	WORK_NR_COLORS = 15,
	WORK_NO_COLOR = 15,
	WORK_CPU_UNBOUND = 8192,
	WORK_STRUCT_FLAG_BITS = 8,
	WORK_OFFQ_FLAG_BASE = 4,
	__WORK_OFFQ_CANCELING = 4,
	WORK_OFFQ_CANCELING = 16,
	WORK_OFFQ_FLAG_BITS = 1,
	WORK_OFFQ_POOL_SHIFT = 5,
	WORK_OFFQ_LEFT = 59,
	WORK_OFFQ_POOL_BITS = 31,
	WORK_OFFQ_POOL_NONE = 2147483647,
	WORK_STRUCT_FLAG_MASK = 255,
	WORK_STRUCT_WQ_DATA_MASK = 4294967040,
	WORK_STRUCT_NO_POOL = 4294967264,
	WORK_BUSY_PENDING = 1,
	WORK_BUSY_RUNNING = 2,
	WORKER_DESC_LEN = 24,
};

enum x86_hypervisor_type {
	X86_HYPER_NATIVE = 0,
	X86_HYPER_VMWARE = 1,
	X86_HYPER_MS_HYPERV = 2,
	X86_HYPER_XEN_PV = 3,
	X86_HYPER_XEN_HVM = 4,
	X86_HYPER_KVM = 5,
	X86_HYPER_JAILHOUSE = 6,
	X86_HYPER_ACRN = 7,
};

union hv_x64_msr_hypercall_contents {
	u64 as_uint64;
	struct {
		u64 enable: 1;
		u64 reserved: 11;
		u64 guest_physical_address: 52;
	};
};

struct hv_reenlightenment_control {
	__u64 vector: 8;
	__u64 reserved1: 8;
	__u64 enabled: 1;
	__u64 reserved2: 15;
	__u64 target_vp: 32;
};

struct hv_tsc_emulation_control {
	__u64 enabled: 1;
	__u64 reserved: 63;
};

struct hv_tsc_emulation_status {
	__u64 inprogress: 1;
	__u64 reserved: 63;
};

struct hv_nested_enlightenments_control {
	struct {
		__u32 directhypercall: 1;
		__u32 reserved: 31;
	} features;
	struct {
		__u32 reserved;
	} hypercallControls;
};

struct hv_vp_assist_page {
	__u32 apic_assist;
	__u32 reserved1;
	__u64 vtl_control[3];
	struct hv_nested_enlightenments_control nested_control;
	__u8 enlighten_vmentry;
	__u8 reserved2[7];
	__u64 current_nested_vmcs;
};

struct ms_hyperv_info {
	u32 features;
	u32 misc_features;
	u32 hints;
	u32 nested_features;
	u32 max_vp_index;
	u32 max_lp_index;
};

typedef u8 pto_T_____3;

struct mmu_gather_batch {
	struct mmu_gather_batch *next;
	unsigned int nr;
	unsigned int max;
	struct page *pages[0];
};

struct mmu_table_batch;

struct mmu_gather {
	struct mm_struct *mm;
	struct mmu_table_batch *batch;
	long unsigned int start;
	long unsigned int end;
	unsigned int fullmm: 1;
	unsigned int need_flush_all: 1;
	unsigned int freed_tables: 1;
	unsigned int cleared_ptes: 1;
	unsigned int cleared_pmds: 1;
	unsigned int cleared_puds: 1;
	unsigned int cleared_p4ds: 1;
	unsigned int vma_exec: 1;
	unsigned int vma_huge: 1;
	unsigned int batch_count;
	struct mmu_gather_batch *active;
	struct mmu_gather_batch local;
	struct page *__pages[8];
};

struct mmu_notifier_mm {
	struct hlist_head list;
	spinlock_t lock;
};

enum HV_GENERIC_SET_FORMAT {
	HV_GENERIC_SET_SPARSE_4K = 0,
	HV_GENERIC_SET_ALL = 1,
};

struct hv_vpset {
	u64 format;
	u64 valid_bank_mask;
	u64 bank_contents[0];
};

struct hv_tlb_flush {
	u64 address_space;
	u64 flags;
	u64 processor_mask;
	u64 gva_list[0];
};

struct hv_tlb_flush_ex {
	u64 address_space;
	u64 flags;
	struct hv_vpset hv_vp_set;
	u64 gva_list[0];
};

struct mmu_table_batch {
	struct callback_head rcu;
	unsigned int nr;
	void *tables[0];
};

struct trace_event_raw_hyperv_mmu_flush_tlb_others {
	struct trace_entry ent;
	unsigned int ncpus;
	struct mm_struct *mm;
	long unsigned int addr;
	long unsigned int end;
	char __data[0];
};

struct trace_event_raw_hyperv_nested_flush_guest_mapping {
	struct trace_entry ent;
	u64 as;
	int ret;
	char __data[0];
};

struct trace_event_raw_hyperv_nested_flush_guest_mapping_range {
	struct trace_entry ent;
	u64 as;
	int ret;
	char __data[0];
};

struct trace_event_raw_hyperv_send_ipi_mask {
	struct trace_entry ent;
	unsigned int ncpus;
	int vector;
	char __data[0];
};

struct trace_event_data_offsets_hyperv_mmu_flush_tlb_others {};

struct trace_event_data_offsets_hyperv_nested_flush_guest_mapping {};

struct trace_event_data_offsets_hyperv_nested_flush_guest_mapping_range {};

struct trace_event_data_offsets_hyperv_send_ipi_mask {};

typedef void (*btf_trace_hyperv_mmu_flush_tlb_others)(void *, const struct cpumask *, const struct flush_tlb_info *);

typedef void (*btf_trace_hyperv_nested_flush_guest_mapping)(void *, u64, int);

typedef void (*btf_trace_hyperv_nested_flush_guest_mapping_range)(void *, u64, int);

typedef void (*btf_trace_hyperv_send_ipi_mask)(void *, const struct cpumask *, int);

struct hv_guest_mapping_flush {
	u64 address_space;
	u64 flags;
};

union hv_gpa_page_range {
	u64 address_space;
	struct {
		u64 additional_pages: 11;
		u64 largepage: 1;
		u64 basepfn: 52;
	} page;
};

struct hv_guest_mapping_flush_list {
	u64 address_space;
	u64 flags;
	union hv_gpa_page_range gpa_list[510];
};

typedef int (*hyperv_fill_flush_list_func)(struct hv_guest_mapping_flush_list *, void *);

struct hv_send_ipi {
	u32 vector;
	u32 reserved;
	u64 cpu_mask;
};

struct hv_send_ipi_ex {
	u32 vector;
	u32 reserved;
	struct hv_vpset vp_set;
};

struct real_mode_header {
	u32 text_start;
	u32 ro_end;
	u32 trampoline_start;
	u32 trampoline_header;
	u32 trampoline_pgd;
	u32 wakeup_start;
	u32 wakeup_header;
	u32 machine_real_restart_asm;
	u32 machine_real_restart_seg;
};

struct trampoline_header {
	u64 start;
	u64 efer;
	u32 cr4;
	u32 flags;
};

enum xfeature {
	XFEATURE_FP = 0,
	XFEATURE_SSE = 1,
	XFEATURE_YMM = 2,
	XFEATURE_BNDREGS = 3,
	XFEATURE_BNDCSR = 4,
	XFEATURE_OPMASK = 5,
	XFEATURE_ZMM_Hi256 = 6,
	XFEATURE_Hi16_ZMM = 7,
	XFEATURE_PT_UNIMPLEMENTED_SO_FAR = 8,
	XFEATURE_PKRU = 9,
	XFEATURE_MAX = 10,
};

struct pkru_state {
	u32 pkru;
	u32 pad;
};

enum show_regs_mode {
	SHOW_REGS_SHORT = 0,
	SHOW_REGS_USER = 1,
	SHOW_REGS_ALL = 2,
};

struct resctrl_pqr_state {
	u32 cur_rmid;
	u32 cur_closid;
	u32 default_rmid;
	u32 default_closid;
};

enum which_selector {
	FS = 0,
	GS = 1,
};

typedef struct task_struct *pto_T_____4;

typedef u64 pto_T_____5;

struct sigcontext_64 {
	__u64 r8;
	__u64 r9;
	__u64 r10;
	__u64 r11;
	__u64 r12;
	__u64 r13;
	__u64 r14;
	__u64 r15;
	__u64 di;
	__u64 si;
	__u64 bp;
	__u64 bx;
	__u64 dx;
	__u64 ax;
	__u64 cx;
	__u64 sp;
	__u64 ip;
	__u64 flags;
	__u16 cs;
	__u16 gs;
	__u16 fs;
	__u16 ss;
	__u64 err;
	__u64 trapno;
	__u64 oldmask;
	__u64 cr2;
	__u64 fpstate;
	__u64 reserved1[8];
};

struct sigaltstack {
	void *ss_sp;
	int ss_flags;
	size_t ss_size;
};

typedef struct sigaltstack stack_t;

struct siginfo {
	union {
		struct {
			int si_signo;
			int si_errno;
			int si_code;
			union __sifields _sifields;
		};
		int _si_pad[32];
	};
};

typedef struct siginfo siginfo_t;

typedef u32 compat_sigset_word;

typedef struct {
	compat_sigset_word sig[2];
} compat_sigset_t;

struct ucontext {
	long unsigned int uc_flags;
	struct ucontext *uc_link;
	stack_t uc_stack;
	struct sigcontext_64 uc_mcontext;
	sigset_t uc_sigmask;
};

struct kernel_vm86_regs {
	struct pt_regs pt;
	short unsigned int es;
	short unsigned int __esh;
	short unsigned int ds;
	short unsigned int __dsh;
	short unsigned int fs;
	short unsigned int __fsh;
	short unsigned int gs;
	short unsigned int __gsh;
};

struct rt_sigframe {
	char *pretcode;
	struct ucontext uc;
	struct siginfo info;
};

typedef s32 compat_clock_t;

typedef s32 compat_pid_t;

typedef s32 compat_timer_t;

typedef s32 compat_int_t;

typedef u32 __compat_uid32_t;

union compat_sigval {
	compat_int_t sival_int;
	compat_uptr_t sival_ptr;
};

typedef union compat_sigval compat_sigval_t;

struct compat_siginfo {
	int si_signo;
	int si_errno;
	int si_code;
	union {
		int _pad[29];
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
		} _kill;
		struct {
			compat_timer_t _tid;
			int _overrun;
			compat_sigval_t _sigval;
		} _timer;
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
			compat_sigval_t _sigval;
		} _rt;
		struct {
			compat_pid_t _pid;
			__compat_uid32_t _uid;
			int _status;
			compat_clock_t _utime;
			compat_clock_t _stime;
		} _sigchld;
		struct {
			compat_uptr_t _addr;
			union {
				short int _addr_lsb;
				struct {
					char _dummy_bnd[4];
					compat_uptr_t _lower;
					compat_uptr_t _upper;
				} _addr_bnd;
				struct {
					char _dummy_pkey[4];
					u32 _pkey;
				} _addr_pkey;
			};
		} _sigfault;
		struct {
			compat_long_t _band;
			int _fd;
		} _sigpoll;
		struct {
			compat_uptr_t _call_addr;
			int _syscall;
			unsigned int _arch;
		} _sigsys;
	} _sifields;
};

typedef struct compat_siginfo compat_siginfo_t;

enum bug_trap_type {
	BUG_TRAP_TYPE_NONE = 0,
	BUG_TRAP_TYPE_WARN = 1,
	BUG_TRAP_TYPE_BUG = 2,
};

struct idt_bits {
	u16 ist: 3;
	u16 zero: 5;
	u16 type: 5;
	u16 dpl: 2;
	u16 p: 1;
};

struct gate_struct {
	u16 offset_low;
	u16 segment;
	struct idt_bits bits;
	u16 offset_middle;
	u32 offset_high;
	u32 reserved;
};

typedef struct gate_struct gate_desc;

struct desc_ptr {
	short unsigned int size;
	long unsigned int address;
} __attribute__((packed));

struct mpx_bndcsr {
	u64 bndcfgu;
	u64 bndstatus;
};

typedef u8 kprobe_opcode_t;

struct arch_specific_insn {
	kprobe_opcode_t *insn;
	bool boostable;
	bool if_modifier;
};

struct kprobe;

typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);

typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);

typedef int (*kprobe_fault_handler_t)(struct kprobe *, struct pt_regs *, int);

struct kprobe {
	struct hlist_node hlist;
	struct list_head list;
	long unsigned int nmissed;
	kprobe_opcode_t *addr;
	const char *symbol_name;
	unsigned int offset;
	kprobe_pre_handler_t pre_handler;
	kprobe_post_handler_t post_handler;
	kprobe_fault_handler_t fault_handler;
	kprobe_opcode_t opcode;
	struct arch_specific_insn ainsn;
	u32 flags;
};

enum die_val {
	DIE_OOPS = 1,
	DIE_INT3 = 2,
	DIE_DEBUG = 3,
	DIE_PANIC = 4,
	DIE_NMI = 5,
	DIE_DIE = 6,
	DIE_KERNELDEBUG = 7,
	DIE_TRAP = 8,
	DIE_GPF = 9,
	DIE_CALL = 10,
	DIE_PAGE_FAULT = 11,
	DIE_NMIUNKNOWN = 12,
};

struct mpx_fault_info {
	void *addr;
	void *lower;
	void *upper;
};

struct bad_iret_stack {
	void *error_entry_ret;
	struct pt_regs regs;
};

enum {
	GATE_INTERRUPT = 14,
	GATE_TRAP = 15,
	GATE_CALL = 12,
	GATE_TASK = 5,
};

struct idt_data {
	unsigned int vector;
	unsigned int segment;
	struct idt_bits bits;
	const void *addr;
};

enum irqreturn {
	IRQ_NONE = 0,
	IRQ_HANDLED = 1,
	IRQ_WAKE_THREAD = 2,
};

typedef enum irqreturn irqreturn_t;

typedef irqreturn_t (*irq_handler_t)(int, void *);

struct irqaction {
	irq_handler_t handler;
	void *dev_id;
	void *percpu_dev_id;
	struct irqaction *next;
	irq_handler_t thread_fn;
	struct task_struct *thread;
	struct irqaction *secondary;
	unsigned int irq;
	unsigned int flags;
	long unsigned int thread_flags;
	long unsigned int thread_mask;
	const char *name;
	struct proc_dir_entry *dir;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
	void (*release)(struct kref *);
};

enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING = 0,
	IRQCHIP_STATE_ACTIVE = 1,
	IRQCHIP_STATE_MASKED = 2,
	IRQCHIP_STATE_LINE_LEVEL = 3,
};

struct irq_desc;

typedef void (*irq_flow_handler_t)(struct irq_desc *);

struct msi_desc;

struct irq_common_data {
	unsigned int state_use_accessors;
	unsigned int node;
	void *handler_data;
	struct msi_desc *msi_desc;
	cpumask_var_t affinity;
	cpumask_var_t effective_affinity;
};

struct irq_chip;

struct irq_data {
	u32 mask;
	unsigned int irq;
	long unsigned int hwirq;
	struct irq_common_data *common;
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct irq_data *parent_data;
	void *chip_data;
};

struct irq_desc {
	struct irq_common_data irq_common_data;
	struct irq_data irq_data;
	unsigned int *kstat_irqs;
	irq_flow_handler_t handle_irq;
	struct irqaction *action;
	unsigned int status_use_accessors;
	unsigned int core_internal_state__do_not_mess_with_it;
	unsigned int depth;
	unsigned int wake_depth;
	unsigned int tot_count;
	unsigned int irq_count;
	long unsigned int last_unhandled;
	unsigned int irqs_unhandled;
	atomic_t threads_handled;
	int threads_handled_last;
	raw_spinlock_t lock;
	struct cpumask *percpu_enabled;
	const struct cpumask *percpu_affinity;
	const struct cpumask *affinity_hint;
	struct irq_affinity_notify *affinity_notify;
	cpumask_var_t pending_mask;
	long unsigned int threads_oneshot;
	atomic_t threads_active;
	wait_queue_head_t wait_for_threads;
	unsigned int nr_actions;
	unsigned int no_suspend_depth;
	unsigned int cond_suspend_depth;
	unsigned int force_resume_depth;
	struct proc_dir_entry *dir;
	struct callback_head rcu;
	struct kobject kobj;
	struct mutex request_mutex;
	int parent_irq;
	struct module *owner;
	const char *name;
	long: 64;
	long: 64;
	long: 64;
};

struct msi_msg;

struct irq_chip {
	struct device *parent_device;
	const char *name;
	unsigned int (*irq_startup)(struct irq_data *);
	void (*irq_shutdown)(struct irq_data *);
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_ack)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	void (*irq_mask_ack)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_eoi)(struct irq_data *);
	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
	int (*irq_retrigger)(struct irq_data *);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	void (*irq_bus_lock)(struct irq_data *);
	void (*irq_bus_sync_unlock)(struct irq_data *);
	void (*irq_cpu_online)(struct irq_data *);
	void (*irq_cpu_offline)(struct irq_data *);
	void (*irq_suspend)(struct irq_data *);
	void (*irq_resume)(struct irq_data *);
	void (*irq_pm_shutdown)(struct irq_data *);
	void (*irq_calc_mask)(struct irq_data *);
	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
	int (*irq_request_resources)(struct irq_data *);
	void (*irq_release_resources)(struct irq_data *);
	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
	void (*ipi_send_single)(struct irq_data *, unsigned int);
	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
	int (*irq_nmi_setup)(struct irq_data *);
	void (*irq_nmi_teardown)(struct irq_data *);
	long unsigned int flags;
};

typedef struct irq_desc *vector_irq_t[256];

struct trace_event_raw_x86_irq_vector {
	struct trace_entry ent;
	int vector;
	char __data[0];
};

struct trace_event_raw_vector_config {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	unsigned int cpu;
	unsigned int apicdest;
	char __data[0];
};

struct trace_event_raw_vector_mod {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	unsigned int cpu;
	unsigned int prev_vector;
	unsigned int prev_cpu;
	char __data[0];
};

struct trace_event_raw_vector_reserve {
	struct trace_entry ent;
	unsigned int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_alloc {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	bool reserved;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_alloc_managed {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_activate {
	struct trace_entry ent;
	unsigned int irq;
	bool is_managed;
	bool can_reserve;
	bool reserve;
	char __data[0];
};

struct trace_event_raw_vector_teardown {
	struct trace_entry ent;
	unsigned int irq;
	bool is_managed;
	bool has_reserved;
	char __data[0];
};

struct trace_event_raw_vector_setup {
	struct trace_entry ent;
	unsigned int irq;
	bool is_legacy;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_free_moved {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int cpu;
	unsigned int vector;
	bool is_managed;
	char __data[0];
};

struct trace_event_data_offsets_x86_irq_vector {};

struct trace_event_data_offsets_vector_config {};

struct trace_event_data_offsets_vector_mod {};

struct trace_event_data_offsets_vector_reserve {};

struct trace_event_data_offsets_vector_alloc {};

struct trace_event_data_offsets_vector_alloc_managed {};

struct trace_event_data_offsets_vector_activate {};

struct trace_event_data_offsets_vector_teardown {};

struct trace_event_data_offsets_vector_setup {};

struct trace_event_data_offsets_vector_free_moved {};

typedef void (*btf_trace_local_timer_entry)(void *, int);

typedef void (*btf_trace_local_timer_exit)(void *, int);

typedef void (*btf_trace_spurious_apic_entry)(void *, int);

typedef void (*btf_trace_spurious_apic_exit)(void *, int);

typedef void (*btf_trace_error_apic_entry)(void *, int);

typedef void (*btf_trace_error_apic_exit)(void *, int);

typedef void (*btf_trace_x86_platform_ipi_entry)(void *, int);

typedef void (*btf_trace_x86_platform_ipi_exit)(void *, int);

typedef void (*btf_trace_irq_work_entry)(void *, int);

typedef void (*btf_trace_irq_work_exit)(void *, int);

typedef void (*btf_trace_reschedule_entry)(void *, int);

typedef void (*btf_trace_reschedule_exit)(void *, int);

typedef void (*btf_trace_call_function_entry)(void *, int);

typedef void (*btf_trace_call_function_exit)(void *, int);

typedef void (*btf_trace_call_function_single_entry)(void *, int);

typedef void (*btf_trace_call_function_single_exit)(void *, int);

typedef void (*btf_trace_threshold_apic_entry)(void *, int);

typedef void (*btf_trace_threshold_apic_exit)(void *, int);

typedef void (*btf_trace_deferred_error_apic_entry)(void *, int);

typedef void (*btf_trace_deferred_error_apic_exit)(void *, int);

typedef void (*btf_trace_thermal_apic_entry)(void *, int);

typedef void (*btf_trace_thermal_apic_exit)(void *, int);

typedef void (*btf_trace_vector_config)(void *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_vector_update)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_vector_clear)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_vector_reserve_managed)(void *, unsigned int, int);

typedef void (*btf_trace_vector_reserve)(void *, unsigned int, int);

typedef void (*btf_trace_vector_alloc)(void *, unsigned int, unsigned int, bool, int);

typedef void (*btf_trace_vector_alloc_managed)(void *, unsigned int, unsigned int, int);

typedef void (*btf_trace_vector_activate)(void *, unsigned int, bool, bool, bool);

typedef void (*btf_trace_vector_deactivate)(void *, unsigned int, bool, bool, bool);

typedef void (*btf_trace_vector_teardown)(void *, unsigned int, bool, bool);

typedef void (*btf_trace_vector_setup)(void *, unsigned int, bool, int);

typedef void (*btf_trace_vector_free_moved)(void *, unsigned int, unsigned int, unsigned int, bool);

typedef struct irq_desc *pto_T_____6;

typedef struct pt_regs *pto_T_____7;

struct irq_stack {
	char stack[16384];
};

struct estack_pages {
	u32 offs;
	u16 size;
	u16 type;
};

struct arch_clocksource_data {
	int vclock_mode;
};

struct clocksource {
	u64 (*read)(struct clocksource *);
	u64 mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
	struct arch_clocksource_data archdata;
	u64 max_cycles;
	const char *name;
	struct list_head list;
	int rating;
	int (*enable)(struct clocksource *);
	void (*disable)(struct clocksource *);
	long unsigned int flags;
	void (*suspend)(struct clocksource *);
	void (*resume)(struct clocksource *);
	void (*mark_unstable)(struct clocksource *);
	void (*tick_stable)(struct clocksource *);
	struct list_head wd_list;
	u64 cs_last;
	u64 wd_last;
	struct module *owner;
};

enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED = 0,
	CLOCK_EVT_STATE_SHUTDOWN = 1,
	CLOCK_EVT_STATE_PERIODIC = 2,
	CLOCK_EVT_STATE_ONESHOT = 3,
	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
};

struct clock_event_device {
	void (*event_handler)(struct clock_event_device *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
	ktime_t next_event;
	u64 max_delta_ns;
	u64 min_delta_ns;
	u32 mult;
	u32 shift;
	enum clock_event_state state_use_accessors;
	unsigned int features;
	long unsigned int retries;
	int (*set_state_periodic)(struct clock_event_device *);
	int (*set_state_oneshot)(struct clock_event_device *);
	int (*set_state_oneshot_stopped)(struct clock_event_device *);
	int (*set_state_shutdown)(struct clock_event_device *);
	int (*tick_resume)(struct clock_event_device *);
	void (*broadcast)(const struct cpumask *);
	void (*suspend)(struct clock_event_device *);
	void (*resume)(struct clock_event_device *);
	long unsigned int min_delta_ticks;
	long unsigned int max_delta_ticks;
	const char *name;
	int rating;
	int irq;
	int bound_on;
	const struct cpumask *cpumask;
	struct list_head list;
	struct module *owner;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	DESC_TSS = 9,
	DESC_LDT = 2,
	DESCTYPE_S = 16,
};

struct ldttss_desc {
	u16 limit0;
	u16 base0;
	u16 base1: 8;
	u16 type: 5;
	u16 dpl: 2;
	u16 p: 1;
	u16 limit1: 4;
	u16 zero0: 3;
	u16 g: 1;
	u16 base2: 8;
	u32 base3;
	u32 zero1;
};

typedef struct ldttss_desc tss_desc;

enum lockdown_reason {
	LOCKDOWN_NONE = 0,
	LOCKDOWN_MODULE_SIGNATURE = 1,
	LOCKDOWN_DEV_MEM = 2,
	LOCKDOWN_EFI_TEST = 3,
	LOCKDOWN_KEXEC = 4,
	LOCKDOWN_HIBERNATION = 5,
	LOCKDOWN_PCI_ACCESS = 6,
	LOCKDOWN_IOPORT = 7,
	LOCKDOWN_MSR = 8,
	LOCKDOWN_ACPI_TABLES = 9,
	LOCKDOWN_PCMCIA_CIS = 10,
	LOCKDOWN_TIOCSSERIAL = 11,
	LOCKDOWN_MODULE_PARAMETERS = 12,
	LOCKDOWN_MMIOTRACE = 13,
	LOCKDOWN_DEBUGFS = 14,
	LOCKDOWN_XMON_WR = 15,
	LOCKDOWN_INTEGRITY_MAX = 16,
	LOCKDOWN_KCORE = 17,
	LOCKDOWN_KPROBES = 18,
	LOCKDOWN_BPF_READ = 19,
	LOCKDOWN_PERF = 20,
	LOCKDOWN_TRACEFS = 21,
	LOCKDOWN_XMON_RW = 22,
	LOCKDOWN_CONFIDENTIALITY_MAX = 23,
};

typedef bool pto_T_____8;

enum lockdep_ok {
	LOCKDEP_STILL_OK = 0,
	LOCKDEP_NOW_UNRELIABLE = 1,
};

typedef long unsigned int uintptr_t;

struct trace_event_raw_nmi_handler {
	struct trace_entry ent;
	void *handler;
	s64 delta_ns;
	int handled;
	char __data[0];
};

struct trace_event_data_offsets_nmi_handler {};

typedef void (*btf_trace_nmi_handler)(void *, void *, s64, int);

struct nmi_desc {
	raw_spinlock_t lock;
	struct list_head head;
};

struct nmi_stats {
	unsigned int normal;
	unsigned int unknown;
	unsigned int external;
	unsigned int swallow;
};

enum nmi_states {
	NMI_NOT_RUNNING = 0,
	NMI_EXECUTING = 1,
	NMI_LATCHED = 2,
};

typedef enum nmi_states pto_T_____9;

typedef struct ldttss_desc ldt_desc;

struct user_desc {
	unsigned int entry_number;
	unsigned int base_addr;
	unsigned int limit;
	unsigned int seg_32bit: 1;
	unsigned int contents: 2;
	unsigned int read_exec_only: 1;
	unsigned int limit_in_pages: 1;
	unsigned int seg_not_present: 1;
	unsigned int useable: 1;
	unsigned int lm: 1;
};

struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block *head;
};

struct setup_data {
	__u64 next;
	__u32 type;
	__u32 len;
	__u8 data[0];
};

struct plist_head {
	struct list_head node_list;
};

struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block *head;
};

enum pm_qos_type {
	PM_QOS_UNITIALIZED = 0,
	PM_QOS_MAX = 1,
	PM_QOS_MIN = 2,
	PM_QOS_SUM = 3,
};

struct pm_qos_constraints {
	struct plist_head list;
	s32 target_value;
	s32 default_value;
	s32 no_constraint_value;
	enum pm_qos_type type;
	struct blocking_notifier_head *notifiers;
};

struct pm_qos_flags {
	struct list_head list;
	s32 effective_flags;
};

struct dev_pm_qos_request;

struct dev_pm_qos {
	struct pm_qos_constraints resume_latency;
	struct pm_qos_constraints latency_tolerance;
	struct pm_qos_flags flags;
	struct dev_pm_qos_request *resume_latency_req;
	struct dev_pm_qos_request *latency_tolerance_req;
	struct dev_pm_qos_request *flags_req;
};

enum memblock_flags {
	MEMBLOCK_NONE = 0,
	MEMBLOCK_HOTPLUG = 1,
	MEMBLOCK_MIRROR = 2,
	MEMBLOCK_NOMAP = 4,
};

struct memblock_region {
	phys_addr_t base;
	phys_addr_t size;
	enum memblock_flags flags;
	int nid;
};

struct memblock_type {
	long unsigned int cnt;
	long unsigned int max;
	phys_addr_t total_size;
	struct memblock_region *regions;
	char *name;
};

struct memblock {
	bool bottom_up;
	phys_addr_t current_limit;
	struct memblock_type memory;
	struct memblock_type reserved;
};

enum con_scroll {
	SM_UP = 0,
	SM_DOWN = 1,
};

struct vc_data;

struct console_font;

struct consw {
	struct module *owner;
	const char * (*con_startup)();
	void (*con_init)(struct vc_data *, int);
	void (*con_deinit)(struct vc_data *);
	void (*con_clear)(struct vc_data *, int, int, int, int);
	void (*con_putc)(struct vc_data *, int, int, int);
	void (*con_putcs)(struct vc_data *, const short unsigned int *, int, int, int);
	void (*con_cursor)(struct vc_data *, int);
	bool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);
	int (*con_switch)(struct vc_data *);
	int (*con_blank)(struct vc_data *, int, int);
	int (*con_font_set)(struct vc_data *, struct console_font *, unsigned int);
	int (*con_font_get)(struct vc_data *, struct console_font *);
	int (*con_font_default)(struct vc_data *, struct console_font *, char *);
	int (*con_font_copy)(struct vc_data *, int);
	int (*con_resize)(struct vc_data *, unsigned int, unsigned int, unsigned int);
	void (*con_set_palette)(struct vc_data *, const unsigned char *);
	void (*con_scrolldelta)(struct vc_data *, int);
	int (*con_set_origin)(struct vc_data *);
	void (*con_save_screen)(struct vc_data *);
	u8 (*con_build_attr)(struct vc_data *, u8, u8, u8, u8, u8, u8);
	void (*con_invert_region)(struct vc_data *, u16 *, int);
	u16 * (*con_screen_pos)(struct vc_data *, int);
	long unsigned int (*con_getxy)(struct vc_data *, long unsigned int, int *, int *);
	void (*con_flush_scrollback)(struct vc_data *);
	int (*con_debug_enter)(struct vc_data *);
	int (*con_debug_leave)(struct vc_data *);
};

enum efi_secureboot_mode {
	efi_secureboot_mode_unset = 0,
	efi_secureboot_mode_unknown = 1,
	efi_secureboot_mode_disabled = 2,
	efi_secureboot_mode_enabled = 3,
};

enum xen_domain_type {
	XEN_NATIVE = 0,
	XEN_PV_DOMAIN = 1,
	XEN_HVM_DOMAIN = 2,
};

struct pm_qos_flags_request {
	struct list_head node;
	s32 flags;
};

enum dev_pm_qos_req_type {
	DEV_PM_QOS_RESUME_LATENCY = 1,
	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
	DEV_PM_QOS_FLAGS = 3,
};

struct dev_pm_qos_request {
	enum dev_pm_qos_req_type type;
	union {
		struct plist_node pnode;
		struct pm_qos_flags_request flr;
	} data;
	struct device *dev;
};

struct e820_entry {
	u64 addr;
	u64 size;
	enum e820_type type;
} __attribute__((packed));

struct e820_table {
	__u32 nr_entries;
	struct e820_entry entries[3200];
} __attribute__((packed));

struct x86_cpuinit_ops {
	void (*setup_percpu_clockev)();
	void (*early_percpu_clock_init)();
	void (*fixup_cpu_id)(struct cpuinfo_x86 *, int);
};

struct x86_msi_ops {
	int (*setup_msi_irqs)(struct pci_dev *, int, int);
	void (*teardown_msi_irq)(unsigned int);
	void (*teardown_msi_irqs)(struct pci_dev *);
	void (*restore_msi_irqs)(struct pci_dev *);
};

struct x86_apic_ops {
	unsigned int (*io_apic_read)(unsigned int, unsigned int);
	void (*restore)();
};

struct irq_affinity_desc {
	struct cpumask mask;
	unsigned int is_managed: 1;
};

struct msi_controller {
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct list_head list;
	int (*setup_irq)(struct msi_controller *, struct pci_dev *, struct msi_desc *);
	int (*setup_irqs)(struct msi_controller *, struct pci_dev *, int, int);
	void (*teardown_irq)(struct msi_controller *, unsigned int);
};

struct msi_msg {
	u32 address_lo;
	u32 address_hi;
	u32 data;
};

struct platform_msi_priv_data;

struct platform_msi_desc {
	struct platform_msi_priv_data *msi_priv_data;
	u16 msi_index;
};

struct fsl_mc_msi_desc {
	u16 msi_index;
};

struct ti_sci_inta_msi_desc {
	u16 dev_index;
};

struct msi_desc {
	struct list_head list;
	unsigned int irq;
	unsigned int nvec_used;
	struct device *dev;
	struct msi_msg msg;
	struct irq_affinity_desc *affinity;
	void (*write_msi_msg)(struct msi_desc *, void *);
	void *write_msi_msg_data;
	union {
		struct {
			u32 masked;
			struct {
				u8 is_msix: 1;
				u8 multiple: 3;
				u8 multi_cap: 3;
				u8 maskbit: 1;
				u8 is_64: 1;
				u8 is_virtual: 1;
				u16 entry_nr;
				unsigned int default_irq;
			} msi_attrib;
			union {
				u8 mask_pos;
				void *mask_base;
			};
		};
		struct platform_msi_desc platform;
		struct fsl_mc_msi_desc fsl_mc;
		struct ti_sci_inta_msi_desc inta;
	};
};

struct irq_chip_regs {
	long unsigned int enable;
	long unsigned int disable;
	long unsigned int mask;
	long unsigned int ack;
	long unsigned int eoi;
	long unsigned int type;
	long unsigned int polarity;
};

struct irq_chip_type {
	struct irq_chip chip;
	struct irq_chip_regs regs;
	irq_flow_handler_t handler;
	u32 type;
	u32 mask_cache_priv;
	u32 *mask_cache;
};

struct irq_chip_generic {
	raw_spinlock_t lock;
	void *reg_base;
	u32 (*reg_readl)(void *);
	void (*reg_writel)(u32, void *);
	void (*suspend)(struct irq_chip_generic *);
	void (*resume)(struct irq_chip_generic *);
	unsigned int irq_base;
	unsigned int irq_cnt;
	u32 mask_cache;
	u32 type_cache;
	u32 polarity_cache;
	u32 wake_enabled;
	u32 wake_active;
	unsigned int num_ct;
	void *private;
	long unsigned int installed;
	long unsigned int unused;
	struct irq_domain *domain;
	struct list_head list;
	struct irq_chip_type chip_types[0];
};

enum irq_gc_flags {
	IRQ_GC_INIT_MASK_CACHE = 1,
	IRQ_GC_INIT_NESTED_LOCK = 2,
	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
	IRQ_GC_NO_MASK = 8,
	IRQ_GC_BE_IO = 16,
};

struct irq_domain_chip_generic {
	unsigned int irqs_per_chip;
	unsigned int num_chips;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	struct irq_chip_generic *gc[0];
};

struct legacy_pic {
	int nr_legacy_irqs;
	struct irq_chip *chip;
	void (*mask)(unsigned int);
	void (*unmask)(unsigned int);
	void (*mask_all)();
	void (*restore_mask)();
	void (*init)(int);
	int (*probe)();
	int (*irq_pending)(unsigned int);
	void (*make_irq)(unsigned int);
};

struct vm_unmapped_area_info {
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
};

enum align_flags {
	ALIGN_VA_32 = 1,
	ALIGN_VA_64 = 2,
};

struct va_alignment {
	int flags;
	long unsigned int mask;
	long unsigned int bits;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kobj_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
};

enum {
	MEMREMAP_WB = 1,
	MEMREMAP_WT = 2,
	MEMREMAP_WC = 4,
	MEMREMAP_ENC = 8,
	MEMREMAP_DEC = 16,
};

enum {
	IORES_DESC_NONE = 0,
	IORES_DESC_CRASH_KERNEL = 1,
	IORES_DESC_ACPI_TABLES = 2,
	IORES_DESC_ACPI_NV_STORAGE = 3,
	IORES_DESC_PERSISTENT_MEMORY = 4,
	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
	IORES_DESC_RESERVED = 7,
};

struct change_member {
	struct e820_entry *entry;
	long long unsigned int addr;
};

struct iommu_fwspec {
	const struct iommu_ops *ops;
	struct fwnode_handle *iommu_fwnode;
	void *iommu_priv;
	u32 flags;
	unsigned int num_ids;
	u32 ids[1];
};

struct iommu_fault_param;

struct iommu_param {
	struct mutex lock;
	struct iommu_fault_param *fault_param;
};

struct of_phandle_args {
	struct device_node *np;
	int args_count;
	uint32_t args[16];
};

struct iommu_fault_unrecoverable {
	__u32 reason;
	__u32 flags;
	__u32 pasid;
	__u32 perm;
	__u64 addr;
	__u64 fetch_addr;
};

struct iommu_fault_page_request {
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 perm;
	__u64 addr;
	__u64 private_data[2];
};

struct iommu_fault {
	__u32 type;
	__u32 padding;
	union {
		struct iommu_fault_unrecoverable event;
		struct iommu_fault_page_request prm;
		__u8 padding2[56];
	};
};

struct iommu_page_response {
	__u32 version;
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 code;
};

typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);

struct iommu_domain_geometry {
	dma_addr_t aperture_start;
	dma_addr_t aperture_end;
	bool force_aperture;
};

struct iommu_domain {
	unsigned int type;
	const struct iommu_ops *ops;
	long unsigned int pgsize_bitmap;
	iommu_fault_handler_t handler;
	void *handler_token;
	struct iommu_domain_geometry geometry;
	void *iova_cookie;
};

typedef int (*iommu_mm_exit_handler_t)(struct device *, struct iommu_sva *, void *);

struct iommu_sva_ops;

struct iommu_sva {
	struct device *dev;
	const struct iommu_sva_ops *ops;
};

typedef int (*iommu_dev_fault_handler_t)(struct iommu_fault *, void *);

enum iommu_resv_type {
	IOMMU_RESV_DIRECT = 0,
	IOMMU_RESV_DIRECT_RELAXABLE = 1,
	IOMMU_RESV_RESERVED = 2,
	IOMMU_RESV_MSI = 3,
	IOMMU_RESV_SW_MSI = 4,
};

struct iommu_resv_region {
	struct list_head list;
	phys_addr_t start;
	size_t length;
	int prot;
	enum iommu_resv_type type;
};

struct iommu_sva_ops {
	iommu_mm_exit_handler_t mm_exit;
};

struct iommu_iotlb_gather {
	long unsigned int start;
	long unsigned int end;
	size_t pgsize;
};

struct iommu_fault_event {
	struct iommu_fault fault;
	struct list_head list;
};

struct iommu_fault_param {
	iommu_dev_fault_handler_t handler;
	void *data;
	struct list_head faults;
	struct mutex lock;
};

struct iommu_table_entry {
	initcall_t detect;
	initcall_t depend;
	void (*early_init)();
	void (*late_init)();
	int flags;
};

enum dmi_field {
	DMI_NONE = 0,
	DMI_BIOS_VENDOR = 1,
	DMI_BIOS_VERSION = 2,
	DMI_BIOS_DATE = 3,
	DMI_SYS_VENDOR = 4,
	DMI_PRODUCT_NAME = 5,
	DMI_PRODUCT_VERSION = 6,
	DMI_PRODUCT_SERIAL = 7,
	DMI_PRODUCT_UUID = 8,
	DMI_PRODUCT_SKU = 9,
	DMI_PRODUCT_FAMILY = 10,
	DMI_BOARD_VENDOR = 11,
	DMI_BOARD_NAME = 12,
	DMI_BOARD_VERSION = 13,
	DMI_BOARD_SERIAL = 14,
	DMI_BOARD_ASSET_TAG = 15,
	DMI_CHASSIS_VENDOR = 16,
	DMI_CHASSIS_TYPE = 17,
	DMI_CHASSIS_VERSION = 18,
	DMI_CHASSIS_SERIAL = 19,
	DMI_CHASSIS_ASSET_TAG = 20,
	DMI_STRING_MAX = 21,
	DMI_OEM_STRING = 22,
};

enum {
	NONE_FORCE_HPET_RESUME = 0,
	OLD_ICH_FORCE_HPET_RESUME = 1,
	ICH_FORCE_HPET_RESUME = 2,
	VT8237_FORCE_HPET_RESUME = 3,
	NVIDIA_FORCE_HPET_RESUME = 4,
	ATI_FORCE_HPET_RESUME = 5,
};

enum meminit_context {
	MEMINIT_EARLY = 0,
	MEMINIT_HOTPLUG = 1,
};

struct cpu {
	int node_id;
	int hotpluggable;
	struct device dev;
};

struct x86_cpu {
	struct cpu cpu;
};

struct debugfs_blob_wrapper {
	void *data;
	long unsigned int size;
};

struct setup_data_node {
	u64 paddr;
	u32 type;
	u32 len;
};

struct paravirt_patch_site {
	u8 *instr;
	u8 type;
	u8 len;
};

struct die_args {
	struct pt_regs *regs;
	const char *str;
	long int err;
	int trapnr;
	int signr;
};

typedef struct {
	struct mm_struct *mm;
} temp_mm_state_t;

struct text_poke_loc {
	void *detour;
	void *addr;
	size_t len;
	const char opcode[5];
};

struct smp_alt_module {
	struct module *mod;
	char *name;
	const s32 *locks;
	const s32 *locks_end;
	u8 *text;
	u8 *text_end;
	struct list_head next;
};

struct bp_patching_desc {
	struct text_poke_loc *vec;
	int nr_entries;
};

struct user_i387_struct {
	short unsigned int cwd;
	short unsigned int swd;
	short unsigned int twd;
	short unsigned int fop;
	__u64 rip;
	__u64 rdp;
	__u32 mxcsr;
	__u32 mxcsr_mask;
	__u32 st_space[32];
	__u32 xmm_space[64];
	__u32 padding[24];
};

struct user_regs_struct {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bp;
	long unsigned int bx;
	long unsigned int r11;
	long unsigned int r10;
	long unsigned int r9;
	long unsigned int r8;
	long unsigned int ax;
	long unsigned int cx;
	long unsigned int dx;
	long unsigned int si;
	long unsigned int di;
	long unsigned int orig_ax;
	long unsigned int ip;
	long unsigned int cs;
	long unsigned int flags;
	long unsigned int sp;
	long unsigned int ss;
	long unsigned int fs_base;
	long unsigned int gs_base;
	long unsigned int ds;
	long unsigned int es;
	long unsigned int fs;
	long unsigned int gs;
};

struct user {
	struct user_regs_struct regs;
	int u_fpvalid;
	int pad0;
	struct user_i387_struct i387;
	long unsigned int u_tsize;
	long unsigned int u_dsize;
	long unsigned int u_ssize;
	long unsigned int start_code;
	long unsigned int start_stack;
	long int signal;
	int reserved;
	int pad1;
	long unsigned int u_ar0;
	struct user_i387_struct *u_fpstate;
	long unsigned int magic;
	char u_comm[32];
	long unsigned int u_debugreg[8];
	long unsigned int error_code;
	long unsigned int fault_address;
};

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_3 = 3,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_5 = 5,
	HW_BREAKPOINT_LEN_6 = 6,
	HW_BREAKPOINT_LEN_7 = 7,
	HW_BREAKPOINT_LEN_8 = 8,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = 3,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = 7,
};

typedef unsigned int u_int;

typedef long long unsigned int cycles_t;

struct system_counterval_t {
	u64 cycles;
	struct clocksource *cs;
};

enum freq_qos_req_type {
	FREQ_QOS_MIN = 1,
	FREQ_QOS_MAX = 2,
};

struct freq_constraints {
	struct pm_qos_constraints min_freq;
	struct blocking_notifier_head min_freq_notifiers;
	struct pm_qos_constraints max_freq;
	struct blocking_notifier_head max_freq_notifiers;
};

struct freq_qos_request {
	enum freq_qos_req_type type;
	struct plist_node pnode;
	struct freq_constraints *qos;
};

enum cpufreq_table_sorting {
	CPUFREQ_TABLE_UNSORTED = 0,
	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
};

struct cpufreq_cpuinfo {
	unsigned int max_freq;
	unsigned int min_freq;
	unsigned int transition_latency;
};

struct cpufreq_stats;

struct clk;

struct cpufreq_governor;

struct cpufreq_frequency_table;

struct thermal_cooling_device;

struct cpufreq_policy {
	cpumask_var_t cpus;
	cpumask_var_t related_cpus;
	cpumask_var_t real_cpus;
	unsigned int shared_type;
	unsigned int cpu;
	struct clk *clk;
	struct cpufreq_cpuinfo cpuinfo;
	unsigned int min;
	unsigned int max;
	unsigned int cur;
	unsigned int restore_freq;
	unsigned int suspend_freq;
	unsigned int policy;
	unsigned int last_policy;
	struct cpufreq_governor *governor;
	void *governor_data;
	char last_governor[16];
	struct work_struct update;
	struct freq_constraints constraints;
	struct freq_qos_request *min_freq_req;
	struct freq_qos_request *max_freq_req;
	struct cpufreq_frequency_table *freq_table;
	enum cpufreq_table_sorting freq_table_sorted;
	struct list_head policy_list;
	struct kobject kobj;
	struct completion kobj_unregister;
	struct rw_semaphore rwsem;
	bool fast_switch_possible;
	bool fast_switch_enabled;
	unsigned int transition_delay_us;
	bool dvfs_possible_from_any_cpu;
	unsigned int cached_target_freq;
	int cached_resolved_idx;
	bool transition_ongoing;
	spinlock_t transition_lock;
	wait_queue_head_t transition_wait;
	struct task_struct *transition_task;
	struct cpufreq_stats *stats;
	void *driver_data;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct cpufreq_governor {
	char name[16];
	int (*init)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*start)(struct cpufreq_policy *);
	void (*stop)(struct cpufreq_policy *);
	void (*limits)(struct cpufreq_policy *);
	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
	bool dynamic_switching;
	struct list_head governor_list;
	struct module *owner;
};

struct cpufreq_frequency_table {
	unsigned int flags;
	unsigned int driver_data;
	unsigned int frequency;
};

struct cpufreq_freqs {
	struct cpufreq_policy *policy;
	unsigned int old;
	unsigned int new;
	u8 flags;
};

struct cyc2ns {
	struct cyc2ns_data data[2];
	seqcount_t seq;
};

struct muldiv {
	u32 multiplier;
	u32 divider;
};

struct freq_desc {
	bool use_msr_plat;
	struct muldiv muldiv[16];
	u32 freqs[16];
	u32 mask;
};

struct dmi_strmatch {
	unsigned char slot: 7;
	unsigned char exact_match: 1;
	char substr[79];
};

struct dmi_system_id {
	int (*callback)(const struct dmi_system_id *);
	const char *ident;
	struct dmi_strmatch matches[4];
	void *driver_data;
};

struct pdev_archdata {};

struct mfd_cell;

struct platform_device_id;

struct platform_device {
	const char *name;
	int id;
	bool id_auto;
	struct device dev;
	u64 platform_dma_mask;
	u32 num_resources;
	struct resource *resource;
	const struct platform_device_id *id_entry;
	char *driver_override;
	struct mfd_cell *mfd_cell;
	struct pdev_archdata archdata;
};

struct platform_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct rtc_time {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};

struct pnp_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
};

struct pnp_card_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
	struct {
		__u8 id[8];
	} devs[8];
};

struct acpi_table_header {
	char signature[4];
	u32 length;
	u8 revision;
	u8 checksum;
	char oem_id[6];
	char oem_table_id[8];
	u32 oem_revision;
	char asl_compiler_id[4];
	u32 asl_compiler_revision;
};

struct acpi_generic_address {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct acpi_table_fadt {
	struct acpi_table_header header;
	u32 facs;
	u32 dsdt;
	u8 model;
	u8 preferred_profile;
	u16 sci_interrupt;
	u32 smi_command;
	u8 acpi_enable;
	u8 acpi_disable;
	u8 s4_bios_request;
	u8 pstate_control;
	u32 pm1a_event_block;
	u32 pm1b_event_block;
	u32 pm1a_control_block;
	u32 pm1b_control_block;
	u32 pm2_control_block;
	u32 pm_timer_block;
	u32 gpe0_block;
	u32 gpe1_block;
	u8 pm1_event_length;
	u8 pm1_control_length;
	u8 pm2_control_length;
	u8 pm_timer_length;
	u8 gpe0_block_length;
	u8 gpe1_block_length;
	u8 gpe1_base;
	u8 cst_control;
	u16 c2_latency;
	u16 c3_latency;
	u16 flush_size;
	u16 flush_stride;
	u8 duty_offset;
	u8 duty_width;
	u8 day_alarm;
	u8 month_alarm;
	u8 century;
	u16 boot_flags;
	u8 reserved;
	u32 flags;
	struct acpi_generic_address reset_register;
	u8 reset_value;
	u16 arm_boot_flags;
	u8 minor_revision;
	u64 Xfacs;
	u64 Xdsdt;
	struct acpi_generic_address xpm1a_event_block;
	struct acpi_generic_address xpm1b_event_block;
	struct acpi_generic_address xpm1a_control_block;
	struct acpi_generic_address xpm1b_control_block;
	struct acpi_generic_address xpm2_control_block;
	struct acpi_generic_address xpm_timer_block;
	struct acpi_generic_address xgpe0_block;
	struct acpi_generic_address xgpe1_block;
	struct acpi_generic_address sleep_control;
	struct acpi_generic_address sleep_status;
	u64 hypervisor_id;
} __attribute__((packed));

struct pnp_protocol;

struct pnp_id;

struct pnp_card {
	struct device dev;
	unsigned char number;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head devices;
	struct pnp_protocol *protocol;
	struct pnp_id *id;
	char name[50];
	unsigned char pnpver;
	unsigned char productver;
	unsigned int serial;
	unsigned char checksum;
	struct proc_dir_entry *procdir;
};

struct pnp_dev;

struct pnp_protocol {
	struct list_head protocol_list;
	char *name;
	int (*get)(struct pnp_dev *);
	int (*set)(struct pnp_dev *);
	int (*disable)(struct pnp_dev *);
	bool (*can_wakeup)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	unsigned char number;
	struct device dev;
	struct list_head cards;
	struct list_head devices;
};

struct pnp_id {
	char id[8];
	struct pnp_id *next;
};

struct pnp_card_driver;

struct pnp_card_link {
	struct pnp_card *card;
	struct pnp_card_driver *driver;
	void *driver_data;
	pm_message_t pm_state;
};

struct pnp_driver {
	char *name;
	const struct pnp_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_dev *, const struct pnp_device_id *);
	void (*remove)(struct pnp_dev *);
	void (*shutdown)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	struct device_driver driver;
};

struct pnp_card_driver {
	struct list_head global_list;
	char *name;
	const struct pnp_card_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_card_link *, const struct pnp_card_device_id *);
	void (*remove)(struct pnp_card_link *);
	int (*suspend)(struct pnp_card_link *, pm_message_t);
	int (*resume)(struct pnp_card_link *);
	struct pnp_driver link;
};

struct pnp_dev {
	struct device dev;
	u64 dma_mask;
	unsigned int number;
	int status;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head card_list;
	struct list_head rdev_list;
	struct pnp_protocol *protocol;
	struct pnp_card *card;
	struct pnp_driver *driver;
	struct pnp_card_link *card_link;
	struct pnp_id *id;
	int active;
	int capabilities;
	unsigned int num_dependent_sets;
	struct list_head resources;
	struct list_head options;
	char name[50];
	int flags;
	struct proc_dir_entry *procent;
	void *data;
};

enum idle_boot_override {
	IDLE_NO_OVERRIDE = 0,
	IDLE_HALT = 1,
	IDLE_NOMWAIT = 2,
	IDLE_POLL = 3,
};

enum tick_broadcast_mode {
	TICK_BROADCAST_OFF = 0,
	TICK_BROADCAST_ON = 1,
	TICK_BROADCAST_FORCE = 2,
};

enum tick_broadcast_state {
	TICK_BROADCAST_EXIT = 0,
	TICK_BROADCAST_ENTER = 1,
};

struct inactive_task_frame {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bx;
	long unsigned int bp;
	long unsigned int ret_addr;
};

struct fork_frame {
	struct inactive_task_frame frame;
	struct pt_regs regs;
};

struct ssb_state {
	struct ssb_state *shared_state;
	raw_spinlock_t lock;
	unsigned int disable_state;
	long unsigned int local_state;
};

struct trace_event_raw_x86_fpu {
	struct trace_entry ent;
	struct fpu *fpu;
	bool load_fpu;
	u64 xfeatures;
	u64 xcomp_bv;
	char __data[0];
};

struct trace_event_data_offsets_x86_fpu {};

typedef void (*btf_trace_x86_fpu_before_save)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_after_save)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_before_restore)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_after_restore)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_regs_activated)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_regs_deactivated)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_init_state)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_dropped)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_copy_src)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_copy_dst)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_xstate_check_failed)(void *, struct fpu *);

typedef struct fpu *pto_T_____10;

struct _fpreg {
	__u16 significand[4];
	__u16 exponent;
};

struct _fpxreg {
	__u16 significand[4];
	__u16 exponent;
	__u16 padding[3];
};

struct user_i387_ia32_struct {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
};

struct user_regset;

typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);

typedef int user_regset_get_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, void *, void *);

typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void *);

typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);

typedef unsigned int user_regset_get_size_fn(struct task_struct *, const struct user_regset *);

struct user_regset {
	user_regset_get_fn *get;
	user_regset_set_fn *set;
	user_regset_active_fn *active;
	user_regset_writeback_fn *writeback;
	user_regset_get_size_fn *get_size;
	unsigned int n;
	unsigned int size;
	unsigned int align;
	unsigned int bias;
	unsigned int core_note_type;
};

struct _fpx_sw_bytes {
	__u32 magic1;
	__u32 extended_size;
	__u64 xfeatures;
	__u32 xstate_size;
	__u32 padding[7];
};

struct _xmmreg {
	__u32 element[4];
};

struct _fpstate_32 {
	__u32 cw;
	__u32 sw;
	__u32 tag;
	__u32 ipoff;
	__u32 cssel;
	__u32 dataoff;
	__u32 datasel;
	struct _fpreg _st[8];
	__u16 status;
	__u16 magic;
	__u32 _fxsr_env[6];
	__u32 mxcsr;
	__u32 reserved;
	struct _fpxreg _fxsr_st[8];
	struct _xmmreg _xmm[8];
	union {
		__u32 padding1[44];
		__u32 padding[44];
	};
	union {
		__u32 padding2[12];
		struct _fpx_sw_bytes sw_reserved;
	};
};

typedef u32 compat_ulong_t;

struct user_regset_view {
	const char *name;
	const struct user_regset *regsets;
	unsigned int n;
	u32 e_flags;
	u16 e_machine;
	u8 ei_osabi;
};

enum x86_regset {
	REGSET_GENERAL = 0,
	REGSET_FP = 1,
	REGSET_XFP = 2,
	REGSET_IOPERM64 = 2,
	REGSET_XSTATE = 3,
	REGSET_TLS = 4,
	REGSET_IOPERM32 = 5,
};

struct pt_regs_offset {
	const char *name;
	int offset;
};

typedef bool (*stack_trace_consume_fn)(void *, long unsigned int, bool);

struct stack_frame_user {
	const void *next_fp;
	long unsigned int ret_addr;
};

enum cache_type {
	CACHE_TYPE_NOCACHE = 0,
	CACHE_TYPE_INST = 1,
	CACHE_TYPE_DATA = 2,
	CACHE_TYPE_SEPARATE = 3,
	CACHE_TYPE_UNIFIED = 4,
};

struct cacheinfo {
	unsigned int id;
	enum cache_type type;
	unsigned int level;
	unsigned int coherency_line_size;
	unsigned int number_of_sets;
	unsigned int ways_of_associativity;
	unsigned int physical_line_partition;
	unsigned int size;
	cpumask_t shared_cpu_map;
	unsigned int attributes;
	void *fw_token;
	bool disable_sysfs;
	void *priv;
};

struct cpu_cacheinfo {
	struct cacheinfo *info_list;
	unsigned int num_levels;
	unsigned int num_leaves;
	bool cpu_map_populated;
};

struct amd_l3_cache {
	unsigned int indices;
	u8 subcaches[4];
};

struct threshold_block {
	unsigned int block;
	unsigned int bank;
	unsigned int cpu;
	u32 address;
	u16 interrupt_enable;
	bool interrupt_capable;
	u16 threshold_limit;
	struct kobject kobj;
	struct list_head miscj;
};

struct threshold_bank {
	struct kobject *kobj;
	struct threshold_block *blocks;
	refcount_t cpus;
};

struct amd_northbridge {
	struct pci_dev *root;
	struct pci_dev *misc;
	struct pci_dev *link;
	struct amd_l3_cache l3_cache;
	struct threshold_bank *bank4;
};

struct _cache_table {
	unsigned char descriptor;
	char cache_type;
	short int size;
};

enum _cache_type {
	CTYPE_NULL = 0,
	CTYPE_DATA = 1,
	CTYPE_INST = 2,
	CTYPE_UNIFIED = 3,
};

union _cpuid4_leaf_eax {
	struct {
		enum _cache_type type: 5;
		unsigned int level: 3;
		unsigned int is_self_initializing: 1;
		unsigned int is_fully_associative: 1;
		unsigned int reserved: 4;
		unsigned int num_threads_sharing: 12;
		unsigned int num_cores_on_die: 6;
	} split;
	u32 full;
};

union _cpuid4_leaf_ebx {
	struct {
		unsigned int coherency_line_size: 12;
		unsigned int physical_line_partition: 10;
		unsigned int ways_of_associativity: 10;
	} split;
	u32 full;
};

union _cpuid4_leaf_ecx {
	struct {
		unsigned int number_of_sets: 32;
	} split;
	u32 full;
};

struct _cpuid4_info_regs {
	union _cpuid4_leaf_eax eax;
	union _cpuid4_leaf_ebx ebx;
	union _cpuid4_leaf_ecx ecx;
	unsigned int id;
	long unsigned int size;
	struct amd_northbridge *nb;
};

union l1_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 8;
		unsigned int assoc: 8;
		unsigned int size_in_kb: 8;
	};
	unsigned int val;
};

union l2_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 4;
		unsigned int assoc: 4;
		unsigned int size_in_kb: 16;
	};
	unsigned int val;
};

union l3_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 4;
		unsigned int assoc: 4;
		unsigned int res: 2;
		unsigned int size_encoded: 14;
	};
	unsigned int val;
};

struct cpuid_bit {
	u16 feature;
	u8 reg;
	u8 bit;
	u32 level;
	u32 sub_leaf;
};

enum cpuid_leafs {
	CPUID_1_EDX = 0,
	CPUID_8000_0001_EDX = 1,
	CPUID_8086_0001_EDX = 2,
	CPUID_LNX_1 = 3,
	CPUID_1_ECX = 4,
	CPUID_C000_0001_EDX = 5,
	CPUID_8000_0001_ECX = 6,
	CPUID_LNX_2 = 7,
	CPUID_LNX_3 = 8,
	CPUID_7_0_EBX = 9,
	CPUID_D_1_EAX = 10,
	CPUID_LNX_4 = 11,
	CPUID_7_1_EAX = 12,
	CPUID_8000_0008_EBX = 13,
	CPUID_6_EAX = 14,
	CPUID_8000_000A_EDX = 15,
	CPUID_7_ECX = 16,
	CPUID_8000_0007_EBX = 17,
	CPUID_7_EDX = 18,
};

struct cpu_dev {
	const char *c_vendor;
	const char *c_ident[2];
	void (*c_early_init)(struct cpuinfo_x86 *);
	void (*c_bsp_init)(struct cpuinfo_x86 *);
	void (*c_init)(struct cpuinfo_x86 *);
	void (*c_identify)(struct cpuinfo_x86 *);
	void (*c_detect_tlb)(struct cpuinfo_x86 *);
	int c_x86_vendor;
};

struct cpuid_dependent_feature {
	u32 feature;
	u32 level;
};

typedef u32 pao_T_____3;

enum spectre_v2_mitigation {
	SPECTRE_V2_NONE = 0,
	SPECTRE_V2_RETPOLINE_GENERIC = 1,
	SPECTRE_V2_RETPOLINE_AMD = 2,
	SPECTRE_V2_IBRS_ENHANCED = 3,
};

enum spectre_v2_user_mitigation {
	SPECTRE_V2_USER_NONE = 0,
	SPECTRE_V2_USER_STRICT = 1,
	SPECTRE_V2_USER_STRICT_PREFERRED = 2,
	SPECTRE_V2_USER_PRCTL = 3,
	SPECTRE_V2_USER_SECCOMP = 4,
};

enum ssb_mitigation {
	SPEC_STORE_BYPASS_NONE = 0,
	SPEC_STORE_BYPASS_DISABLE = 1,
	SPEC_STORE_BYPASS_PRCTL = 2,
	SPEC_STORE_BYPASS_SECCOMP = 3,
};

enum l1tf_mitigations {
	L1TF_MITIGATION_OFF = 0,
	L1TF_MITIGATION_FLUSH_NOWARN = 1,
	L1TF_MITIGATION_FLUSH = 2,
	L1TF_MITIGATION_FLUSH_NOSMT = 3,
	L1TF_MITIGATION_FULL = 4,
	L1TF_MITIGATION_FULL_FORCE = 5,
};

enum mds_mitigations {
	MDS_MITIGATION_OFF = 0,
	MDS_MITIGATION_FULL = 1,
	MDS_MITIGATION_VMWERV = 2,
};

enum taa_mitigations {
	TAA_MITIGATION_OFF = 0,
	TAA_MITIGATION_UCODE_NEEDED = 1,
	TAA_MITIGATION_VERW = 2,
	TAA_MITIGATION_TSX_DISABLED = 3,
};

enum cpuhp_smt_control {
	CPU_SMT_ENABLED = 0,
	CPU_SMT_DISABLED = 1,
	CPU_SMT_FORCE_DISABLED = 2,
	CPU_SMT_NOT_SUPPORTED = 3,
	CPU_SMT_NOT_IMPLEMENTED = 4,
};

enum vmx_l1d_flush_state {
	VMENTER_L1D_FLUSH_AUTO = 0,
	VMENTER_L1D_FLUSH_NEVER = 1,
	VMENTER_L1D_FLUSH_COND = 2,
	VMENTER_L1D_FLUSH_ALWAYS = 3,
	VMENTER_L1D_FLUSH_EPT_DISABLED = 4,
	VMENTER_L1D_FLUSH_NOT_REQUIRED = 5,
};

enum srbds_mitigations {
	SRBDS_MITIGATION_OFF = 0,
	SRBDS_MITIGATION_UCODE_NEEDED = 1,
	SRBDS_MITIGATION_FULL = 2,
	SRBDS_MITIGATION_TSX_OFF = 3,
	SRBDS_MITIGATION_HYPERVISOR = 4,
};

enum spectre_v1_mitigation {
	SPECTRE_V1_MITIGATION_NONE = 0,
	SPECTRE_V1_MITIGATION_AUTO = 1,
};

enum spectre_v2_mitigation_cmd {
	SPECTRE_V2_CMD_NONE = 0,
	SPECTRE_V2_CMD_AUTO = 1,
	SPECTRE_V2_CMD_FORCE = 2,
	SPECTRE_V2_CMD_RETPOLINE = 3,
	SPECTRE_V2_CMD_RETPOLINE_GENERIC = 4,
	SPECTRE_V2_CMD_RETPOLINE_AMD = 5,
};

enum spectre_v2_user_cmd {
	SPECTRE_V2_USER_CMD_NONE = 0,
	SPECTRE_V2_USER_CMD_AUTO = 1,
	SPECTRE_V2_USER_CMD_FORCE = 2,
	SPECTRE_V2_USER_CMD_PRCTL = 3,
	SPECTRE_V2_USER_CMD_PRCTL_IBPB = 4,
	SPECTRE_V2_USER_CMD_SECCOMP = 5,
	SPECTRE_V2_USER_CMD_SECCOMP_IBPB = 6,
};

enum ssb_mitigation_cmd {
	SPEC_STORE_BYPASS_CMD_NONE = 0,
	SPEC_STORE_BYPASS_CMD_AUTO = 1,
	SPEC_STORE_BYPASS_CMD_ON = 2,
	SPEC_STORE_BYPASS_CMD_PRCTL = 3,
	SPEC_STORE_BYPASS_CMD_SECCOMP = 4,
};

enum hk_flags {
	HK_FLAG_TIMER = 1,
	HK_FLAG_RCU = 2,
	HK_FLAG_MISC = 4,
	HK_FLAG_SCHED = 8,
	HK_FLAG_TICK = 16,
	HK_FLAG_DOMAIN = 32,
	HK_FLAG_WQ = 64,
};

struct aperfmperf_sample {
	unsigned int khz;
	ktime_t time;
	u64 aperf;
	u64 mperf;
};

struct cpuid_dep {
	unsigned int feature;
	unsigned int depends;
};

struct _tlb_table {
	unsigned char descriptor;
	char tlb_type;
	unsigned int entries;
	char info[128];
};

enum tsx_ctrl_states {
	TSX_CTRL_ENABLE = 0,
	TSX_CTRL_DISABLE = 1,
	TSX_CTRL_NOT_SUPPORTED = 2,
};

struct sku_microcode {
	u8 model;
	u8 stepping;
	u32 microcode;
};

struct cpuid_regs {
	u32 eax;
	u32 ebx;
	u32 ecx;
	u32 edx;
};

enum pconfig_target {
	INVALID_TARGET = 0,
	MKTME_TARGET = 1,
	PCONFIG_TARGET_NR = 2,
};

enum {
	PCONFIG_CPUID_SUBLEAF_INVALID = 0,
	PCONFIG_CPUID_SUBLEAF_TARGETID = 1,
};

enum mf_flags {
	MF_COUNT_INCREASED = 1,
	MF_ACTION_REQUIRED = 2,
	MF_MUST_KILL = 4,
	MF_SOFT_OFFLINE = 8,
};

struct mce {
	__u64 status;
	__u64 misc;
	__u64 addr;
	__u64 mcgstatus;
	__u64 ip;
	__u64 tsc;
	__u64 time;
	__u8 cpuvendor;
	__u8 inject_flags;
	__u8 severity;
	__u8 pad;
	__u32 cpuid;
	__u8 cs;
	__u8 bank;
	__u8 cpu;
	__u8 finished;
	__u32 extcpu;
	__u32 socketid;
	__u32 apicid;
	__u64 mcgcap;
	__u64 synd;
	__u64 ipid;
	__u64 ppin;
	__u32 microcode;
	__u64 kflags;
};

enum mce_notifier_prios {
	MCE_PRIO_LOWEST = 0,
	MCE_PRIO_MCELOG = 1,
	MCE_PRIO_EDAC = 2,
	MCE_PRIO_NFIT = 3,
	MCE_PRIO_EXTLOG = 4,
	MCE_PRIO_SRAO = 5,
	MCE_PRIO_EARLY = 6,
	MCE_PRIO_CEC = 7,
};

typedef long unsigned int mce_banks_t[1];

enum mcp_flags {
	MCP_TIMESTAMP = 1,
	MCP_UC = 2,
	MCP_DONTLOG = 4,
};

enum severity_level {
	MCE_NO_SEVERITY = 0,
	MCE_DEFERRED_SEVERITY = 1,
	MCE_UCNA_SEVERITY = 1,
	MCE_KEEP_SEVERITY = 2,
	MCE_SOME_SEVERITY = 3,
	MCE_AO_SEVERITY = 4,
	MCE_UC_SEVERITY = 5,
	MCE_AR_SEVERITY = 6,
	MCE_PANIC_SEVERITY = 7,
};

struct mce_evt_llist {
	struct llist_node llnode;
	struct mce mce;
};

struct mca_config {
	bool dont_log_ce;
	bool cmci_disabled;
	bool ignore_ce;
	bool print_all;
	__u64 lmce_disabled: 1;
	__u64 disabled: 1;
	__u64 ser: 1;
	__u64 recovery: 1;
	__u64 bios_cmci_threshold: 1;
	int: 27;
	__u64 __reserved: 59;
	s8 bootlog;
	int tolerant;
	int monarch_timeout;
	int panic_timeout;
	u32 rip_msr;
};

struct mce_vendor_flags {
	__u64 overflow_recov: 1;
	__u64 succor: 1;
	__u64 smca: 1;
	__u64 __reserved_0: 61;
};

struct mca_msr_regs {
	u32 (*ctl)(int);
	u32 (*status)(int);
	u32 (*addr)(int);
	u32 (*misc)(int);
};

struct trace_event_raw_mce_record {
	struct trace_entry ent;
	u64 mcgcap;
	u64 mcgstatus;
	u64 status;
	u64 addr;
	u64 misc;
	u64 synd;
	u64 ipid;
	u64 ip;
	u64 tsc;
	u64 walltime;
	u32 cpu;
	u32 cpuid;
	u32 apicid;
	u32 socketid;
	u8 cs;
	u8 bank;
	u8 cpuvendor;
	char __data[0];
};

struct trace_event_data_offsets_mce_record {};

typedef void (*btf_trace_mce_record)(void *, struct mce *);

struct mce_bank {
	u64 ctl;
	bool init;
};

struct mce_bank_dev {
	struct device_attribute attr;
	char attrname[16];
	u8 bank;
};

typedef unsigned int pto_T_____11;

enum handler_type {
	EX_HANDLER_NONE = 0,
	EX_HANDLER_FAULT = 1,
	EX_HANDLER_UACCESS = 2,
	EX_HANDLER_OTHER = 3,
};

enum context {
	IN_KERNEL = 1,
	IN_USER = 2,
	IN_KERNEL_RECOV = 3,
};

enum ser {
	SER_REQUIRED = 1,
	NO_SER = 2,
};

enum exception {
	EXCP_CONTEXT = 1,
	NO_EXCP = 2,
};

struct severity {
	u64 mask;
	u64 result;
	unsigned char sev;
	unsigned char mcgmask;
	unsigned char mcgres;
	unsigned char ser;
	unsigned char context;
	unsigned char excp;
	unsigned char covered;
	unsigned char cpu_model;
	unsigned char cpu_minstepping;
	unsigned char bank_lo;
	unsigned char bank_hi;
	char *msg;
};

struct gen_pool;

typedef long unsigned int (*genpool_algo_t)(long unsigned int *, long unsigned int, long unsigned int, unsigned int, void *, struct gen_pool *, long unsigned int);

struct gen_pool {
	spinlock_t lock;
	struct list_head chunks;
	int min_alloc_order;
	genpool_algo_t algo;
	void *data;
	const char *name;
};

enum {
	CMCI_STORM_NONE = 0,
	CMCI_STORM_ACTIVE = 1,
	CMCI_STORM_SUBSIDED = 2,
};

enum kobject_action {
	KOBJ_ADD = 0,
	KOBJ_REMOVE = 1,
	KOBJ_CHANGE = 2,
	KOBJ_MOVE = 3,
	KOBJ_ONLINE = 4,
	KOBJ_OFFLINE = 5,
	KOBJ_BIND = 6,
	KOBJ_UNBIND = 7,
	KOBJ_MAX = 8,
};

enum smca_bank_types {
	SMCA_LS = 0,
	SMCA_LS_V2 = 1,
	SMCA_IF = 2,
	SMCA_L2_CACHE = 3,
	SMCA_DE = 4,
	SMCA_RESERVED = 5,
	SMCA_EX = 6,
	SMCA_FP = 7,
	SMCA_L3_CACHE = 8,
	SMCA_CS = 9,
	SMCA_CS_V2 = 10,
	SMCA_PIE = 11,
	SMCA_UMC = 12,
	SMCA_PB = 13,
	SMCA_PSP = 14,
	SMCA_PSP_V2 = 15,
	SMCA_SMU = 16,
	SMCA_SMU_V2 = 17,
	SMCA_MP5 = 18,
	SMCA_NBIO = 19,
	SMCA_PCIE = 20,
	N_SMCA_BANK_TYPES = 21,
};

struct smca_hwid {
	unsigned int bank_type;
	u32 hwid_mcatype;
	u32 xec_bitmap;
	u8 count;
};

struct smca_bank {
	struct smca_hwid *hwid;
	u32 id;
	u8 sysfs_id;
};

struct smca_bank_name {
	const char *name;
	const char *long_name;
};

struct thresh_restart {
	struct threshold_block *b;
	int reset;
	int set_lvt_off;
	int lvt_off;
	u16 old_limit;
};

struct threshold_attr {
	struct attribute attr;
	ssize_t (*show)(struct threshold_block *, char *);
	ssize_t (*store)(struct threshold_block *, const char *, size_t);
};

struct _thermal_state {
	bool new_event;
	int event;
	u64 next_check;
	long unsigned int count;
	long unsigned int last_count;
};

struct thermal_state {
	struct _thermal_state core_throttle;
	struct _thermal_state core_power_limit;
	struct _thermal_state package_throttle;
	struct _thermal_state package_power_limit;
	struct _thermal_state core_thresh0;
	struct _thermal_state core_thresh1;
	struct _thermal_state pkg_thresh0;
	struct _thermal_state pkg_thresh1;
};

enum {
	CPER_SEV_RECOVERABLE = 0,
	CPER_SEV_FATAL = 1,
	CPER_SEV_CORRECTED = 2,
	CPER_SEV_INFORMATIONAL = 3,
};

struct cper_record_header {
	char signature[4];
	u16 revision;
	u32 signature_end;
	u16 section_count;
	u32 error_severity;
	u32 validation_bits;
	u32 record_length;
	u64 timestamp;
	guid_t platform_id;
	guid_t partition_id;
	guid_t creator_id;
	guid_t notification_type;
	u64 record_id;
	u32 flags;
	u64 persistence_information;
	u8 reserved[12];
} __attribute__((packed));

struct cper_section_descriptor {
	u32 section_offset;
	u32 section_length;
	u16 revision;
	u8 validation_bits;
	u8 reserved;
	u32 flags;
	guid_t section_type;
	guid_t fru_id;
	u32 section_severity;
	u8 fru_text[20];
};

struct cper_sec_mem_err {
	u64 validation_bits;
	u64 error_status;
	u64 physical_addr;
	u64 physical_addr_mask;
	u16 node;
	u16 card;
	u16 module;
	u16 bank;
	u16 device;
	u16 row;
	u16 column;
	u16 bit_pos;
	u64 requestor_id;
	u64 responder_id;
	u64 target_id;
	u8 error_type;
	u8 reserved;
	u16 rank;
	u16 mem_array_handle;
	u16 mem_dev_handle;
};

enum {
	GHES_SEV_NO = 0,
	GHES_SEV_CORRECTED = 1,
	GHES_SEV_RECOVERABLE = 2,
	GHES_SEV_PANIC = 3,
};

struct cper_mce_record {
	struct cper_record_header hdr;
	struct cper_section_descriptor sec_hdr;
	struct mce mce;
};

struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

typedef struct poll_table_struct poll_table;

struct mce_log_buffer {
	char signature[12];
	unsigned int len;
	unsigned int next;
	unsigned int flags;
	unsigned int recordlen;
	struct mce entry[32];
};

typedef int (*cpu_stop_fn_t)(void *);

typedef __u8 mtrr_type;

struct mtrr_ops {
	u32 vendor;
	u32 use_intel_if;
	void (*set)(unsigned int, long unsigned int, long unsigned int, mtrr_type);
	void (*set_all)();
	void (*get)(unsigned int, long unsigned int *, long unsigned int *, mtrr_type *);
	int (*get_free_region)(long unsigned int, long unsigned int, int);
	int (*validate_add_page)(long unsigned int, long unsigned int, unsigned int);
	int (*have_wrcomb)();
};

struct set_mtrr_data {
	long unsigned int smp_base;
	long unsigned int smp_size;
	unsigned int smp_reg;
	mtrr_type smp_type;
};

struct mtrr_value {
	mtrr_type ltype;
	long unsigned int lbase;
	long unsigned int lsize;
};

struct mtrr_sentry {
	__u64 base;
	__u32 size;
	__u32 type;
};

struct mtrr_gentry {
	__u64 base;
	__u32 size;
	__u32 regnum;
	__u32 type;
	__u32 _pad;
};

typedef u32 compat_uint_t;

struct mtrr_sentry32 {
	compat_ulong_t base;
	compat_uint_t size;
	compat_uint_t type;
};

struct mtrr_gentry32 {
	compat_ulong_t regnum;
	compat_uint_t base;
	compat_uint_t size;
	compat_uint_t type;
};

struct mtrr_var_range {
	__u32 base_lo;
	__u32 base_hi;
	__u32 mask_lo;
	__u32 mask_hi;
};

struct mtrr_state_type {
	struct mtrr_var_range var_ranges[256];
	mtrr_type fixed_ranges[88];
	unsigned char enabled;
	unsigned char have_fixed;
	mtrr_type def_type;
};

struct fixed_range_block {
	int base_msr;
	int ranges;
};

struct range {
	u64 start;
	u64 end;
};

struct var_mtrr_range_state {
	long unsigned int base_pfn;
	long unsigned int size_pfn;
	mtrr_type type;
};

struct var_mtrr_state {
	long unsigned int range_startk;
	long unsigned int range_sizek;
	long unsigned int chunk_sizek;
	long unsigned int gran_sizek;
	unsigned int reg;
};

struct mtrr_cleanup_result {
	long unsigned int gran_sizek;
	long unsigned int chunk_sizek;
	long unsigned int lose_cover_sizek;
	unsigned int num_reg;
	int bad;
};

struct subsys_interface {
	const char *name;
	struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *, struct subsys_interface *);
	void (*remove_dev)(struct device *, struct subsys_interface *);
};

struct property_entry;

struct platform_device_info {
	struct device *parent;
	struct fwnode_handle *fwnode;
	bool of_node_reused;
	const char *name;
	int id;
	const struct resource *res;
	unsigned int num_res;
	const void *data;
	size_t size_data;
	u64 dma_mask;
	struct property_entry *properties;
};

struct builtin_fw {
	char *name;
	void *data;
	long unsigned int size;
};

struct cpio_data {
	void *data;
	size_t size;
	char name[18];
};

struct cpu_signature {
	unsigned int sig;
	unsigned int pf;
	unsigned int rev;
};

enum ucode_state {
	UCODE_OK = 0,
	UCODE_NEW = 1,
	UCODE_UPDATED = 2,
	UCODE_NFOUND = 3,
	UCODE_ERROR = 4,
};

struct microcode_ops {
	enum ucode_state (*request_microcode_user)(int, const void *, size_t);
	enum ucode_state (*request_microcode_fw)(int, struct device *, bool);
	void (*microcode_fini_cpu)(int);
	enum ucode_state (*apply_microcode)(int);
	int (*collect_cpu_info)(int, struct cpu_signature *);
};

struct ucode_cpu_info {
	struct cpu_signature cpu_sig;
	int valid;
	void *mc;
};

struct cpu_info_ctx {
	struct cpu_signature *cpu_sig;
	int err;
};

struct firmware {
	size_t size;
	const u8 *data;
	struct page **pages;
	void *priv;
};

struct ucode_patch {
	struct list_head plist;
	void *data;
	u32 patch_id;
	u16 equiv_cpu;
};

struct microcode_header_intel {
	unsigned int hdrver;
	unsigned int rev;
	unsigned int date;
	unsigned int sig;
	unsigned int cksum;
	unsigned int ldrver;
	unsigned int pf;
	unsigned int datasize;
	unsigned int totalsize;
	unsigned int reserved[3];
};

struct microcode_intel {
	struct microcode_header_intel hdr;
	unsigned int bits[0];
};

struct extended_signature {
	unsigned int sig;
	unsigned int pf;
	unsigned int cksum;
};

struct extended_sigtable {
	unsigned int count;
	unsigned int cksum;
	unsigned int reserved[3];
	struct extended_signature sigs[0];
};

struct equiv_cpu_entry {
	u32 installed_cpu;
	u32 fixed_errata_mask;
	u32 fixed_errata_compare;
	u16 equiv_cpu;
	u16 res;
};

struct microcode_header_amd {
	u32 data_code;
	u32 patch_id;
	u16 mc_patch_data_id;
	u8 mc_patch_data_len;
	u8 init_flag;
	u32 mc_patch_data_checksum;
	u32 nb_dev_id;
	u32 sb_dev_id;
	u16 processor_rev_id;
	u8 nb_rev_id;
	u8 sb_rev_id;
	u8 bios_api_rev;
	u8 reserved1[3];
	u32 match_reg[8];
};

struct microcode_amd {
	struct microcode_header_amd hdr;
	unsigned int mpb[0];
};

struct equiv_cpu_table {
	unsigned int num_entries;
	struct equiv_cpu_entry *entry;
};

struct cont_desc {
	struct microcode_amd *mc;
	u32 cpuid_1_eax;
	u32 psize;
	u8 *data;
	size_t size;
};

enum fs_context_purpose {
	FS_CONTEXT_FOR_MOUNT = 0,
	FS_CONTEXT_FOR_SUBMOUNT = 1,
	FS_CONTEXT_FOR_RECONFIGURE = 2,
};

enum fs_context_phase {
	FS_CONTEXT_CREATE_PARAMS = 0,
	FS_CONTEXT_CREATING = 1,
	FS_CONTEXT_AWAITING_MOUNT = 2,
	FS_CONTEXT_AWAITING_RECONF = 3,
	FS_CONTEXT_RECONF_PARAMS = 4,
	FS_CONTEXT_RECONFIGURING = 5,
	FS_CONTEXT_FAILED = 6,
};

struct fs_context_operations;

struct fc_log;

struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex uapi_mutex;
	struct file_system_type *fs_type;
	void *fs_private;
	void *sget_key;
	struct dentry *root;
	struct user_namespace *user_ns;
	struct net *net_ns;
	const struct cred *cred;
	struct fc_log *log;
	const char *source;
	void *security;
	void *s_fs_info;
	unsigned int sb_flags;
	unsigned int sb_flags_mask;
	unsigned int s_iflags;
	unsigned int lsm_flags;
	enum fs_context_purpose purpose: 8;
	enum fs_context_phase phase: 8;
	bool need_free: 1;
	bool global: 1;
};

enum fs_value_type {
	fs_value_is_undefined = 0,
	fs_value_is_flag = 1,
	fs_value_is_string = 2,
	fs_value_is_blob = 3,
	fs_value_is_filename = 4,
	fs_value_is_filename_empty = 5,
	fs_value_is_file = 6,
};

struct fs_parameter {
	const char *key;
	enum fs_value_type type: 8;
	union {
		char *string;
		void *blob;
		struct filename *name;
		struct file *file;
	};
	size_t size;
	int dirfd;
};

struct fs_context_operations {
	void (*free)(struct fs_context *);
	int (*dup)(struct fs_context *, struct fs_context *);
	int (*parse_param)(struct fs_context *, struct fs_parameter *);
	int (*parse_monolithic)(struct fs_context *, void *);
	int (*get_tree)(struct fs_context *);
	int (*reconfigure)(struct fs_context *);
};

struct fc_log {
	refcount_t usage;
	u8 head;
	u8 tail;
	u8 need_free;
	struct module *owner;
	char *buffer[8];
};

enum rdt_group_type {
	RDTCTRL_GROUP = 0,
	RDTMON_GROUP = 1,
	RDT_NUM_GROUP = 2,
};

struct rdtgroup;

struct mongroup {
	struct kernfs_node *mon_data_kn;
	struct rdtgroup *parent;
	struct list_head crdtgrp_list;
	u32 rmid;
};

enum rdtgrp_mode {
	RDT_MODE_SHAREABLE = 0,
	RDT_MODE_EXCLUSIVE = 1,
	RDT_MODE_PSEUDO_LOCKSETUP = 2,
	RDT_MODE_PSEUDO_LOCKED = 3,
	RDT_NUM_MODES = 4,
};

struct pseudo_lock_region;

struct rdtgroup {
	struct kernfs_node *kn;
	struct list_head rdtgroup_list;
	u32 closid;
	struct cpumask cpu_mask;
	int flags;
	atomic_t waitcount;
	enum rdt_group_type type;
	struct mongroup mon;
	enum rdtgrp_mode mode;
	struct pseudo_lock_region *plr;
};

struct mbm_state;

struct rdt_domain {
	struct list_head list;
	int id;
	struct cpumask cpu_mask;
	long unsigned int *rmid_busy_llc;
	struct mbm_state *mbm_total;
	struct mbm_state *mbm_local;
	struct delayed_work mbm_over;
	struct delayed_work cqm_limbo;
	int mbm_work_cpu;
	int cqm_work_cpu;
	u32 *ctrl_val;
	u32 *mbps_val;
	u32 new_ctrl;
	bool have_new_ctrl;
	struct pseudo_lock_region *plr;
};

struct rdt_resource;

struct pseudo_lock_region {
	struct rdt_resource *r;
	struct rdt_domain *d;
	u32 cbm;
	wait_queue_head_t lock_thread_wq;
	int thread_done;
	int cpu;
	unsigned int line_size;
	unsigned int size;
	void *kmem;
	unsigned int minor;
	struct dentry *debugfs_dir;
	struct list_head pm_reqs;
};

struct rdt_cache {
	unsigned int cbm_len;
	unsigned int min_cbm_bits;
	unsigned int cbm_idx_mult;
	unsigned int cbm_idx_offset;
	unsigned int shareable_bits;
};

struct rdt_membw {
	u32 max_delay;
	u32 min_bw;
	u32 bw_gran;
	u32 delay_linear;
	u32 mbm_width;
	bool mba_sc;
	u32 *mb_map;
};

struct msr_param;

struct rdt_parse_data;

struct rdt_resource {
	int rid;
	bool alloc_enabled;
	bool mon_enabled;
	bool alloc_capable;
	bool mon_capable;
	char *name;
	int num_closid;
	int cache_level;
	u32 default_ctrl;
	unsigned int msr_base;
	void (*msr_update)(struct rdt_domain *, struct msr_param *, struct rdt_resource *);
	int data_width;
	struct list_head domains;
	struct rdt_cache cache;
	struct rdt_membw membw;
	const char *format_str;
	int (*parse_ctrlval)(struct rdt_parse_data *, struct rdt_resource *, struct rdt_domain *);
	bool (*cbm_validate)(char *, u32 *, struct rdt_resource *);
	struct list_head evt_list;
	int num_rmid;
	unsigned int mon_scale;
	long unsigned int fflags;
};

struct mbm_state {
	u64 chunks;
	u64 prev_msr;
	u64 prev_bw_msr;
	u32 prev_bw;
	u32 delta_bw;
	bool delta_comp;
};

struct msr_param {
	struct rdt_resource *res;
	int low;
	int high;
};

struct rdt_parse_data {
	struct rdtgroup *rdtgrp;
	char *buf;
};

enum {
	RDT_RESOURCE_L3 = 0,
	RDT_RESOURCE_L3DATA = 1,
	RDT_RESOURCE_L3CODE = 2,
	RDT_RESOURCE_L2 = 3,
	RDT_RESOURCE_L2DATA = 4,
	RDT_RESOURCE_L2CODE = 5,
	RDT_RESOURCE_MBA = 6,
	RDT_NUM_RESOURCES = 7,
};

union cpuid_0x10_1_eax {
	struct {
		unsigned int cbm_len: 5;
	} split;
	unsigned int full;
};

union cpuid_0x10_3_eax {
	struct {
		unsigned int max_delay: 12;
	} split;
	unsigned int full;
};

union cpuid_0x10_x_edx {
	struct {
		unsigned int cos_max: 16;
	} split;
	unsigned int full;
};

enum {
	RDT_FLAG_CMT = 0,
	RDT_FLAG_MBM_TOTAL = 1,
	RDT_FLAG_MBM_LOCAL = 2,
	RDT_FLAG_L3_CAT = 3,
	RDT_FLAG_L3_CDP = 4,
	RDT_FLAG_L2_CAT = 5,
	RDT_FLAG_L2_CDP = 6,
	RDT_FLAG_MBA = 7,
};

struct rdt_options {
	char *name;
	int flag;
	bool force_off;
	bool force_on;
};

typedef unsigned int uint;

typedef __builtin_va_list __gnuc_va_list;

typedef __gnuc_va_list va_list;

enum kernfs_node_type {
	KERNFS_DIR = 1,
	KERNFS_FILE = 2,
	KERNFS_LINK = 4,
};

enum kernfs_root_flag {
	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
};

struct kernfs_fs_context {
	struct kernfs_root *root;
	void *ns_tag;
	long unsigned int magic;
	bool new_sb_created;
};

enum fs_parameter_type {
	__fs_param_wasnt_defined = 0,
	fs_param_is_flag = 1,
	fs_param_is_bool = 2,
	fs_param_is_u32 = 3,
	fs_param_is_u32_octal = 4,
	fs_param_is_u32_hex = 5,
	fs_param_is_s32 = 6,
	fs_param_is_u64 = 7,
	fs_param_is_enum = 8,
	fs_param_is_string = 9,
	fs_param_is_blob = 10,
	fs_param_is_blockdev = 11,
	fs_param_is_path = 12,
	fs_param_is_fd = 13,
	nr__fs_parameter_type = 14,
};

struct fs_parameter_spec {
	const char *name;
	u8 opt;
	enum fs_parameter_type type: 8;
	short unsigned int flags;
};

struct fs_parameter_enum {
	u8 opt;
	char name[14];
	u8 value;
};

struct fs_parse_result {
	bool negated;
	bool has_value;
	union {
		bool boolean;
		int int_32;
		unsigned int uint_32;
		u64 uint_64;
	};
};

struct rdt_fs_context {
	struct kernfs_fs_context kfc;
	bool enable_cdpl2;
	bool enable_cdpl3;
	bool enable_mba_mbps;
};

struct mon_evt {
	u32 evtid;
	char *name;
	struct list_head list;
};

union mon_data_bits {
	void *priv;
	struct {
		unsigned int rid: 10;
		unsigned int evtid: 8;
		unsigned int domid: 14;
	} u;
};

struct rmid_read {
	struct rdtgroup *rgrp;
	struct rdt_domain *d;
	int evtid;
	bool first;
	u64 val;
};

struct rftype {
	char *name;
	umode_t mode;
	struct kernfs_ops *kf_ops;
	long unsigned int flags;
	long unsigned int fflags;
	int (*seq_show)(struct kernfs_open_file *, struct seq_file *, void *);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
};

enum rdt_param {
	Opt_cdp = 0,
	Opt_cdpl2 = 1,
	Opt_mba_mbps = 2,
	nr__rdt_params = 3,
};

typedef u32 pto_T_____12;

struct rmid_entry {
	u32 rmid;
	int busy;
	struct list_head list;
};

struct wait_queue_entry;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);

struct wait_queue_entry {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head entry;
};

struct trace_event_raw_pseudo_lock_mem_latency {
	struct trace_entry ent;
	u32 latency;
	char __data[0];
};

struct trace_event_raw_pseudo_lock_l2 {
	struct trace_entry ent;
	u64 l2_hits;
	u64 l2_miss;
	char __data[0];
};

struct trace_event_raw_pseudo_lock_l3 {
	struct trace_entry ent;
	u64 l3_hits;
	u64 l3_miss;
	char __data[0];
};

struct trace_event_data_offsets_pseudo_lock_mem_latency {};

struct trace_event_data_offsets_pseudo_lock_l2 {};

struct trace_event_data_offsets_pseudo_lock_l3 {};

typedef void (*btf_trace_pseudo_lock_mem_latency)(void *, u32);

typedef void (*btf_trace_pseudo_lock_l2)(void *, u64, u64);

typedef void (*btf_trace_pseudo_lock_l3)(void *, u64, u64);

struct pseudo_lock_pm_req {
	struct list_head list;
	struct dev_pm_qos_request req;
};

struct residency_counts {
	u64 miss_before;
	u64 hits_before;
	u64 miss_after;
	u64 hits_after;
};

enum mmu_notifier_event {
	MMU_NOTIFY_UNMAP = 0,
	MMU_NOTIFY_CLEAR = 1,
	MMU_NOTIFY_PROTECTION_VMA = 2,
	MMU_NOTIFY_PROTECTION_PAGE = 3,
	MMU_NOTIFY_SOFT_DIRTY = 4,
};

struct mmu_notifier_range {
	struct vm_area_struct *vma;
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int flags;
	enum mmu_notifier_event event;
};

struct mmu_notifier;

struct mmu_notifier_ops {
	void (*release)(struct mmu_notifier *, struct mm_struct *);
	int (*clear_flush_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*clear_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*test_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int);
	void (*change_pte)(struct mmu_notifier *, struct mm_struct *, long unsigned int, pte_t);
	int (*invalidate_range_start)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range_end)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	struct mmu_notifier * (*alloc_notifier)(struct mm_struct *);
	void (*free_notifier)(struct mmu_notifier *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct mmu_notifier {
	struct hlist_node hlist;
	const struct mmu_notifier_ops *ops;
	struct mm_struct *mm;
	struct callback_head rcu;
	unsigned int users;
	long unsigned int kabi_reserved1;
};

enum sgx_page_type {
	SGX_PAGE_TYPE_SECS = 0,
	SGX_PAGE_TYPE_TCS = 1,
	SGX_PAGE_TYPE_REG = 2,
	SGX_PAGE_TYPE_VA = 3,
	SGX_PAGE_TYPE_TRIM = 4,
};

struct sgx_encl_page;

struct sgx_epc_page {
	unsigned int section;
	unsigned int flags;
	struct sgx_encl_page *owner;
	struct list_head list;
};

struct sgx_encl;

struct sgx_va_page;

struct sgx_encl_page {
	long unsigned int desc;
	long unsigned int vm_max_prot_bits;
	struct sgx_epc_page *epc_page;
	struct sgx_encl *encl;
	struct sgx_va_page *va_page;
};

struct sgx_encl {
	long unsigned int base;
	long unsigned int size;
	long unsigned int flags;
	unsigned int page_cnt;
	unsigned int secs_child_cnt;
	struct mutex lock;
	struct xarray page_array;
	struct sgx_encl_page secs;
	long unsigned int attributes;
	long unsigned int attributes_mask;
	cpumask_t cpumask;
	struct file *backing;
	struct kref refcount;
	struct list_head va_pages;
	long unsigned int mm_list_version;
	struct list_head mm_list;
	spinlock_t mm_lock;
	struct srcu_struct srcu;
};

struct sgx_va_page {
	struct sgx_epc_page *epc_page;
	long unsigned int slots[8];
	struct list_head list;
};

struct sgx_encl_mm {
	struct sgx_encl *encl;
	struct mm_struct *mm;
	struct list_head list;
	struct mmu_notifier mmu_notifier;
};

typedef unsigned int xa_mark_t;

struct xa_node {
	unsigned char shift;
	unsigned char offset;
	unsigned char count;
	unsigned char nr_values;
	struct xa_node *parent;
	struct xarray *array;
	union {
		struct list_head private_list;
		struct callback_head callback_head;
	};
	void *slots[64];
	union {
		long unsigned int tags[3];
		long unsigned int marks[3];
	};
};

typedef void (*xa_update_node_t)(struct xa_node *);

struct xa_state {
	struct xarray *xa;
	long unsigned int xa_index;
	unsigned char xa_shift;
	unsigned char xa_sibs;
	unsigned char xa_offset;
	unsigned char xa_pad;
	struct xa_node *xa_node;
	struct xa_node *xa_alloc;
	xa_update_node_t xa_update;
};

enum {
	XA_CHECK_SCHED = 4096,
};

typedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);

struct sgx_pageinfo {
	u64 addr;
	u64 contents;
	u64 metadata;
	u64 secs;
};

struct sgx_epc_section {
	long unsigned int phys_addr;
	void *virt_addr;
	struct sgx_epc_page *pages;
	spinlock_t lock;
	struct list_head page_list;
	long unsigned int free_cnt;
	struct list_head init_laundry_list;
};

enum sgx_encl_flags {
	SGX_ENCL_IOCTL = 1,
	SGX_ENCL_DEBUG = 2,
	SGX_ENCL_CREATED = 4,
	SGX_ENCL_INITIALIZED = 8,
};

struct sgx_backing {
	long unsigned int page_index;
	struct page *contents;
	struct page *pcmd;
	long unsigned int pcmd_offset;
};

enum sgx_encls_function {
	ECREATE = 0,
	EADD = 1,
	EINIT = 2,
	EREMOVE = 3,
	EDGBRD = 4,
	EDGBWR = 5,
	EEXTEND = 6,
	ELDU = 8,
	EBLOCK = 9,
	EPA = 10,
	EWB = 11,
	ETRACK = 12,
};

struct crypto_async_request;

typedef void (*crypto_completion_t)(struct crypto_async_request *, int);

struct crypto_tfm;

struct crypto_async_request {
	struct list_head list;
	crypto_completion_t complete;
	void *data;
	struct crypto_tfm *tfm;
	u32 flags;
};

struct crypto_ablkcipher;

struct ablkcipher_request;

struct ablkcipher_tfm {
	int (*setkey)(struct crypto_ablkcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct ablkcipher_request *);
	int (*decrypt)(struct ablkcipher_request *);
	struct crypto_ablkcipher *base;
	unsigned int ivsize;
	unsigned int reqsize;
};

struct blkcipher_desc;

struct blkcipher_tfm {
	void *iv;
	int (*setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	int (*encrypt)(struct blkcipher_desc *, struct scatterlist *, struct scatterlist *, unsigned int);
	int (*decrypt)(struct blkcipher_desc *, struct scatterlist *, struct scatterlist *, unsigned int);
};

struct cipher_tfm {
	int (*cit_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cit_encrypt_one)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cit_decrypt_one)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_tfm {
	int (*cot_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*cot_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_alg;

struct crypto_tfm {
	u32 crt_flags;
	union {
		struct ablkcipher_tfm ablkcipher;
		struct blkcipher_tfm blkcipher;
		struct cipher_tfm cipher;
		struct compress_tfm compress;
	} crt_u;
	void (*exit)(struct crypto_tfm *);
	struct crypto_alg *__crt_alg;
	void *__crt_ctx[0];
};

struct ablkcipher_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	void *info;
	struct scatterlist *src;
	struct scatterlist *dst;
	void *__ctx[0];
};

struct crypto_blkcipher;

struct blkcipher_desc {
	struct crypto_blkcipher *tfm;
	void *info;
	u32 flags;
};

struct crypto_blkcipher {
	struct crypto_tfm base;
};

struct ablkcipher_alg {
	int (*setkey)(struct crypto_ablkcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct ablkcipher_request *);
	int (*decrypt)(struct ablkcipher_request *);
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

struct crypto_ablkcipher {
	struct crypto_tfm base;
};

struct blkcipher_alg {
	int (*setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	int (*encrypt)(struct blkcipher_desc *, struct scatterlist *, struct scatterlist *, unsigned int);
	int (*decrypt)(struct blkcipher_desc *, struct scatterlist *, struct scatterlist *, unsigned int);
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_alg {
	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_type;

struct crypto_alg {
	struct list_head cra_list;
	struct list_head cra_users;
	u32 cra_flags;
	unsigned int cra_blocksize;
	unsigned int cra_ctxsize;
	unsigned int cra_alignmask;
	int cra_priority;
	refcount_t cra_refcnt;
	char cra_name[128];
	char cra_driver_name[128];
	const struct crypto_type *cra_type;
	union {
		struct ablkcipher_alg ablkcipher;
		struct blkcipher_alg blkcipher;
		struct cipher_alg cipher;
		struct compress_alg compress;
	} cra_u;
	int (*cra_init)(struct crypto_tfm *);
	void (*cra_exit)(struct crypto_tfm *);
	void (*cra_destroy)(struct crypto_alg *);
	struct module *cra_module;
};

struct crypto_instance;

struct crypto_type {
	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
	unsigned int (*extsize)(struct crypto_alg *);
	int (*init)(struct crypto_tfm *, u32, u32);
	int (*init_tfm)(struct crypto_tfm *);
	void (*show)(struct seq_file *, struct crypto_alg *);
	int (*report)(struct sk_buff *, struct crypto_alg *);
	void (*free)(struct crypto_instance *);
	unsigned int type;
	unsigned int maskclear;
	unsigned int maskset;
	unsigned int tfmsize;
};

struct crypto_shash;

struct shash_desc {
	struct crypto_shash *tfm;
	void *__ctx[0];
};

struct crypto_shash {
	unsigned int descsize;
	struct crypto_tfm base;
};

enum sgx_page_flags {
	SGX_PAGE_MEASURE = 1,
};

struct sgx_enclave_create {
	__u64 src;
};

struct sgx_enclave_add_pages {
	__u64 src;
	__u64 offset;
	__u64 length;
	__u64 secinfo;
	__u64 flags;
	__u64 count;
};

struct sgx_enclave_init {
	__u64 sigstruct;
};

struct sgx_enclave_provision {
	__u64 fd;
};

enum sgx_return_code {
	SGX_NOT_TRACKED = 11,
	SGX_INVALID_EINITTOKEN = 16,
	SGX_UNMASKED_EVENT = 128,
};

enum sgx_attribute {
	SGX_ATTR_INIT = 1,
	SGX_ATTR_DEBUG = 2,
	SGX_ATTR_MODE64BIT = 4,
	SGX_ATTR_PROVISIONKEY = 16,
	SGX_ATTR_EINITTOKENKEY = 32,
	SGX_ATTR_KSS = 128,
};

struct sgx_secs {
	u64 size;
	u64 base;
	u32 ssa_frame_size;
	u32 miscselect;
	u8 reserved1[24];
	u64 attributes;
	u64 xfrm;
	u32 mrenclave[8];
	u8 reserved2[32];
	u32 mrsigner[8];
	u8 reserved3[32];
	u32 config_id[16];
	u16 isv_prod_id;
	u16 isv_svn;
	u16 config_svn;
	u8 reserved4[3834];
};

enum sgx_secinfo_flags {
	SGX_SECINFO_R = 1,
	SGX_SECINFO_W = 2,
	SGX_SECINFO_X = 4,
	SGX_SECINFO_SECS = 0,
	SGX_SECINFO_TCS = 256,
	SGX_SECINFO_REG = 512,
	SGX_SECINFO_VA = 768,
	SGX_SECINFO_TRIM = 1024,
};

struct sgx_secinfo {
	u64 flags;
	u8 reserved[56];
};

struct sgx_sigstruct_header {
	u64 header1[2];
	u32 vendor;
	u32 date;
	u64 header2[2];
	u32 swdefined;
	u8 reserved1[84];
};

struct sgx_sigstruct_body {
	u32 miscselect;
	u32 misc_mask;
	u8 reserved2[20];
	u64 attributes;
	u64 xfrm;
	u64 attributes_mask;
	u64 xfrm_mask;
	u8 mrenclave[32];
	u8 reserved3[32];
	u16 isvprodid;
	u16 isvsvn;
} __attribute__((packed));

struct sgx_sigstruct {
	struct sgx_sigstruct_header header;
	u8 modulus[384];
	u32 exponent;
	u8 signature[384];
	struct sgx_sigstruct_body body;
	u8 reserved4[12];
	u8 q1[384];
	u8 q2[384];
} __attribute__((packed));

struct pv_info {
	const char *name;
};

struct hypervisor_x86 {
	const char *name;
	uint32_t (*detect)();
	enum x86_hypervisor_type type;
	struct x86_hyper_init init;
	struct x86_hyper_runtime runtime;
	bool ignore_nopv;
};

struct machine_ops {
	void (*restart)(char *);
	void (*halt)();
	void (*power_off)();
	void (*shutdown)();
	void (*crash_shutdown)(struct pt_regs *);
	void (*emergency_restart)();
};

struct mpc_intsrc {
	unsigned char type;
	unsigned char irqtype;
	short unsigned int irqflag;
	unsigned char srcbus;
	unsigned char srcbusirq;
	unsigned char dstapic;
	unsigned char dstirq;
};

enum mp_irq_source_types {
	mp_INT = 0,
	mp_NMI = 1,
	mp_SMI = 2,
	mp_ExtINT = 3,
};

struct IO_APIC_route_entry {
	__u32 vector: 8;
	__u32 delivery_mode: 3;
	__u32 dest_mode: 1;
	__u32 delivery_status: 1;
	__u32 polarity: 1;
	__u32 irr: 1;
	__u32 trigger: 1;
	__u32 mask: 1;
	__u32 __reserved_2: 15;
	__u32 __reserved_3: 24;
	__u32 dest: 8;
};

typedef u64 acpi_io_address;

typedef u64 acpi_physical_address;

typedef u32 acpi_status;

typedef char *acpi_string;

typedef void *acpi_handle;

typedef u32 acpi_object_type;

typedef u8 acpi_adr_space_type;

union acpi_object {
	acpi_object_type type;
	struct {
		acpi_object_type type;
		u64 value;
	} integer;
	struct {
		acpi_object_type type;
		u32 length;
		char *pointer;
	} string;
	struct {
		acpi_object_type type;
		u32 length;
		u8 *pointer;
	} buffer;
	struct {
		acpi_object_type type;
		u32 count;
		union acpi_object *elements;
	} package;
	struct {
		acpi_object_type type;
		acpi_object_type actual_type;
		acpi_handle handle;
	} reference;
	struct {
		acpi_object_type type;
		u32 proc_id;
		acpi_io_address pblk_address;
		u32 pblk_length;
	} processor;
	struct {
		acpi_object_type type;
		u32 system_level;
		u32 resource_order;
	} power_resource;
};

struct acpi_object_list {
	u32 count;
	union acpi_object *pointer;
};

struct acpi_subtable_header {
	u8 type;
	u8 length;
};

struct acpi_table_boot {
	struct acpi_table_header header;
	u8 cmos_index;
	u8 reserved[3];
};

struct acpi_hmat_structure {
	u16 type;
	u16 reserved;
	u32 length;
};

struct acpi_table_hpet {
	struct acpi_table_header header;
	u32 id;
	struct acpi_generic_address address;
	u8 sequence;
	u16 minimum_tick;
	u8 flags;
} __attribute__((packed));

struct acpi_table_madt {
	struct acpi_table_header header;
	u32 address;
	u32 flags;
};

enum acpi_madt_type {
	ACPI_MADT_TYPE_LOCAL_APIC = 0,
	ACPI_MADT_TYPE_IO_APIC = 1,
	ACPI_MADT_TYPE_INTERRUPT_OVERRIDE = 2,
	ACPI_MADT_TYPE_NMI_SOURCE = 3,
	ACPI_MADT_TYPE_LOCAL_APIC_NMI = 4,
	ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE = 5,
	ACPI_MADT_TYPE_IO_SAPIC = 6,
	ACPI_MADT_TYPE_LOCAL_SAPIC = 7,
	ACPI_MADT_TYPE_INTERRUPT_SOURCE = 8,
	ACPI_MADT_TYPE_LOCAL_X2APIC = 9,
	ACPI_MADT_TYPE_LOCAL_X2APIC_NMI = 10,
	ACPI_MADT_TYPE_GENERIC_INTERRUPT = 11,
	ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR = 12,
	ACPI_MADT_TYPE_GENERIC_MSI_FRAME = 13,
	ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR = 14,
	ACPI_MADT_TYPE_GENERIC_TRANSLATOR = 15,
	ACPI_MADT_TYPE_RESERVED = 16,
	ACPI_MADT_TYPE_PHYTIUM_2500 = 128,
};

struct acpi_madt_local_apic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u32 lapic_flags;
};

struct acpi_madt_io_apic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 address;
	u32 global_irq_base;
};

struct acpi_madt_interrupt_override {
	struct acpi_subtable_header header;
	u8 bus;
	u8 source_irq;
	u32 global_irq;
	u16 inti_flags;
} __attribute__((packed));

struct acpi_madt_nmi_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 global_irq;
};

struct acpi_madt_local_apic_nmi {
	struct acpi_subtable_header header;
	u8 processor_id;
	u16 inti_flags;
	u8 lint;
} __attribute__((packed));

struct acpi_madt_local_apic_override {
	struct acpi_subtable_header header;
	u16 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_madt_local_sapic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u8 eid;
	u8 reserved[3];
	u32 lapic_flags;
	u32 uid;
	char uid_string[1];
} __attribute__((packed));

struct acpi_madt_local_x2apic {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 local_apic_id;
	u32 lapic_flags;
	u32 uid;
};

struct acpi_madt_local_x2apic_nmi {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 uid;
	u8 lint;
	u8 reserved[3];
};

enum acpi_irq_model_id {
	ACPI_IRQ_MODEL_PIC = 0,
	ACPI_IRQ_MODEL_IOAPIC = 1,
	ACPI_IRQ_MODEL_IOSAPIC = 2,
	ACPI_IRQ_MODEL_PLATFORM = 3,
	ACPI_IRQ_MODEL_GIC = 4,
	ACPI_IRQ_MODEL_COUNT = 5,
};

union acpi_subtable_headers {
	struct acpi_subtable_header common;
	struct acpi_hmat_structure hmat;
};

typedef int (*acpi_tbl_table_handler)(struct acpi_table_header *);

typedef int (*acpi_tbl_entry_handler)(union acpi_subtable_headers *, const long unsigned int);

struct acpi_subtable_proc {
	int id;
	acpi_tbl_entry_handler handler;
	int count;
};

typedef u32 phys_cpuid_t;

enum irq_alloc_type {
	X86_IRQ_ALLOC_TYPE_IOAPIC = 1,
	X86_IRQ_ALLOC_TYPE_HPET = 2,
	X86_IRQ_ALLOC_TYPE_MSI = 3,
	X86_IRQ_ALLOC_TYPE_MSIX = 4,
	X86_IRQ_ALLOC_TYPE_DMAR = 5,
	X86_IRQ_ALLOC_TYPE_UV = 6,
};

struct irq_alloc_info {
	enum irq_alloc_type type;
	u32 flags;
	const struct cpumask *mask;
	union {
		int unused;
		struct {
			int hpet_id;
			int hpet_index;
			void *hpet_data;
		};
		struct {
			struct pci_dev *msi_dev;
			irq_hw_number_t msi_hwirq;
		};
		struct {
			int ioapic_id;
			int ioapic_pin;
			int ioapic_node;
			u32 ioapic_trigger: 1;
			u32 ioapic_polarity: 1;
			u32 ioapic_valid: 1;
			struct IO_APIC_route_entry *ioapic_entry;
		};
		struct {
			int dmar_id;
			void *dmar_data;
		};
		struct {
			struct msi_desc *desc;
		};
	};
};

enum ioapic_domain_type {
	IOAPIC_DOMAIN_INVALID = 0,
	IOAPIC_DOMAIN_LEGACY = 1,
	IOAPIC_DOMAIN_STRICT = 2,
	IOAPIC_DOMAIN_DYNAMIC = 3,
};

struct ioapic_domain_cfg {
	enum ioapic_domain_type type;
	const struct irq_domain_ops *ops;
	struct device_node *dev;
};

struct wakeup_header {
	u16 video_mode;
	u32 pmode_entry;
	u16 pmode_cs;
	u32 pmode_cr0;
	u32 pmode_cr3;
	u32 pmode_cr4;
	u32 pmode_efer_low;
	u32 pmode_efer_high;
	u64 pmode_gdt;
	u32 pmode_misc_en_low;
	u32 pmode_misc_en_high;
	u32 pmode_behavior;
	u32 realmode_flags;
	u32 real_magic;
	u32 signature;
} __attribute__((packed));

struct acpi_hest_header {
	u16 type;
	u16 source_id;
};

struct acpi_hest_ia_error_bank {
	u8 bank_number;
	u8 clear_status_on_init;
	u8 status_format;
	u8 reserved;
	u32 control_register;
	u64 control_data;
	u32 status_register;
	u32 address_register;
	u32 misc_register;
} __attribute__((packed));

struct acpi_hest_notify {
	u8 type;
	u8 length;
	u16 config_write_enable;
	u32 poll_interval;
	u32 vector;
	u32 polling_threshold_value;
	u32 polling_threshold_window;
	u32 error_threshold_value;
	u32 error_threshold_window;
};

struct acpi_hest_ia_corrected {
	struct acpi_hest_header header;
	u16 reserved1;
	u8 flags;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	struct acpi_hest_notify notify;
	u8 num_hardware_banks;
	u8 reserved2[3];
};

struct cpc_reg {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct acpi_power_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_processor_cx {
	u8 valid;
	u8 type;
	u32 address;
	u8 entry_method;
	u8 index;
	u32 latency;
	u8 bm_sts_skip;
	char desc[32];
};

struct acpi_processor_flags {
	u8 power: 1;
	u8 performance: 1;
	u8 throttling: 1;
	u8 limit: 1;
	u8 bm_control: 1;
	u8 bm_check: 1;
	u8 has_cst: 1;
	u8 has_lpi: 1;
	u8 power_setup_done: 1;
	u8 bm_rld_set: 1;
	u8 need_hotplug_init: 1;
};

struct cstate_entry {
	struct {
		unsigned int eax;
		unsigned int ecx;
	} states[8];
};

enum reboot_mode {
	REBOOT_UNDEFINED = 4294967295,
	REBOOT_COLD = 0,
	REBOOT_WARM = 1,
	REBOOT_HARD = 2,
	REBOOT_SOFT = 3,
	REBOOT_GPIO = 4,
};

enum reboot_type {
	BOOT_TRIPLE = 116,
	BOOT_KBD = 107,
	BOOT_BIOS = 98,
	BOOT_ACPI = 97,
	BOOT_EFI = 101,
	BOOT_CF9_FORCE = 112,
	BOOT_CF9_SAFE = 113,
};

typedef void (*nmi_shootdown_cb)(int, struct pt_regs *);

typedef struct __call_single_data call_single_data_t;

struct cpuid_regs_done {
	struct cpuid_regs regs;
	struct completion done;
};

struct intel_early_ops {
	resource_size_t (*stolen_size)(int, int, int);
	resource_size_t (*stolen_base)(int, int, int, resource_size_t);
};

struct chipset {
	u32 vendor;
	u32 device;
	u32 class;
	u32 class_mask;
	u32 flags;
	void (*f)(int, int, int);
};

enum apic_intr_mode_id {
	APIC_PIC = 0,
	APIC_VIRTUAL_WIRE = 1,
	APIC_VIRTUAL_WIRE_NO_CONFIG = 2,
	APIC_SYMMETRIC_IO = 3,
	APIC_SYMMETRIC_IO_NO_ROUTING = 4,
};

struct sched_domain_shared {
	atomic_t ref;
	atomic_t nr_busy_cpus;
	int has_idle_cores;
};

struct sched_group;

struct sched_domain {
	struct sched_domain *parent;
	struct sched_domain *child;
	struct sched_group *groups;
	long unsigned int min_interval;
	long unsigned int max_interval;
	unsigned int busy_factor;
	unsigned int imbalance_pct;
	unsigned int cache_nice_tries;
	int nohz_idle;
	int flags;
	int level;
	long unsigned int last_balance;
	unsigned int balance_interval;
	unsigned int nr_balance_failed;
	u64 max_newidle_lb_cost;
	long unsigned int next_decay_max_lb_cost;
	u64 avg_scan_cost;
	unsigned int lb_count[3];
	unsigned int lb_failed[3];
	unsigned int lb_balanced[3];
	unsigned int lb_imbalance[3];
	unsigned int lb_gained[3];
	unsigned int lb_hot_gained[3];
	unsigned int lb_nobusyg[3];
	unsigned int lb_nobusyq[3];
	unsigned int alb_count;
	unsigned int alb_failed;
	unsigned int alb_pushed;
	unsigned int sbe_count;
	unsigned int sbe_balanced;
	unsigned int sbe_pushed;
	unsigned int sbf_count;
	unsigned int sbf_balanced;
	unsigned int sbf_pushed;
	unsigned int ttwu_wake_remote;
	unsigned int ttwu_move_affine;
	unsigned int ttwu_move_balance;
	char *name;
	union {
		void *private;
		struct callback_head rcu;
	};
	struct sched_domain_shared *shared;
	unsigned int span_weight;
	long unsigned int span[0];
};

typedef const struct cpumask * (*sched_domain_mask_f)(int);

typedef int (*sched_domain_flags_f)();

struct sched_group_capacity;

struct sd_data {
	struct sched_domain **sd;
	struct sched_domain_shared **sds;
	struct sched_group **sg;
	struct sched_group_capacity **sgc;
};

struct sched_domain_topology_level {
	sched_domain_mask_f mask;
	sched_domain_flags_f sd_flags;
	int flags;
	int numa_level;
	struct sd_data data;
	char *name;
};

struct tsc_adjust {
	s64 bootval;
	s64 adjusted;
	long unsigned int nextcheck;
	bool warned;
};

typedef void * (*pcpu_fc_alloc_fn_t)(unsigned int, size_t, size_t);

typedef void (*pcpu_fc_free_fn_t)(void *, size_t);

typedef void (*pcpu_fc_populate_pte_fn_t)(long unsigned int);

typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);

enum {
	DUMP_PREFIX_NONE = 0,
	DUMP_PREFIX_ADDRESS = 1,
	DUMP_PREFIX_OFFSET = 2,
};

struct mpf_intel {
	char signature[4];
	unsigned int physptr;
	unsigned char length;
	unsigned char specification;
	unsigned char checksum;
	unsigned char feature1;
	unsigned char feature2;
	unsigned char feature3;
	unsigned char feature4;
	unsigned char feature5;
};

struct mpc_ioapic {
	unsigned char type;
	unsigned char apicid;
	unsigned char apicver;
	unsigned char flags;
	unsigned int apicaddr;
};

struct mpc_lintsrc {
	unsigned char type;
	unsigned char irqtype;
	short unsigned int irqflag;
	unsigned char srcbusid;
	unsigned char srcbusirq;
	unsigned char destapic;
	unsigned char destapiclint;
};

typedef u16 uint16_t;

enum {
	IRQ_REMAP_XAPIC_MODE = 0,
	IRQ_REMAP_X2APIC_MODE = 1,
};

union apic_ir {
	long unsigned int map[4];
	u32 regs[8];
};

enum {
	X2APIC_OFF = 0,
	X2APIC_ON = 1,
	X2APIC_DISABLED = 2,
};

enum ioapic_irq_destination_types {
	dest_Fixed = 0,
	dest_LowestPrio = 1,
	dest_SMI = 2,
	dest__reserved_1 = 3,
	dest_NMI = 4,
	dest_INIT = 5,
	dest__reserved_2 = 6,
	dest_ExtINT = 7,
};

enum {
	IRQ_SET_MASK_OK = 0,
	IRQ_SET_MASK_OK_NOCOPY = 1,
	IRQ_SET_MASK_OK_DONE = 2,
};

enum {
	IRQD_TRIGGER_MASK = 15,
	IRQD_SETAFFINITY_PENDING = 256,
	IRQD_ACTIVATED = 512,
	IRQD_NO_BALANCING = 1024,
	IRQD_PER_CPU = 2048,
	IRQD_AFFINITY_SET = 4096,
	IRQD_LEVEL = 8192,
	IRQD_WAKEUP_STATE = 16384,
	IRQD_MOVE_PCNTXT = 32768,
	IRQD_IRQ_DISABLED = 65536,
	IRQD_IRQ_MASKED = 131072,
	IRQD_IRQ_INPROGRESS = 262144,
	IRQD_WAKEUP_ARMED = 524288,
	IRQD_FORWARDED_TO_VCPU = 1048576,
	IRQD_AFFINITY_MANAGED = 2097152,
	IRQD_IRQ_STARTED = 4194304,
	IRQD_MANAGED_SHUTDOWN = 8388608,
	IRQD_SINGLE_TARGET = 16777216,
	IRQD_DEFAULT_TRIGGER_SET = 33554432,
	IRQD_CAN_RESERVE = 67108864,
	IRQD_MSI_NOMASK_QUIRK = 134217728,
	IRQD_HANDLE_ENFORCE_IRQCTX = 268435456,
	IRQD_AFFINITY_ON_ACTIVATE = 536870912,
};

struct irq_cfg {
	unsigned int dest_apicid;
	unsigned int vector;
};

enum {
	IRQCHIP_FWNODE_REAL = 0,
	IRQCHIP_FWNODE_NAMED = 1,
	IRQCHIP_FWNODE_NAMED_ID = 2,
};

enum {
	X86_IRQ_ALLOC_CONTIGUOUS_VECTORS = 1,
	X86_IRQ_ALLOC_LEGACY = 2,
};

struct apic_chip_data {
	struct irq_cfg hw_irq_cfg;
	unsigned int vector;
	unsigned int prev_vector;
	unsigned int cpu;
	unsigned int prev_cpu;
	unsigned int irq;
	struct hlist_node clist;
	unsigned int move_in_progress: 1;
	unsigned int is_managed: 1;
	unsigned int can_reserve: 1;
	unsigned int has_reserved: 1;
};

struct irq_matrix;

union IO_APIC_reg_00 {
	u32 raw;
	struct {
		u32 __reserved_2: 14;
		u32 LTS: 1;
		u32 delivery_type: 1;
		u32 __reserved_1: 8;
		u32 ID: 8;
	} bits;
};

union IO_APIC_reg_01 {
	u32 raw;
	struct {
		u32 version: 8;
		u32 __reserved_2: 7;
		u32 PRQ: 1;
		u32 entries: 8;
		u32 __reserved_1: 8;
	} bits;
};

union IO_APIC_reg_02 {
	u32 raw;
	struct {
		u32 __reserved_2: 24;
		u32 arbitration: 4;
		u32 __reserved_1: 4;
	} bits;
};

union IO_APIC_reg_03 {
	u32 raw;
	struct {
		u32 boot_DT: 1;
		u32 __reserved_1: 31;
	} bits;
};

struct IR_IO_APIC_route_entry {
	__u64 vector: 8;
	__u64 zero: 3;
	__u64 index2: 1;
	__u64 delivery_status: 1;
	__u64 polarity: 1;
	__u64 irr: 1;
	__u64 trigger: 1;
	__u64 mask: 1;
	__u64 reserved: 31;
	__u64 format: 1;
	__u64 index: 15;
};

enum {
	IRQ_TYPE_NONE = 0,
	IRQ_TYPE_EDGE_RISING = 1,
	IRQ_TYPE_EDGE_FALLING = 2,
	IRQ_TYPE_EDGE_BOTH = 3,
	IRQ_TYPE_LEVEL_HIGH = 4,
	IRQ_TYPE_LEVEL_LOW = 8,
	IRQ_TYPE_LEVEL_MASK = 12,
	IRQ_TYPE_SENSE_MASK = 15,
	IRQ_TYPE_DEFAULT = 15,
	IRQ_TYPE_PROBE = 16,
	IRQ_LEVEL = 256,
	IRQ_PER_CPU = 512,
	IRQ_NOPROBE = 1024,
	IRQ_NOREQUEST = 2048,
	IRQ_NOAUTOEN = 4096,
	IRQ_NO_BALANCING = 8192,
	IRQ_MOVE_PCNTXT = 16384,
	IRQ_NESTED_THREAD = 32768,
	IRQ_NOTHREAD = 65536,
	IRQ_PER_CPU_DEVID = 131072,
	IRQ_IS_POLLED = 262144,
	IRQ_DISABLE_UNLAZY = 524288,
};

enum {
	IRQCHIP_SET_TYPE_MASKED = 1,
	IRQCHIP_EOI_IF_HANDLED = 2,
	IRQCHIP_MASK_ON_SUSPEND = 4,
	IRQCHIP_ONOFFLINE_ENABLED = 8,
	IRQCHIP_SKIP_SET_WAKE = 16,
	IRQCHIP_ONESHOT_SAFE = 32,
	IRQCHIP_EOI_THREADED = 64,
	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
	IRQCHIP_SUPPORTS_NMI = 256,
};

struct clock_event_device;

struct irq_pin_list {
	struct list_head list;
	int apic;
	int pin;
};

struct mp_chip_data {
	struct list_head irq_2_pin;
	struct IO_APIC_route_entry entry;
	int trigger;
	int polarity;
	u32 count;
	bool isa_irq;
};

struct mp_ioapic_gsi {
	u32 gsi_base;
	u32 gsi_end;
};

struct ioapic {
	int nr_registers;
	struct IO_APIC_route_entry *saved_registers;
	struct mpc_ioapic mp_config;
	struct mp_ioapic_gsi gsi_config;
	struct ioapic_domain_cfg irqdomain_cfg;
	struct irq_domain *irqdomain;
	struct resource *iomem_res;
};

struct io_apic {
	unsigned int index;
	unsigned int unused[3];
	unsigned int data;
	unsigned int unused2[11];
	unsigned int eoi;
};

union entry_union {
	struct {
		u32 w1;
		u32 w2;
	};
	struct IO_APIC_route_entry entry;
};

enum {
	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
	IRQ_DOMAIN_NAME_ALLOCATED = 2,
	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
	IRQ_DOMAIN_FLAG_MSI = 16,
	IRQ_DOMAIN_FLAG_MSI_REMAP = 32,
	IRQ_DOMAIN_MSI_NOMASK_QUIRK = 64,
	IRQ_DOMAIN_FLAG_NONCORE = 65536,
};

typedef struct irq_alloc_info msi_alloc_info_t;

struct msi_domain_info;

struct msi_domain_ops {
	irq_hw_number_t (*get_hwirq)(struct msi_domain_info *, msi_alloc_info_t *);
	int (*msi_init)(struct irq_domain *, struct msi_domain_info *, unsigned int, irq_hw_number_t, msi_alloc_info_t *);
	void (*msi_free)(struct irq_domain *, struct msi_domain_info *, unsigned int);
	int (*msi_check)(struct irq_domain *, struct msi_domain_info *, struct device *);
	int (*msi_prepare)(struct irq_domain *, struct device *, int, msi_alloc_info_t *);
	void (*msi_finish)(msi_alloc_info_t *, int);
	void (*set_desc)(msi_alloc_info_t *, struct msi_desc *);
	int (*handle_error)(struct irq_domain *, struct msi_desc *, int);
};

struct msi_domain_info {
	u32 flags;
	struct msi_domain_ops *ops;
	struct irq_chip *chip;
	void *chip_data;
	irq_flow_handler_t handler;
	void *handler_data;
	const char *handler_name;
	void *data;
};

enum {
	MSI_FLAG_USE_DEF_DOM_OPS = 1,
	MSI_FLAG_USE_DEF_CHIP_OPS = 2,
	MSI_FLAG_MULTI_PCI_MSI = 4,
	MSI_FLAG_PCI_MSIX = 8,
	MSI_FLAG_ACTIVATE_EARLY = 16,
	MSI_FLAG_MUST_REACTIVATE = 32,
	MSI_FLAG_LEVEL_CAPABLE = 64,
};

struct hpet_channel;

typedef u16 pto_T_____13;

struct cluster_mask {
	unsigned int clusterid;
	int node;
	struct cpumask mask;
};

typedef struct cluster_mask *pto_T_____14;

struct dyn_arch_ftrace {};

enum {
	FTRACE_OPS_FL_ENABLED = 1,
	FTRACE_OPS_FL_DYNAMIC = 2,
	FTRACE_OPS_FL_SAVE_REGS = 4,
	FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED = 8,
	FTRACE_OPS_FL_RECURSION_SAFE = 16,
	FTRACE_OPS_FL_STUB = 32,
	FTRACE_OPS_FL_INITIALIZED = 64,
	FTRACE_OPS_FL_DELETED = 128,
	FTRACE_OPS_FL_ADDING = 256,
	FTRACE_OPS_FL_REMOVING = 512,
	FTRACE_OPS_FL_MODIFYING = 1024,
	FTRACE_OPS_FL_ALLOC_TRAMP = 2048,
	FTRACE_OPS_FL_IPMODIFY = 4096,
	FTRACE_OPS_FL_PID = 8192,
	FTRACE_OPS_FL_RCU = 16384,
	FTRACE_OPS_FL_TRACE_ARRAY = 32768,
};

enum {
	FTRACE_FL_ENABLED = 2147483648,
	FTRACE_FL_REGS = 1073741824,
	FTRACE_FL_REGS_EN = 536870912,
	FTRACE_FL_TRAMP = 268435456,
	FTRACE_FL_TRAMP_EN = 134217728,
	FTRACE_FL_IPMODIFY = 67108864,
	FTRACE_FL_DISABLED = 33554432,
};

struct dyn_ftrace {
	long unsigned int ip;
	long unsigned int flags;
	struct dyn_arch_ftrace arch;
};

enum {
	FTRACE_UPDATE_IGNORE = 0,
	FTRACE_UPDATE_MAKE_CALL = 1,
	FTRACE_UPDATE_MODIFY_CALL = 2,
	FTRACE_UPDATE_MAKE_NOP = 3,
};

union ftrace_code_union {
	char code[5];
	struct {
		unsigned char op;
		int offset;
	} __attribute__((packed));
};

union ftrace_op_code_union {
	char code[7];
	struct {
		char op[3];
		int offset;
	} __attribute__((packed));
};

struct ftrace_rec_iter;

struct klp_func {
	const char *old_name;
	void *new_func;
	long unsigned int old_sympos;
	void *old_func;
	struct kobject kobj;
	struct list_head node;
	struct list_head stack_node;
	long unsigned int old_size;
	long unsigned int new_size;
	bool nop;
	bool patched;
	bool transition;
};

struct klp_object;

struct klp_callbacks {
	int (*pre_patch)(struct klp_object *);
	void (*post_patch)(struct klp_object *);
	void (*pre_unpatch)(struct klp_object *);
	void (*post_unpatch)(struct klp_object *);
	bool post_unpatch_enabled;
};

struct klp_object {
	const char *name;
	struct klp_func *funcs;
	struct klp_callbacks callbacks;
	struct kobject kobj;
	struct list_head func_list;
	struct list_head node;
	struct module *mod;
	bool dynamic;
	bool patched;
};

struct klp_patch {
	struct module *mod;
	struct klp_object *objs;
	bool replace;
	struct list_head list;
	struct kobject kobj;
	struct list_head obj_list;
	bool enabled;
	bool forced;
	struct work_struct free_work;
	struct completion finish;
};

typedef __s64 Elf64_Sxword;

struct elf64_rela {
	Elf64_Addr r_offset;
	Elf64_Xword r_info;
	Elf64_Sxword r_addend;
};

typedef struct elf64_rela Elf64_Rela;

struct kimage_arch {
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;
	long unsigned int backup_src_start;
	long unsigned int backup_src_sz;
	long unsigned int backup_load_addr;
	void *elf_headers;
	long unsigned int elf_headers_sz;
	long unsigned int elf_load_addr;
};

typedef long unsigned int kimage_entry_t;

struct kexec_segment {
	union {
		void *buf;
		void *kbuf;
	};
	size_t bufsz;
	long unsigned int mem;
	size_t memsz;
};

struct purgatory_info {
	const Elf64_Ehdr *ehdr;
	Elf64_Shdr *sechdrs;
	void *purgatory_buf;
};

typedef int kexec_probe_t(const char *, long unsigned int);

struct kimage;

typedef void *kexec_load_t(struct kimage *, char *, long unsigned int, char *, long unsigned int, char *, long unsigned int);

struct kexec_file_ops;

struct kimage {
	kimage_entry_t head;
	kimage_entry_t *entry;
	kimage_entry_t *last_entry;
	long unsigned int start;
	struct page *control_code_page;
	struct page *swap_page;
	void *vmcoreinfo_data_copy;
	long unsigned int nr_segments;
	struct kexec_segment segment[16];
	struct list_head control_pages;
	struct list_head dest_pages;
	struct list_head unusable_pages;
	long unsigned int control_page;
	unsigned int type: 1;
	unsigned int preserve_context: 1;
	unsigned int file_mode: 1;
	struct kimage_arch arch;
	void *kernel_buf;
	long unsigned int kernel_buf_len;
	void *initrd_buf;
	long unsigned int initrd_buf_len;
	char *cmdline_buf;
	long unsigned int cmdline_buf_len;
	const struct kexec_file_ops *fops;
	void *image_loader_data;
	struct purgatory_info purgatory_info;
};

typedef int kexec_cleanup_t(void *);

struct kexec_file_ops {
	kexec_probe_t *probe;
	kexec_load_t *load;
	kexec_cleanup_t *cleanup;
};

struct x86_mapping_info {
	void * (*alloc_pgt_page)(void *);
	void *context;
	long unsigned int page_flag;
	long unsigned int offset;
	bool direct_gbpages;
	long unsigned int kernpg_flag;
};

struct init_pgtable_data {
	struct x86_mapping_info *info;
	pgd_t *level4p;
};

struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
};

typedef struct elf64_phdr Elf64_Phdr;

typedef void crash_vmclear_fn();

struct kexec_buf {
	struct kimage *image;
	void *buffer;
	long unsigned int bufsz;
	long unsigned int mem;
	long unsigned int memsz;
	long unsigned int buf_align;
	long unsigned int buf_min;
	long unsigned int buf_max;
	bool top_down;
};

struct crash_mem_range {
	u64 start;
	u64 end;
};

struct crash_mem {
	unsigned int max_nr_ranges;
	unsigned int nr_ranges;
	struct crash_mem_range ranges[0];
};

struct crash_memmap_data {
	struct boot_params *params;
	unsigned int type;
};

struct kexec_entry64_regs {
	uint64_t rax;
	uint64_t rcx;
	uint64_t rdx;
	uint64_t rbx;
	uint64_t rsp;
	uint64_t rbp;
	uint64_t rsi;
	uint64_t rdi;
	uint64_t r8;
	uint64_t r9;
	uint64_t r10;
	uint64_t r11;
	uint64_t r12;
	uint64_t r13;
	uint64_t r14;
	uint64_t r15;
	uint64_t rip;
};

enum key_being_used_for {
	VERIFYING_MODULE_SIGNATURE = 0,
	VERIFYING_FIRMWARE_SIGNATURE = 1,
	VERIFYING_KEXEC_PE_SIGNATURE = 2,
	VERIFYING_KEY_SIGNATURE = 3,
	VERIFYING_KEY_SELF_SIGNATURE = 4,
	VERIFYING_UNSPECIFIED_SIGNATURE = 5,
	NR__KEY_BEING_USED_FOR = 6,
};

struct efi_setup_data {
	u64 fw_vendor;
	u64 runtime;
	u64 tables;
	u64 smbios;
	u64 reserved[8];
};

struct bzimage64_data {
	void *bootparams_buf;
};

struct prev_kprobe {
	struct kprobe *kp;
	long unsigned int status;
	long unsigned int old_flags;
	long unsigned int saved_flags;
};

struct kprobe_ctlblk {
	long unsigned int kprobe_status;
	long unsigned int kprobe_old_flags;
	long unsigned int kprobe_saved_flags;
	struct prev_kprobe prev_kprobe;
};

struct kretprobe_instance;

typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);

struct kretprobe;

struct kretprobe_instance {
	struct hlist_node hlist;
	struct kretprobe *rp;
	kprobe_opcode_t *ret_addr;
	struct task_struct *task;
	void *fp;
	char data[0];
};

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
	int nmissed;
	size_t data_size;
	struct hlist_head free_instances;
	raw_spinlock_t lock;
};

struct kretprobe_blackpoint {
	const char *name;
	void *addr;
};

struct kprobe_insn_cache {
	struct mutex mutex;
	void * (*alloc)();
	void (*free)(void *);
	struct list_head pages;
	size_t insn_size;
	int nr_garbage;
};

typedef struct kprobe *pto_T_____15;

struct __arch_relative_insn {
	u8 op;
	s32 raddr;
} __attribute__((packed));

struct arch_optimized_insn {
	kprobe_opcode_t copied_insn[4];
	kprobe_opcode_t *insn;
	size_t size;
};

struct optimized_kprobe {
	struct kprobe kp;
	struct list_head list;
	struct arch_optimized_insn optinsn;
};

struct console {
	char name[16];
	void (*write)(struct console *, const char *, unsigned int);
	int (*read)(struct console *, char *, unsigned int);
	struct tty_driver * (*device)(struct console *, int *);
	void (*unblank)();
	int (*setup)(struct console *, char *);
	int (*match)(struct console *, char *, int, char *);
	short int flags;
	short int index;
	int cflag;
	void *data;
	struct console *next;
};

struct hpet_data {
	long unsigned int hd_phys_address;
	void *hd_address;
	short unsigned int hd_nirqs;
	unsigned int hd_state;
	unsigned int hd_irq[32];
};

typedef irqreturn_t (*rtc_irq_handler)(int, void *);

enum hpet_mode {
	HPET_MODE_UNUSED = 0,
	HPET_MODE_LEGACY = 1,
	HPET_MODE_CLOCKEVT = 2,
	HPET_MODE_DEVICE = 3,
};

struct hpet_channel {
	struct clock_event_device evt;
	unsigned int num;
	unsigned int cpu;
	unsigned int irq;
	unsigned int in_use;
	enum hpet_mode mode;
	unsigned int boot_cfg;
	char name[10];
	long: 48;
	long: 64;
	long: 64;
	long: 64;
};

struct hpet_base {
	unsigned int nr_channels;
	unsigned int nr_clockevents;
	unsigned int boot_cfg;
	struct hpet_channel *channels;
};

union hpet_lock {
	struct {
		arch_spinlock_t lock;
		u32 value;
	};
	u64 lockval;
};

struct amd_nb_bus_dev_range {
	u8 bus;
	u8 dev_base;
	u8 dev_limit;
};

struct amd_northbridge_info {
	u16 num;
	u64 flags;
	struct amd_northbridge *nb;
};

struct static_key_true {
	struct static_key key;
};

struct kvm_steal_time {
	__u64 steal;
	__u32 version;
	__u32 flags;
	__u8 preempted;
	__u8 u8_pad[3];
	__u32 pad[11];
};

struct kvm_vcpu_pv_apf_data {
	__u32 reason;
	__u8 pad[60];
	__u32 enabled;
};

struct swait_queue_head {
	raw_spinlock_t lock;
	struct list_head task_list;
};

struct swait_queue {
	struct task_struct *task;
	struct list_head task_list;
};

struct kvm_task_sleep_node {
	struct hlist_node link;
	struct swait_queue_head wq;
	u32 token;
	int cpu;
	bool halted;
};

struct kvm_task_sleep_head {
	raw_spinlock_t lock;
	struct hlist_head list;
};

typedef __u32 pto_T_____16;

struct pvclock_wall_clock {
	u32 version;
	u32 sec;
	u32 nsec;
};

typedef struct pvclock_vsyscall_time_info *pto_T_____17;

enum paravirt_lazy_mode {
	PARAVIRT_LAZY_NONE = 0,
	PARAVIRT_LAZY_MMU = 1,
	PARAVIRT_LAZY_CPU = 2,
};

struct branch {
	unsigned char opcode;
	u32 delta;
} __attribute__((packed));

typedef enum paravirt_lazy_mode pto_T_____18;

struct patch_lock {
	unsigned char queued_spin_unlock[3];
	unsigned char vcpu_is_preempted[2];
};

typedef long unsigned int ulong;

struct jailhouse_setup_data {
	__u16 version;
	__u16 compatible_version;
	__u16 pm_timer_address;
	__u16 num_cpus;
	__u64 pci_mmconfig_base;
	__u32 tsc_khz;
	__u32 apic_khz;
	__u8 standard_ioapic;
	__u8 cpu_ids[255];
};

struct pci_mmcfg_region {
	struct list_head list;
	struct resource res;
	u64 address;
	char *virt;
	u16 segment;
	u8 start_bus;
	u8 end_bus;
	char name[30];
};

struct scan_area {
	u64 addr;
	u64 size;
};

enum swiotlb_force {
	SWIOTLB_NORMAL = 0,
	SWIOTLB_FORCE = 1,
	SWIOTLB_NO_FORCE = 2,
};

struct uprobe_xol_ops;

struct arch_uprobe {
	union {
		u8 insn[16];
		u8 ixol[16];
	};
	const struct uprobe_xol_ops *ops;
	union {
		struct {
			s32 offs;
			u8 ilen;
			u8 opc1;
		} branch;
		struct {
			u8 fixups;
			u8 ilen;
		} defparam;
		struct {
			u8 reg_offset;
			u8 ilen;
		} push;
	};
};

struct uprobe_xol_ops {
	bool (*emulate)(struct arch_uprobe *, struct pt_regs *);
	int (*pre_xol)(struct arch_uprobe *, struct pt_regs *);
	int (*post_xol)(struct arch_uprobe *, struct pt_regs *);
	void (*abort)(struct arch_uprobe *, struct pt_regs *);
};

enum rp_check {
	RP_CHECK_CALL = 0,
	RP_CHECK_CHAIN_CALL = 1,
	RP_CHECK_RET = 2,
};

enum dev_prop_type {
	DEV_PROP_U8 = 0,
	DEV_PROP_U16 = 1,
	DEV_PROP_U32 = 2,
	DEV_PROP_U64 = 3,
	DEV_PROP_STRING = 4,
	DEV_PROP_MAX = 5,
};

struct property_entry {
	const char *name;
	size_t length;
	bool is_array;
	enum dev_prop_type type;
	union {
		union {
			const u8 *u8_data;
			const u16 *u16_data;
			const u32 *u32_data;
			const u64 *u64_data;
			const char * const *str;
		} pointer;
		union {
			u8 u8_data;
			u16 u16_data;
			u32 u32_data;
			u64 u64_data;
			const char *str;
		} value;
	};
};

struct simplefb_platform_data {
	u32 width;
	u32 height;
	u32 stride;
	const char *format;
};

enum {
	M_I17 = 0,
	M_I20 = 1,
	M_I20_SR = 2,
	M_I24 = 3,
	M_I24_8_1 = 4,
	M_I24_10_1 = 5,
	M_I27_11_1 = 6,
	M_MINI = 7,
	M_MINI_3_1 = 8,
	M_MINI_4_1 = 9,
	M_MB = 10,
	M_MB_2 = 11,
	M_MB_3 = 12,
	M_MB_5_1 = 13,
	M_MB_6_1 = 14,
	M_MB_7_1 = 15,
	M_MB_SR = 16,
	M_MBA = 17,
	M_MBA_3 = 18,
	M_MBP = 19,
	M_MBP_2 = 20,
	M_MBP_2_2 = 21,
	M_MBP_SR = 22,
	M_MBP_4 = 23,
	M_MBP_5_1 = 24,
	M_MBP_5_2 = 25,
	M_MBP_5_3 = 26,
	M_MBP_6_1 = 27,
	M_MBP_6_2 = 28,
	M_MBP_7_1 = 29,
	M_MBP_8_2 = 30,
	M_UNKNOWN = 31,
};

struct efifb_dmi_info {
	char *optname;
	long unsigned int base;
	int stride;
	int width;
	int height;
	int flags;
};

enum {
	OVERRIDE_NONE = 0,
	OVERRIDE_BASE = 1,
	OVERRIDE_STRIDE = 2,
	OVERRIDE_HEIGHT = 4,
	OVERRIDE_WIDTH = 8,
};

enum perf_sample_regs_abi {
	PERF_SAMPLE_REGS_ABI_NONE = 0,
	PERF_SAMPLE_REGS_ABI_32 = 1,
	PERF_SAMPLE_REGS_ABI_64 = 2,
};

struct va_format {
	const char *fmt;
	va_list *va;
};

enum chipset_type {
	NOT_SUPPORTED = 0,
	SUPPORTED = 1,
};

struct agp_version {
	u16 major;
	u16 minor;
};

struct agp_kern_info {
	struct agp_version version;
	struct pci_dev *device;
	enum chipset_type chipset;
	long unsigned int mode;
	long unsigned int aper_base;
	size_t aper_size;
	int max_memory;
	int current_memory;
	bool cant_use_aperture;
	long unsigned int page_mask;
	const struct vm_operations_struct *vm_ops;
};

struct pci_hostbridge_probe {
	u32 bus;
	u32 slot;
	u32 vendor;
	u32 device;
};

typedef u8 uint8_t;

enum pg_level {
	PG_LEVEL_NONE = 0,
	PG_LEVEL_4K = 1,
	PG_LEVEL_2M = 2,
	PG_LEVEL_1G = 3,
	PG_LEVEL_512G = 4,
	PG_LEVEL_NUM = 5,
};

struct trace_print_flags {
	long unsigned int mask;
	const char *name;
};

enum tlb_flush_reason {
	TLB_FLUSH_ON_TASK_SWITCH = 0,
	TLB_REMOTE_SHOOTDOWN = 1,
	TLB_LOCAL_SHOOTDOWN = 2,
	TLB_LOCAL_MM_SHOOTDOWN = 3,
	TLB_REMOTE_SEND_IPI = 4,
	NR_TLB_FLUSH_REASONS = 5,
};

enum {
	REGION_INTERSECTS = 0,
	REGION_DISJOINT = 1,
	REGION_MIXED = 2,
};

struct trace_event_raw_tlb_flush {
	struct trace_entry ent;
	int reason;
	long unsigned int pages;
	char __data[0];
};

struct trace_event_data_offsets_tlb_flush {};

typedef void (*btf_trace_tlb_flush)(void *, int, long unsigned int);

struct map_range {
	long unsigned int start;
	long unsigned int end;
	unsigned int page_size_mask;
};

enum {
	MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE = 12,
	SECTION_INFO = 12,
	MIX_SECTION_INFO = 13,
	NODE_INFO = 14,
	MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE = 14,
};

struct mhp_restrictions {
	long unsigned int flags;
	struct vmem_altmap *altmap;
};

struct mem_section_usage {
	long unsigned int subsection_map[1];
	long unsigned int pageblock_flags[0];
};

struct mem_section {
	long unsigned int section_mem_map;
	struct mem_section_usage *usage;
};

enum kcore_type {
	KCORE_TEXT = 0,
	KCORE_VMALLOC = 1,
	KCORE_RAM = 2,
	KCORE_VMEMMAP = 3,
	KCORE_USER = 4,
	KCORE_OTHER = 5,
	KCORE_REMAP = 6,
};

struct kcore_list {
	struct list_head list;
	long unsigned int addr;
	long unsigned int vaddr;
	size_t size;
	int type;
};

struct hstate {
	int next_nid_to_alloc;
	int next_nid_to_free;
	unsigned int order;
	long unsigned int mask;
	long unsigned int max_huge_pages;
	long unsigned int nr_huge_pages;
	long unsigned int free_huge_pages;
	long unsigned int resv_huge_pages;
	long unsigned int surplus_huge_pages;
	long unsigned int nr_overcommit_huge_pages;
	struct list_head hugepage_activelist;
	struct list_head hugepage_freelists[1024];
	unsigned int nr_huge_pages_node[1024];
	unsigned int free_huge_pages_node[1024];
	unsigned int surplus_huge_pages_node[1024];
	struct cftype cgroup_files[5];
	char name[32];
};

struct trace_event_raw_x86_exceptions {
	struct trace_entry ent;
	long unsigned int address;
	long unsigned int ip;
	long unsigned int error_code;
	char __data[0];
};

struct trace_event_data_offsets_x86_exceptions {};

typedef void (*btf_trace_page_fault_user)(void *, long unsigned int, struct pt_regs *, long unsigned int);

typedef void (*btf_trace_page_fault_kernel)(void *, long unsigned int, struct pt_regs *, long unsigned int);

enum {
	IORES_MAP_SYSTEM_RAM = 1,
	IORES_MAP_ENCRYPTED = 2,
};

struct ioremap_desc {
	unsigned int flags;
};

typedef bool (*ex_handler_t)(const struct exception_table_entry *, struct pt_regs *, int, long unsigned int, long unsigned int);

struct cpa_data {
	long unsigned int *vaddr;
	pgd_t *pgd;
	pgprot_t mask_set;
	pgprot_t mask_clr;
	long unsigned int numpages;
	long unsigned int curpage;
	long unsigned int pfn;
	unsigned int flags;
	unsigned int force_split: 1;
	unsigned int force_static_prot: 1;
	unsigned int force_flush_all: 1;
	struct page **pages;
};

enum cpa_warn {
	CPA_CONFLICT = 0,
	CPA_PROTECT = 1,
	CPA_DETECT = 2,
};

typedef struct {
	u64 val;
} pfn_t;

struct memtype {
	u64 start;
	u64 end;
	u64 subtree_max_end;
	enum page_cache_mode type;
	struct rb_node rb;
};

enum {
	PAT_UC = 0,
	PAT_WC = 1,
	PAT_WT = 4,
	PAT_WP = 5,
	PAT_WB = 6,
	PAT_UC_MINUS = 7,
};

struct pagerange_state {
	long unsigned int cur_pfn;
	int ram;
	int not_ram;
};

struct hugepage_subpool {
	spinlock_t lock;
	long int count;
	long int max_hpages;
	long int used_hpages;
	struct hstate *hstate;
	long int min_hpages;
	long int rsv_hpages;
};

struct hugetlbfs_sb_info {
	long int max_inodes;
	long int free_inodes;
	spinlock_t stat_lock;
	struct hstate *hstate;
	struct hugepage_subpool *spool;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

typedef struct mm_struct *pto_T_____19;

struct exception_stacks {
	char DF_stack_guard[0];
	char DF_stack[4096];
	char NMI_stack_guard[0];
	char NMI_stack[4096];
	char DB2_stack_guard[0];
	char DB2_stack[0];
	char DB1_stack_guard[0];
	char DB1_stack[4096];
	char DB_stack_guard[0];
	char DB_stack[4096];
	char MCE_stack_guard[0];
	char MCE_stack[4096];
	char IST_top_guard[0];
};

struct rb_augment_callbacks {
	void (*propagate)(struct rb_node *, struct rb_node *);
	void (*copy)(struct rb_node *, struct rb_node *);
	void (*rotate)(struct rb_node *, struct rb_node *);
};

enum {
	MEMTYPE_EXACT_MATCH = 0,
	MEMTYPE_END_MATCH = 1,
};

struct numa_memblk {
	u64 start;
	u64 end;
	int nid;
};

struct numa_meminfo {
	int nr_blks;
	struct numa_memblk blk[2048];
};

struct acpi_srat_cpu_affinity {
	struct acpi_subtable_header header;
	u8 proximity_domain_lo;
	u8 apic_id;
	u32 flags;
	u8 local_sapic_eid;
	u8 proximity_domain_hi[3];
	u32 clock_domain;
};

struct acpi_srat_x2apic_cpu_affinity {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 proximity_domain;
	u32 apic_id;
	u32 flags;
	u32 clock_domain;
	u32 reserved2;
};

enum uv_system_type {
	UV_NONE = 0,
	UV_LEGACY_APIC = 1,
	UV_X2APIC = 2,
	UV_NON_UNIQUE_APIC = 3,
};

struct mpx_bndreg {
	u64 lower_bound;
	u64 upper_bound;
};

struct mpx_bndreg_state {
	struct mpx_bndreg bndreg[4];
};

typedef long unsigned int vm_flags_t;

struct trace_event_raw_mpx_bounds_register_exception {
	struct trace_entry ent;
	void *addr_referenced;
	u64 lower_bound;
	u64 upper_bound;
	char __data[0];
};

struct trace_event_raw_bounds_exception_mpx {
	struct trace_entry ent;
	u64 bndcfgu;
	u64 bndstatus;
	char __data[0];
};

struct trace_event_raw_mpx_range_trace {
	struct trace_entry ent;
	long unsigned int start;
	long unsigned int end;
	char __data[0];
};

struct trace_event_raw_mpx_new_bounds_table {
	struct trace_entry ent;
	long unsigned int table_vaddr;
	char __data[0];
};

struct trace_event_data_offsets_mpx_bounds_register_exception {};

struct trace_event_data_offsets_bounds_exception_mpx {};

struct trace_event_data_offsets_mpx_range_trace {};

struct trace_event_data_offsets_mpx_new_bounds_table {};

typedef void (*btf_trace_mpx_bounds_register_exception)(void *, void *, const struct mpx_bndreg *);

typedef void (*btf_trace_bounds_exception_mpx)(void *, const struct mpx_bndcsr *);

typedef void (*btf_trace_mpx_unmap_zap)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_mpx_unmap_search)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_mpx_new_bounds_table)(void *, long unsigned int);

enum pti_mode {
	PTI_AUTO = 0,
	PTI_FORCE_OFF = 1,
	PTI_FORCE_ON = 2,
};

enum pti_clone_level {
	PTI_CLONE_PMD = 0,
	PTI_CLONE_PTE = 1,
};

struct sme_populate_pgd_data {
	void *pgtable_area;
	pgd_t *pgd;
	pmdval_t pmd_flags;
	pteval_t pte_flags;
	long unsigned int paddr;
	long unsigned int vaddr;
	long unsigned int vaddr_end;
};

typedef short unsigned int __kernel_old_uid_t;

typedef short unsigned int __kernel_old_gid_t;

typedef struct {
	int val[2];
} __kernel_fsid_t;

typedef __kernel_old_uid_t old_uid_t;

typedef __kernel_old_gid_t old_gid_t;

struct kstatfs {
	long int f_type;
	long int f_bsize;
	u64 f_blocks;
	u64 f_bfree;
	u64 f_bavail;
	u64 f_files;
	u64 f_ffree;
	__kernel_fsid_t f_fsid;
	long int f_namelen;
	long int f_frsize;
	long int f_flags;
	long int f_spare[4];
};

struct kernel_clone_args {
	u64 flags;
	int *pidfd;
	int *child_tid;
	int *parent_tid;
	int exit_signal;
	long unsigned int stack;
	long unsigned int stack_size;
	long unsigned int tls;
};

struct stat64 {
	long long unsigned int st_dev;
	unsigned char __pad0[4];
	unsigned int __st_ino;
	unsigned int st_mode;
	unsigned int st_nlink;
	unsigned int st_uid;
	unsigned int st_gid;
	long long unsigned int st_rdev;
	unsigned char __pad3[4];
	long long int st_size;
	unsigned int st_blksize;
	long long int st_blocks;
	unsigned int st_atime;
	unsigned int st_atime_nsec;
	unsigned int st_mtime;
	unsigned int st_mtime_nsec;
	unsigned int st_ctime;
	unsigned int st_ctime_nsec;
	long long unsigned int st_ino;
} __attribute__((packed));

struct mmap_arg_struct32 {
	unsigned int addr;
	unsigned int len;
	unsigned int prot;
	unsigned int flags;
	unsigned int fd;
	unsigned int offset;
};

struct sigcontext_32 {
	__u16 gs;
	__u16 __gsh;
	__u16 fs;
	__u16 __fsh;
	__u16 es;
	__u16 __esh;
	__u16 ds;
	__u16 __dsh;
	__u32 di;
	__u32 si;
	__u32 bp;
	__u32 sp;
	__u32 bx;
	__u32 dx;
	__u32 cx;
	__u32 ax;
	__u32 trapno;
	__u32 err;
	__u32 ip;
	__u16 cs;
	__u16 __csh;
	__u32 flags;
	__u32 sp_at_signal;
	__u16 ss;
	__u16 __ssh;
	__u32 fpstate;
	__u32 oldmask;
	__u32 cr2;
};

typedef u32 compat_size_t;

struct compat_sigaltstack {
	compat_uptr_t ss_sp;
	int ss_flags;
	compat_size_t ss_size;
};

typedef struct compat_sigaltstack compat_stack_t;

struct ucontext_ia32 {
	unsigned int uc_flags;
	unsigned int uc_link;
	compat_stack_t uc_stack;
	struct sigcontext_32 uc_mcontext;
	compat_sigset_t uc_sigmask;
};

struct sigframe_ia32 {
	u32 pretcode;
	int sig;
	struct sigcontext_32 sc;
	struct _fpstate_32 fpstate_unused;
	unsigned int extramask[1];
	char retcode[8];
};

struct rt_sigframe_ia32 {
	u32 pretcode;
	int sig;
	u32 pinfo;
	u32 puc;
	compat_siginfo_t info;
	struct ucontext_ia32 uc;
	char retcode[8];
};

typedef struct {
	efi_guid_t guid;
	u64 table;
} efi_config_table_64_t;

struct efi_mem_range {
	struct range range;
	u64 attribute;
};

enum efi_rts_ids {
	EFI_NONE = 0,
	EFI_GET_TIME = 1,
	EFI_SET_TIME = 2,
	EFI_GET_WAKEUP_TIME = 3,
	EFI_SET_WAKEUP_TIME = 4,
	EFI_GET_VARIABLE = 5,
	EFI_GET_NEXT_VARIABLE = 6,
	EFI_SET_VARIABLE = 7,
	EFI_QUERY_VARIABLE_INFO = 8,
	EFI_GET_NEXT_HIGH_MONO_COUNT = 9,
	EFI_RESET_SYSTEM = 10,
	EFI_UPDATE_CAPSULE = 11,
	EFI_QUERY_CAPSULE_CAPS = 12,
};

struct efi_runtime_work {
	void *arg1;
	void *arg2;
	void *arg3;
	void *arg4;
	void *arg5;
	efi_status_t status;
	struct work_struct work;
	enum efi_rts_ids efi_rts_id;
	struct completion efi_rts_comp;
};

struct efi_scratch {
	u64 phys_stack;
	struct mm_struct *prev_mm;
};

typedef struct {
	efi_table_hdr_t hdr;
	u32 get_time;
	u32 set_time;
	u32 get_wakeup_time;
	u32 set_wakeup_time;
	u32 set_virtual_address_map;
	u32 convert_pointer;
	u32 get_variable;
	u32 get_next_variable;
	u32 set_variable;
	u32 get_next_high_mono_count;
	u32 reset_system;
	u32 update_capsule;
	u32 query_capsule_caps;
	u32 query_variable_info;
} efi_runtime_services_32_t;

typedef struct {
	efi_table_hdr_t hdr;
	u64 get_time;
	u64 set_time;
	u64 get_wakeup_time;
	u64 set_wakeup_time;
	u64 set_virtual_address_map;
	u64 convert_pointer;
	u64 get_variable;
	u64 get_next_variable;
	u64 set_variable;
	u64 get_next_high_mono_count;
	u64 reset_system;
	u64 update_capsule;
	u64 query_capsule_caps;
	u64 query_variable_info;
} efi_runtime_services_64_t;

typedef struct {
	efi_guid_t guid;
	const char *name;
	long unsigned int *ptr;
} efi_config_table_type_t;

typedef struct {
	efi_table_hdr_t hdr;
	u64 fw_vendor;
	u32 fw_revision;
	u32 __pad1;
	u64 con_in_handle;
	u64 con_in;
	u64 con_out_handle;
	u64 con_out;
	u64 stderr_handle;
	u64 stderr;
	u64 runtime;
	u64 boottime;
	u32 nr_tables;
	u32 __pad2;
	u64 tables;
} efi_system_table_64_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 fw_vendor;
	u32 fw_revision;
	u32 con_in_handle;
	u32 con_in;
	u32 con_out_handle;
	u32 con_out;
	u32 stderr_handle;
	u32 stderr;
	u32 runtime;
	u32 boottime;
	u32 nr_tables;
	u32 tables;
} efi_system_table_32_t;

struct efi_memory_map_data {
	phys_addr_t phys_map;
	long unsigned int size;
	long unsigned int desc_version;
	long unsigned int desc_size;
};

typedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *);

enum {
	BPF_REG_0 = 0,
	BPF_REG_1 = 1,
	BPF_REG_2 = 2,
	BPF_REG_3 = 3,
	BPF_REG_4 = 4,
	BPF_REG_5 = 5,
	BPF_REG_6 = 6,
	BPF_REG_7 = 7,
	BPF_REG_8 = 8,
	BPF_REG_9 = 9,
	BPF_REG_10 = 10,
	__MAX_BPF_REG = 11,
};

struct bpf_tramp_progs {
	struct bpf_prog *progs[40];
	int nr_progs;
};

enum bpf_jit_poke_reason {
	BPF_POKE_REASON_TAIL_CALL = 0,
};

struct bpf_array_aux {
	enum bpf_prog_type type;
	bool jited;
	struct list_head poke_progs;
	struct bpf_map *map;
	struct mutex poke_mutex;
	struct work_struct work;
};

struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	union {
		char value[0];
		void *ptrs[0];
		void *pptrs[0];
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum bpf_text_poke_type {
	BPF_MOD_CALL = 0,
	BPF_MOD_JUMP = 1,
};

struct bpf_binary_header {
	u32 pages;
	int: 32;
	u8 image[0];
};

typedef void (*bpf_jit_fill_hole_t)(void *, unsigned int);

struct jit_context {
	int cleanup_addr;
};

struct x64_jit_data {
	struct bpf_binary_header *header;
	int *addrs;
	u8 *image;
	int proglen;
	struct jit_context ctx;
};

typedef void (*rcu_callback_t)(struct callback_head *);

enum tk_offsets {
	TK_OFFS_REAL = 0,
	TK_OFFS_BOOT = 1,
	TK_OFFS_TAI = 2,
	TK_OFFS_MAX = 3,
};

struct clone_args {
	__u64 flags;
	__u64 pidfd;
	__u64 child_tid;
	__u64 parent_tid;
	__u64 exit_signal;
	__u64 stack;
	__u64 stack_size;
	__u64 tls;
};

struct fdtable {
	unsigned int max_fds;
	struct file **fd;
	long unsigned int *close_on_exec;
	long unsigned int *open_fds;
	long unsigned int *full_fds_bits;
	struct callback_head rcu;
};

struct files_struct {
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable *fdt;
	struct fdtable fdtab;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t file_lock;
	unsigned int next_fd;
	long unsigned int close_on_exec_init[1];
	long unsigned int open_fds_init[1];
	long unsigned int full_fds_bits_init[1];
	struct file *fd_array[64];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct robust_list {
	struct robust_list *next;
};

struct robust_list_head {
	struct robust_list list;
	long int futex_offset;
	struct robust_list *list_op_pending;
};

struct multiprocess_signals {
	sigset_t signal;
	struct hlist_node node;
};

typedef int (*proc_visitor)(struct task_struct *, void *);

enum {
	IOPRIO_CLASS_NONE = 0,
	IOPRIO_CLASS_RT = 1,
	IOPRIO_CLASS_BE = 2,
	IOPRIO_CLASS_IDLE = 3,
};

enum {
	FUTEX_STATE_OK = 0,
	FUTEX_STATE_EXITING = 1,
	FUTEX_STATE_DEAD = 2,
};

struct trace_event_raw_task_newtask {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	long unsigned int clone_flags;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_task_rename {
	struct trace_entry ent;
	pid_t pid;
	char oldcomm[16];
	char newcomm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_data_offsets_task_newtask {};

struct trace_event_data_offsets_task_rename {};

typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, long unsigned int);

typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);

typedef long unsigned int pao_T_____4;

struct taint_flag {
	char c_true;
	char c_false;
	bool module;
};

enum ftrace_dump_mode {
	DUMP_NONE = 0,
	DUMP_ALL = 1,
	DUMP_ORIG = 2,
};

enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF = 0,
	KMSG_DUMP_PANIC = 1,
	KMSG_DUMP_OOPS = 2,
	KMSG_DUMP_EMERG = 3,
	KMSG_DUMP_RESTART = 4,
	KMSG_DUMP_HALT = 5,
	KMSG_DUMP_POWEROFF = 6,
};

enum con_flush_mode {
	CONSOLE_FLUSH_PENDING = 0,
	CONSOLE_REPLAY_ALL = 1,
};

struct warn_args {
	const char *fmt;
	va_list args;
};

struct smp_hotplug_thread {
	struct task_struct **store;
	struct list_head list;
	int (*thread_should_run)(unsigned int);
	void (*thread_fn)(unsigned int);
	void (*create)(unsigned int);
	void (*setup)(unsigned int);
	void (*cleanup)(unsigned int, bool);
	void (*park)(unsigned int);
	void (*unpark)(unsigned int);
	bool selfparking;
	const char *thread_comm;
};

struct trace_event_raw_cpuhp_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_multi_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_exit {
	struct trace_entry ent;
	unsigned int cpu;
	int state;
	int idx;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_cpuhp_enter {};

struct trace_event_data_offsets_cpuhp_multi_enter {};

struct trace_event_data_offsets_cpuhp_exit {};

typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));

typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);

typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);

struct cpuhp_cpu_state {
	enum cpuhp_state state;
	enum cpuhp_state target;
	enum cpuhp_state fail;
	struct task_struct *thread;
	bool should_run;
	bool rollback;
	bool single;
	bool bringup;
	struct hlist_node *node;
	struct hlist_node *last;
	enum cpuhp_state cb_state;
	int result;
	struct completion done_up;
	struct completion done_down;
};

struct cpuhp_step {
	const char *name;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} startup;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} teardown;
	struct hlist_head list;
	bool cant_stop;
	bool multi_instance;
};

enum cpu_mitigations {
	CPU_MITIGATIONS_OFF = 0,
	CPU_MITIGATIONS_AUTO = 1,
	CPU_MITIGATIONS_AUTO_NOSMT = 2,
};

typedef enum cpuhp_state pto_T_____20;

typedef __kernel_long_t __kernel_suseconds_t;

typedef __kernel_long_t __kernel_time_t;

struct timeval {
	__kernel_time_t tv_sec;
	__kernel_suseconds_t tv_usec;
};

typedef struct wait_queue_entry wait_queue_entry_t;

struct old_timeval32 {
	old_time32_t tv_sec;
	s32 tv_usec;
};

struct rusage {
	struct timeval ru_utime;
	struct timeval ru_stime;
	__kernel_long_t ru_maxrss;
	__kernel_long_t ru_ixrss;
	__kernel_long_t ru_idrss;
	__kernel_long_t ru_isrss;
	__kernel_long_t ru_minflt;
	__kernel_long_t ru_majflt;
	__kernel_long_t ru_nswap;
	__kernel_long_t ru_inblock;
	__kernel_long_t ru_oublock;
	__kernel_long_t ru_msgsnd;
	__kernel_long_t ru_msgrcv;
	__kernel_long_t ru_nsignals;
	__kernel_long_t ru_nvcsw;
	__kernel_long_t ru_nivcsw;
};

struct fd {
	struct file *file;
	unsigned int flags;
};

struct compat_rusage {
	struct old_timeval32 ru_utime;
	struct old_timeval32 ru_stime;
	compat_long_t ru_maxrss;
	compat_long_t ru_ixrss;
	compat_long_t ru_idrss;
	compat_long_t ru_isrss;
	compat_long_t ru_minflt;
	compat_long_t ru_majflt;
	compat_long_t ru_nswap;
	compat_long_t ru_inblock;
	compat_long_t ru_oublock;
	compat_long_t ru_msgsnd;
	compat_long_t ru_msgrcv;
	compat_long_t ru_nsignals;
	compat_long_t ru_nvcsw;
	compat_long_t ru_nivcsw;
};

struct waitid_info {
	pid_t pid;
	uid_t uid;
	int status;
	int cause;
};

struct wait_opts {
	enum pid_type wo_type;
	int wo_flags;
	struct pid *wo_pid;
	struct waitid_info *wo_info;
	int wo_stat;
	struct rusage *wo_rusage;
	wait_queue_entry_t child_wait;
	int notask_error;
};

struct softirq_action {
	void (*action)(struct softirq_action *);
};

struct tasklet_struct {
	struct tasklet_struct *next;
	long unsigned int state;
	atomic_t count;
	void (*func)(long unsigned int);
	long unsigned int data;
};

enum {
	TASKLET_STATE_SCHED = 0,
	TASKLET_STATE_RUN = 1,
};

struct kernel_stat {
	long unsigned int irqs_sum;
	unsigned int softirqs[10];
};

struct trace_event_raw_irq_handler_entry {
	struct trace_entry ent;
	int irq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_irq_handler_exit {
	struct trace_entry ent;
	int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_softirq {
	struct trace_entry ent;
	unsigned int vec;
	char __data[0];
};

struct trace_event_data_offsets_irq_handler_entry {
	u32 name;
};

struct trace_event_data_offsets_irq_handler_exit {};

struct trace_event_data_offsets_softirq {};

typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);

typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);

typedef void (*btf_trace_softirq_entry)(void *, unsigned int);

typedef void (*btf_trace_softirq_exit)(void *, unsigned int);

typedef void (*btf_trace_softirq_raise)(void *, unsigned int);

struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

typedef struct tasklet_struct **pto_T_____21;

typedef void (*dr_release_t)(struct device *, void *);

typedef int (*dr_match_t)(struct device *, void *, void *);

struct resource_entry {
	struct list_head node;
	struct resource *res;
	resource_size_t offset;
	struct resource __res;
};

struct resource_constraint {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t (*alignf)(void *, const struct resource *, resource_size_t, resource_size_t);
	void *alignf_data;
};

enum {
	MAX_IORES_LEVEL = 5,
};

struct region_devres {
	struct resource *parent;
	resource_size_t start;
	resource_size_t n;
};

typedef __kernel_clock_t clock_t;

struct dentry_stat_t {
	long int nr_dentry;
	long int nr_unused;
	long int age_limit;
	long int want_pages;
	long int nr_negative;
	long int dummy;
};

struct files_stat_struct {
	long unsigned int nr_files;
	long unsigned int nr_free_files;
	long unsigned int max_files;
};

struct inodes_stat_t {
	long int nr_inodes;
	long int nr_unused;
	long int dummy[5];
};

enum sched_tunable_scaling {
	SCHED_TUNABLESCALING_NONE = 0,
	SCHED_TUNABLESCALING_LOG = 1,
	SCHED_TUNABLESCALING_LINEAR = 2,
	SCHED_TUNABLESCALING_END = 3,
};

enum sysctl_writes_mode {
	SYSCTL_WRITES_LEGACY = 4294967295,
	SYSCTL_WRITES_WARN = 0,
	SYSCTL_WRITES_STRICT = 1,
};

struct do_proc_dointvec_minmax_conv_param {
	int *min;
	int *max;
};

struct do_proc_douintvec_minmax_conv_param {
	unsigned int *min;
	unsigned int *max;
};

struct __sysctl_args {
	int *name;
	int nlen;
	void *oldval;
	size_t *oldlenp;
	void *newval;
	size_t newlen;
	long unsigned int __unused[4];
};

enum {
	CTL_KERN = 1,
	CTL_VM = 2,
	CTL_NET = 3,
	CTL_PROC = 4,
	CTL_FS = 5,
	CTL_DEBUG = 6,
	CTL_DEV = 7,
	CTL_BUS = 8,
	CTL_ABI = 9,
	CTL_CPU = 10,
	CTL_ARLAN = 254,
	CTL_S390DBF = 5677,
	CTL_SUNRPC = 7249,
	CTL_PM = 9899,
	CTL_FRV = 9898,
};

enum {
	CTL_BUS_ISA = 1,
};

enum {
	INOTIFY_MAX_USER_INSTANCES = 1,
	INOTIFY_MAX_USER_WATCHES = 2,
	INOTIFY_MAX_QUEUED_EVENTS = 3,
};

enum {
	KERN_OSTYPE = 1,
	KERN_OSRELEASE = 2,
	KERN_OSREV = 3,
	KERN_VERSION = 4,
	KERN_SECUREMASK = 5,
	KERN_PROF = 6,
	KERN_NODENAME = 7,
	KERN_DOMAINNAME = 8,
	KERN_PANIC = 15,
	KERN_REALROOTDEV = 16,
	KERN_SPARC_REBOOT = 21,
	KERN_CTLALTDEL = 22,
	KERN_PRINTK = 23,
	KERN_NAMETRANS = 24,
	KERN_PPC_HTABRECLAIM = 25,
	KERN_PPC_ZEROPAGED = 26,
	KERN_PPC_POWERSAVE_NAP = 27,
	KERN_MODPROBE = 28,
	KERN_SG_BIG_BUFF = 29,
	KERN_ACCT = 30,
	KERN_PPC_L2CR = 31,
	KERN_RTSIGNR = 32,
	KERN_RTSIGMAX = 33,
	KERN_SHMMAX = 34,
	KERN_MSGMAX = 35,
	KERN_MSGMNB = 36,
	KERN_MSGPOOL = 37,
	KERN_SYSRQ = 38,
	KERN_MAX_THREADS = 39,
	KERN_RANDOM = 40,
	KERN_SHMALL = 41,
	KERN_MSGMNI = 42,
	KERN_SEM = 43,
	KERN_SPARC_STOP_A = 44,
	KERN_SHMMNI = 45,
	KERN_OVERFLOWUID = 46,
	KERN_OVERFLOWGID = 47,
	KERN_SHMPATH = 48,
	KERN_HOTPLUG = 49,
	KERN_IEEE_EMULATION_WARNINGS = 50,
	KERN_S390_USER_DEBUG_LOGGING = 51,
	KERN_CORE_USES_PID = 52,
	KERN_TAINTED = 53,
	KERN_CADPID = 54,
	KERN_PIDMAX = 55,
	KERN_CORE_PATTERN = 56,
	KERN_PANIC_ON_OOPS = 57,
	KERN_HPPA_PWRSW = 58,
	KERN_HPPA_UNALIGNED = 59,
	KERN_PRINTK_RATELIMIT = 60,
	KERN_PRINTK_RATELIMIT_BURST = 61,
	KERN_PTY = 62,
	KERN_NGROUPS_MAX = 63,
	KERN_SPARC_SCONS_PWROFF = 64,
	KERN_HZ_TIMER = 65,
	KERN_UNKNOWN_NMI_PANIC = 66,
	KERN_BOOTLOADER_TYPE = 67,
	KERN_RANDOMIZE = 68,
	KERN_SETUID_DUMPABLE = 69,
	KERN_SPIN_RETRY = 70,
	KERN_ACPI_VIDEO_FLAGS = 71,
	KERN_IA64_UNALIGNED = 72,
	KERN_COMPAT_LOG = 73,
	KERN_MAX_LOCK_DEPTH = 74,
	KERN_NMI_WATCHDOG = 75,
	KERN_PANIC_ON_NMI = 76,
	KERN_PANIC_ON_WARN = 77,
	KERN_PANIC_PRINT = 78,
};

enum {
	VM_UNUSED1 = 1,
	VM_UNUSED2 = 2,
	VM_UNUSED3 = 3,
	VM_UNUSED4 = 4,
	VM_OVERCOMMIT_MEMORY = 5,
	VM_UNUSED5 = 6,
	VM_UNUSED7 = 7,
	VM_UNUSED8 = 8,
	VM_UNUSED9 = 9,
	VM_PAGE_CLUSTER = 10,
	VM_DIRTY_BACKGROUND = 11,
	VM_DIRTY_RATIO = 12,
	VM_DIRTY_WB_CS = 13,
	VM_DIRTY_EXPIRE_CS = 14,
	VM_NR_PDFLUSH_THREADS = 15,
	VM_OVERCOMMIT_RATIO = 16,
	VM_PAGEBUF = 17,
	VM_HUGETLB_PAGES = 18,
	VM_SWAPPINESS = 19,
	VM_LOWMEM_RESERVE_RATIO = 20,
	VM_MIN_FREE_KBYTES = 21,
	VM_MAX_MAP_COUNT = 22,
	VM_LAPTOP_MODE = 23,
	VM_BLOCK_DUMP = 24,
	VM_HUGETLB_GROUP = 25,
	VM_VFS_CACHE_PRESSURE = 26,
	VM_LEGACY_VA_LAYOUT = 27,
	VM_SWAP_TOKEN_TIMEOUT = 28,
	VM_DROP_PAGECACHE = 29,
	VM_PERCPU_PAGELIST_FRACTION = 30,
	VM_ZONE_RECLAIM_MODE = 31,
	VM_MIN_UNMAPPED = 32,
	VM_PANIC_ON_OOM = 33,
	VM_VDSO_ENABLED = 34,
	VM_MIN_SLAB = 35,
};

enum {
	NET_CORE = 1,
	NET_ETHER = 2,
	NET_802 = 3,
	NET_UNIX = 4,
	NET_IPV4 = 5,
	NET_IPX = 6,
	NET_ATALK = 7,
	NET_NETROM = 8,
	NET_AX25 = 9,
	NET_BRIDGE = 10,
	NET_ROSE = 11,
	NET_IPV6 = 12,
	NET_X25 = 13,
	NET_TR = 14,
	NET_DECNET = 15,
	NET_ECONET = 16,
	NET_SCTP = 17,
	NET_LLC = 18,
	NET_NETFILTER = 19,
	NET_DCCP = 20,
	NET_IRDA = 412,
};

enum {
	RANDOM_POOLSIZE = 1,
	RANDOM_ENTROPY_COUNT = 2,
	RANDOM_READ_THRESH = 3,
	RANDOM_WRITE_THRESH = 4,
	RANDOM_BOOT_ID = 5,
	RANDOM_UUID = 6,
};

enum {
	PTY_MAX = 1,
	PTY_NR = 2,
};

enum {
	BUS_ISA_MEM_BASE = 1,
	BUS_ISA_PORT_BASE = 2,
	BUS_ISA_PORT_SHIFT = 3,
};

enum {
	NET_CORE_WMEM_MAX = 1,
	NET_CORE_RMEM_MAX = 2,
	NET_CORE_WMEM_DEFAULT = 3,
	NET_CORE_RMEM_DEFAULT = 4,
	NET_CORE_MAX_BACKLOG = 6,
	NET_CORE_FASTROUTE = 7,
	NET_CORE_MSG_COST = 8,
	NET_CORE_MSG_BURST = 9,
	NET_CORE_OPTMEM_MAX = 10,
	NET_CORE_HOT_LIST_LENGTH = 11,
	NET_CORE_DIVERT_VERSION = 12,
	NET_CORE_NO_CONG_THRESH = 13,
	NET_CORE_NO_CONG = 14,
	NET_CORE_LO_CONG = 15,
	NET_CORE_MOD_CONG = 16,
	NET_CORE_DEV_WEIGHT = 17,
	NET_CORE_SOMAXCONN = 18,
	NET_CORE_BUDGET = 19,
	NET_CORE_AEVENT_ETIME = 20,
	NET_CORE_AEVENT_RSEQTH = 21,
	NET_CORE_WARNINGS = 22,
};

enum {
	NET_UNIX_DESTROY_DELAY = 1,
	NET_UNIX_DELETE_DELAY = 2,
	NET_UNIX_MAX_DGRAM_QLEN = 3,
};

enum {
	NET_NF_CONNTRACK_MAX = 1,
	NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
	NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
	NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
	NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
	NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
	NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
	NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
	NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
	NET_NF_CONNTRACK_UDP_TIMEOUT = 10,
	NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
	NET_NF_CONNTRACK_ICMP_TIMEOUT = 12,
	NET_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
	NET_NF_CONNTRACK_BUCKETS = 14,
	NET_NF_CONNTRACK_LOG_INVALID = 15,
	NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
	NET_NF_CONNTRACK_TCP_LOOSE = 17,
	NET_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
	NET_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
	NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
	NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
	NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
	NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
	NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
	NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
	NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
	NET_NF_CONNTRACK_COUNT = 27,
	NET_NF_CONNTRACK_ICMPV6_TIMEOUT = 28,
	NET_NF_CONNTRACK_FRAG6_TIMEOUT = 29,
	NET_NF_CONNTRACK_FRAG6_LOW_THRESH = 30,
	NET_NF_CONNTRACK_FRAG6_HIGH_THRESH = 31,
	NET_NF_CONNTRACK_CHECKSUM = 32,
};

enum {
	NET_IPV4_FORWARD = 8,
	NET_IPV4_DYNADDR = 9,
	NET_IPV4_CONF = 16,
	NET_IPV4_NEIGH = 17,
	NET_IPV4_ROUTE = 18,
	NET_IPV4_FIB_HASH = 19,
	NET_IPV4_NETFILTER = 20,
	NET_IPV4_TCP_TIMESTAMPS = 33,
	NET_IPV4_TCP_WINDOW_SCALING = 34,
	NET_IPV4_TCP_SACK = 35,
	NET_IPV4_TCP_RETRANS_COLLAPSE = 36,
	NET_IPV4_DEFAULT_TTL = 37,
	NET_IPV4_AUTOCONFIG = 38,
	NET_IPV4_NO_PMTU_DISC = 39,
	NET_IPV4_TCP_SYN_RETRIES = 40,
	NET_IPV4_IPFRAG_HIGH_THRESH = 41,
	NET_IPV4_IPFRAG_LOW_THRESH = 42,
	NET_IPV4_IPFRAG_TIME = 43,
	NET_IPV4_TCP_MAX_KA_PROBES = 44,
	NET_IPV4_TCP_KEEPALIVE_TIME = 45,
	NET_IPV4_TCP_KEEPALIVE_PROBES = 46,
	NET_IPV4_TCP_RETRIES1 = 47,
	NET_IPV4_TCP_RETRIES2 = 48,
	NET_IPV4_TCP_FIN_TIMEOUT = 49,
	NET_IPV4_IP_MASQ_DEBUG = 50,
	NET_TCP_SYNCOOKIES = 51,
	NET_TCP_STDURG = 52,
	NET_TCP_RFC1337 = 53,
	NET_TCP_SYN_TAILDROP = 54,
	NET_TCP_MAX_SYN_BACKLOG = 55,
	NET_IPV4_LOCAL_PORT_RANGE = 56,
	NET_IPV4_ICMP_ECHO_IGNORE_ALL = 57,
	NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS = 58,
	NET_IPV4_ICMP_SOURCEQUENCH_RATE = 59,
	NET_IPV4_ICMP_DESTUNREACH_RATE = 60,
	NET_IPV4_ICMP_TIMEEXCEED_RATE = 61,
	NET_IPV4_ICMP_PARAMPROB_RATE = 62,
	NET_IPV4_ICMP_ECHOREPLY_RATE = 63,
	NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES = 64,
	NET_IPV4_IGMP_MAX_MEMBERSHIPS = 65,
	NET_TCP_TW_RECYCLE = 66,
	NET_IPV4_ALWAYS_DEFRAG = 67,
	NET_IPV4_TCP_KEEPALIVE_INTVL = 68,
	NET_IPV4_INET_PEER_THRESHOLD = 69,
	NET_IPV4_INET_PEER_MINTTL = 70,
	NET_IPV4_INET_PEER_MAXTTL = 71,
	NET_IPV4_INET_PEER_GC_MINTIME = 72,
	NET_IPV4_INET_PEER_GC_MAXTIME = 73,
	NET_TCP_ORPHAN_RETRIES = 74,
	NET_TCP_ABORT_ON_OVERFLOW = 75,
	NET_TCP_SYNACK_RETRIES = 76,
	NET_TCP_MAX_ORPHANS = 77,
	NET_TCP_MAX_TW_BUCKETS = 78,
	NET_TCP_FACK = 79,
	NET_TCP_REORDERING = 80,
	NET_TCP_ECN = 81,
	NET_TCP_DSACK = 82,
	NET_TCP_MEM = 83,
	NET_TCP_WMEM = 84,
	NET_TCP_RMEM = 85,
	NET_TCP_APP_WIN = 86,
	NET_TCP_ADV_WIN_SCALE = 87,
	NET_IPV4_NONLOCAL_BIND = 88,
	NET_IPV4_ICMP_RATELIMIT = 89,
	NET_IPV4_ICMP_RATEMASK = 90,
	NET_TCP_TW_REUSE = 91,
	NET_TCP_FRTO = 92,
	NET_TCP_LOW_LATENCY = 93,
	NET_IPV4_IPFRAG_SECRET_INTERVAL = 94,
	NET_IPV4_IGMP_MAX_MSF = 96,
	NET_TCP_NO_METRICS_SAVE = 97,
	NET_TCP_DEFAULT_WIN_SCALE = 105,
	NET_TCP_MODERATE_RCVBUF = 106,
	NET_TCP_TSO_WIN_DIVISOR = 107,
	NET_TCP_BIC_BETA = 108,
	NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR = 109,
	NET_TCP_CONG_CONTROL = 110,
	NET_TCP_ABC = 111,
	NET_IPV4_IPFRAG_MAX_DIST = 112,
	NET_TCP_MTU_PROBING = 113,
	NET_TCP_BASE_MSS = 114,
	NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS = 115,
	NET_TCP_DMA_COPYBREAK = 116,
	NET_TCP_SLOW_START_AFTER_IDLE = 117,
	NET_CIPSOV4_CACHE_ENABLE = 118,
	NET_CIPSOV4_CACHE_BUCKET_SIZE = 119,
	NET_CIPSOV4_RBM_OPTFMT = 120,
	NET_CIPSOV4_RBM_STRICTVALID = 121,
	NET_TCP_AVAIL_CONG_CONTROL = 122,
	NET_TCP_ALLOWED_CONG_CONTROL = 123,
	NET_TCP_MAX_SSTHRESH = 124,
	NET_TCP_FRTO_RESPONSE = 125,
	NET_TCP_TW_IGNORE_SYN_TSVAL_ZERO = 126,
	NET_IPV4_TCP_RTO_MIN = 127,
	NET_IPV4_TCP_RTO_MAX = 128,
	NET_IPV4_TCP_TW_TIMEOUT = 129,
};

enum {
	NET_IPV4_ROUTE_FLUSH = 1,
	NET_IPV4_ROUTE_MIN_DELAY = 2,
	NET_IPV4_ROUTE_MAX_DELAY = 3,
	NET_IPV4_ROUTE_GC_THRESH = 4,
	NET_IPV4_ROUTE_MAX_SIZE = 5,
	NET_IPV4_ROUTE_GC_MIN_INTERVAL = 6,
	NET_IPV4_ROUTE_GC_TIMEOUT = 7,
	NET_IPV4_ROUTE_GC_INTERVAL = 8,
	NET_IPV4_ROUTE_REDIRECT_LOAD = 9,
	NET_IPV4_ROUTE_REDIRECT_NUMBER = 10,
	NET_IPV4_ROUTE_REDIRECT_SILENCE = 11,
	NET_IPV4_ROUTE_ERROR_COST = 12,
	NET_IPV4_ROUTE_ERROR_BURST = 13,
	NET_IPV4_ROUTE_GC_ELASTICITY = 14,
	NET_IPV4_ROUTE_MTU_EXPIRES = 15,
	NET_IPV4_ROUTE_MIN_PMTU = 16,
	NET_IPV4_ROUTE_MIN_ADVMSS = 17,
	NET_IPV4_ROUTE_SECRET_INTERVAL = 18,
	NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS = 19,
};

enum {
	NET_PROTO_CONF_ALL = 4294967294,
	NET_PROTO_CONF_DEFAULT = 4294967293,
};

enum {
	NET_IPV4_CONF_FORWARDING = 1,
	NET_IPV4_CONF_MC_FORWARDING = 2,
	NET_IPV4_CONF_PROXY_ARP = 3,
	NET_IPV4_CONF_ACCEPT_REDIRECTS = 4,
	NET_IPV4_CONF_SECURE_REDIRECTS = 5,
	NET_IPV4_CONF_SEND_REDIRECTS = 6,
	NET_IPV4_CONF_SHARED_MEDIA = 7,
	NET_IPV4_CONF_RP_FILTER = 8,
	NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE = 9,
	NET_IPV4_CONF_BOOTP_RELAY = 10,
	NET_IPV4_CONF_LOG_MARTIANS = 11,
	NET_IPV4_CONF_TAG = 12,
	NET_IPV4_CONF_ARPFILTER = 13,
	NET_IPV4_CONF_MEDIUM_ID = 14,
	NET_IPV4_CONF_NOXFRM = 15,
	NET_IPV4_CONF_NOPOLICY = 16,
	NET_IPV4_CONF_FORCE_IGMP_VERSION = 17,
	NET_IPV4_CONF_ARP_ANNOUNCE = 18,
	NET_IPV4_CONF_ARP_IGNORE = 19,
	NET_IPV4_CONF_PROMOTE_SECONDARIES = 20,
	NET_IPV4_CONF_ARP_ACCEPT = 21,
	NET_IPV4_CONF_ARP_NOTIFY = 22,
};

enum {
	NET_IPV4_NF_CONNTRACK_MAX = 1,
	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT = 2,
	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV = 3,
	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED = 4,
	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT = 5,
	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT = 6,
	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK = 7,
	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT = 8,
	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE = 9,
	NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT = 10,
	NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM = 11,
	NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT = 12,
	NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT = 13,
	NET_IPV4_NF_CONNTRACK_BUCKETS = 14,
	NET_IPV4_NF_CONNTRACK_LOG_INVALID = 15,
	NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS = 16,
	NET_IPV4_NF_CONNTRACK_TCP_LOOSE = 17,
	NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL = 18,
	NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS = 19,
	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED = 20,
	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT = 21,
	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED = 22,
	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED = 23,
	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT = 24,
	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD = 25,
	NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT = 26,
	NET_IPV4_NF_CONNTRACK_COUNT = 27,
	NET_IPV4_NF_CONNTRACK_CHECKSUM = 28,
};

enum {
	NET_IPV6_CONF = 16,
	NET_IPV6_NEIGH = 17,
	NET_IPV6_ROUTE = 18,
	NET_IPV6_ICMP = 19,
	NET_IPV6_BINDV6ONLY = 20,
	NET_IPV6_IP6FRAG_HIGH_THRESH = 21,
	NET_IPV6_IP6FRAG_LOW_THRESH = 22,
	NET_IPV6_IP6FRAG_TIME = 23,
	NET_IPV6_IP6FRAG_SECRET_INTERVAL = 24,
	NET_IPV6_MLD_MAX_MSF = 25,
};

enum {
	NET_IPV6_ROUTE_FLUSH = 1,
	NET_IPV6_ROUTE_GC_THRESH = 2,
	NET_IPV6_ROUTE_MAX_SIZE = 3,
	NET_IPV6_ROUTE_GC_MIN_INTERVAL = 4,
	NET_IPV6_ROUTE_GC_TIMEOUT = 5,
	NET_IPV6_ROUTE_GC_INTERVAL = 6,
	NET_IPV6_ROUTE_GC_ELASTICITY = 7,
	NET_IPV6_ROUTE_MTU_EXPIRES = 8,
	NET_IPV6_ROUTE_MIN_ADVMSS = 9,
	NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS = 10,
};

enum {
	NET_IPV6_FORWARDING = 1,
	NET_IPV6_HOP_LIMIT = 2,
	NET_IPV6_MTU = 3,
	NET_IPV6_ACCEPT_RA = 4,
	NET_IPV6_ACCEPT_REDIRECTS = 5,
	NET_IPV6_AUTOCONF = 6,
	NET_IPV6_DAD_TRANSMITS = 7,
	NET_IPV6_RTR_SOLICITS = 8,
	NET_IPV6_RTR_SOLICIT_INTERVAL = 9,
	NET_IPV6_RTR_SOLICIT_DELAY = 10,
	NET_IPV6_USE_TEMPADDR = 11,
	NET_IPV6_TEMP_VALID_LFT = 12,
	NET_IPV6_TEMP_PREFERED_LFT = 13,
	NET_IPV6_REGEN_MAX_RETRY = 14,
	NET_IPV6_MAX_DESYNC_FACTOR = 15,
	NET_IPV6_MAX_ADDRESSES = 16,
	NET_IPV6_FORCE_MLD_VERSION = 17,
	NET_IPV6_ACCEPT_RA_DEFRTR = 18,
	NET_IPV6_ACCEPT_RA_PINFO = 19,
	NET_IPV6_ACCEPT_RA_RTR_PREF = 20,
	NET_IPV6_RTR_PROBE_INTERVAL = 21,
	NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN = 22,
	NET_IPV6_PROXY_NDP = 23,
	NET_IPV6_ACCEPT_SOURCE_ROUTE = 25,
	NET_IPV6_ACCEPT_RA_FROM_LOCAL = 26,
	NET_IPV6_ACCEPT_RA_RT_INFO_MIN_PLEN = 27,
	__NET_IPV6_MAX = 28,
};

enum {
	NET_IPV6_ICMP_RATELIMIT = 1,
	NET_IPV6_ICMP_ECHO_IGNORE_ALL = 2,
};

enum {
	NET_NEIGH_MCAST_SOLICIT = 1,
	NET_NEIGH_UCAST_SOLICIT = 2,
	NET_NEIGH_APP_SOLICIT = 3,
	NET_NEIGH_RETRANS_TIME = 4,
	NET_NEIGH_REACHABLE_TIME = 5,
	NET_NEIGH_DELAY_PROBE_TIME = 6,
	NET_NEIGH_GC_STALE_TIME = 7,
	NET_NEIGH_UNRES_QLEN = 8,
	NET_NEIGH_PROXY_QLEN = 9,
	NET_NEIGH_ANYCAST_DELAY = 10,
	NET_NEIGH_PROXY_DELAY = 11,
	NET_NEIGH_LOCKTIME = 12,
	NET_NEIGH_GC_INTERVAL = 13,
	NET_NEIGH_GC_THRESH1 = 14,
	NET_NEIGH_GC_THRESH2 = 15,
	NET_NEIGH_GC_THRESH3 = 16,
	NET_NEIGH_RETRANS_TIME_MS = 17,
	NET_NEIGH_REACHABLE_TIME_MS = 18,
};

enum {
	NET_IPX_PPROP_BROADCASTING = 1,
	NET_IPX_FORWARDING = 2,
};

enum {
	NET_LLC2 = 1,
	NET_LLC_STATION = 2,
};

enum {
	NET_LLC_STATION_ACK_TIMEOUT = 1,
};

enum {
	NET_LLC2_ACK_TIMEOUT = 1,
	NET_LLC2_P_TIMEOUT = 2,
	NET_LLC2_REJ_TIMEOUT = 3,
	NET_LLC2_BUSY_TIMEOUT = 4,
};

enum {
	NET_ATALK_AARP_EXPIRY_TIME = 1,
	NET_ATALK_AARP_TICK_TIME = 2,
	NET_ATALK_AARP_RETRANSMIT_LIMIT = 3,
	NET_ATALK_AARP_RESOLVE_TIME = 4,
};

enum {
	NET_NETROM_DEFAULT_PATH_QUALITY = 1,
	NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER = 2,
	NET_NETROM_NETWORK_TTL_INITIALISER = 3,
	NET_NETROM_TRANSPORT_TIMEOUT = 4,
	NET_NETROM_TRANSPORT_MAXIMUM_TRIES = 5,
	NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY = 6,
	NET_NETROM_TRANSPORT_BUSY_DELAY = 7,
	NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE = 8,
	NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT = 9,
	NET_NETROM_ROUTING_CONTROL = 10,
	NET_NETROM_LINK_FAILS_COUNT = 11,
	NET_NETROM_RESET = 12,
};

enum {
	NET_AX25_IP_DEFAULT_MODE = 1,
	NET_AX25_DEFAULT_MODE = 2,
	NET_AX25_BACKOFF_TYPE = 3,
	NET_AX25_CONNECT_MODE = 4,
	NET_AX25_STANDARD_WINDOW = 5,
	NET_AX25_EXTENDED_WINDOW = 6,
	NET_AX25_T1_TIMEOUT = 7,
	NET_AX25_T2_TIMEOUT = 8,
	NET_AX25_T3_TIMEOUT = 9,
	NET_AX25_IDLE_TIMEOUT = 10,
	NET_AX25_N2 = 11,
	NET_AX25_PACLEN = 12,
	NET_AX25_PROTOCOL = 13,
	NET_AX25_DAMA_SLAVE_TIMEOUT = 14,
};

enum {
	NET_ROSE_RESTART_REQUEST_TIMEOUT = 1,
	NET_ROSE_CALL_REQUEST_TIMEOUT = 2,
	NET_ROSE_RESET_REQUEST_TIMEOUT = 3,
	NET_ROSE_CLEAR_REQUEST_TIMEOUT = 4,
	NET_ROSE_ACK_HOLD_BACK_TIMEOUT = 5,
	NET_ROSE_ROUTING_CONTROL = 6,
	NET_ROSE_LINK_FAIL_TIMEOUT = 7,
	NET_ROSE_MAX_VCS = 8,
	NET_ROSE_WINDOW_SIZE = 9,
	NET_ROSE_NO_ACTIVITY_TIMEOUT = 10,
};

enum {
	NET_X25_RESTART_REQUEST_TIMEOUT = 1,
	NET_X25_CALL_REQUEST_TIMEOUT = 2,
	NET_X25_RESET_REQUEST_TIMEOUT = 3,
	NET_X25_CLEAR_REQUEST_TIMEOUT = 4,
	NET_X25_ACK_HOLD_BACK_TIMEOUT = 5,
	NET_X25_FORWARD = 6,
};

enum {
	NET_TR_RIF_TIMEOUT = 1,
};

enum {
	NET_DECNET_NODE_TYPE = 1,
	NET_DECNET_NODE_ADDRESS = 2,
	NET_DECNET_NODE_NAME = 3,
	NET_DECNET_DEFAULT_DEVICE = 4,
	NET_DECNET_TIME_WAIT = 5,
	NET_DECNET_DN_COUNT = 6,
	NET_DECNET_DI_COUNT = 7,
	NET_DECNET_DR_COUNT = 8,
	NET_DECNET_DST_GC_INTERVAL = 9,
	NET_DECNET_CONF = 10,
	NET_DECNET_NO_FC_MAX_CWND = 11,
	NET_DECNET_MEM = 12,
	NET_DECNET_RMEM = 13,
	NET_DECNET_WMEM = 14,
	NET_DECNET_DEBUG_LEVEL = 255,
};

enum {
	NET_DECNET_CONF_LOOPBACK = 4294967294,
	NET_DECNET_CONF_DDCMP = 4294967293,
	NET_DECNET_CONF_PPP = 4294967292,
	NET_DECNET_CONF_X25 = 4294967291,
	NET_DECNET_CONF_GRE = 4294967290,
	NET_DECNET_CONF_ETHER = 4294967289,
};

enum {
	NET_DECNET_CONF_DEV_PRIORITY = 1,
	NET_DECNET_CONF_DEV_T1 = 2,
	NET_DECNET_CONF_DEV_T2 = 3,
	NET_DECNET_CONF_DEV_T3 = 4,
	NET_DECNET_CONF_DEV_FORWARDING = 5,
	NET_DECNET_CONF_DEV_BLKSIZE = 6,
	NET_DECNET_CONF_DEV_STATE = 7,
};

enum {
	NET_SCTP_RTO_INITIAL = 1,
	NET_SCTP_RTO_MIN = 2,
	NET_SCTP_RTO_MAX = 3,
	NET_SCTP_RTO_ALPHA = 4,
	NET_SCTP_RTO_BETA = 5,
	NET_SCTP_VALID_COOKIE_LIFE = 6,
	NET_SCTP_ASSOCIATION_MAX_RETRANS = 7,
	NET_SCTP_PATH_MAX_RETRANS = 8,
	NET_SCTP_MAX_INIT_RETRANSMITS = 9,
	NET_SCTP_HB_INTERVAL = 10,
	NET_SCTP_PRESERVE_ENABLE = 11,
	NET_SCTP_MAX_BURST = 12,
	NET_SCTP_ADDIP_ENABLE = 13,
	NET_SCTP_PRSCTP_ENABLE = 14,
	NET_SCTP_SNDBUF_POLICY = 15,
	NET_SCTP_SACK_TIMEOUT = 16,
	NET_SCTP_RCVBUF_POLICY = 17,
};

enum {
	FS_NRINODE = 1,
	FS_STATINODE = 2,
	FS_MAXINODE = 3,
	FS_NRDQUOT = 4,
	FS_MAXDQUOT = 5,
	FS_NRFILE = 6,
	FS_MAXFILE = 7,
	FS_DENTRY = 8,
	FS_NRSUPER = 9,
	FS_MAXSUPER = 10,
	FS_OVERFLOWUID = 11,
	FS_OVERFLOWGID = 12,
	FS_LEASES = 13,
	FS_DIR_NOTIFY = 14,
	FS_LEASE_TIME = 15,
	FS_DQSTATS = 16,
	FS_XFS = 17,
	FS_AIO_NR = 18,
	FS_AIO_MAX_NR = 19,
	FS_INOTIFY = 20,
	FS_OCFS2 = 988,
};

enum {
	FS_DQ_LOOKUPS = 1,
	FS_DQ_DROPS = 2,
	FS_DQ_READS = 3,
	FS_DQ_WRITES = 4,
	FS_DQ_CACHE_HITS = 5,
	FS_DQ_ALLOCATED = 6,
	FS_DQ_FREE = 7,
	FS_DQ_SYNCS = 8,
	FS_DQ_WARNINGS = 9,
};

enum {
	DEV_CDROM = 1,
	DEV_HWMON = 2,
	DEV_PARPORT = 3,
	DEV_RAID = 4,
	DEV_MAC_HID = 5,
	DEV_SCSI = 6,
	DEV_IPMI = 7,
};

enum {
	DEV_RAID_SPEED_LIMIT_MIN = 1,
	DEV_RAID_SPEED_LIMIT_MAX = 2,
};

enum {
	DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES = 1,
	DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES = 2,
	DEV_MAC_HID_MOUSE_BUTTON_EMULATION = 3,
	DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE = 4,
	DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE = 5,
	DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES = 6,
};

enum {
	DEV_SCSI_LOGGING_LEVEL = 1,
};

enum {
	DEV_IPMI_POWEROFF_POWERCYCLE = 1,
};

enum {
	XFS_SGID_INHERIT = 4,
	XFS_SYMLINK_MODE = 5,
	XFS_PANIC_MASK = 6,
	XFS_ERRLEVEL = 7,
	XFS_SYNCD_TIMER = 8,
	XFS_STATS_CLEAR = 12,
	XFS_INHERIT_SYNC = 13,
	XFS_INHERIT_NODUMP = 14,
	XFS_INHERIT_NOATIME = 15,
	XFS_BUF_TIMER = 16,
	XFS_BUF_AGE = 17,
	XFS_INHERIT_NOSYM = 19,
	XFS_ROTORSTEP = 20,
	XFS_INHERIT_NODFRG = 21,
	XFS_FILESTREAM_TIMER = 22,
};

enum {
	CTL_RPCDEBUG = 1,
	CTL_NFSDEBUG = 2,
	CTL_NFSDDEBUG = 3,
	CTL_NLMDEBUG = 4,
	CTL_SLOTTABLE_UDP = 5,
	CTL_SLOTTABLE_TCP = 6,
	CTL_MIN_RESVPORT = 7,
	CTL_MAX_RESVPORT = 8,
};

enum {
	DEV_MIB_NUM = 0,
	DEV_MIB_IPV4_RX_PKTS = 1,
	DEV_MIB_IPV4_RX_BYTES = 2,
	DEV_MIB_IPV4_TX_PKTS = 3,
	DEV_MIB_IPV4_TX_BYTES = 4,
	DEV_MIB_IPV6_RX_PKTS = 5,
	DEV_MIB_IPV6_RX_BYTES = 6,
	DEV_MIB_IPV6_TX_PKTS = 7,
	DEV_MIB_IPV6_TX_BYTES = 8,
	__DEV_MIB_MAX = 9,
};

enum {
	NAPI_STATE_SCHED = 0,
	NAPI_STATE_MISSED = 1,
	NAPI_STATE_DISABLE = 2,
	NAPI_STATE_NPSVC = 3,
	NAPI_STATE_HASHED = 4,
	NAPI_STATE_NO_BUSY_POLL = 5,
	NAPI_STATE_IN_BUSY_POLL = 6,
};

typedef ssize_t bin_convert_t(struct file *, void *, size_t, void *, size_t);

struct bin_table {
	bin_convert_t *convert;
	int ctl_name;
	const char *procname;
	const struct bin_table *child;
};

struct compat_sysctl_args {
	compat_uptr_t name;
	int nlen;
	compat_uptr_t oldval;
	compat_uptr_t oldlenp;
	compat_uptr_t newval;
	compat_size_t newlen;
	compat_ulong_t __unused[4];
};

struct __user_cap_header_struct {
	__u32 version;
	int pid;
};

typedef struct __user_cap_header_struct *cap_user_header_t;

struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
};

typedef struct __user_cap_data_struct *cap_user_data_t;

struct sigqueue {
	struct list_head list;
	int flags;
	kernel_siginfo_t info;
	struct user_struct *user;
};

struct wait_bit_key {
	void *flags;
	int bit_nr;
	long unsigned int timeout;
};

typedef int wait_bit_action_f(struct wait_bit_key *, int);

struct ptrace_peeksiginfo_args {
	__u64 off;
	__u32 flags;
	__s32 nr;
};

struct ptrace_syscall_info {
	__u8 op;
	__u8 pad[3];
	__u32 arch;
	__u64 instruction_pointer;
	__u64 stack_pointer;
	union {
		struct {
			__u64 nr;
			__u64 args[6];
		} entry;
		struct {
			__s64 rval;
			__u8 is_error;
		} exit;
		struct {
			__u64 nr;
			__u64 args[6];
			__u32 ret_data;
		} seccomp;
	};
};

struct compat_iovec {
	compat_uptr_t iov_base;
	compat_size_t iov_len;
};

typedef long unsigned int old_sigset_t;

enum siginfo_layout {
	SIL_KILL = 0,
	SIL_TIMER = 1,
	SIL_POLL = 2,
	SIL_FAULT = 3,
	SIL_FAULT_MCEERR = 4,
	SIL_FAULT_BNDERR = 5,
	SIL_FAULT_PKUERR = 6,
	SIL_CHLD = 7,
	SIL_RT = 8,
	SIL_SYS = 9,
};

typedef u32 compat_old_sigset_t;

struct compat_sigaction {
	compat_uptr_t sa_handler;
	compat_ulong_t sa_flags;
	compat_uptr_t sa_restorer;
	compat_sigset_t sa_mask;
};

struct compat_old_sigaction {
	compat_uptr_t sa_handler;
	compat_old_sigset_t sa_mask;
	compat_ulong_t sa_flags;
	compat_uptr_t sa_restorer;
};

enum {
	TRACE_SIGNAL_DELIVERED = 0,
	TRACE_SIGNAL_IGNORED = 1,
	TRACE_SIGNAL_ALREADY_PENDING = 2,
	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
	TRACE_SIGNAL_LOSE_INFO = 4,
};

struct trace_event_raw_signal_generate {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	char comm[16];
	pid_t pid;
	int group;
	int result;
	char __data[0];
};

struct trace_event_raw_signal_deliver {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	long unsigned int sa_handler;
	long unsigned int sa_flags;
	char __data[0];
};

struct trace_event_data_offsets_signal_generate {};

struct trace_event_data_offsets_signal_deliver {};

typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);

typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);

struct sysinfo {
	__kernel_long_t uptime;
	__kernel_ulong_t loads[3];
	__kernel_ulong_t totalram;
	__kernel_ulong_t freeram;
	__kernel_ulong_t sharedram;
	__kernel_ulong_t bufferram;
	__kernel_ulong_t totalswap;
	__kernel_ulong_t freeswap;
	__u16 procs;
	__u16 pad;
	__kernel_ulong_t totalhigh;
	__kernel_ulong_t freehigh;
	__u32 mem_unit;
	char _f[0];
};

enum {
	PER_LINUX = 0,
	PER_LINUX_32BIT = 8388608,
	PER_LINUX_FDPIC = 524288,
	PER_SVR4 = 68157441,
	PER_SVR3 = 83886082,
	PER_SCOSVR3 = 117440515,
	PER_OSR5 = 100663299,
	PER_WYSEV386 = 83886084,
	PER_ISCR4 = 67108869,
	PER_BSD = 6,
	PER_SUNOS = 67108870,
	PER_XENIX = 83886087,
	PER_LINUX32 = 8,
	PER_LINUX32_3GB = 134217736,
	PER_IRIX32 = 67108873,
	PER_IRIXN32 = 67108874,
	PER_IRIX64 = 67108875,
	PER_RISCOS = 12,
	PER_SOLARIS = 67108877,
	PER_UW7 = 68157454,
	PER_OSF4 = 15,
	PER_HPUX = 16,
	PER_MASK = 255,
};

struct rlimit64 {
	__u64 rlim_cur;
	__u64 rlim_max;
};

struct oldold_utsname {
	char sysname[9];
	char nodename[9];
	char release[9];
	char version[9];
	char machine[9];
};

struct old_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
};

enum uts_proc {
	UTS_PROC_OSTYPE = 0,
	UTS_PROC_OSRELEASE = 1,
	UTS_PROC_VERSION = 2,
	UTS_PROC_HOSTNAME = 3,
	UTS_PROC_DOMAINNAME = 4,
};

struct prctl_mm_map {
	__u64 start_code;
	__u64 end_code;
	__u64 start_data;
	__u64 end_data;
	__u64 start_brk;
	__u64 brk;
	__u64 start_stack;
	__u64 arg_start;
	__u64 arg_end;
	__u64 env_start;
	__u64 env_end;
	__u64 *auxv;
	__u32 auxv_size;
	__u32 exe_fd;
};

struct compat_tms {
	compat_clock_t tms_utime;
	compat_clock_t tms_stime;
	compat_clock_t tms_cutime;
	compat_clock_t tms_cstime;
};

struct compat_rlimit {
	compat_ulong_t rlim_cur;
	compat_ulong_t rlim_max;
};

struct tms {
	__kernel_clock_t tms_utime;
	__kernel_clock_t tms_stime;
	__kernel_clock_t tms_cutime;
	__kernel_clock_t tms_cstime;
};

struct getcpu_cache {
	long unsigned int blob[16];
};

struct compat_sysinfo {
	s32 uptime;
	u32 loads[3];
	u32 totalram;
	u32 freeram;
	u32 sharedram;
	u32 bufferram;
	u32 totalswap;
	u32 freeswap;
	u16 procs;
	u16 pad;
	u32 totalhigh;
	u32 freehigh;
	u32 mem_unit;
	char _f[8];
};

struct umh_info {
	const char *cmdline;
	struct file *pipe_to_umh;
	struct file *pipe_from_umh;
	struct list_head list;
	void (*cleanup)(struct umh_info *);
	pid_t pid;
};

struct wq_flusher;

struct worker;

struct workqueue_attrs;

struct pool_workqueue;

struct wq_device;

struct workqueue_struct {
	struct list_head pwqs;
	struct list_head list;
	struct mutex mutex;
	int work_color;
	int flush_color;
	atomic_t nr_pwqs_to_flush;
	struct wq_flusher *first_flusher;
	struct list_head flusher_queue;
	struct list_head flusher_overflow;
	struct list_head maydays;
	struct worker *rescuer;
	int nr_drainers;
	int saved_max_active;
	struct workqueue_attrs *unbound_attrs;
	struct pool_workqueue *dfl_pwq;
	struct wq_device *wq_dev;
	char name[24];
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int flags;
	struct pool_workqueue *cpu_pwqs;
	struct pool_workqueue *numa_pwq_tbl[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct workqueue_attrs {
	int nice;
	cpumask_var_t cpumask;
	bool no_numa;
};

struct execute_work {
	struct work_struct work;
};

enum {
	WQ_UNBOUND = 2,
	WQ_FREEZABLE = 4,
	WQ_MEM_RECLAIM = 8,
	WQ_HIGHPRI = 16,
	WQ_CPU_INTENSIVE = 32,
	WQ_SYSFS = 64,
	WQ_POWER_EFFICIENT = 128,
	__WQ_DRAINING = 65536,
	__WQ_ORDERED = 131072,
	__WQ_LEGACY = 262144,
	__WQ_ORDERED_EXPLICIT = 524288,
	WQ_MAX_ACTIVE = 512,
	WQ_MAX_UNBOUND_PER_CPU = 4,
	WQ_DFL_ACTIVE = 256,
};

enum xa_lock_type {
	XA_LOCK_IRQ = 1,
	XA_LOCK_BH = 2,
};

struct ida {
	struct xarray xa;
};

struct __una_u32 {
	u32 x;
};

struct worker_pool;

struct worker {
	union {
		struct list_head entry;
		struct hlist_node hentry;
	};
	struct work_struct *current_work;
	work_func_t current_func;
	struct pool_workqueue *current_pwq;
	struct list_head scheduled;
	struct task_struct *task;
	struct worker_pool *pool;
	struct list_head node;
	long unsigned int last_active;
	unsigned int flags;
	int id;
	int sleeping;
	char desc[24];
	struct workqueue_struct *rescue_wq;
	work_func_t last_func;
};

struct pool_workqueue {
	struct worker_pool *pool;
	struct workqueue_struct *wq;
	int work_color;
	int flush_color;
	int refcnt;
	int nr_in_flight[15];
	int nr_active;
	int max_active;
	struct list_head delayed_works;
	struct list_head pwqs_node;
	struct list_head mayday_node;
	struct work_struct unbound_release_work;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct worker_pool {
	spinlock_t lock;
	int cpu;
	int node;
	int id;
	unsigned int flags;
	long unsigned int watchdog_ts;
	struct list_head worklist;
	int nr_workers;
	int nr_idle;
	struct list_head idle_list;
	struct timer_list idle_timer;
	struct timer_list mayday_timer;
	struct hlist_head busy_hash[64];
	struct worker *manager;
	struct list_head workers;
	struct completion *detach_completion;
	struct ida worker_ida;
	struct workqueue_attrs *attrs;
	struct hlist_node hash_node;
	int refcnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t nr_running;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	POOL_MANAGER_ACTIVE = 1,
	POOL_DISASSOCIATED = 4,
	WORKER_DIE = 2,
	WORKER_IDLE = 4,
	WORKER_PREP = 8,
	WORKER_CPU_INTENSIVE = 64,
	WORKER_UNBOUND = 128,
	WORKER_REBOUND = 256,
	WORKER_NOT_RUNNING = 456,
	NR_STD_WORKER_POOLS = 2,
	UNBOUND_POOL_HASH_ORDER = 6,
	BUSY_WORKER_HASH_ORDER = 6,
	MAX_IDLE_WORKERS_RATIO = 4,
	IDLE_WORKER_TIMEOUT = 300000,
	MAYDAY_INITIAL_TIMEOUT = 10,
	MAYDAY_INTERVAL = 100,
	CREATE_COOLDOWN = 1000,
	RESCUER_NICE_LEVEL = 4294967276,
	HIGHPRI_NICE_LEVEL = 4294967276,
	WQ_NAME_LEN = 24,
};

struct wq_flusher {
	struct list_head list;
	int flush_color;
	struct completion done;
};

struct wq_device {
	struct workqueue_struct *wq;
	struct device dev;
};

struct trace_event_raw_workqueue_work {
	struct trace_entry ent;
	void *work;
	char __data[0];
};

struct trace_event_raw_workqueue_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *workqueue;
	unsigned int req_cpu;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_data_offsets_workqueue_work {};

struct trace_event_data_offsets_workqueue_queue_work {};

struct trace_event_data_offsets_workqueue_execute_start {};

typedef void (*btf_trace_workqueue_queue_work)(void *, unsigned int, struct pool_workqueue *, struct work_struct *);

typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *);

struct wq_barrier {
	struct work_struct work;
	struct completion done;
	struct task_struct *task;
};

struct cwt_wait {
	wait_queue_entry_t wait;
	struct work_struct *work;
};

struct apply_wqattrs_ctx {
	struct workqueue_struct *wq;
	struct workqueue_attrs *attrs;
	struct list_head list;
	struct pool_workqueue *dfl_pwq;
	struct pool_workqueue *pwq_tbl[0];
};

struct work_for_cpu {
	struct work_struct work;
	long int (*fn)(void *);
	void *arg;
	long int ret;
};

typedef void (*task_work_func_t)(struct callback_head *);

enum {
	KERNEL_PARAM_OPS_FL_NOARG = 1,
};

enum {
	KERNEL_PARAM_FL_UNSAFE = 1,
	KERNEL_PARAM_FL_HWPARAM = 2,
};

struct param_attribute {
	struct module_attribute mattr;
	const struct kernel_param *param;
};

struct module_param_attrs {
	unsigned int num;
	struct attribute_group grp;
	struct param_attribute attrs[0];
};

struct module_version_attribute {
	struct module_attribute mattr;
	const char *module_name;
	const char *version;
};

struct kmalloced_param {
	struct list_head list;
	char val[0];
};

struct sched_param {
	int sched_priority;
};

enum {
	KTW_FREEZABLE = 1,
};

enum {
	__PERCPU_REF_ATOMIC = 1,
	__PERCPU_REF_DEAD = 2,
	__PERCPU_REF_ATOMIC_DEAD = 3,
	__PERCPU_REF_FLAG_BITS = 2,
};

enum {
	CSS_NO_REF = 1,
	CSS_ONLINE = 2,
	CSS_RELEASED = 4,
	CSS_VISIBLE = 8,
	CSS_DYING = 16,
};

struct kthread_create_info {
	int (*threadfn)(void *);
	void *data;
	int node;
	struct task_struct *result;
	struct completion *done;
	struct list_head list;
};

struct kthread {
	long unsigned int flags;
	unsigned int cpu;
	void *data;
	struct completion parked;
	struct completion exited;
	struct cgroup_subsys_state *blkcg_css;
};

enum KTHREAD_BITS {
	KTHREAD_IS_PER_CPU = 0,
	KTHREAD_SHOULD_STOP = 1,
	KTHREAD_SHOULD_PARK = 2,
};

struct kthread_flush_work {
	struct kthread_work work;
	struct completion done;
};

struct pt_regs;

struct ipc_ids {
	int in_use;
	short unsigned int seq;
	struct rw_semaphore rwsem;
	struct idr ipcs_idr;
	int max_idx;
	int last_idx;
	struct rhashtable key_ht;
};

struct ipc_namespace {
	refcount_t count;
	struct ipc_ids ids[3];
	int sem_ctls[4];
	int used_sems;
	unsigned int msg_ctlmax;
	unsigned int msg_ctlmnb;
	unsigned int msg_ctlmni;
	atomic_t msg_bytes;
	atomic_t msg_hdrs;
	size_t shm_ctlmax;
	size_t shm_ctlall;
	long unsigned int shm_tot;
	int shm_ctlmni;
	int shm_rmid_forced;
	struct notifier_block ipcns_nb;
	struct vfsmount *mq_mnt;
	unsigned int mq_queues_count;
	unsigned int mq_queues_max;
	unsigned int mq_msg_max;
	unsigned int mq_msgsize_max;
	unsigned int mq_msg_default;
	unsigned int mq_msgsize_default;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

struct raw_notifier_head {
	struct notifier_block *head;
};

struct srcu_notifier_head {
	struct mutex mutex;
	struct srcu_struct srcu;
	struct notifier_block *head;
};

enum what {
	PROC_EVENT_NONE = 0,
	PROC_EVENT_FORK = 1,
	PROC_EVENT_EXEC = 2,
	PROC_EVENT_UID = 4,
	PROC_EVENT_GID = 64,
	PROC_EVENT_SID = 128,
	PROC_EVENT_PTRACE = 256,
	PROC_EVENT_COMM = 512,
	PROC_EVENT_COREDUMP = 1073741824,
	PROC_EVENT_EXIT = 2147483648,
};

typedef u64 async_cookie_t;

typedef void (*async_func_t)(void *, async_cookie_t);

struct async_domain {
	struct list_head pending;
	unsigned int registered: 1;
};

struct async_entry {
	struct list_head domain_list;
	struct list_head global_list;
	struct work_struct work;
	async_cookie_t cookie;
	async_func_t func;
	void *data;
	struct async_domain *domain;
};

struct smpboot_thread_data {
	unsigned int cpu;
	unsigned int status;
	struct smp_hotplug_thread *ht;
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE = 1,
	HP_THREAD_PARKED = 2,
};

struct ctl_path {
	const char *procname;
};

struct mount_pair {
	struct list_head list;
	char dev_name[1024];
	char mnt_path[1024];
};

typedef struct fsnotify_mark_connector *fsnotify_connp_t;

struct fsnotify_mark_connector {
	spinlock_t lock;
	short unsigned int type;
	short unsigned int flags;
	__kernel_fsid_t fsid;
	union {
		fsnotify_connp_t *obj;
		struct fsnotify_mark_connector *destroy_next;
	};
	struct hlist_head list;
};

struct scm_creds {
	u32 pid;
	kuid_t uid;
	kgid_t gid;
};

struct netlink_skb_parms {
	struct scm_creds creds;
	__u32 portid;
	__u32 dst_group;
	__u32 flags;
	struct sock *sk;
	bool nsid_is_set;
	int nsid;
};

struct netlink_kernel_cfg {
	unsigned int groups;
	unsigned int flags;
	void (*input)(struct sk_buff *);
	struct mutex *cb_mutex;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
};

enum fsnotify_obj_type {
	FSNOTIFY_OBJ_TYPE_INODE = 0,
	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 1,
	FSNOTIFY_OBJ_TYPE_SB = 2,
	FSNOTIFY_OBJ_TYPE_COUNT = 3,
	FSNOTIFY_OBJ_TYPE_DETACHED = 3,
};

struct gpu_request_list {
	struct list_head list;
	struct mutex lock;
};

enum GPU_EVENT_TYPE {
	GPU_OPEN = 0,
	GPU_CLOSE = 1,
};

struct gpu_wait {
	struct list_head node;
	wait_queue_head_t wait;
	bool proceed;
	bool wakup;
	int pid;
	int type;
	bool used;
};

struct preempt_notifier;

struct preempt_ops {
	void (*sched_in)(struct preempt_notifier *, int);
	void (*sched_out)(struct preempt_notifier *, struct task_struct *);
};

struct preempt_notifier {
	struct hlist_node link;
	struct preempt_ops *ops;
};

struct pin_cookie {};

struct dl_bw {
	raw_spinlock_t lock;
	u64 bw;
	u64 total_bw;
};

struct cpudl_item;

struct cpudl {
	raw_spinlock_t lock;
	int size;
	cpumask_var_t free_cpus;
	struct cpudl_item *elements;
};

struct cpupri_vec {
	atomic_t count;
	cpumask_var_t mask;
};

struct cpupri {
	struct cpupri_vec pri_to_cpu[102];
	int *cpu_to_pri;
};

struct perf_domain;

struct root_domain {
	atomic_t refcount;
	atomic_t rto_count;
	struct callback_head rcu;
	cpumask_var_t span;
	cpumask_var_t online;
	int overload;
	int overutilized;
	cpumask_var_t dlo_mask;
	atomic_t dlo_count;
	struct dl_bw dl_bw;
	struct cpudl cpudl;
	struct irq_work rto_push_work;
	raw_spinlock_t rto_lock;
	int rto_loop;
	int rto_cpu;
	atomic_t rto_loop_next;
	atomic_t rto_loop_start;
	cpumask_var_t rto_mask;
	struct cpupri cpupri;
	long unsigned int max_cpu_capacity;
	struct perf_domain *pd;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct cfs_rq {
	struct load_weight load;
	long unsigned int runnable_weight;
	unsigned int nr_running;
	unsigned int h_nr_running;
	unsigned int idle_h_nr_running;
	u64 exec_clock;
	u64 min_vruntime;
	struct rb_root_cached tasks_timeline;
	struct sched_entity *curr;
	struct sched_entity *next;
	struct sched_entity *last;
	struct sched_entity *skip;
	unsigned int nr_spread_over;
	long: 32;
	long: 64;
	long: 64;
	struct sched_avg avg;
	struct {
		raw_spinlock_t lock;
		int nr;
		long unsigned int load_avg;
		long unsigned int util_avg;
		long unsigned int runnable_sum;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	} removed;
	long unsigned int tg_load_avg_contrib;
	long int propagate;
	long int prop_runnable_sum;
	long unsigned int h_load;
	u64 last_h_load_update;
	struct sched_entity *h_load_next;
	struct rq *rq;
	int on_list;
	struct list_head leaf_cfs_rq_list;
	struct task_group *tg;
	int runtime_enabled;
	s64 runtime_remaining;
	u64 throttled_clock;
	u64 throttled_clock_task;
	u64 throttled_clock_task_time;
	int throttled;
	int throttle_count;
	struct list_head throttled_list;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long: 64;
	long: 64;
	long: 64;
};

struct rt_prio_array {
	long unsigned int bitmap[2];
	struct list_head queue[100];
};

struct rt_rq {
	struct rt_prio_array active;
	unsigned int rt_nr_running;
	unsigned int rr_nr_running;
	struct {
		int curr;
		int next;
	} highest_prio;
	long unsigned int rt_nr_migratory;
	long unsigned int rt_nr_total;
	int overloaded;
	struct plist_head pushable_tasks;
	int rt_queued;
	int rt_throttled;
	u64 rt_time;
	u64 rt_runtime;
	raw_spinlock_t rt_runtime_lock;
	long unsigned int rt_nr_boosted;
	struct rq *rq;
	struct task_group *tg;
};

struct rt_bandwidth {
	raw_spinlock_t rt_runtime_lock;
	ktime_t rt_period;
	u64 rt_runtime;
	struct hrtimer rt_period_timer;
	unsigned int rt_period_active;
};

struct cfs_bandwidth {
	raw_spinlock_t lock;
	ktime_t period;
	u64 quota;
	u64 runtime;
	u64 burst;
	u64 buffer;
	u64 max_overrun;
	u64 runtime_at_period_start;
	s64 hierarchical_quota;
	u8 idle;
	u8 period_active;
	u8 distribute_running;
	u8 slack_started;
	struct hrtimer period_timer;
	struct hrtimer slack_timer;
	struct list_head throttled_cfs_rq;
	int nr_periods;
	int nr_throttled;
	int nr_burst;
	u64 throttled_time;
	u64 burst_time;
};

struct task_group {
	struct cgroup_subsys_state css;
	struct sched_entity **se;
	struct cfs_rq **cfs_rq;
	long unsigned int shares;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t load_avg;
	struct sched_rt_entity **rt_se;
	struct rt_rq **rt_rq;
	struct rt_bandwidth rt_bandwidth;
	struct callback_head rcu;
	struct list_head list;
	struct task_group *parent;
	struct list_head siblings;
	struct list_head children;
	struct autogroup *autogroup;
	u64 cpuquota_aware;
	struct cfs_bandwidth cfs_bandwidth;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct autogroup {
	struct kref kref;
	struct task_group *tg;
	struct rw_semaphore lock;
	long unsigned int id;
	int nice;
};

enum {
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
};

struct sched_domain_attr {
	int relax_domain_level;
};

struct sched_group {
	struct sched_group *next;
	atomic_t ref;
	unsigned int group_weight;
	struct sched_group_capacity *sgc;
	int asym_prefer_cpu;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int cpumask[0];
};

struct sched_group_capacity {
	atomic_t ref;
	long unsigned int capacity;
	long unsigned int min_capacity;
	long unsigned int max_capacity;
	long unsigned int next_update;
	int imbalance;
	int id;
	long unsigned int cpumask[0];
};

struct wake_q_head {
	struct wake_q_node *first;
	struct wake_q_node **lastp;
};

struct sched_attr {
	__u32 size;
	__u32 sched_policy;
	__u64 sched_flags;
	__s32 sched_nice;
	__u32 sched_priority;
	__u64 sched_runtime;
	__u64 sched_deadline;
	__u64 sched_period;
	__u32 sched_util_min;
	__u32 sched_util_max;
};

struct kernel_cpustat {
	u64 cpustat[10];
};

enum {
	CFTYPE_ONLY_ON_ROOT = 1,
	CFTYPE_NOT_ON_ROOT = 2,
	CFTYPE_NS_DELEGATABLE = 4,
	CFTYPE_NO_PREFIX = 8,
	CFTYPE_WORLD_WRITABLE = 16,
	CFTYPE_DEBUG = 32,
	__CFTYPE_ONLY_ON_DFL = 65536,
	__CFTYPE_NOT_ON_DFL = 131072,
};

struct cpuidle_state_usage {
	long long unsigned int disable;
	long long unsigned int usage;
	long long unsigned int time;
	long long unsigned int above;
	long long unsigned int below;
	long long unsigned int s2idle_usage;
	long long unsigned int s2idle_time;
};

struct cpuidle_device;

struct cpuidle_driver;

struct cpuidle_state {
	char name[16];
	char desc[32];
	unsigned int flags;
	unsigned int exit_latency;
	int power_usage;
	unsigned int target_residency;
	bool disabled;
	int (*enter)(struct cpuidle_device *, struct cpuidle_driver *, int);
	int (*enter_dead)(struct cpuidle_device *, int);
	void (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver *, int);
};

struct cpuidle_driver_kobj;

struct cpuidle_state_kobj;

struct cpuidle_device_kobj;

struct cpuidle_device {
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int use_deepest_state: 1;
	unsigned int poll_time_limit: 1;
	unsigned int cpu;
	ktime_t next_hrtimer;
	int last_state_idx;
	int last_residency;
	u64 poll_limit_ns;
	struct cpuidle_state_usage states_usage[10];
	struct cpuidle_state_kobj *kobjs[10];
	struct cpuidle_driver_kobj *kobj_driver;
	struct cpuidle_device_kobj *kobj_dev;
	struct list_head device_list;
};

struct cpuidle_driver {
	const char *name;
	struct module *owner;
	int refcnt;
	unsigned int bctimer: 1;
	struct cpuidle_state states[10];
	int state_count;
	int safe_state_index;
	struct cpumask *cpumask;
	const char *governor;
};

struct em_perf_domain {};

struct cpu_stop_done;

struct cpu_stop_work {
	struct list_head list;
	cpu_stop_fn_t fn;
	void *arg;
	struct cpu_stop_done *done;
};

struct cpudl_item {
	u64 dl;
	int cpu;
	int idx;
};

struct dl_bandwidth {
	raw_spinlock_t dl_runtime_lock;
	u64 dl_runtime;
	u64 dl_period;
};

typedef int (*tg_visitor)(struct task_group *, void *);

struct dl_rq {
	struct rb_root_cached root;
	long unsigned int dl_nr_running;
	struct {
		u64 curr;
		u64 next;
	} earliest_dl;
	long unsigned int dl_nr_migratory;
	int overloaded;
	struct rb_root_cached pushable_dl_tasks_root;
	u64 running_bw;
	u64 this_bw;
	u64 extra_bw;
	u64 bw_ratio;
};

struct rq {
	raw_spinlock_t lock;
	unsigned int nr_running;
	unsigned int nr_numa_running;
	unsigned int nr_preferred_running;
	unsigned int numa_migrate_on;
	long unsigned int last_load_update_tick;
	long unsigned int last_blocked_load_update_tick;
	unsigned int has_blocked_load;
	unsigned int nohz_tick_stopped;
	atomic_t nohz_flags;
	long unsigned int nr_load_updates;
	u64 nr_switches;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cfs_rq cfs;
	struct rt_rq rt;
	struct dl_rq dl;
	struct list_head leaf_cfs_rq_list;
	struct list_head *tmp_alone_branch;
	long unsigned int nr_uninterruptible;
	struct task_struct *curr;
	struct task_struct *idle;
	struct task_struct *stop;
	long unsigned int next_balance;
	struct mm_struct *prev_mm;
	unsigned int clock_update_flags;
	u64 clock;
	u64 clock_task;
	u64 clock_pelt;
	long unsigned int lost_idle_time;
	atomic_t nr_iowait;
	int membarrier_state;
	struct root_domain *rd;
	struct sched_domain *sd;
	long unsigned int cpu_capacity;
	long unsigned int cpu_capacity_orig;
	struct callback_head *balance_callback;
	unsigned char idle_balance;
	long unsigned int misfit_task_load;
	int active_balance;
	int push_cpu;
	struct cpu_stop_work active_balance_work;
	int cpu;
	int online;
	struct list_head cfs_tasks;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg_rt;
	struct sched_avg avg_dl;
	struct sched_avg avg_irq;
	u64 idle_stamp;
	u64 avg_idle;
	u64 max_idle_balance_cost;
	u64 prev_steal_time;
	u64 prev_steal_time_rq;
	long unsigned int calc_load_update;
	long int calc_load_active;
	int hrtick_csd_pending;
	call_single_data_t hrtick_csd;
	struct hrtimer hrtick_timer;
	ktime_t hrtick_time;
	struct sched_info rq_sched_info;
	long long unsigned int rq_cpu_time;
	unsigned int yld_count;
	unsigned int sched_count;
	unsigned int sched_goidle;
	unsigned int ttwu_count;
	unsigned int ttwu_local;
	struct llist_head wake_list;
	struct cpuidle_state *idle_state;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct perf_domain {
	struct em_perf_domain *em_pd;
	struct perf_domain *next;
	struct callback_head rcu;
};

struct rq_flags {
	long unsigned int flags;
	struct pin_cookie cookie;
	unsigned int clock_update_flags;
};

enum {
	__SCHED_FEAT_GENTLE_FAIR_SLEEPERS = 0,
	__SCHED_FEAT_START_DEBIT = 1,
	__SCHED_FEAT_NEXT_BUDDY = 2,
	__SCHED_FEAT_LAST_BUDDY = 3,
	__SCHED_FEAT_CACHE_HOT_BUDDY = 4,
	__SCHED_FEAT_WAKEUP_PREEMPTION = 5,
	__SCHED_FEAT_HRTICK = 6,
	__SCHED_FEAT_DOUBLE_TICK = 7,
	__SCHED_FEAT_NONTASK_CAPACITY = 8,
	__SCHED_FEAT_TTWU_QUEUE = 9,
	__SCHED_FEAT_SIS_AVG_CPU = 10,
	__SCHED_FEAT_SIS_PROP = 11,
	__SCHED_FEAT_WARN_DOUBLE_CLOCK = 12,
	__SCHED_FEAT_RT_PUSH_IPI = 13,
	__SCHED_FEAT_RT_RUNTIME_SHARE = 14,
	__SCHED_FEAT_LB_MIN = 15,
	__SCHED_FEAT_ATTACH_AGE_LOAD = 16,
	__SCHED_FEAT_WA_IDLE = 17,
	__SCHED_FEAT_WA_WEIGHT = 18,
	__SCHED_FEAT_WA_BIAS = 19,
	__SCHED_FEAT_UTIL_EST = 20,
	__SCHED_FEAT_NR = 21,
};

struct trace_event_raw_sched_kthread_stop {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop_ret {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_sched_wakeup_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int success;
	int target_cpu;
	char __data[0];
};

struct trace_event_raw_sched_switch {
	struct trace_entry ent;
	char prev_comm[16];
	pid_t prev_pid;
	int prev_prio;
	long int prev_state;
	char next_comm[16];
	pid_t next_pid;
	int next_prio;
	char __data[0];
};

struct trace_event_raw_sched_migrate_task {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int orig_cpu;
	int dest_cpu;
	char __data[0];
};

struct trace_event_raw_sched_process_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_wait {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_fork {
	struct trace_entry ent;
	char parent_comm[16];
	pid_t parent_pid;
	char child_comm[16];
	pid_t child_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_exec {
	struct trace_entry ent;
	u32 __data_loc_filename;
	pid_t pid;
	pid_t old_pid;
	char __data[0];
};

struct trace_event_raw_sched_stat_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 delay;
	char __data[0];
};

struct trace_event_raw_sched_stat_runtime {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 runtime;
	u64 vruntime;
	char __data[0];
};

struct trace_event_raw_sched_pi_setprio {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int oldprio;
	int newprio;
	char __data[0];
};

struct trace_event_raw_sched_process_hang {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_move_task_template {
	struct trace_entry ent;
	pid_t pid;
	pid_t tgid;
	pid_t ngid;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_swap_numa {
	struct trace_entry ent;
	pid_t src_pid;
	pid_t src_tgid;
	pid_t src_ngid;
	int src_cpu;
	int src_nid;
	pid_t dst_pid;
	pid_t dst_tgid;
	pid_t dst_ngid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_wake_idle_without_ipi {
	struct trace_entry ent;
	int cpu;
	char __data[0];
};

struct trace_event_data_offsets_sched_kthread_stop {};

struct trace_event_data_offsets_sched_kthread_stop_ret {};

struct trace_event_data_offsets_sched_wakeup_template {};

struct trace_event_data_offsets_sched_switch {};

struct trace_event_data_offsets_sched_migrate_task {};

struct trace_event_data_offsets_sched_process_template {};

struct trace_event_data_offsets_sched_process_wait {};

struct trace_event_data_offsets_sched_process_fork {};

struct trace_event_data_offsets_sched_process_exec {
	u32 filename;
};

struct trace_event_data_offsets_sched_stat_template {};

struct trace_event_data_offsets_sched_stat_runtime {};

struct trace_event_data_offsets_sched_pi_setprio {};

struct trace_event_data_offsets_sched_process_hang {};

struct trace_event_data_offsets_sched_move_task_template {};

struct trace_event_data_offsets_sched_swap_numa {};

struct trace_event_data_offsets_sched_wake_idle_without_ipi {};

typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);

typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);

typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);

typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);

typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);

typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);

typedef void (*btf_trace_sched_stat_wait)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_sleep)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_iowait)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_blocked)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64, u64);

typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_hang)(void *, struct task_struct *);

typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);

struct migration_arg {
	struct task_struct *task;
	int dest_cpu;
};

struct migration_swap_arg {
	struct task_struct *src_task;
	struct task_struct *dst_task;
	int src_cpu;
	int dst_cpu;
};

struct cfs_schedulable_data {
	struct task_group *tg;
	u64 period;
	u64 quota;
};

enum {
	cpuset = 0,
	possible = 1,
	fail = 2,
};

enum tick_dep_bits {
	TICK_DEP_BIT_POSIX_TIMER = 0,
	TICK_DEP_BIT_PERF_EVENTS = 1,
	TICK_DEP_BIT_SCHED = 2,
	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
};

struct sched_clock_data {
	u64 tick_raw;
	u64 tick_gtod;
	u64 clock;
};

typedef u64 pao_T_____5;

enum s2idle_states {
	S2IDLE_STATE_NONE = 0,
	S2IDLE_STATE_ENTER = 1,
	S2IDLE_STATE_WAKE = 2,
};

struct idle_timer {
	struct hrtimer timer;
	int done;
};

struct numa_group {
	refcount_t refcount;
	spinlock_t lock;
	int nr_tasks;
	pid_t gid;
	int active_nodes;
	struct callback_head rcu;
	long unsigned int total_faults;
	long unsigned int max_faults_cpu;
	long unsigned int *faults_cpu;
	long unsigned int faults[0];
};

struct update_util_data {
	void (*func)(struct update_util_data *, u64, unsigned int);
};

enum numa_topology_type {
	NUMA_DIRECT = 0,
	NUMA_GLUELESS_MESH = 1,
	NUMA_BACKPLANE = 2,
};

enum numa_faults_stats {
	NUMA_MEM = 0,
	NUMA_CPU = 1,
	NUMA_MEMBUF = 2,
	NUMA_CPUBUF = 3,
};

enum schedutil_type {
	FREQUENCY_UTIL = 0,
	ENERGY_UTIL = 1,
};

struct numa_stats {
	long unsigned int load;
	long unsigned int compute_capacity;
};

struct task_numa_env {
	struct task_struct *p;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	struct numa_stats src_stats;
	struct numa_stats dst_stats;
	int imbalance_pct;
	int dist;
	struct task_struct *best_task;
	long int best_imp;
	int best_cpu;
};

enum fbq_type {
	regular = 0,
	remote = 1,
	all = 2,
};

enum group_type {
	group_other = 0,
	group_misfit_task = 1,
	group_imbalanced = 2,
	group_overloaded = 3,
};

struct lb_env {
	struct sched_domain *sd;
	struct rq *src_rq;
	int src_cpu;
	int dst_cpu;
	struct rq *dst_rq;
	struct cpumask *dst_grpmask;
	int new_dst_cpu;
	enum cpu_idle_type idle;
	long int imbalance;
	struct cpumask *cpus;
	unsigned int flags;
	unsigned int loop;
	unsigned int loop_break;
	unsigned int loop_max;
	enum fbq_type fbq_type;
	enum group_type src_grp_type;
	struct list_head tasks;
};

struct sg_lb_stats {
	long unsigned int avg_load;
	long unsigned int group_load;
	long unsigned int load_per_task;
	long unsigned int group_capacity;
	long unsigned int group_util;
	unsigned int sum_nr_running;
	unsigned int idle_cpus;
	unsigned int group_weight;
	enum group_type group_type;
	int group_no_capacity;
	long unsigned int group_misfit_task_load;
	unsigned int nr_numa_running;
	unsigned int nr_preferred_running;
};

struct sd_lb_stats {
	struct sched_group *busiest;
	struct sched_group *local;
	long unsigned int total_running;
	long unsigned int total_load;
	long unsigned int total_capacity;
	long unsigned int avg_load;
	struct sg_lb_stats busiest_stat;
	struct sg_lb_stats local_stat;
};

struct css_task_iter {
	struct cgroup_subsys *ss;
	unsigned int flags;
	struct list_head *cset_pos;
	struct list_head *cset_head;
	struct list_head *tcset_pos;
	struct list_head *tcset_head;
	struct list_head *task_pos;
	struct list_head *tasks_head;
	struct list_head *mg_tasks_head;
	struct list_head *dying_tasks_head;
	struct list_head *cur_tasks_head;
	struct css_set *cur_cset;
	struct css_set *cur_dcset;
	struct task_struct *cur_task;
	struct list_head iters_node;
};

typedef struct task_group *rt_rq_iter_t;

struct rt_schedulable_data {
	struct task_group *tg;
	u64 rt_period;
	u64 rt_runtime;
};

struct wait_bit_queue_entry {
	struct wait_bit_key key;
	struct wait_queue_entry wq_entry;
};

struct s_data {
	struct sched_domain **sd;
	struct root_domain *rd;
};

enum s_alloc {
	sa_rootdomain = 0,
	sa_sd = 1,
	sa_sd_storage = 2,
	sa_none = 3,
};

enum cpuacct_stat_index {
	CPUACCT_STAT_USER = 0,
	CPUACCT_STAT_SYSTEM = 1,
	CPUACCT_STAT_NSTATS = 2,
};

struct cpuacct_usage {
	u64 usages[2];
};

struct cpuacct {
	struct cgroup_subsys_state css;
	struct cpuacct_usage *cpuusage;
	struct kernel_cpustat *cpustat;
	struct timespec64 uptime;
	u64 idletime;
};

struct gov_attr_set {
	struct kobject kobj;
	struct list_head policy_list;
	struct mutex update_lock;
	int usage_count;
};

struct governor_attr {
	struct attribute attr;
	ssize_t (*show)(struct gov_attr_set *, char *);
	ssize_t (*store)(struct gov_attr_set *, const char *, size_t);
};

struct sugov_tunables {
	struct gov_attr_set attr_set;
	unsigned int rate_limit_us;
};

struct sugov_policy {
	struct cpufreq_policy *policy;
	struct sugov_tunables *tunables;
	struct list_head tunables_hook;
	raw_spinlock_t update_lock;
	u64 last_freq_update_time;
	s64 freq_update_delay_ns;
	unsigned int next_freq;
	unsigned int cached_raw_freq;
	struct irq_work irq_work;
	struct kthread_work work;
	struct mutex work_lock;
	struct kthread_worker worker;
	struct task_struct *thread;
	bool work_in_progress;
	bool limits_changed;
	bool need_freq_update;
};

struct sugov_cpu {
	struct update_util_data update_util;
	struct sugov_policy *sg_policy;
	unsigned int cpu;
	bool iowait_boost_pending;
	unsigned int iowait_boost;
	u64 last_update;
	long unsigned int bw_dl;
	long unsigned int max;
	long unsigned int saved_idle_calls;
};

enum {
	MEMBARRIER_FLAG_SYNC_CORE = 1,
};

enum membarrier_cmd {
	MEMBARRIER_CMD_QUERY = 0,
	MEMBARRIER_CMD_GLOBAL = 1,
	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
	MEMBARRIER_CMD_SHARED = 1,
};

enum psi_res {
	PSI_IO = 0,
	PSI_MEM = 1,
	PSI_CPU = 2,
	NR_PSI_RESOURCES = 3,
};

struct psi_window {
	u64 size;
	u64 start_time;
	u64 start_value;
	u64 prev_growth;
};

struct psi_trigger {
	enum psi_states state;
	u64 threshold;
	struct list_head node;
	struct psi_group *group;
	wait_queue_head_t event_wait;
	int event;
	struct psi_window win;
	u64 last_event_time;
	struct kref refcount;
};

struct ww_acquire_ctx;

struct mutex_waiter {
	struct list_head list;
	struct task_struct *task;
	struct ww_acquire_ctx *ww_ctx;
};

struct ww_acquire_ctx {
	struct task_struct *task;
	long unsigned int stamp;
	unsigned int acquired;
	short unsigned int wounded;
	short unsigned int is_wait_die;
};

enum mutex_trylock_recursive_enum {
	MUTEX_TRYLOCK_FAILED = 0,
	MUTEX_TRYLOCK_SUCCESS = 1,
	MUTEX_TRYLOCK_RECURSIVE = 2,
};

struct ww_mutex {
	struct mutex base;
	struct ww_acquire_ctx *ctx;
};

struct semaphore {
	raw_spinlock_t lock;
	unsigned int count;
	struct list_head wait_list;
};

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

enum rwsem_waiter_type {
	RWSEM_WAITING_FOR_WRITE = 0,
	RWSEM_WAITING_FOR_READ = 1,
};

struct rwsem_waiter {
	struct list_head list;
	struct task_struct *task;
	enum rwsem_waiter_type type;
	long unsigned int timeout;
	long unsigned int last_rowner;
};

enum rwsem_wake_type {
	RWSEM_WAKE_ANY = 0,
	RWSEM_WAKE_READERS = 1,
	RWSEM_WAKE_READ_OWNED = 2,
};

enum writer_wait_state {
	WRITER_NOT_FIRST = 0,
	WRITER_FIRST = 1,
	WRITER_HANDOFF = 2,
};

enum owner_state {
	OWNER_NULL = 1,
	OWNER_WRITER = 2,
	OWNER_READER = 4,
	OWNER_NONSPINNABLE = 8,
};

struct optimistic_spin_node {
	struct optimistic_spin_node *next;
	struct optimistic_spin_node *prev;
	int locked;
	int cpu;
};

struct mcs_spinlock {
	struct mcs_spinlock *next;
	unsigned int locked;
	int count;
};

struct qnode {
	struct mcs_spinlock mcs;
	long int reserved[2];
};

struct cna_node {
	struct mcs_spinlock mcs;
	u16 llc_id;
	u16 real_llc_id;
	u32 encoded_tail;
	u64 start_time;
};

enum vcpu_state {
	vcpu_running = 0,
	vcpu_halted = 1,
	vcpu_hashed = 2,
};

struct pv_node {
	struct mcs_spinlock mcs;
	int cpu;
	u8 state;
};

struct pv_hash_entry {
	struct qspinlock *lock;
	struct pv_node *node;
};

struct hrtimer_sleeper {
	struct hrtimer timer;
	struct task_struct *task;
};

struct rt_mutex;

struct rt_mutex_waiter {
	struct rb_node tree_entry;
	struct rb_node pi_tree_entry;
	struct task_struct *task;
	struct rt_mutex *lock;
	int prio;
	u64 deadline;
};

struct rt_mutex {
	raw_spinlock_t wait_lock;
	struct rb_root_cached waiters;
	struct task_struct *owner;
};

enum rtmutex_chainwalk {
	RT_MUTEX_MIN_CHAINWALK = 0,
	RT_MUTEX_FULL_CHAINWALK = 1,
};

enum {
	PM_QOS_RESERVED = 0,
	PM_QOS_CPU_DMA_LATENCY = 1,
	PM_QOS_NUM_CLASSES = 2,
};

struct pm_qos_request {
	struct plist_node node;
	int pm_qos_class;
	struct delayed_work work;
};

enum pm_qos_req_action {
	PM_QOS_ADD_REQ = 0,
	PM_QOS_UPDATE_REQ = 1,
	PM_QOS_REMOVE_REQ = 2,
};

struct pm_qos_object {
	struct pm_qos_constraints *constraints;
	struct miscdevice pm_qos_power_miscdev;
	char *name;
};

typedef int suspend_state_t;

enum suspend_stat_step {
	SUSPEND_FREEZE = 1,
	SUSPEND_PREPARE = 2,
	SUSPEND_SUSPEND = 3,
	SUSPEND_SUSPEND_LATE = 4,
	SUSPEND_SUSPEND_NOIRQ = 5,
	SUSPEND_RESUME_NOIRQ = 6,
	SUSPEND_RESUME_EARLY = 7,
	SUSPEND_RESUME = 8,
};

struct suspend_stats {
	int success;
	int fail;
	int failed_freeze;
	int failed_prepare;
	int failed_suspend;
	int failed_suspend_late;
	int failed_suspend_noirq;
	int failed_resume;
	int failed_resume_early;
	int failed_resume_noirq;
	int last_failed_dev;
	char failed_devs[80];
	int last_failed_errno;
	int errno[2];
	int last_failed_step;
	enum suspend_stat_step failed_steps[2];
};

struct pm_vt_switch {
	struct list_head head;
	struct device *dev;
	bool required;
};

struct platform_suspend_ops {
	int (*valid)(suspend_state_t);
	int (*begin)(suspend_state_t);
	int (*prepare)();
	int (*prepare_late)();
	int (*enter)(suspend_state_t);
	void (*wake)();
	void (*finish)();
	bool (*suspend_again)();
	void (*end)();
	void (*recover)();
};

struct platform_s2idle_ops {
	int (*begin)();
	int (*prepare)();
	int (*prepare_late)();
	bool (*wake)();
	void (*restore_early)();
	void (*restore)();
	void (*end)();
};

enum {
	TEST_NONE = 0,
	TEST_CORE = 1,
	TEST_CPUS = 2,
	TEST_PLATFORM = 3,
	TEST_DEVICES = 4,
	TEST_FREEZER = 5,
	__TEST_AFTER_LAST = 6,
};

struct sysrq_key_op {
	void (*handler)(int);
	char *help_msg;
	char *action_msg;
	int enable_mask;
};

struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *, enum kmsg_dump_reason);
	enum kmsg_dump_reason max_reason;
	bool active;
	bool registered;
	u32 cur_idx;
	u32 next_idx;
	u64 cur_seq;
	u64 next_seq;
};

struct trace_event_raw_console {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_console {
	u32 msg;
};

typedef void (*btf_trace_console)(void *, const char *, size_t);

struct console_cmdline {
	char name[16];
	int index;
	char *options;
};

enum devkmsg_log_bits {
	__DEVKMSG_LOG_BIT_ON = 0,
	__DEVKMSG_LOG_BIT_OFF = 1,
	__DEVKMSG_LOG_BIT_LOCK = 2,
};

enum devkmsg_log_masks {
	DEVKMSG_LOG_MASK_ON = 1,
	DEVKMSG_LOG_MASK_OFF = 2,
	DEVKMSG_LOG_MASK_LOCK = 4,
};

enum con_msg_format_flags {
	MSG_FORMAT_DEFAULT = 0,
	MSG_FORMAT_SYSLOG = 1,
};

enum log_flags {
	LOG_NEWLINE = 2,
	LOG_CONT = 8,
};

struct printk_log {
	u64 ts_nsec;
	u16 len;
	u16 text_len;
	u16 dict_len;
	u8 facility;
	u8 flags: 5;
	u8 level: 3;
};

struct devkmsg_user {
	u64 seq;
	u32 idx;
	struct ratelimit_state rs;
	struct mutex lock;
	char buf[8192];
};

struct cont {
	char buf[992];
	size_t len;
	u32 caller_id;
	u64 ts_nsec;
	u8 level;
	u8 facility;
	enum log_flags flags;
};

struct printk_safe_seq_buf {
	atomic_t len;
	atomic_t message_lost;
	struct irq_work work;
	unsigned char buffer[8160];
};

enum {
	IRQS_AUTODETECT = 1,
	IRQS_SPURIOUS_DISABLED = 2,
	IRQS_POLL_INPROGRESS = 8,
	IRQS_ONESHOT = 32,
	IRQS_REPLAY = 64,
	IRQS_WAITING = 128,
	IRQS_PENDING = 512,
	IRQS_SUSPENDED = 2048,
	IRQS_TIMINGS = 4096,
	IRQS_NMI = 8192,
};

enum {
	_IRQ_DEFAULT_INIT_FLAGS = 0,
	_IRQ_PER_CPU = 512,
	_IRQ_LEVEL = 256,
	_IRQ_NOPROBE = 1024,
	_IRQ_NOREQUEST = 2048,
	_IRQ_NOTHREAD = 65536,
	_IRQ_NOAUTOEN = 4096,
	_IRQ_MOVE_PCNTXT = 16384,
	_IRQ_NO_BALANCING = 8192,
	_IRQ_NESTED_THREAD = 32768,
	_IRQ_PER_CPU_DEVID = 131072,
	_IRQ_IS_POLLED = 262144,
	_IRQ_DISABLE_UNLAZY = 524288,
	_IRQF_MODIFY_MASK = 1048335,
};

enum {
	IRQTF_RUNTHREAD = 0,
	IRQTF_WARNED = 1,
	IRQTF_AFFINITY = 2,
	IRQTF_FORCED_THREAD = 3,
};

enum {
	IRQC_IS_HARDIRQ = 0,
	IRQC_IS_NESTED = 1,
};

enum {
	IRQ_STARTUP_NORMAL = 0,
	IRQ_STARTUP_MANAGED = 1,
	IRQ_STARTUP_ABORT = 2,
};

struct irq_devres {
	unsigned int irq;
	void *dev_id;
};

struct irq_desc_devres {
	unsigned int from;
	unsigned int cnt;
};

typedef u64 acpi_size;

struct acpi_buffer {
	acpi_size length;
	void *pointer;
};

struct acpi_hotplug_profile {
	struct kobject kobj;
	int (*scan_dependent)(struct acpi_device *);
	void (*notify_online)(struct acpi_device *);
	bool enabled: 1;
	bool demand_offline: 1;
};

struct acpi_device_status {
	u32 present: 1;
	u32 enabled: 1;
	u32 show_in_ui: 1;
	u32 functional: 1;
	u32 battery_present: 1;
	u32 reserved: 27;
};

struct acpi_device_flags {
	u32 dynamic_status: 1;
	u32 removable: 1;
	u32 ejectable: 1;
	u32 power_manageable: 1;
	u32 match_driver: 1;
	u32 initialized: 1;
	u32 visited: 1;
	u32 hotplug_notify: 1;
	u32 is_dock_station: 1;
	u32 of_compatible_ok: 1;
	u32 coherent_dma: 1;
	u32 cca_seen: 1;
	u32 enumeration_by_parent: 1;
	u32 reserved: 19;
};

typedef char acpi_bus_id[8];

struct acpi_pnp_type {
	u32 hardware_id: 1;
	u32 bus_address: 1;
	u32 platform_id: 1;
	u32 reserved: 29;
};

typedef u64 acpi_bus_address;

typedef char acpi_device_name[40];

typedef char acpi_device_class[20];

struct acpi_device_pnp {
	acpi_bus_id bus_id;
	int instance_no;
	struct acpi_pnp_type type;
	acpi_bus_address bus_address;
	char *unique_id;
	struct list_head ids;
	acpi_device_name device_name;
	acpi_device_class device_class;
	union acpi_object *str_obj;
};

struct acpi_device_power_flags {
	u32 explicit_get: 1;
	u32 power_resources: 1;
	u32 inrush_current: 1;
	u32 power_removed: 1;
	u32 ignore_parent: 1;
	u32 dsw_present: 1;
	u32 reserved: 26;
};

struct acpi_device_power_state {
	struct {
		u8 valid: 1;
		u8 explicit_set: 1;
		u8 reserved: 6;
	} flags;
	int power;
	int latency;
	struct list_head resources;
};

struct acpi_device_power {
	int state;
	struct acpi_device_power_flags flags;
	struct acpi_device_power_state states[5];
};

struct acpi_device_wakeup_flags {
	u8 valid: 1;
	u8 notifier_present: 1;
};

struct acpi_device_wakeup_context {
	void (*func)(struct acpi_device_wakeup_context *);
	struct device *dev;
};

struct acpi_device_wakeup {
	acpi_handle gpe_device;
	u64 gpe_number;
	u64 sleep_state;
	struct list_head resources;
	struct acpi_device_wakeup_flags flags;
	struct acpi_device_wakeup_context context;
	struct wakeup_source *ws;
	int prepare_count;
	int enable_count;
};

struct acpi_device_perf_flags {
	u8 reserved: 8;
};

struct acpi_device_perf_state;

struct acpi_device_perf {
	int state;
	struct acpi_device_perf_flags flags;
	int state_count;
	struct acpi_device_perf_state *states;
};

struct acpi_device_dir {
	struct proc_dir_entry *entry;
};

struct acpi_device_data {
	const union acpi_object *pointer;
	struct list_head properties;
	const union acpi_object *of_compatible;
	struct list_head subnodes;
};

struct acpi_scan_handler;

struct acpi_hotplug_context;

struct acpi_driver;

struct acpi_gpio_mapping;

struct acpi_device {
	int device_type;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct acpi_device *parent;
	struct list_head children;
	struct list_head node;
	struct list_head wakeup_list;
	struct list_head del_list;
	struct acpi_device_status status;
	struct acpi_device_flags flags;
	struct acpi_device_pnp pnp;
	struct acpi_device_power power;
	struct acpi_device_wakeup wakeup;
	struct acpi_device_perf performance;
	struct acpi_device_dir dir;
	struct acpi_device_data data;
	struct acpi_scan_handler *handler;
	struct acpi_hotplug_context *hp;
	struct acpi_driver *driver;
	const struct acpi_gpio_mapping *driver_gpios;
	void *driver_data;
	struct device dev;
	unsigned int physical_node_count;
	unsigned int dep_unmet;
	struct list_head physical_node_list;
	struct mutex physical_node_lock;
	void (*remove)(struct acpi_device *);
};

struct acpi_scan_handler {
	const struct acpi_device_id *ids;
	struct list_head list_node;
	bool (*match)(const char *, const struct acpi_device_id **);
	int (*attach)(struct acpi_device *, const struct acpi_device_id *);
	void (*detach)(struct acpi_device *);
	void (*bind)(struct device *);
	void (*unbind)(struct device *);
	struct acpi_hotplug_profile hotplug;
};

struct acpi_hotplug_context {
	struct acpi_device *self;
	int (*notify)(struct acpi_device *, u32);
	void (*uevent)(struct acpi_device *, u32);
	void (*fixup)(struct acpi_device *);
};

typedef int (*acpi_op_add)(struct acpi_device *);

typedef int (*acpi_op_remove)(struct acpi_device *);

typedef void (*acpi_op_notify)(struct acpi_device *, u32);

struct acpi_device_ops {
	acpi_op_add add;
	acpi_op_remove remove;
	acpi_op_notify notify;
};

struct acpi_driver {
	char name[80];
	char class[80];
	const struct acpi_device_id *ids;
	unsigned int flags;
	struct acpi_device_ops ops;
	struct device_driver drv;
	struct module *owner;
};

struct acpi_device_perf_state {
	struct {
		u8 valid: 1;
		u8 reserved: 7;
	} flags;
	u8 power;
	u8 performance;
	int latency;
};

struct acpi_gpio_params;

struct acpi_gpio_mapping {
	const char *name;
	const struct acpi_gpio_params *data;
	unsigned int size;
	unsigned int quirks;
};

struct irqchip_fwid {
	struct fwnode_handle fwnode;
	unsigned int type;
	char *name;
	phys_addr_t *pa;
};

enum {
	AFFINITY = 0,
	AFFINITY_LIST = 1,
	EFFECTIVE = 2,
	EFFECTIVE_LIST = 3,
};

struct irq_affinity {
	unsigned int pre_vectors;
	unsigned int post_vectors;
	unsigned int nr_sets;
	unsigned int set_size[4];
	void (*calc_sets)(struct irq_affinity *, unsigned int);
	void *priv;
};

struct node_vectors {
	unsigned int id;
	union {
		unsigned int nvectors;
		unsigned int ncpus;
	};
};

struct cpumap {
	unsigned int available;
	unsigned int allocated;
	unsigned int managed;
	unsigned int managed_allocated;
	bool initialized;
	bool online;
	long unsigned int alloc_map[4];
	long unsigned int managed_map[4];
};

struct irq_matrix {
	unsigned int matrix_bits;
	unsigned int alloc_start;
	unsigned int alloc_end;
	unsigned int alloc_size;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int systembits_inalloc;
	unsigned int total_allocated;
	unsigned int online_maps;
	struct cpumap *maps;
	long unsigned int scratch_map[4];
	long unsigned int system_map[4];
};

struct trace_event_raw_irq_matrix_global {
	struct trace_entry ent;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_raw_irq_matrix_global_update {
	struct trace_entry ent;
	int bit;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_raw_irq_matrix_cpu {
	struct trace_entry ent;
	int bit;
	unsigned int cpu;
	bool online;
	unsigned int available;
	unsigned int allocated;
	unsigned int managed;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_data_offsets_irq_matrix_global {};

struct trace_event_data_offsets_irq_matrix_global_update {};

struct trace_event_data_offsets_irq_matrix_cpu {};

typedef void (*btf_trace_irq_matrix_online)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_offline)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_reserve)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_remove_reserved)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_assign_system)(void *, int, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_alloc_reserved)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_reserve_managed)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_remove_managed)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_alloc_managed)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_assign)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_alloc)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_free)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);

struct rcu_synchronize {
	struct callback_head head;
	struct completion completion;
};

struct trace_event_raw_rcu_utilization {
	struct trace_entry ent;
	const char *s;
	char __data[0];
};

struct trace_event_data_offsets_rcu_utilization {};

typedef void (*btf_trace_rcu_utilization)(void *, const char *);

enum {
	GP_IDLE = 0,
	GP_ENTER = 1,
	GP_PASSED = 2,
	GP_EXIT = 3,
	GP_REPLAY = 4,
};

struct rcu_cblist {
	struct callback_head *head;
	struct callback_head **tail;
	long int len;
	long int len_lazy;
};

enum rcutorture_type {
	RCU_FLAVOR = 0,
	RCU_TASKS_FLAVOR = 1,
	RCU_TRIVIAL_FLAVOR = 2,
	SRCU_FLAVOR = 3,
	INVALID_RCU_FLAVOR = 4,
};

struct rcu_exp_work {
	long unsigned int rew_s;
	struct work_struct rew_work;
};

struct rcu_node {
	raw_spinlock_t lock;
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	long unsigned int completedqs;
	long unsigned int qsmask;
	long unsigned int rcu_gp_init_mask;
	long unsigned int qsmaskinit;
	long unsigned int qsmaskinitnext;
	long unsigned int expmask;
	long unsigned int expmaskinit;
	long unsigned int expmaskinitnext;
	long unsigned int ffmask;
	long unsigned int grpmask;
	int grplo;
	int grphi;
	u8 grpnum;
	u8 level;
	bool wait_blkd_tasks;
	struct rcu_node *parent;
	struct list_head blkd_tasks;
	struct list_head *gp_tasks;
	struct list_head *exp_tasks;
	struct list_head *boost_tasks;
	struct rt_mutex boost_mtx;
	long unsigned int boost_time;
	struct task_struct *boost_kthread_task;
	unsigned int boost_kthread_status;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	raw_spinlock_t fqslock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t exp_lock;
	long unsigned int exp_seq_rq;
	wait_queue_head_t exp_wq[4];
	struct rcu_exp_work rew;
	bool exp_need_flush;
	long: 56;
	long: 64;
	long: 64;
};

union rcu_noqs {
	struct {
		u8 norm;
		u8 exp;
	} b;
	u16 s;
};

struct rcu_data {
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	union rcu_noqs cpu_no_qs;
	bool core_needs_qs;
	bool beenonline;
	bool gpwrap;
	bool exp_deferred_qs;
	struct rcu_node *mynode;
	long unsigned int grpmask;
	long unsigned int ticks_this_gp;
	struct irq_work defer_qs_iw;
	bool defer_qs_iw_pending;
	struct rcu_segcblist cblist;
	long int qlen_last_fqs_check;
	long unsigned int n_force_qs_snap;
	long int blimit;
	int dynticks_snap;
	long int dynticks_nesting;
	long int dynticks_nmi_nesting;
	atomic_t dynticks;
	bool rcu_need_heavy_qs;
	bool rcu_urgent_qs;
	struct callback_head barrier_head;
	int exp_dynticks_snap;
	struct task_struct *rcu_cpu_kthread_task;
	unsigned int rcu_cpu_kthread_status;
	char rcu_cpu_has_work;
	unsigned int softirq_snap;
	struct irq_work rcu_iw;
	bool rcu_iw_pending;
	long unsigned int rcu_iw_gp_seq;
	long unsigned int rcu_ofl_gp_seq;
	short int rcu_ofl_gp_flags;
	long unsigned int rcu_onl_gp_seq;
	short int rcu_onl_gp_flags;
	long unsigned int last_fqs_resched;
	int cpu;
};

struct rcu_state {
	struct rcu_node node[521];
	struct rcu_node *level[4];
	int ncpus;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	u8 boost;
	long unsigned int gp_seq;
	struct task_struct *gp_kthread;
	struct swait_queue_head gp_wq;
	short int gp_flags;
	short int gp_state;
	long unsigned int gp_wake_time;
	long unsigned int gp_wake_seq;
	struct mutex barrier_mutex;
	atomic_t barrier_cpu_count;
	struct completion barrier_completion;
	long unsigned int barrier_sequence;
	struct mutex exp_mutex;
	struct mutex exp_wake_mutex;
	long unsigned int expedited_sequence;
	atomic_t expedited_need_qs;
	struct swait_queue_head expedited_wq;
	int ncpus_snap;
	long unsigned int jiffies_force_qs;
	long unsigned int jiffies_kick_kthreads;
	long unsigned int n_force_qs;
	long unsigned int gp_start;
	long unsigned int gp_end;
	long unsigned int gp_activity;
	long unsigned int gp_req_activity;
	long unsigned int jiffies_stall;
	long unsigned int jiffies_resched;
	long unsigned int n_force_qs_gpstart;
	long unsigned int gp_max;
	const char *name;
	char abbr;
	long: 56;
	long: 64;
	long: 64;
	raw_spinlock_t ofl_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef char pto_T_____22;

struct klp_find_arg {
	const char *objname;
	const char *name;
	long unsigned int addr;
	long unsigned int count;
	long unsigned int pos;
};

struct klp_ops {
	struct list_head node;
	struct list_head func_stack;
	struct ftrace_ops fops;
};

typedef int (*klp_shadow_ctor_t)(void *, void *, void *);

typedef void (*klp_shadow_dtor_t)(void *, void *);

struct klp_shadow {
	struct hlist_node node;
	struct callback_head callback_head;
	void *obj;
	long unsigned int id;
	char data[0];
};

struct dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
	long unsigned int attrs;
};

enum dma_sync_target {
	SYNC_FOR_CPU = 0,
	SYNC_FOR_DEVICE = 1,
};

struct trace_event_raw_swiotlb_bounced {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u64 dma_mask;
	dma_addr_t dev_addr;
	size_t size;
	enum swiotlb_force swiotlb_force;
	char __data[0];
};

struct trace_event_data_offsets_swiotlb_bounced {
	u32 dev_name;
};

typedef void (*btf_trace_swiotlb_bounced)(void *, struct device *, dma_addr_t, size_t, enum swiotlb_force);

enum profile_type {
	PROFILE_TASK_EXIT = 0,
	PROFILE_MUNMAP = 1,
};

struct profile_hit {
	u32 pc;
	u32 hits;
};

struct stacktrace_cookie {
	long unsigned int *store;
	unsigned int size;
	unsigned int skip;
	unsigned int len;
};

typedef __kernel_suseconds_t suseconds_t;

typedef __kernel_time_t time_t;

typedef __u64 timeu64_t;

struct __kernel_itimerspec {
	struct __kernel_timespec it_interval;
	struct __kernel_timespec it_value;
};

struct __kernel_old_timeval {
	__kernel_long_t tv_sec;
	__kernel_long_t tv_usec;
};

struct timespec {
	__kernel_time_t tv_sec;
	long int tv_nsec;
};

struct timezone {
	int tz_minuteswest;
	int tz_dsttime;
};

struct itimerspec64 {
	struct timespec64 it_interval;
	struct timespec64 it_value;
};

struct old_itimerspec32 {
	struct old_timespec32 it_interval;
	struct old_timespec32 it_value;
};

struct old_timex32 {
	u32 modes;
	s32 offset;
	s32 freq;
	s32 maxerror;
	s32 esterror;
	s32 status;
	s32 constant;
	s32 precision;
	s32 tolerance;
	struct old_timeval32 time;
	s32 tick;
	s32 ppsfreq;
	s32 jitter;
	s32 shift;
	s32 stabil;
	s32 jitcnt;
	s32 calcnt;
	s32 errcnt;
	s32 stbcnt;
	s32 tai;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct __kernel_timex_timeval {
	__kernel_time64_t tv_sec;
	long long int tv_usec;
};

struct __kernel_timex {
	unsigned int modes;
	long long int offset;
	long long int freq;
	long long int maxerror;
	long long int esterror;
	int status;
	long long int constant;
	long long int precision;
	long long int tolerance;
	struct __kernel_timex_timeval time;
	long long int tick;
	long long int ppsfreq;
	long long int jitter;
	int shift;
	long long int stabil;
	long long int jitcnt;
	long long int calcnt;
	long long int errcnt;
	long long int stbcnt;
	int tai;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct itimerval {
	struct timeval it_interval;
	struct timeval it_value;
};

struct trace_event_raw_timer_class {
	struct trace_entry ent;
	void *timer;
	char __data[0];
};

struct trace_event_raw_timer_start {
	struct trace_entry ent;
	void *timer;
	void *function;
	long unsigned int expires;
	long unsigned int now;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_timer_expire_entry {
	struct trace_entry ent;
	void *timer;
	long unsigned int now;
	void *function;
	long unsigned int baseclk;
	char __data[0];
};

struct trace_event_raw_hrtimer_init {
	struct trace_entry ent;
	void *hrtimer;
	clockid_t clockid;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_start {
	struct trace_entry ent;
	void *hrtimer;
	void *function;
	s64 expires;
	s64 softexpires;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_expire_entry {
	struct trace_entry ent;
	void *hrtimer;
	s64 now;
	void *function;
	char __data[0];
};

struct trace_event_raw_hrtimer_class {
	struct trace_entry ent;
	void *hrtimer;
	char __data[0];
};

struct trace_event_raw_itimer_state {
	struct trace_entry ent;
	int which;
	long long unsigned int expires;
	long int value_sec;
	long int value_usec;
	long int interval_sec;
	long int interval_usec;
	char __data[0];
};

struct trace_event_raw_itimer_expire {
	struct trace_entry ent;
	int which;
	pid_t pid;
	long long unsigned int now;
	char __data[0];
};

struct trace_event_raw_tick_stop {
	struct trace_entry ent;
	int success;
	int dependency;
	char __data[0];
};

struct trace_event_data_offsets_timer_class {};

struct trace_event_data_offsets_timer_start {};

struct trace_event_data_offsets_timer_expire_entry {};

struct trace_event_data_offsets_hrtimer_init {};

struct trace_event_data_offsets_hrtimer_start {};

struct trace_event_data_offsets_hrtimer_expire_entry {};

struct trace_event_data_offsets_hrtimer_class {};

struct trace_event_data_offsets_itimer_state {};

struct trace_event_data_offsets_itimer_expire {};

struct trace_event_data_offsets_tick_stop {};

typedef void (*btf_trace_timer_init)(void *, struct timer_list *);

typedef void (*btf_trace_timer_start)(void *, struct timer_list *, long unsigned int, unsigned int);

typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);

typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);

typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);

typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);

typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerval * const, long long unsigned int);

typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, long long unsigned int);

typedef void (*btf_trace_tick_stop)(void *, int, int);

struct timer_base {
	raw_spinlock_t lock;
	struct timer_list *running_timer;
	long unsigned int clk;
	long unsigned int next_expiry;
	unsigned int cpu;
	bool is_idle;
	bool must_forward_clk;
	long unsigned int pending_map[9];
	struct hlist_head vectors[576];
	long: 64;
	long: 64;
};

struct process_timer {
	struct timer_list timer;
	struct task_struct *task;
};

enum tick_device_mode {
	TICKDEV_MODE_PERIODIC = 0,
	TICKDEV_MODE_ONESHOT = 1,
};

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};

struct system_time_snapshot {
	u64 cycles;
	ktime_t real;
	ktime_t raw;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
};

struct system_device_crosststamp {
	ktime_t device;
	ktime_t sys_realtime;
	ktime_t sys_monoraw;
};

struct tk_read_base {
	struct clocksource *clock;
	u64 mask;
	u64 cycle_last;
	u32 mult;
	u32 shift;
	u64 xtime_nsec;
	ktime_t base;
	u64 base_real;
};

struct timekeeper {
	struct tk_read_base tkr_mono;
	struct tk_read_base tkr_raw;
	u64 xtime_sec;
	long unsigned int ktime_sec;
	struct timespec64 wall_to_monotonic;
	ktime_t offs_real;
	ktime_t offs_boot;
	ktime_t offs_tai;
	s32 tai_offset;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	ktime_t next_leap_ktime;
	u64 raw_sec;
	struct timespec64 monotonic_to_boot;
	u64 cycle_interval;
	u64 xtime_interval;
	s64 xtime_remainder;
	u64 raw_interval;
	u64 ntp_tick;
	s64 ntp_error;
	u32 ntp_error_shift;
	u32 ntp_err_mult;
	u32 skip_second_overflow;
};

struct audit_ntp_val {
	long long int oldval;
	long long int newval;
};

struct audit_ntp_data {
	struct audit_ntp_val vals[6];
};

enum timekeeping_adv_mode {
	TK_ADV_TICK = 0,
	TK_ADV_FREQ = 1,
};

struct tk_fast {
	seqcount_t seq;
	struct tk_read_base base[2];
};

typedef s64 int64_t;

enum tick_nohz_mode {
	NOHZ_MODE_INACTIVE = 0,
	NOHZ_MODE_LOWRES = 1,
	NOHZ_MODE_HIGHRES = 2,
};

struct tick_sched {
	struct hrtimer sched_timer;
	long unsigned int check_clocks;
	enum tick_nohz_mode nohz_mode;
	unsigned int inidle: 1;
	unsigned int tick_stopped: 1;
	unsigned int idle_active: 1;
	unsigned int do_timer_last: 1;
	unsigned int got_idle_tick: 1;
	ktime_t last_tick;
	ktime_t next_tick;
	long unsigned int idle_jiffies;
	long unsigned int idle_calls;
	long unsigned int idle_sleeps;
	ktime_t idle_entrytime;
	ktime_t idle_waketime;
	ktime_t idle_exittime;
	ktime_t idle_sleeptime;
	ktime_t iowait_sleeptime;
	long unsigned int last_jiffies;
	u64 timer_expires;
	u64 timer_expires_base;
	u64 next_timer;
	ktime_t idle_expires;
	atomic_t tick_dep_mask;
};

struct timer_list_iter {
	int cpu;
	bool second_pass;
	u64 now;
};

struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	long int tm_year;
	int tm_wday;
	int tm_yday;
};

struct cyclecounter {
	u64 (*read)(const struct cyclecounter *);
	u64 mask;
	u32 mult;
	u32 shift;
};

struct timecounter {
	const struct cyclecounter *cc;
	u64 cycle_last;
	u64 nsec;
	u64 mask;
	u64 frac;
};

typedef __kernel_timer_t timer_t;

struct rtc_wkalrm {
	unsigned char enabled;
	unsigned char pending;
	struct rtc_time time;
};

enum alarmtimer_type {
	ALARM_REALTIME = 0,
	ALARM_BOOTTIME = 1,
	ALARM_NUMTYPE = 2,
	ALARM_REALTIME_FREEZER = 3,
	ALARM_BOOTTIME_FREEZER = 4,
};

enum alarmtimer_restart {
	ALARMTIMER_NORESTART = 0,
	ALARMTIMER_RESTART = 1,
};

struct alarm {
	struct timerqueue_node node;
	struct hrtimer timer;
	enum alarmtimer_restart (*function)(struct alarm *, ktime_t);
	enum alarmtimer_type type;
	int state;
	void *data;
};

struct cpu_timer {
	struct timerqueue_node node;
	struct timerqueue_head *head;
	struct task_struct *task;
	struct list_head elist;
	int firing;
};

struct k_clock;

struct k_itimer {
	struct list_head list;
	struct hlist_node t_hash;
	spinlock_t it_lock;
	const struct k_clock *kclock;
	clockid_t it_clock;
	timer_t it_id;
	int it_active;
	s64 it_overrun;
	s64 it_overrun_last;
	int it_requeue_pending;
	int it_sigev_notify;
	ktime_t it_interval;
	struct signal_struct *it_signal;
	union {
		struct pid *it_pid;
		struct task_struct *it_process;
	};
	struct sigqueue *sigq;
	union {
		struct {
			struct hrtimer timer;
		} real;
		struct cpu_timer cpu;
		struct {
			struct alarm alarmtimer;
		} alarm;
	} it;
	struct callback_head rcu;
};

struct k_clock {
	int (*clock_getres)(const clockid_t, struct timespec64 *);
	int (*clock_set)(const clockid_t, const struct timespec64 *);
	int (*clock_get)(const clockid_t, struct timespec64 *);
	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
	int (*timer_create)(struct k_itimer *);
	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
	int (*timer_del)(struct k_itimer *);
	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
	void (*timer_rearm)(struct k_itimer *);
	s64 (*timer_forward)(struct k_itimer *, ktime_t);
	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
	int (*timer_try_to_cancel)(struct k_itimer *);
	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
	void (*timer_wait_running)(struct k_itimer *);
};

struct class_interface {
	struct list_head node;
	struct class *class;
	int (*add_dev)(struct device *, struct class_interface *);
	void (*remove_dev)(struct device *, struct class_interface *);
};

struct rtc_class_ops {
	int (*ioctl)(struct device *, unsigned int, long unsigned int);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*alarm_irq_enable)(struct device *, unsigned int);
	int (*read_offset)(struct device *, long int *);
	int (*set_offset)(struct device *, long int);
};

struct rtc_device;

struct rtc_timer {
	struct timerqueue_node node;
	ktime_t period;
	void (*func)(struct rtc_device *);
	struct rtc_device *rtc;
	int enabled;
};

struct rtc_device {
	struct device dev;
	struct module *owner;
	int id;
	const struct rtc_class_ops *ops;
	struct mutex ops_lock;
	struct cdev char_dev;
	long unsigned int flags;
	long unsigned int irq_data;
	spinlock_t irq_lock;
	wait_queue_head_t irq_queue;
	struct fasync_struct *async_queue;
	int irq_freq;
	int max_user_freq;
	struct timerqueue_head timerqueue;
	struct rtc_timer aie_timer;
	struct rtc_timer uie_rtctimer;
	struct hrtimer pie_timer;
	int pie_enabled;
	struct work_struct irqwork;
	int uie_unsupported;
	long int set_offset_nsec;
	bool registered;
	bool nvram_old_abi;
	struct bin_attribute *nvram;
	time64_t range_min;
	timeu64_t range_max;
	time64_t start_secs;
	time64_t offset_secs;
	bool set_start_time;
};

struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
};

struct trace_event_raw_alarmtimer_suspend {
	struct trace_entry ent;
	s64 expires;
	unsigned char alarm_type;
	char __data[0];
};

struct trace_event_raw_alarm_class {
	struct trace_entry ent;
	void *alarm;
	unsigned char alarm_type;
	s64 expires;
	s64 now;
	char __data[0];
};

struct trace_event_data_offsets_alarmtimer_suspend {};

struct trace_event_data_offsets_alarm_class {};

typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);

typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);

struct alarm_base {
	spinlock_t lock;
	struct timerqueue_head timerqueue;
	ktime_t (*gettime)();
	clockid_t base_clockid;
};

struct sigevent {
	sigval_t sigev_value;
	int sigev_signo;
	int sigev_notify;
	union {
		int _pad[12];
		int _tid;
		struct {
			void (*_function)(sigval_t);
			void *_attribute;
		} _sigev_thread;
	} _sigev_un;
};

typedef struct sigevent sigevent_t;

struct compat_sigevent {
	compat_sigval_t sigev_value;
	compat_int_t sigev_signo;
	compat_int_t sigev_notify;
	union {
		compat_int_t _pad[13];
		compat_int_t _tid;
		struct {
			compat_uptr_t _function;
			compat_uptr_t _attribute;
		} _sigev_thread;
	} _sigev_un;
};

struct posix_clock;

struct posix_clock_operations {
	struct module *owner;
	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
	long int (*ioctl)(struct posix_clock *, unsigned int, long unsigned int);
	int (*open)(struct posix_clock *, fmode_t);
	__poll_t (*poll)(struct posix_clock *, struct file *, poll_table *);
	int (*release)(struct posix_clock *);
	ssize_t (*read)(struct posix_clock *, uint, char *, size_t);
};

struct posix_clock {
	struct posix_clock_operations ops;
	struct cdev cdev;
	struct device *dev;
	struct rw_semaphore rwsem;
	bool zombie;
};

struct posix_clock_desc {
	struct file *fp;
	struct posix_clock *clk;
};

struct compat_itimerval {
	struct old_timeval32 it_interval;
	struct old_timeval32 it_value;
};

struct ce_unbind {
	struct clock_event_device *ce;
	int res;
};

typedef ktime_t pto_T_____23;

struct vdso_timestamp {
	u64 sec;
	u64 nsec;
};

struct vdso_data {
	u32 seq;
	s32 clock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	struct vdso_timestamp basetime[12];
	s32 tz_minuteswest;
	s32 tz_dsttime;
	u32 hrtimer_res;
	u32 __unused;
};

union futex_key {
	struct {
		u64 i_seq;
		long unsigned int pgoff;
		unsigned int offset;
	} shared;
	struct {
		union {
			struct mm_struct *mm;
			u64 __tmp;
		};
		long unsigned int address;
		unsigned int offset;
	} private;
	struct {
		u64 ptr;
		long unsigned int word;
		unsigned int offset;
	} both;
};

struct futex_pi_state {
	struct list_head list;
	struct rt_mutex pi_mutex;
	struct task_struct *owner;
	refcount_t refcount;
	union futex_key key;
};

struct futex_q {
	struct plist_node list;
	struct task_struct *task;
	spinlock_t *lock_ptr;
	union futex_key key;
	struct futex_pi_state *pi_state;
	struct rt_mutex_waiter *rt_waiter;
	union futex_key *requeue_pi_key;
	u32 bitset;
};

struct futex_hash_bucket {
	atomic_t waiters;
	spinlock_t lock;
	struct plist_head chain;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum futex_access {
	FUTEX_READ = 0,
	FUTEX_WRITE = 1,
};

struct dma_chan {
	int lock;
	const char *device_id;
};

enum {
	CSD_FLAG_LOCK = 1,
	CSD_FLAG_SYNCHRONOUS = 2,
};

struct call_function_data {
	call_single_data_t *csd;
	cpumask_var_t cpumask;
	cpumask_var_t cpumask_ipi;
};

struct smp_call_on_cpu_struct {
	struct work_struct work;
	struct completion done;
	int (*func)(void *);
	void *data;
	int ret;
	int cpu;
};

struct latch_tree_root {
	seqcount_t seq;
	struct rb_root tree[2];
};

struct latch_tree_ops {
	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
	int (*comp)(void *, struct latch_tree_node *);
};

struct modversion_info {
	long unsigned int crc;
	char name[56];
};

struct module_use {
	struct list_head source_list;
	struct list_head target_list;
	struct module *source;
	struct module *target;
};

struct module_sect_attr {
	struct bin_attribute battr;
	long unsigned int address;
};

struct module_sect_attrs {
	struct attribute_group grp;
	unsigned int nsections;
	struct module_sect_attr attrs[0];
};

struct module_notes_attrs {
	struct kobject *dir;
	unsigned int notes;
	struct bin_attribute attrs[0];
};

struct symsearch {
	const struct kernel_symbol *start;
	const struct kernel_symbol *stop;
	const s32 *crcs;
	enum {
		NOT_GPL_ONLY = 0,
		GPL_ONLY = 1,
		WILL_BE_GPL_ONLY = 2,
	} licence;
	bool unused;
};

enum kernel_read_file_id {
	READING_UNKNOWN = 0,
	READING_FIRMWARE = 1,
	READING_FIRMWARE_PREALLOC_BUFFER = 2,
	READING_MODULE = 3,
	READING_KEXEC_IMAGE = 4,
	READING_KEXEC_INITRAMFS = 5,
	READING_POLICY = 6,
	READING_X509_CERTIFICATE = 7,
	READING_MAX_ID = 8,
};

enum kernel_load_data_id {
	LOADING_UNKNOWN = 0,
	LOADING_FIRMWARE = 1,
	LOADING_FIRMWARE_PREALLOC_BUFFER = 2,
	LOADING_MODULE = 3,
	LOADING_KEXEC_IMAGE = 4,
	LOADING_KEXEC_INITRAMFS = 5,
	LOADING_POLICY = 6,
	LOADING_X509_CERTIFICATE = 7,
	LOADING_MAX_ID = 8,
};

struct load_info {
	const char *name;
	struct module *mod;
	Elf64_Ehdr *hdr;
	long unsigned int len;
	Elf64_Shdr *sechdrs;
	char *secstrings;
	char *strtab;
	long unsigned int symoffs;
	long unsigned int stroffs;
	long unsigned int init_typeoffs;
	long unsigned int core_typeoffs;
	struct _ddebug *debug;
	unsigned int num_debug;
	bool sig_ok;
	long unsigned int mod_kallsyms_init_off;
	struct {
		unsigned int sym;
		unsigned int str;
		unsigned int mod;
		unsigned int vers;
		unsigned int info;
		unsigned int pcpu;
	} index;
};

struct trace_event_raw_module_load {
	struct trace_entry ent;
	unsigned int taints;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_free {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_refcnt {
	struct trace_entry ent;
	long unsigned int ip;
	int refcnt;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_request {
	struct trace_entry ent;
	long unsigned int ip;
	bool wait;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_module_load {
	u32 name;
};

struct trace_event_data_offsets_module_free {
	u32 name;
};

struct trace_event_data_offsets_module_refcnt {
	u32 name;
};

struct trace_event_data_offsets_module_request {
	u32 name;
};

typedef void (*btf_trace_module_load)(void *, struct module *);

typedef void (*btf_trace_module_free)(void *, struct module *);

typedef void (*btf_trace_module_get)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_put)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_request)(void *, char *, bool, long unsigned int);

struct mod_tree_root {
	struct latch_tree_root root;
	long unsigned int addr_min;
	long unsigned int addr_max;
};

struct find_symbol_arg {
	const char *name;
	bool gplok;
	bool warn;
	struct module *owner;
	const s32 *crc;
	const struct kernel_symbol *sym;
};

struct mod_initfree {
	struct llist_node node;
	void *module_init;
};

struct kallsym_iter {
	loff_t pos;
	loff_t pos_arch_end;
	loff_t pos_mod_end;
	loff_t pos_ftrace_mod_end;
	long unsigned int value;
	unsigned int nameoff;
	char type;
	char name[128];
	char module_name[56];
	int exported;
	int show_value;
};

enum {
	SB_UNFROZEN = 0,
	SB_FREEZE_WRITE = 1,
	SB_FREEZE_PAGEFAULT = 2,
	SB_FREEZE_FS = 3,
	SB_FREEZE_COMPLETE = 4,
};

typedef __u16 comp_t;

struct acct_v3 {
	char ac_flag;
	char ac_version;
	__u16 ac_tty;
	__u32 ac_exitcode;
	__u32 ac_uid;
	__u32 ac_gid;
	__u32 ac_pid;
	__u32 ac_ppid;
	__u32 ac_btime;
	__u32 ac_etime;
	comp_t ac_utime;
	comp_t ac_stime;
	comp_t ac_mem;
	comp_t ac_io;
	comp_t ac_rw;
	comp_t ac_minflt;
	comp_t ac_majflt;
	comp_t ac_swaps;
	char ac_comm[16];
};

typedef struct acct_v3 acct_t;

struct fs_pin {
	wait_queue_head_t wait;
	int done;
	struct hlist_node s_list;
	struct hlist_node m_list;
	void (*kill)(struct fs_pin *);
};

struct bsd_acct_struct {
	struct fs_pin pin;
	atomic_long_t count;
	struct callback_head rcu;
	struct mutex lock;
	int active;
	long unsigned int needcheck;
	struct file *file;
	struct pid_namespace *ns;
	struct work_struct work;
	struct completion done;
};

enum compound_dtor_id {
	NULL_COMPOUND_DTOR = 0,
	COMPOUND_PAGE_DTOR = 1,
	HUGETLB_PAGE_DTOR = 2,
	TRANSHUGE_PAGE_DTOR = 3,
	NR_COMPOUND_DTORS = 4,
};

struct elf64_note {
	Elf64_Word n_namesz;
	Elf64_Word n_descsz;
	Elf64_Word n_type;
};

typedef long unsigned int elf_greg_t;

typedef elf_greg_t elf_gregset_t[27];

struct elf_siginfo {
	int si_signo;
	int si_code;
	int si_errno;
};

struct elf_prstatus {
	struct elf_siginfo pr_info;
	short int pr_cursig;
	long unsigned int pr_sigpend;
	long unsigned int pr_sighold;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	struct timeval pr_utime;
	struct timeval pr_stime;
	struct timeval pr_cutime;
	struct timeval pr_cstime;
	elf_gregset_t pr_reg;
	int pr_fpvalid;
};

typedef u32 note_buf_t[92];

struct compat_kexec_segment {
	compat_uptr_t buf;
	compat_size_t bufsz;
	compat_ulong_t mem;
	compat_size_t memsz;
};

struct shash_alg {
	int (*init)(struct shash_desc *);
	int (*update)(struct shash_desc *, const u8 *, unsigned int);
	int (*final)(struct shash_desc *, u8 *);
	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*export)(struct shash_desc *, void *);
	int (*import)(struct shash_desc *, const void *);
	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
	unsigned int descsize;
	int: 32;
	unsigned int digestsize;
	unsigned int statesize;
	struct crypto_alg base;
};

struct kexec_sha_region {
	long unsigned int start;
	long unsigned int len;
};

enum migrate_reason {
	MR_COMPACTION = 0,
	MR_MEMORY_FAILURE = 1,
	MR_MEMORY_HOTPLUG = 2,
	MR_SYSCALL = 3,
	MR_MEMPOLICY_MBIND = 4,
	MR_NUMA_MISPLACED = 5,
	MR_CONTIG_RANGE = 6,
	MR_TYPES = 7,
};

typedef __kernel_ulong_t __kernel_ino_t;

typedef __kernel_ino_t ino_t;

enum bpf_link_type {
	BPF_LINK_TYPE_UNSPEC = 0,
	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
	BPF_LINK_TYPE_TRACING = 2,
	BPF_LINK_TYPE_CGROUP = 3,
	BPF_LINK_TYPE_ITER = 4,
	BPF_LINK_TYPE_NETNS = 5,
	MAX_BPF_LINK_TYPE = 6,
};

struct bpf_link_info {
	__u32 type;
	__u32 id;
	__u32 prog_id;
	union {
		struct {
			__u64 tp_name;
			__u32 tp_name_len;
		} raw_tracepoint;
		struct {
			__u32 attach_type;
		} tracing;
		struct {
			__u64 cgroup_id;
			__u32 attach_type;
		} cgroup;
		struct {
			__u32 netns_ino;
			__u32 attach_type;
		} netns;
	};
};

struct bpf_link_ops;

struct bpf_link {
	atomic64_t refcnt;
	u32 id;
	enum bpf_link_type type;
	const struct bpf_link_ops *ops;
	struct bpf_prog *prog;
	struct work_struct work;
};

struct bpf_link_ops {
	void (*release)(struct bpf_link *);
	void (*dealloc)(struct bpf_link *);
	int (*detach)(struct bpf_link *);
	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
};

struct bpf_cgroup_link {
	struct bpf_link link;
	struct cgroup *cgroup;
	enum bpf_attach_type type;
};

enum {
	CGRP_NOTIFY_ON_RELEASE = 0,
	CGRP_CPUSET_CLONE_CHILDREN = 1,
	CGRP_FREEZE = 2,
	CGRP_FROZEN = 3,
};

enum {
	CGRP_ROOT_NOPREFIX = 2,
	CGRP_ROOT_XATTR = 4,
	CGRP_ROOT_NS_DELEGATE = 8,
	CGRP_ROOT_CPUSET_V2_MODE = 16,
	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 32,
};

struct cgroup_taskset {
	struct list_head src_csets;
	struct list_head dst_csets;
	int nr_tasks;
	int ssid;
	struct list_head *csets;
	struct css_set *cur_cset;
	struct task_struct *cur_task;
};

struct cgroup_fs_context {
	struct kernfs_fs_context kfc;
	struct cgroup_root *root;
	struct cgroup_namespace *ns;
	unsigned int flags;
	bool cpuset_clone_children;
	bool none;
	bool all_ss;
	u16 subsys_mask;
	char *name;
	char *release_agent;
};

struct cgrp_cset_link {
	struct cgroup *cgrp;
	struct css_set *cset;
	struct list_head cset_link;
	struct list_head cgrp_link;
};

struct cgroup_mgctx {
	struct list_head preloaded_src_csets;
	struct list_head preloaded_dst_csets;
	struct cgroup_taskset tset;
	u16 ss_mask;
};

struct trace_event_raw_cgroup_root {
	struct trace_entry ent;
	int root;
	u16 ss_mask;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cgroup {
	struct trace_entry ent;
	int root;
	int id;
	int level;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_cgroup_migrate {
	struct trace_entry ent;
	int dst_root;
	int dst_id;
	int dst_level;
	int pid;
	u32 __data_loc_dst_path;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_cgroup_event {
	struct trace_entry ent;
	int root;
	int id;
	int level;
	u32 __data_loc_path;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_cgroup_root {
	u32 name;
};

struct trace_event_data_offsets_cgroup {
	u32 path;
};

struct trace_event_data_offsets_cgroup_migrate {
	u32 dst_path;
	u32 comm;
};

struct trace_event_data_offsets_cgroup_event {
	u32 path;
};

typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);

enum cgroup2_param {
	Opt_nsdelegate = 0,
	Opt_memory_localevents = 1,
	nr__cgroup2_params = 2,
};

struct cgroupstats {
	__u64 nr_sleeping;
	__u64 nr_running;
	__u64 nr_stopped;
	__u64 nr_uninterruptible;
	__u64 nr_io_wait;
};

enum cgroup_filetype {
	CGROUP_FILE_PROCS = 0,
	CGROUP_FILE_TASKS = 1,
};

struct cgroup_pidlist {
	struct {
		enum cgroup_filetype type;
		struct pid_namespace *ns;
	} key;
	pid_t *list;
	int length;
	struct list_head links;
	struct cgroup *owner;
	struct delayed_work destroy_dwork;
};

enum cgroup1_param {
	Opt_all = 0,
	Opt_clone_children = 1,
	Opt_cpuset_v2_mode = 2,
	Opt_name = 3,
	Opt_none = 4,
	Opt_noprefix = 5,
	Opt_release_agent = 6,
	Opt_xattr = 7,
};

enum freezer_state_flags {
	CGROUP_FREEZER_ONLINE = 1,
	CGROUP_FREEZING_SELF = 2,
	CGROUP_FREEZING_PARENT = 4,
	CGROUP_FROZEN = 8,
	CGROUP_FREEZING = 6,
};

struct freezer {
	struct cgroup_subsys_state css;
	unsigned int state;
};

struct pids_cgroup {
	struct cgroup_subsys_state css;
	atomic64_t counter;
	atomic64_t limit;
	struct cgroup_file events_file;
	atomic64_t events_limit;
};

struct root_domain;

struct fmeter {
	int cnt;
	int val;
	time64_t time;
	spinlock_t lock;
};

struct cpuset {
	struct cgroup_subsys_state css;
	long unsigned int flags;
	cpumask_var_t cpus_allowed;
	nodemask_t mems_allowed;
	cpumask_var_t effective_cpus;
	nodemask_t effective_mems;
	cpumask_var_t subparts_cpus;
	nodemask_t old_mems_allowed;
	struct fmeter fmeter;
	int attach_in_progress;
	int pn;
	int relax_domain_level;
	int nr_subparts_cpus;
	int partition_root_state;
	int use_parent_ecpus;
	int child_ecpus_count;
	long unsigned int calc_load_tasks;
	long unsigned int avenrun[3];
	long unsigned int calc_load_tasks_r;
	long unsigned int avenrun_r[3];
	long unsigned int calc_load_tasks_d;
	long unsigned int avenrun_d[3];
};

struct tmpmasks {
	cpumask_var_t addmask;
	cpumask_var_t delmask;
	cpumask_var_t new_cpus;
};

typedef enum {
	CS_ONLINE = 0,
	CS_CPU_EXCLUSIVE = 1,
	CS_MEM_EXCLUSIVE = 2,
	CS_MEM_HARDWALL = 3,
	CS_MEMORY_MIGRATE = 4,
	CS_SCHED_LOAD_BALANCE = 5,
	CS_SPREAD_PAGE = 6,
	CS_SPREAD_SLAB = 7,
} cpuset_flagbits_t;

enum subparts_cmd {
	partcmd_enable = 0,
	partcmd_disable = 1,
	partcmd_update = 2,
};

struct cpuset_migrate_mm_work {
	struct work_struct work;
	struct mm_struct *mm;
	nodemask_t from;
	nodemask_t to;
};

typedef enum {
	FILE_MEMORY_MIGRATE = 0,
	FILE_CPULIST = 1,
	FILE_MEMLIST = 2,
	FILE_EFFECTIVE_CPULIST = 3,
	FILE_EFFECTIVE_MEMLIST = 4,
	FILE_SUBPARTS_CPULIST = 5,
	FILE_CPU_EXCLUSIVE = 6,
	FILE_MEM_EXCLUSIVE = 7,
	FILE_MEM_HARDWALL = 8,
	FILE_SCHED_LOAD_BALANCE = 9,
	FILE_PARTITION_ROOT = 10,
	FILE_SCHED_RELAX_DOMAIN_LEVEL = 11,
	FILE_MEMORY_PRESSURE_ENABLED = 12,
	FILE_MEMORY_PRESSURE = 13,
	FILE_SPREAD_PAGE = 14,
	FILE_SPREAD_SLAB = 15,
} cpuset_filetype_t;

struct usage_info {
	u64 sys;
	u64 usr;
	u64 idle;
};

typedef struct usage_info u_info;

struct mbuf_struct {
	u32 mbuf_len;
	u32 mbuf_max_slots;
	u32 mbuf_frees;
	u32 mbuf_next_id;
	u32 mbuf_size_per_cg;
	spinlock_t mbuf_lock;
	char *mbuf;
	long unsigned int *mbuf_bitmap;
};

struct mbuf_ring_desc {
	u64 ts_ns;
	u16 len;
	u16 text_len;
};

struct kernel_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
};

enum kernel_pkey_operation {
	kernel_pkey_encrypt = 0,
	kernel_pkey_decrypt = 1,
	kernel_pkey_sign = 2,
	kernel_pkey_verify = 3,
};

struct kernel_pkey_params {
	struct key *key;
	const char *encoding;
	const char *hash_algo;
	char *info;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	enum kernel_pkey_operation op: 8;
};

struct key_preparsed_payload {
	char *description;
	union key_payload payload;
	const void *data;
	size_t datalen;
	size_t quotalen;
	time64_t expiry;
};

struct key_match_data {
	bool (*cmp)(const struct key *, const struct key_match_data *);
	const void *raw_data;
	void *preparsed;
	unsigned int lookup_type;
};

struct idmap_key {
	bool map_up;
	u32 id;
	u32 count;
};

struct cpu_stop_done {
	atomic_t nr_todo;
	int ret;
	struct completion completion;
};

struct cpu_stopper {
	struct task_struct *thread;
	raw_spinlock_t lock;
	bool enabled;
	struct list_head works;
	struct cpu_stop_work stop_work;
};

enum multi_stop_state {
	MULTI_STOP_NONE = 0,
	MULTI_STOP_PREPARE = 1,
	MULTI_STOP_DISABLE_IRQ = 2,
	MULTI_STOP_RUN = 3,
	MULTI_STOP_EXIT = 4,
};

struct multi_stop_data {
	cpu_stop_fn_t fn;
	void *data;
	unsigned int num_threads;
	const struct cpumask *active_cpus;
	enum multi_stop_state state;
	atomic_t thread_ack;
};

typedef int __kernel_mqd_t;

typedef __kernel_mqd_t mqd_t;

enum audit_state {
	AUDIT_DISABLED = 0,
	AUDIT_BUILD_CONTEXT = 1,
	AUDIT_RECORD_CONTEXT = 2,
};

struct audit_cap_data {
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	union {
		unsigned int fE;
		kernel_cap_t effective;
	};
	kernel_cap_t ambient;
	kuid_t rootid;
};

struct audit_names {
	struct list_head list;
	struct filename *name;
	int name_len;
	bool hidden;
	long unsigned int ino;
	dev_t dev;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	u32 osid;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	unsigned char type;
	bool should_free;
};

struct mq_attr {
	__kernel_long_t mq_flags;
	__kernel_long_t mq_maxmsg;
	__kernel_long_t mq_msgsize;
	__kernel_long_t mq_curmsgs;
	__kernel_long_t __reserved[4];
};

struct audit_proctitle {
	int len;
	char *value;
};

struct audit_aux_data;

struct __kernel_sockaddr_storage;

struct audit_tree_refs;

struct audit_context {
	int dummy;
	int in_syscall;
	enum audit_state state;
	enum audit_state current_state;
	unsigned int serial;
	int major;
	struct timespec64 ctime;
	long unsigned int argv[4];
	long int return_code;
	u64 prio;
	int return_valid;
	struct audit_names preallocated_names[5];
	int name_count;
	struct list_head names_list;
	char *filterkey;
	struct path pwd;
	struct audit_aux_data *aux;
	struct audit_aux_data *aux_pids;
	struct __kernel_sockaddr_storage *sockaddr;
	size_t sockaddr_len;
	pid_t pid;
	pid_t ppid;
	kuid_t uid;
	kuid_t euid;
	kuid_t suid;
	kuid_t fsuid;
	kgid_t gid;
	kgid_t egid;
	kgid_t sgid;
	kgid_t fsgid;
	long unsigned int personality;
	int arch;
	pid_t target_pid;
	kuid_t target_auid;
	kuid_t target_uid;
	unsigned int target_sessionid;
	u32 target_sid;
	char target_comm[16];
	struct audit_tree_refs *trees;
	struct audit_tree_refs *first_trees;
	struct list_head killed_trees;
	int tree_count;
	int type;
	union {
		struct {
			int nargs;
			long int args[6];
		} socketcall;
		struct {
			kuid_t uid;
			kgid_t gid;
			umode_t mode;
			u32 osid;
			int has_perm;
			uid_t perm_uid;
			gid_t perm_gid;
			umode_t perm_mode;
			long unsigned int qbytes;
		} ipc;
		struct {
			mqd_t mqdes;
			struct mq_attr mqstat;
		} mq_getsetattr;
		struct {
			mqd_t mqdes;
			int sigev_signo;
		} mq_notify;
		struct {
			mqd_t mqdes;
			size_t msg_len;
			unsigned int msg_prio;
			struct timespec64 abs_timeout;
		} mq_sendrecv;
		struct {
			int oflag;
			umode_t mode;
			struct mq_attr attr;
		} mq_open;
		struct {
			pid_t pid;
			struct audit_cap_data cap;
		} capset;
		struct {
			int fd;
			int flags;
		} mmap;
		struct {
			int argc;
		} execve;
		struct {
			char *name;
		} module;
	};
	int fds[2];
	struct audit_proctitle proctitle;
};

struct __kernel_sockaddr_storage {
	union {
		struct {
			__kernel_sa_family_t ss_family;
			char __data[126];
		};
		void *__align;
	};
};

enum audit_nlgrps {
	AUDIT_NLGRP_NONE = 0,
	AUDIT_NLGRP_READLOG = 1,
	__AUDIT_NLGRP_MAX = 2,
};

struct audit_status {
	__u32 mask;
	__u32 enabled;
	__u32 failure;
	__u32 pid;
	__u32 rate_limit;
	__u32 backlog_limit;
	__u32 lost;
	__u32 backlog;
	union {
		__u32 version;
		__u32 feature_bitmap;
	};
	__u32 backlog_wait_time;
};

struct audit_features {
	__u32 vers;
	__u32 mask;
	__u32 features;
	__u32 lock;
};

struct audit_tty_status {
	__u32 enabled;
	__u32 log_passwd;
};

struct audit_sig_info {
	uid_t uid;
	pid_t pid;
	char ctx[0];
};

enum skb_drop_reason {
	SKB_NOT_DROPPED_YET = 0,
	SKB_DROP_REASON_NOT_SPECIFIED = 1,
	SKB_DROP_REASON_NO_SOCKET = 2,
	SKB_DROP_REASON_PKT_TOO_SMALL = 3,
	SKB_DROP_REASON_TCP_CSUM = 4,
	SKB_DROP_REASON_SOCKET_FILTER = 5,
	SKB_DROP_REASON_UDP_CSUM = 6,
	SKB_DROP_REASON_NETFILTER_DROP = 7,
	SKB_DROP_REASON_OTHERHOST = 8,
	SKB_DROP_REASON_IP_CSUM = 9,
	SKB_DROP_REASON_IP_INHDR = 10,
	SKB_DROP_REASON_IP_RPFILTER = 11,
	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST = 12,
	SKB_DROP_REASON_XFRM_POLICY = 13,
	SKB_DROP_REASON_IP_NOPROTO = 14,
	SKB_DROP_REASON_SOCKET_RCVBUFF = 15,
	SKB_DROP_REASON_PROTO_MEM = 16,
	SKB_DROP_REASON_TCP_MD5NOTFOUND = 17,
	SKB_DROP_REASON_TCP_MD5UNEXPECTED = 18,
	SKB_DROP_REASON_TCP_MD5FAILURE = 19,
	SKB_DROP_REASON_SOCKET_BACKLOG = 20,
	SKB_DROP_REASON_TCP_FLAGS = 21,
	SKB_DROP_REASON_TCP_ZEROWINDOW = 22,
	SKB_DROP_REASON_TCP_OLD_DATA = 23,
	SKB_DROP_REASON_TCP_OVERWINDOW = 24,
	SKB_DROP_REASON_TCP_OFOMERGE = 25,
	SKB_DROP_REASON_TCP_RFC7323_PAWS = 26,
	SKB_DROP_REASON_TCP_INVALID_SEQUENCE = 27,
	SKB_DROP_REASON_TCP_RESET = 28,
	SKB_DROP_REASON_TCP_INVALID_SYN = 29,
	SKB_DROP_REASON_TCP_CLOSE = 30,
	SKB_DROP_REASON_TCP_FASTOPEN = 31,
	SKB_DROP_REASON_TCP_OLD_ACK = 32,
	SKB_DROP_REASON_TCP_TOO_OLD_ACK = 33,
	SKB_DROP_REASON_TCP_ACK_UNSENT_DATA = 34,
	SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE = 35,
	SKB_DROP_REASON_TCP_OFO_DROP = 36,
	SKB_DROP_REASON_IP_OUTNOROUTES = 37,
	SKB_DROP_REASON_BPF_CGROUP_EGRESS = 38,
	SKB_DROP_REASON_IPV6DISABLED = 39,
	SKB_DROP_REASON_NEIGH_CREATEFAIL = 40,
	SKB_DROP_REASON_NEIGH_FAILED = 41,
	SKB_DROP_REASON_NEIGH_QUEUEFULL = 42,
	SKB_DROP_REASON_NEIGH_DEAD = 43,
	SKB_DROP_REASON_TC_EGRESS = 44,
	SKB_DROP_REASON_QDISC_DROP = 45,
	SKB_DROP_REASON_CPU_BACKLOG = 46,
	SKB_DROP_REASON_XDP = 47,
	SKB_DROP_REASON_TC_INGRESS = 48,
	SKB_DROP_REASON_UNHANDLED_PROTO = 49,
	SKB_DROP_REASON_SKB_CSUM = 50,
	SKB_DROP_REASON_SKB_GSO_SEG = 51,
	SKB_DROP_REASON_SKB_UCOPY_FAULT = 52,
	SKB_DROP_REASON_DEV_HDR = 53,
	SKB_DROP_REASON_DEV_READY = 54,
	SKB_DROP_REASON_FULL_RING = 55,
	SKB_DROP_REASON_NOMEM = 56,
	SKB_DROP_REASON_HDR_TRUNC = 57,
	SKB_DROP_REASON_TAP_FILTER = 58,
	SKB_DROP_REASON_TAP_TXFILTER = 59,
	SKB_DROP_REASON_ICMP_CSUM = 60,
	SKB_DROP_REASON_INVALID_PROTO = 61,
	SKB_DROP_REASON_IP_INADDRERRORS = 62,
	SKB_DROP_REASON_IP_INNOROUTES = 63,
	SKB_DROP_REASON_PKT_TOO_BIG = 64,
	SKB_DROP_REASON_SOCKET_DESTROYED = 65,
	SKB_DROP_REASON_TCP_PAWSACTIVEREJECTED = 66,
	SKB_DROP_REASON_TCP_LINGER = 67,
	SKB_DROP_REASON_LISTENOVERFLOWS = 68,
	SKB_DROP_REASON_TCP_REQQFULLDROP = 69,
	SKB_DROP_REASON_TIMEWAIT = 70,
	SKB_DROP_REASON_LSM = 71,
	SKB_DROP_REASON_MAX = 72,
};

struct net_generic {
	union {
		struct {
			unsigned int len;
			struct callback_head rcu;
		} s;
		void *ptr[0];
	};
};

struct pernet_operations {
	struct list_head list;
	int (*init)(struct net *);
	void (*pre_exit)(struct net *);
	void (*exit)(struct net *);
	void (*exit_batch)(struct list_head *);
	unsigned int *id;
	size_t size;
};

struct audit_netlink_list {
	__u32 portid;
	struct net *net;
	struct sk_buff_head q;
};

struct audit_net {
	struct sock *sk;
};

struct auditd_connection {
	struct pid *pid;
	u32 portid;
	struct net *net;
	struct callback_head rcu;
};

struct audit_ctl_mutex {
	struct mutex lock;
	void *owner;
};

struct audit_buffer {
	struct sk_buff *skb;
	struct audit_context *ctx;
	gfp_t gfp_mask;
};

struct audit_reply {
	__u32 portid;
	struct net *net;
	struct sk_buff *skb;
};

enum {
	Audit_equal = 0,
	Audit_not_equal = 1,
	Audit_bitmask = 2,
	Audit_bittest = 3,
	Audit_lt = 4,
	Audit_gt = 5,
	Audit_le = 6,
	Audit_ge = 7,
	Audit_bad = 8,
};

struct audit_rule_data {
	__u32 flags;
	__u32 action;
	__u32 field_count;
	__u32 mask[64];
	__u32 fields[64];
	__u32 values[64];
	__u32 fieldflags[64];
	__u32 buflen;
	char buf[0];
};

struct audit_field;

struct audit_watch;

struct audit_tree;

struct audit_fsnotify_mark;

struct audit_krule {
	u32 pflags;
	u32 flags;
	u32 listnr;
	u32 action;
	u32 mask[64];
	u32 buflen;
	u32 field_count;
	char *filterkey;
	struct audit_field *fields;
	struct audit_field *arch_f;
	struct audit_field *inode_f;
	struct audit_watch *watch;
	struct audit_tree *tree;
	struct audit_fsnotify_mark *exe;
	struct list_head rlist;
	struct list_head list;
	u64 prio;
};

struct audit_field {
	u32 type;
	union {
		u32 val;
		kuid_t uid;
		kgid_t gid;
		struct {
			char *lsm_str;
			void *lsm_rule;
		};
	};
	u32 op;
};

struct audit_entry {
	struct list_head list;
	struct callback_head rcu;
	struct audit_krule rule;
};

struct audit_buffer;

typedef int __kernel_key_t;

typedef __kernel_key_t key_t;

struct cpu_vfs_cap_data {
	__u32 magic_etc;
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	kuid_t rootid;
};

struct kern_ipc_perm {
	spinlock_t lock;
	bool deleted;
	int id;
	key_t key;
	kuid_t uid;
	kgid_t gid;
	kuid_t cuid;
	kgid_t cgid;
	umode_t mode;
	long unsigned int seq;
	void *security;
	struct rhash_head khtnode;
	struct callback_head rcu;
	refcount_t refcount;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct audit_aux_data {
	struct audit_aux_data *next;
	int type;
};

struct audit_chunk;

struct audit_tree_refs {
	struct audit_tree_refs *next;
	struct audit_chunk *c[31];
};

struct audit_aux_data_pids {
	struct audit_aux_data d;
	pid_t target_pid[16];
	kuid_t target_auid[16];
	kuid_t target_uid[16];
	unsigned int target_sessionid[16];
	u32 target_sid[16];
	char target_comm[256];
	int pid_count;
};

struct audit_aux_data_bprm_fcaps {
	struct audit_aux_data d;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	struct audit_cap_data old_pcap;
	struct audit_cap_data new_pcap;
};

struct audit_parent;

struct audit_watch {
	refcount_t count;
	dev_t dev;
	char *path;
	long unsigned int ino;
	struct audit_parent *parent;
	struct list_head wlist;
	struct list_head rules;
};

struct fsnotify_group;

struct fsnotify_iter_info;

struct fsnotify_mark;

struct fsnotify_event;

struct fsnotify_ops {
	int (*handle_event)(struct fsnotify_group *, struct inode *, u32, const void *, int, const struct qstr *, u32, struct fsnotify_iter_info *);
	void (*free_group_priv)(struct fsnotify_group *);
	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
	void (*free_event)(struct fsnotify_event *);
	void (*free_mark)(struct fsnotify_mark *);
};

struct inotify_group_private_data {
	spinlock_t idr_lock;
	struct idr idr;
	struct ucounts *ucounts;
};

struct fanotify_group_private_data {
	struct list_head access_list;
	wait_queue_head_t access_waitq;
	int flags;
	int f_flags;
	unsigned int max_marks;
	struct user_struct *user;
};

struct fsnotify_group {
	const struct fsnotify_ops *ops;
	refcount_t refcnt;
	spinlock_t notification_lock;
	struct list_head notification_list;
	wait_queue_head_t notification_waitq;
	unsigned int q_len;
	unsigned int max_events;
	unsigned int priority;
	bool shutdown;
	struct mutex mark_mutex;
	atomic_t num_marks;
	atomic_t user_waits;
	struct list_head marks_list;
	struct fasync_struct *fsn_fa;
	struct fsnotify_event *overflow_event;
	struct mem_cgroup *memcg;
	union {
		void *private;
		struct inotify_group_private_data inotify_data;
		struct fanotify_group_private_data fanotify_data;
	};
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct fsnotify_iter_info {
	struct fsnotify_mark *marks[3];
	unsigned int report_mask;
	int srcu_idx;
};

struct fsnotify_mark {
	__u32 mask;
	refcount_t refcnt;
	struct fsnotify_group *group;
	struct list_head g_list;
	spinlock_t lock;
	struct hlist_node obj_list;
	struct fsnotify_mark_connector *connector;
	__u32 ignored_mask;
	unsigned int flags;
};

struct fsnotify_event {
	struct list_head list;
	long unsigned int objectid;
};

struct audit_parent {
	struct list_head watches;
	struct fsnotify_mark mark;
};

struct audit_fsnotify_mark {
	dev_t dev;
	long unsigned int ino;
	char *path;
	struct fsnotify_mark mark;
	struct audit_krule *rule;
};

struct audit_chunk;

struct audit_tree {
	refcount_t count;
	int goner;
	struct audit_chunk *root;
	struct list_head chunks;
	struct list_head rules;
	struct list_head list;
	struct list_head same_root;
	struct callback_head head;
	char pathname[0];
};

struct node {
	struct list_head list;
	struct audit_tree *owner;
	unsigned int index;
};

struct audit_chunk {
	struct list_head hash;
	long unsigned int key;
	struct fsnotify_mark *mark;
	struct list_head trees;
	int count;
	atomic_long_t refs;
	struct callback_head head;
	struct node owners[0];
};

struct audit_tree_mark {
	struct fsnotify_mark mark;
	struct audit_chunk *chunk;
};

enum {
	HASH_SIZE = 128,
};

struct kprobe_blacklist_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
};

struct kprobe_insn_page {
	struct list_head list;
	kprobe_opcode_t *insns;
	struct kprobe_insn_cache *cache;
	int nused;
	int ngarbage;
	char slot_used[0];
};

enum kprobe_slot_state {
	SLOT_CLEAN = 0,
	SLOT_DIRTY = 1,
	SLOT_USED = 2,
};

typedef struct perf_event *pto_T_____24;

struct seccomp_notif_sizes {
	__u16 seccomp_notif;
	__u16 seccomp_notif_resp;
	__u16 seccomp_data;
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

struct notification;

struct seccomp_filter {
	refcount_t usage;
	bool log;
	struct seccomp_filter *prev;
	struct bpf_prog *prog;
	struct notification *notif;
	struct mutex notify_lock;
};

struct sock_fprog {
	short unsigned int len;
	struct sock_filter *filter;
};

struct compat_sock_fprog {
	u16 len;
	compat_uptr_t filter;
};

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);

enum notify_state {
	SECCOMP_NOTIFY_INIT = 0,
	SECCOMP_NOTIFY_SENT = 1,
	SECCOMP_NOTIFY_REPLIED = 2,
};

struct seccomp_knotif {
	struct task_struct *task;
	u64 id;
	const struct seccomp_data *data;
	enum notify_state state;
	int error;
	long int val;
	struct completion ready;
	struct list_head list;
};

struct notification {
	struct semaphore request;
	u64 next_id;
	struct list_head notifications;
	wait_queue_head_t wqh;
};

struct seccomp_log_name {
	u32 log;
	const char *name;
};

struct rchan;

struct rchan_buf {
	void *start;
	void *data;
	size_t offset;
	size_t subbufs_produced;
	size_t subbufs_consumed;
	struct rchan *chan;
	wait_queue_head_t read_wait;
	struct irq_work wakeup_work;
	struct dentry *dentry;
	struct kref kref;
	struct page **page_array;
	unsigned int page_count;
	unsigned int finalized;
	size_t *padding;
	size_t prev_padding;
	size_t bytes_consumed;
	size_t early_bytes;
	unsigned int cpu;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
};

struct rchan_callbacks;

struct rchan {
	u32 version;
	size_t subbuf_size;
	size_t n_subbufs;
	size_t alloc_size;
	struct rchan_callbacks *cb;
	struct kref kref;
	void *private_data;
	size_t last_toobig;
	struct rchan_buf **buf;
	int is_global;
	struct list_head list;
	struct dentry *parent;
	int has_base_filename;
	char base_filename[255];
};

struct rchan_callbacks {
	int (*subbuf_start)(struct rchan_buf *, void *, void *, size_t);
	void (*buf_mapped)(struct rchan_buf *, struct file *);
	void (*buf_unmapped)(struct rchan_buf *, struct file *);
	struct dentry * (*create_buf_file)(const char *, struct dentry *, umode_t, struct rchan_buf *, int *);
	int (*remove_buf_file)(struct dentry *);
};

struct partial_page {
	unsigned int offset;
	unsigned int len;
	long unsigned int private;
};

struct splice_pipe_desc {
	struct page **pages;
	struct partial_page *partial;
	int nr_pages;
	unsigned int nr_pages_max;
	const struct pipe_buf_operations *ops;
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

struct rchan_percpu_buf_dispatcher {
	struct rchan_buf *buf;
	struct dentry *dentry;
};

enum {
	TASKSTATS_TYPE_UNSPEC = 0,
	TASKSTATS_TYPE_PID = 1,
	TASKSTATS_TYPE_TGID = 2,
	TASKSTATS_TYPE_STATS = 3,
	TASKSTATS_TYPE_AGGR_PID = 4,
	TASKSTATS_TYPE_AGGR_TGID = 5,
	TASKSTATS_TYPE_NULL = 6,
	__TASKSTATS_TYPE_MAX = 7,
};

enum {
	TASKSTATS_CMD_ATTR_UNSPEC = 0,
	TASKSTATS_CMD_ATTR_PID = 1,
	TASKSTATS_CMD_ATTR_TGID = 2,
	TASKSTATS_CMD_ATTR_REGISTER_CPUMASK = 3,
	TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 4,
	__TASKSTATS_CMD_ATTR_MAX = 5,
};

enum {
	CGROUPSTATS_CMD_UNSPEC = 3,
	CGROUPSTATS_CMD_GET = 4,
	CGROUPSTATS_CMD_NEW = 5,
	__CGROUPSTATS_CMD_MAX = 6,
};

enum {
	CGROUPSTATS_TYPE_UNSPEC = 0,
	CGROUPSTATS_TYPE_CGROUP_STATS = 1,
	__CGROUPSTATS_TYPE_MAX = 2,
};

enum {
	CGROUPSTATS_CMD_ATTR_UNSPEC = 0,
	CGROUPSTATS_CMD_ATTR_FD = 1,
	__CGROUPSTATS_CMD_ATTR_MAX = 2,
};

struct genlmsghdr {
	__u8 cmd;
	__u8 version;
	__u16 reserved;
};

enum {
	NLA_UNSPEC = 0,
	NLA_U8 = 1,
	NLA_U16 = 2,
	NLA_U32 = 3,
	NLA_U64 = 4,
	NLA_STRING = 5,
	NLA_FLAG = 6,
	NLA_MSECS = 7,
	NLA_NESTED = 8,
	NLA_NESTED_ARRAY = 9,
	NLA_NUL_STRING = 10,
	NLA_BINARY = 11,
	NLA_S8 = 12,
	NLA_S16 = 13,
	NLA_S32 = 14,
	NLA_S64 = 15,
	NLA_BITFIELD32 = 16,
	NLA_REJECT = 17,
	NLA_EXACT_LEN = 18,
	NLA_EXACT_LEN_WARN = 19,
	NLA_MIN_LEN = 20,
	__NLA_TYPE_MAX = 21,
};

enum netlink_validation {
	NL_VALIDATE_LIBERAL = 0,
	NL_VALIDATE_TRAILING = 1,
	NL_VALIDATE_MAXTYPE = 2,
	NL_VALIDATE_UNSPEC = 4,
	NL_VALIDATE_STRICT_ATTRS = 8,
	NL_VALIDATE_NESTED = 16,
};

struct genl_multicast_group {
	char name[16];
	u8 flags;
};

struct genl_ops;

struct genl_info;

struct genl_family {
	int id;
	unsigned int hdrsize;
	char name[16];
	unsigned int version;
	unsigned int maxattr;
	bool netnsok;
	bool parallel_ops;
	const struct nla_policy *policy;
	int (*pre_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	void (*post_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	struct nlattr **attrbuf;
	const struct genl_ops *ops;
	const struct genl_multicast_group *mcgrps;
	unsigned int n_ops;
	unsigned int n_mcgrps;
	unsigned int mcgrp_offset;
	struct module *module;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct genl_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*start)(struct netlink_callback *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

struct genl_info {
	u32 snd_seq;
	u32 snd_portid;
	struct nlmsghdr *nlhdr;
	struct genlmsghdr *genlhdr;
	void *userhdr;
	struct nlattr **attrs;
	possible_net_t _net;
	void *user_ptr[2];
	struct netlink_ext_ack *extack;
};

enum genl_validate_flags {
	GENL_DONT_VALIDATE_STRICT = 1,
	GENL_DONT_VALIDATE_DUMP = 2,
	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
};

struct listener {
	struct list_head list;
	pid_t pid;
	char valid;
};

struct listener_list {
	struct rw_semaphore sem;
	struct list_head list;
};

enum actions {
	REGISTER = 0,
	DEREGISTER = 1,
	CPU_DONT_CARE = 2,
};

struct tp_module {
	struct list_head list;
	struct module *mod;
};

struct tp_probes {
	struct callback_head rcu;
	struct tracepoint_func probes[0];
};

struct ftrace_hash {
	long unsigned int size_bits;
	struct hlist_head *buckets;
	long unsigned int count;
	long unsigned int flags;
	struct callback_head rcu;
};

enum ftrace_bug_type {
	FTRACE_BUG_UNKNOWN = 0,
	FTRACE_BUG_INIT = 1,
	FTRACE_BUG_NOP = 2,
	FTRACE_BUG_CALL = 3,
	FTRACE_BUG_UPDATE = 4,
};

enum {
	FTRACE_UPDATE_CALLS = 1,
	FTRACE_DISABLE_CALLS = 2,
	FTRACE_UPDATE_TRACE_FUNC = 4,
	FTRACE_START_FUNC_RET = 8,
	FTRACE_STOP_FUNC_RET = 16,
	FTRACE_MAY_SLEEP = 32,
};

enum {
	FTRACE_ITER_FILTER = 1,
	FTRACE_ITER_NOTRACE = 2,
	FTRACE_ITER_PRINTALL = 4,
	FTRACE_ITER_DO_PROBES = 8,
	FTRACE_ITER_PROBE = 16,
	FTRACE_ITER_MOD = 32,
	FTRACE_ITER_ENABLED = 64,
};

struct ftrace_graph_ent {
	long unsigned int func;
	int depth;
} __attribute__((packed));

struct ftrace_graph_ret {
	long unsigned int func;
	long unsigned int overrun;
	long long unsigned int calltime;
	long long unsigned int rettime;
	int depth;
} __attribute__((packed));

typedef void (*trace_func_graph_ret_t)(struct ftrace_graph_ret *);

typedef int (*trace_func_graph_ent_t)(struct ftrace_graph_ent *);

struct fgraph_ops {
	trace_func_graph_ent_t entryfunc;
	trace_func_graph_ret_t retfunc;
};

struct prog_entry;

struct event_filter {
	struct prog_entry *prog;
	char *filter_string;
};

struct trace_array_cpu;

struct trace_buffer {
	struct trace_array *tr;
	struct ring_buffer *buffer;
	struct trace_array_cpu *data;
	u64 time_start;
	int cpu;
};

struct trace_pid_list;

struct trace_options;

struct cond_snapshot;

struct trace_array {
	struct list_head list;
	char *name;
	struct trace_buffer trace_buffer;
	struct trace_buffer max_buffer;
	bool allocated_snapshot;
	long unsigned int max_latency;
	struct trace_pid_list *filtered_pids;
	arch_spinlock_t max_lock;
	int buffer_disabled;
	int sys_refcount_enter;
	int sys_refcount_exit;
	struct trace_event_file *enter_syscall_files[436];
	struct trace_event_file *exit_syscall_files[436];
	int stop_count;
	int clock_id;
	int nr_topts;
	bool clear_trace;
	int buffer_percent;
	unsigned int n_err_log_entries;
	struct tracer *current_trace;
	unsigned int trace_flags;
	unsigned char trace_flags_index[32];
	unsigned int flags;
	raw_spinlock_t start_lock;
	struct list_head err_log;
	struct dentry *dir;
	struct dentry *options;
	struct dentry *percpu_dir;
	struct dentry *event_dir;
	struct trace_options *topts;
	struct list_head systems;
	struct list_head events;
	struct trace_event_file *trace_marker_file;
	cpumask_var_t tracing_cpumask;
	int ref;
	int trace_ref;
	struct ftrace_ops *ops;
	struct trace_pid_list *function_pids;
	struct list_head func_probes;
	struct list_head mod_trace;
	struct list_head mod_notrace;
	int function_enabled;
	int time_stamp_abs_ref;
	struct list_head hist_vars;
	struct cond_snapshot *cond_snapshot;
};

struct tracer_flags;

struct tracer {
	const char *name;
	int (*init)(struct trace_array *);
	void (*reset)(struct trace_array *);
	void (*start)(struct trace_array *);
	void (*stop)(struct trace_array *);
	int (*update_thresh)(struct trace_array *);
	void (*open)(struct trace_iterator *);
	void (*pipe_open)(struct trace_iterator *);
	void (*close)(struct trace_iterator *);
	void (*pipe_close)(struct trace_iterator *);
	ssize_t (*read)(struct trace_iterator *, struct file *, char *, size_t, loff_t *);
	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*print_header)(struct seq_file *);
	enum print_line_t (*print_line)(struct trace_iterator *);
	int (*set_flag)(struct trace_array *, u32, u32, int);
	int (*flag_changed)(struct trace_array *, u32, int);
	struct tracer *next;
	struct tracer_flags *flags;
	int enabled;
	bool print_max;
	bool allow_instances;
	bool use_max_tr;
	bool noboot;
};

struct event_subsystem;

struct trace_subsystem_dir {
	struct list_head list;
	struct event_subsystem *subsystem;
	struct trace_array *tr;
	struct dentry *entry;
	int ref_count;
	int nr_events;
};

struct trace_array_cpu {
	atomic_t disabled;
	void *buffer_page;
	long unsigned int entries;
	long unsigned int saved_latency;
	long unsigned int critical_start;
	long unsigned int critical_end;
	long unsigned int critical_sequence;
	long unsigned int nice;
	long unsigned int policy;
	long unsigned int rt_priority;
	long unsigned int skipped_entries;
	u64 preempt_timestamp;
	pid_t pid;
	kuid_t uid;
	char comm[16];
	bool ignore_pid;
	bool ftrace_ignore_pid;
};

struct trace_option_dentry;

struct trace_options {
	struct tracer *tracer;
	struct trace_option_dentry *topts;
};

struct tracer_opt;

struct trace_option_dentry {
	struct tracer_opt *opt;
	struct tracer_flags *flags;
	struct trace_array *tr;
	struct dentry *entry;
};

struct trace_pid_list {
	int pid_max;
	long unsigned int *pids;
};

typedef bool (*cond_update_fn_t)(struct trace_array *, void *);

struct cond_snapshot {
	void *cond_data;
	cond_update_fn_t update;
};

enum {
	TRACE_ARRAY_FL_GLOBAL = 1,
};

struct tracer_opt {
	const char *name;
	u32 bit;
};

struct tracer_flags {
	u32 val;
	struct tracer_opt *opts;
	struct tracer *trace;
};

enum {
	TRACE_BUFFER_BIT = 0,
	TRACE_BUFFER_NMI_BIT = 1,
	TRACE_BUFFER_IRQ_BIT = 2,
	TRACE_BUFFER_SIRQ_BIT = 3,
	TRACE_FTRACE_BIT = 4,
	TRACE_FTRACE_NMI_BIT = 5,
	TRACE_FTRACE_IRQ_BIT = 6,
	TRACE_FTRACE_SIRQ_BIT = 7,
	TRACE_INTERNAL_BIT = 8,
	TRACE_INTERNAL_NMI_BIT = 9,
	TRACE_INTERNAL_IRQ_BIT = 10,
	TRACE_INTERNAL_SIRQ_BIT = 11,
	TRACE_BRANCH_BIT = 12,
	TRACE_IRQ_BIT = 13,
	TRACE_GRAPH_BIT = 14,
	TRACE_GRAPH_DEPTH_START_BIT = 15,
	TRACE_GRAPH_DEPTH_END_BIT = 16,
	TRACE_GRAPH_NOTRACE_BIT = 17,
	TRACE_TRANSITION_BIT = 18,
};

struct ftrace_mod_load {
	struct list_head list;
	char *func;
	char *module;
	int enable;
};

enum {
	FTRACE_HASH_FL_MOD = 1,
};

struct ftrace_func_command {
	struct list_head list;
	char *name;
	int (*func)(struct trace_array *, struct ftrace_hash *, char *, char *, char *, int);
};

struct ftrace_probe_ops {
	void (*func)(long unsigned int, long unsigned int, struct trace_array *, struct ftrace_probe_ops *, void *);
	int (*init)(struct ftrace_probe_ops *, struct trace_array *, long unsigned int, void *, void **);
	void (*free)(struct ftrace_probe_ops *, struct trace_array *, long unsigned int, void *);
	int (*print)(struct seq_file *, long unsigned int, struct ftrace_probe_ops *, void *);
};

typedef int (*ftrace_mapper_func)(void *);

struct trace_parser {
	bool cont;
	char *buffer;
	unsigned int idx;
	unsigned int size;
};

enum trace_iterator_bits {
	TRACE_ITER_PRINT_PARENT_BIT = 0,
	TRACE_ITER_SYM_OFFSET_BIT = 1,
	TRACE_ITER_SYM_ADDR_BIT = 2,
	TRACE_ITER_VERBOSE_BIT = 3,
	TRACE_ITER_RAW_BIT = 4,
	TRACE_ITER_HEX_BIT = 5,
	TRACE_ITER_BIN_BIT = 6,
	TRACE_ITER_BLOCK_BIT = 7,
	TRACE_ITER_PRINTK_BIT = 8,
	TRACE_ITER_ANNOTATE_BIT = 9,
	TRACE_ITER_USERSTACKTRACE_BIT = 10,
	TRACE_ITER_SYM_USEROBJ_BIT = 11,
	TRACE_ITER_PRINTK_MSGONLY_BIT = 12,
	TRACE_ITER_CONTEXT_INFO_BIT = 13,
	TRACE_ITER_LATENCY_FMT_BIT = 14,
	TRACE_ITER_RECORD_CMD_BIT = 15,
	TRACE_ITER_RECORD_TGID_BIT = 16,
	TRACE_ITER_OVERWRITE_BIT = 17,
	TRACE_ITER_STOP_ON_FREE_BIT = 18,
	TRACE_ITER_IRQ_INFO_BIT = 19,
	TRACE_ITER_MARKERS_BIT = 20,
	TRACE_ITER_EVENT_FORK_BIT = 21,
	TRACE_ITER_FUNCTION_BIT = 22,
	TRACE_ITER_FUNC_FORK_BIT = 23,
	TRACE_ITER_DISPLAY_GRAPH_BIT = 24,
	TRACE_ITER_STACKTRACE_BIT = 25,
	TRACE_ITER_LAST_BIT = 26,
};

struct event_subsystem {
	struct list_head list;
	const char *name;
	struct event_filter *filter;
	int ref_count;
};

enum regex_type {
	MATCH_FULL = 0,
	MATCH_FRONT_ONLY = 1,
	MATCH_MIDDLE_ONLY = 2,
	MATCH_END_ONLY = 3,
	MATCH_GLOB = 4,
	MATCH_INDEX = 5,
};

struct tracer_stat {
	const char *name;
	void * (*stat_start)(struct tracer_stat *);
	void * (*stat_next)(void *, int);
	int (*stat_cmp)(void *, void *);
	int (*stat_show)(struct seq_file *, void *);
	void (*stat_release)(void *);
	int (*stat_headers)(struct seq_file *);
};

enum {
	FTRACE_MODIFY_ENABLE_FL = 1,
	FTRACE_MODIFY_MAY_SLEEP_FL = 2,
};

struct ftrace_profile {
	struct hlist_node node;
	long unsigned int ip;
	long unsigned int counter;
	long long unsigned int time;
	long long unsigned int time_squared;
};

struct ftrace_profile_page {
	struct ftrace_profile_page *next;
	long unsigned int index;
	struct ftrace_profile records[0];
};

struct ftrace_profile_stat {
	atomic_t disabled;
	struct hlist_head *hash;
	struct ftrace_profile_page *pages;
	struct ftrace_profile_page *start;
	struct tracer_stat stat;
};

struct ftrace_func_entry {
	struct hlist_node hlist;
	long unsigned int ip;
};

struct ftrace_func_probe {
	struct ftrace_probe_ops *probe_ops;
	struct ftrace_ops ops;
	struct trace_array *tr;
	struct list_head list;
	void *data;
	int ref;
};

struct ftrace_page {
	struct ftrace_page *next;
	struct dyn_ftrace *records;
	int index;
	int size;
};

struct ftrace_rec_iter {
	struct ftrace_page *pg;
	int index;
};

struct ftrace_iterator {
	loff_t pos;
	loff_t func_pos;
	loff_t mod_pos;
	struct ftrace_page *pg;
	struct dyn_ftrace *func;
	struct ftrace_func_probe *probe;
	struct ftrace_func_entry *probe_entry;
	struct trace_parser parser;
	struct ftrace_hash *hash;
	struct ftrace_ops *ops;
	struct trace_array *tr;
	struct list_head *mod_list;
	int pidx;
	int idx;
	unsigned int flags;
};

struct ftrace_glob {
	char *search;
	unsigned int len;
	int type;
};

struct ftrace_func_map {
	struct ftrace_func_entry entry;
	void *data;
};

struct ftrace_func_mapper {
	struct ftrace_hash hash;
};

enum graph_filter_type {
	GRAPH_FILTER_NOTRACE = 0,
	GRAPH_FILTER_FUNCTION = 1,
};

struct ftrace_graph_data {
	struct ftrace_hash *hash;
	struct ftrace_func_entry *entry;
	int idx;
	enum graph_filter_type type;
	struct ftrace_hash *new_hash;
	const struct seq_operations *seq_ops;
	struct trace_parser parser;
};

struct ftrace_mod_func {
	struct list_head list;
	char *name;
	long unsigned int ip;
	unsigned int size;
};

struct ftrace_mod_map {
	struct callback_head rcu;
	struct list_head list;
	struct module *mod;
	long unsigned int start_addr;
	long unsigned int end_addr;
	struct list_head funcs;
	unsigned int num_funcs;
};

struct ftrace_init_func {
	struct list_head list;
	long unsigned int ip;
};

enum ring_buffer_type {
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING = 29,
	RINGBUF_TYPE_TIME_EXTEND = 30,
	RINGBUF_TYPE_TIME_STAMP = 31,
};

enum ring_buffer_flags {
	RB_FL_OVERWRITE = 1,
};

struct rb_irq_work {
	struct irq_work work;
	wait_queue_head_t waiters;
	wait_queue_head_t full_waiters;
	bool waiters_pending;
	bool full_waiters_pending;
	bool wakeup_full;
};

struct ring_buffer_per_cpu;

struct ring_buffer {
	unsigned int flags;
	int cpus;
	atomic_t record_disabled;
	atomic_t resize_disabled;
	cpumask_var_t cpumask;
	struct lock_class_key *reader_lock_key;
	struct mutex mutex;
	struct ring_buffer_per_cpu **buffers;
	struct hlist_node node;
	u64 (*clock)();
	struct rb_irq_work irq_work;
	bool time_stamp_abs;
};

struct buffer_page;

struct ring_buffer_iter {
	struct ring_buffer_per_cpu *cpu_buffer;
	long unsigned int head;
	struct buffer_page *head_page;
	struct buffer_page *cache_reader_page;
	long unsigned int cache_read;
	u64 read_stamp;
};

enum {
	RB_LEN_TIME_EXTEND = 8,
	RB_LEN_TIME_STAMP = 8,
};

struct buffer_data_page {
	u64 time_stamp;
	local_t commit;
	unsigned char data[0];
};

struct buffer_page {
	struct list_head list;
	local_t write;
	unsigned int read;
	local_t entries;
	long unsigned int real_end;
	struct buffer_data_page *page;
};

struct rb_event_info {
	u64 ts;
	u64 delta;
	long unsigned int length;
	struct buffer_page *tail_page;
	int add_timestamp;
};

enum {
	RB_CTX_TRANSITION = 0,
	RB_CTX_NMI = 1,
	RB_CTX_IRQ = 2,
	RB_CTX_SOFTIRQ = 3,
	RB_CTX_NORMAL = 4,
	RB_CTX_MAX = 5,
};

struct ring_buffer_per_cpu {
	int cpu;
	atomic_t record_disabled;
	struct ring_buffer *buffer;
	raw_spinlock_t reader_lock;
	arch_spinlock_t lock;
	struct lock_class_key lock_key;
	struct buffer_data_page *free_page;
	long unsigned int nr_pages;
	unsigned int current_context;
	struct list_head *pages;
	struct buffer_page *head_page;
	struct buffer_page *tail_page;
	struct buffer_page *commit_page;
	struct buffer_page *reader_page;
	long unsigned int lost_events;
	long unsigned int last_overrun;
	long unsigned int nest;
	local_t entries_bytes;
	local_t entries;
	local_t overrun;
	local_t commit_overrun;
	local_t dropped_events;
	local_t committing;
	local_t commits;
	local_t pages_touched;
	local_t pages_read;
	long int last_pages_touch;
	size_t shortest_full;
	long unsigned int read;
	long unsigned int read_bytes;
	u64 write_stamp;
	u64 read_stamp;
	long int nr_pages_to_update;
	struct list_head new_pages;
	struct work_struct update_pages_work;
	struct completion update_done;
	struct rb_irq_work irq_work;
};

typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);

struct trace_export {
	struct trace_export *next;
	void (*write)(struct trace_export *, const void *, unsigned int);
};

enum trace_iter_flags {
	TRACE_FILE_LAT_FMT = 1,
	TRACE_FILE_ANNOTATE = 2,
	TRACE_FILE_TIME_IN_NS = 4,
};

enum trace_type {
	__TRACE_FIRST_TYPE = 0,
	TRACE_FN = 1,
	TRACE_CTX = 2,
	TRACE_WAKE = 3,
	TRACE_STACK = 4,
	TRACE_PRINT = 5,
	TRACE_BPRINT = 6,
	TRACE_MMIO_RW = 7,
	TRACE_MMIO_MAP = 8,
	TRACE_BRANCH = 9,
	TRACE_GRAPH_RET = 10,
	TRACE_GRAPH_ENT = 11,
	TRACE_USER_STACK = 12,
	TRACE_BLK = 13,
	TRACE_BPUTS = 14,
	TRACE_HWLAT = 15,
	TRACE_RAW_DATA = 16,
	__TRACE_LAST_TYPE = 17,
};

struct ftrace_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
};

struct stack_entry {
	struct trace_entry ent;
	int size;
	long unsigned int caller[8];
};

struct userstack_entry {
	struct trace_entry ent;
	unsigned int tgid;
	long unsigned int caller[8];
};

struct bprint_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *fmt;
	u32 buf[0];
};

struct print_entry {
	struct trace_entry ent;
	long unsigned int ip;
	char buf[0];
};

struct raw_data_entry {
	struct trace_entry ent;
	unsigned int id;
	char buf[0];
};

struct bputs_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *str;
};

enum trace_flag_type {
	TRACE_FLAG_IRQS_OFF = 1,
	TRACE_FLAG_IRQS_NOSUPPORT = 2,
	TRACE_FLAG_NEED_RESCHED = 4,
	TRACE_FLAG_HARDIRQ = 8,
	TRACE_FLAG_SOFTIRQ = 16,
	TRACE_FLAG_PREEMPT_RESCHED = 32,
	TRACE_FLAG_NMI = 64,
};

enum trace_iterator_flags {
	TRACE_ITER_PRINT_PARENT = 1,
	TRACE_ITER_SYM_OFFSET = 2,
	TRACE_ITER_SYM_ADDR = 4,
	TRACE_ITER_VERBOSE = 8,
	TRACE_ITER_RAW = 16,
	TRACE_ITER_HEX = 32,
	TRACE_ITER_BIN = 64,
	TRACE_ITER_BLOCK = 128,
	TRACE_ITER_PRINTK = 256,
	TRACE_ITER_ANNOTATE = 512,
	TRACE_ITER_USERSTACKTRACE = 1024,
	TRACE_ITER_SYM_USEROBJ = 2048,
	TRACE_ITER_PRINTK_MSGONLY = 4096,
	TRACE_ITER_CONTEXT_INFO = 8192,
	TRACE_ITER_LATENCY_FMT = 16384,
	TRACE_ITER_RECORD_CMD = 32768,
	TRACE_ITER_RECORD_TGID = 65536,
	TRACE_ITER_OVERWRITE = 131072,
	TRACE_ITER_STOP_ON_FREE = 262144,
	TRACE_ITER_IRQ_INFO = 524288,
	TRACE_ITER_MARKERS = 1048576,
	TRACE_ITER_EVENT_FORK = 2097152,
	TRACE_ITER_FUNCTION = 4194304,
	TRACE_ITER_FUNC_FORK = 8388608,
	TRACE_ITER_DISPLAY_GRAPH = 16777216,
	TRACE_ITER_STACKTRACE = 33554432,
};

struct saved_cmdlines_buffer {
	unsigned int map_pid_to_cmdline[32769];
	unsigned int *map_cmdline_to_pid;
	unsigned int cmdline_num;
	int cmdline_idx;
	char *saved_cmdlines;
};

struct ftrace_stack {
	long unsigned int calls[1024];
};

struct ftrace_stacks {
	struct ftrace_stack stacks[4];
};

struct trace_buffer_struct {
	int nesting;
	char buffer[4096];
};

struct ftrace_buffer_info {
	struct trace_iterator iter;
	void *spare;
	unsigned int spare_cpu;
	unsigned int read;
};

struct err_info {
	const char **errs;
	u8 type;
	u8 pos;
	u64 ts;
};

struct tracing_log_err {
	struct list_head list;
	struct err_info info;
	char loc[128];
	char cmd[256];
};

struct buffer_ref {
	struct ring_buffer *buffer;
	void *page;
	int cpu;
	refcount_t refcount;
};

struct ftrace_func_mapper;

struct ctx_switch_entry {
	struct trace_entry ent;
	unsigned int prev_pid;
	unsigned int next_pid;
	unsigned int next_cpu;
	unsigned char prev_prio;
	unsigned char prev_state;
	unsigned char next_prio;
	unsigned char next_state;
};

struct hwlat_entry {
	struct trace_entry ent;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	unsigned int nmi_count;
	unsigned int seqnum;
};

struct trace_mark {
	long long unsigned int val;
	char sym;
};

struct stat_node {
	struct rb_node node;
	void *stat;
};

struct stat_session {
	struct list_head session_list;
	struct tracer_stat *ts;
	struct rb_root stat_root;
	struct mutex stat_mutex;
	struct dentry *file;
};

typedef int (*cmp_stat_t)(void *, void *);

struct trace_bprintk_fmt {
	struct list_head list;
	const char *fmt;
};

enum {
	TRACE_FUNC_OPT_STACK = 1,
};

struct ftrace_func_entry;

enum {
	TRACE_NOP_OPT_ACCEPT = 1,
	TRACE_NOP_OPT_REFUSE = 2,
};

struct ftrace_graph_ent_entry {
	struct trace_entry ent;
	struct ftrace_graph_ent graph_ent;
} __attribute__((packed));

struct ftrace_graph_ret_entry {
	struct trace_entry ent;
	struct ftrace_graph_ret ret;
} __attribute__((packed));

struct fgraph_cpu_data {
	pid_t last_pid;
	int depth;
	int depth_irq;
	int ignore;
	long unsigned int enter_funcs[50];
};

struct fgraph_data {
	struct fgraph_cpu_data *cpu_data;
	struct ftrace_graph_ent_entry ent;
	struct ftrace_graph_ret_entry ret;
	int failed;
	int cpu;
} __attribute__((packed));

enum {
	FLAGS_FILL_FULL = 268435456,
	FLAGS_FILL_START = 536870912,
	FLAGS_FILL_END = 805306368,
};

typedef __u32 blk_mq_req_flags_t;

enum req_opf {
	REQ_OP_READ = 0,
	REQ_OP_WRITE = 1,
	REQ_OP_FLUSH = 2,
	REQ_OP_DISCARD = 3,
	REQ_OP_SECURE_ERASE = 5,
	REQ_OP_ZONE_RESET = 6,
	REQ_OP_WRITE_SAME = 7,
	REQ_OP_ZONE_RESET_ALL = 8,
	REQ_OP_WRITE_ZEROES = 9,
	REQ_OP_SCSI_IN = 32,
	REQ_OP_SCSI_OUT = 33,
	REQ_OP_DRV_IN = 34,
	REQ_OP_DRV_OUT = 35,
	REQ_OP_LAST = 36,
};

enum req_flag_bits {
	__REQ_FAILFAST_DEV = 8,
	__REQ_FAILFAST_TRANSPORT = 9,
	__REQ_FAILFAST_DRIVER = 10,
	__REQ_SYNC = 11,
	__REQ_META = 12,
	__REQ_PRIO = 13,
	__REQ_NOMERGE = 14,
	__REQ_IDLE = 15,
	__REQ_INTEGRITY = 16,
	__REQ_FUA = 17,
	__REQ_PREFLUSH = 18,
	__REQ_RAHEAD = 19,
	__REQ_BACKGROUND = 20,
	__REQ_NOWAIT = 21,
	__REQ_NOWAIT_INLINE = 22,
	__REQ_CGROUP_PUNT = 23,
	__REQ_NOUNMAP = 24,
	__REQ_HIPRI = 25,
	__REQ_DRV = 26,
	__REQ_SWAP = 27,
	__REQ_NR_BITS = 28,
};

struct blk_mq_ctxs;

struct blk_mq_ctx {
	struct {
		spinlock_t lock;
		struct list_head rq_lists[3];
		long: 64;
	};
	unsigned int cpu;
	short unsigned int index_hw[3];
	struct blk_mq_hw_ctx *hctxs[3];
	long unsigned int rq_dispatched[2];
	long unsigned int rq_merged;
	long unsigned int rq_completed[2];
	struct request_queue *queue;
	struct blk_mq_ctxs *ctxs;
	struct kobject kobj;
	long: 64;
	long: 64;
};

struct sbitmap_word;

struct sbitmap {
	unsigned int depth;
	unsigned int shift;
	unsigned int map_nr;
	struct sbitmap_word *map;
};

struct blk_mq_tags;

struct blk_mq_hw_ctx {
	struct {
		spinlock_t lock;
		struct list_head dispatch;
		long unsigned int state;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct delayed_work run_work;
	cpumask_var_t cpumask;
	int next_cpu;
	int next_cpu_batch;
	long unsigned int flags;
	void *sched_data;
	struct request_queue *queue;
	struct blk_flush_queue *fq;
	void *driver_data;
	struct sbitmap ctx_map;
	struct blk_mq_ctx *dispatch_from;
	unsigned int dispatch_busy;
	short unsigned int type;
	short unsigned int nr_ctx;
	struct blk_mq_ctx **ctxs;
	spinlock_t dispatch_wait_lock;
	wait_queue_entry_t dispatch_wait;
	atomic_t wait_index;
	struct blk_mq_tags *tags;
	struct blk_mq_tags *sched_tags;
	long unsigned int queued;
	long unsigned int run;
	long unsigned int dispatched[7];
	unsigned int numa_node;
	unsigned int queue_num;
	atomic_t nr_active;
	struct hlist_node cpuhp_dead;
	struct kobject kobj;
	long unsigned int poll_considered;
	long unsigned int poll_invoked;
	long unsigned int poll_success;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct list_head hctx_list;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	struct srcu_struct srcu[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blk_mq_alloc_data {
	struct request_queue *q;
	blk_mq_req_flags_t flags;
	unsigned int shallow_depth;
	unsigned int cmd_flags;
	struct blk_mq_ctx *ctx;
	struct blk_mq_hw_ctx *hctx;
};

struct blk_stat_callback {
	struct list_head list;
	struct timer_list timer;
	struct blk_rq_stat *cpu_stat;
	int (*bucket_fn)(const struct request *);
	unsigned int buckets;
	struct blk_rq_stat *stat;
	void (*timer_fn)(struct blk_stat_callback *);
	void *data;
	struct callback_head rcu;
};

struct blk_trace {
	int trace_state;
	struct rchan *rchan;
	long unsigned int *sequence;
	unsigned char *msg_data;
	u16 act_mask;
	u64 start_lba;
	u64 end_lba;
	u32 pid;
	u32 dev;
	struct dentry *dir;
	struct dentry *dropped_file;
	struct dentry *msg_file;
	struct list_head running_list;
	atomic_t dropped;
};

struct blk_flush_queue {
	unsigned int flush_queue_delayed: 1;
	unsigned int flush_pending_idx: 1;
	unsigned int flush_running_idx: 1;
	blk_status_t rq_status;
	long unsigned int flush_pending_since;
	struct list_head flush_queue[2];
	struct list_head flush_data_in_flight;
	struct request *flush_rq;
	struct request *orig_rq;
	struct lock_class_key key;
	spinlock_t mq_flush_lock;
};

struct blk_mq_queue_map {
	unsigned int *mq_map;
	unsigned int nr_queues;
	unsigned int queue_offset;
};

struct blk_mq_tag_set {
	struct blk_mq_queue_map map[3];
	unsigned int nr_maps;
	const struct blk_mq_ops *ops;
	unsigned int nr_hw_queues;
	unsigned int queue_depth;
	unsigned int reserved_tags;
	unsigned int cmd_size;
	int numa_node;
	unsigned int timeout;
	unsigned int flags;
	void *driver_data;
	struct blk_mq_tags **tags;
	struct mutex tag_list_lock;
	struct list_head tag_list;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

typedef u64 compat_u64;

enum blktrace_cat {
	BLK_TC_READ = 1,
	BLK_TC_WRITE = 2,
	BLK_TC_FLUSH = 4,
	BLK_TC_SYNC = 8,
	BLK_TC_SYNCIO = 8,
	BLK_TC_QUEUE = 16,
	BLK_TC_REQUEUE = 32,
	BLK_TC_ISSUE = 64,
	BLK_TC_COMPLETE = 128,
	BLK_TC_FS = 256,
	BLK_TC_PC = 512,
	BLK_TC_NOTIFY = 1024,
	BLK_TC_AHEAD = 2048,
	BLK_TC_META = 4096,
	BLK_TC_DISCARD = 8192,
	BLK_TC_DRV_DATA = 16384,
	BLK_TC_FUA = 32768,
	BLK_TC_END = 32768,
};

enum blktrace_act {
	__BLK_TA_QUEUE = 1,
	__BLK_TA_BACKMERGE = 2,
	__BLK_TA_FRONTMERGE = 3,
	__BLK_TA_GETRQ = 4,
	__BLK_TA_SLEEPRQ = 5,
	__BLK_TA_REQUEUE = 6,
	__BLK_TA_ISSUE = 7,
	__BLK_TA_COMPLETE = 8,
	__BLK_TA_PLUG = 9,
	__BLK_TA_UNPLUG_IO = 10,
	__BLK_TA_UNPLUG_TIMER = 11,
	__BLK_TA_INSERT = 12,
	__BLK_TA_SPLIT = 13,
	__BLK_TA_BOUNCE = 14,
	__BLK_TA_REMAP = 15,
	__BLK_TA_ABORT = 16,
	__BLK_TA_DRV_DATA = 17,
	__BLK_TA_CGROUP = 256,
};

enum blktrace_notify {
	__BLK_TN_PROCESS = 0,
	__BLK_TN_TIMESTAMP = 1,
	__BLK_TN_MESSAGE = 2,
	__BLK_TN_CGROUP = 256,
};

struct blk_io_trace {
	__u32 magic;
	__u32 sequence;
	__u64 time;
	__u64 sector;
	__u32 bytes;
	__u32 action;
	__u32 pid;
	__u32 device;
	__u32 cpu;
	__u16 error;
	__u16 pdu_len;
};

struct blk_io_trace_remap {
	__be32 device_from;
	__be32 device_to;
	__be64 sector_from;
};

enum {
	Blktrace_setup = 1,
	Blktrace_running = 2,
	Blktrace_stopped = 3,
};

struct blk_user_trace_setup {
	char name[32];
	__u16 act_mask;
	__u32 buf_size;
	__u32 buf_nr;
	__u64 start_lba;
	__u64 end_lba;
	__u32 pid;
};

struct compat_blk_user_trace_setup {
	char name[32];
	u16 act_mask;
	short: 16;
	u32 buf_size;
	u32 buf_nr;
	compat_u64 start_lba;
	compat_u64 end_lba;
	u32 pid;
} __attribute__((packed));

struct sbitmap_word {
	long unsigned int depth;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int word;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int cleared;
	spinlock_t swap_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbq_wait_state {
	atomic_t wait_cnt;
	wait_queue_head_t wait;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbitmap_queue {
	struct sbitmap sb;
	unsigned int *alloc_hint;
	unsigned int wake_batch;
	atomic_t wake_index;
	struct sbq_wait_state *ws;
	atomic_t ws_active;
	bool round_robin;
	unsigned int min_shallow_depth;
};

struct blk_mq_tags {
	unsigned int nr_tags;
	unsigned int nr_reserved_tags;
	atomic_t active_queues;
	struct sbitmap_queue bitmap_tags;
	struct sbitmap_queue breserved_tags;
	struct request **rqs;
	struct request **static_rqs;
	struct list_head page_list;
};

enum hctx_type {
	HCTX_TYPE_DEFAULT = 0,
	HCTX_TYPE_READ = 1,
	HCTX_TYPE_POLL = 2,
	HCTX_MAX_TYPES = 3,
};

struct blk_mq_queue_data {
	struct request *rq;
	bool last;
	long unsigned int kabi_reserved1;
};

struct blk_mq_ctxs {
	struct kobject kobj;
	struct blk_mq_ctx *queue_ctx;
};

typedef void blk_log_action_t(struct trace_iterator *, const char *, bool);

struct ftrace_event_field {
	struct list_head link;
	const char *name;
	const char *type;
	int filter_type;
	int offset;
	int size;
	int is_signed;
};

enum {
	FORMAT_HEADER = 1,
	FORMAT_FIELD_SEPERATOR = 2,
	FORMAT_PRINTFMT = 3,
};

struct event_probe_data {
	struct trace_event_file *file;
	long unsigned int count;
	int ref;
	bool enable;
};

struct mmiotrace_rw {
	resource_size_t phys;
	long unsigned int value;
	long unsigned int pc;
	int map_id;
	unsigned char opcode;
	unsigned char width;
};

struct mmiotrace_map {
	resource_size_t phys;
	long unsigned int virt;
	long unsigned int len;
	int map_id;
	unsigned char opcode;
};

struct trace_mmiotrace_rw {
	struct trace_entry ent;
	struct mmiotrace_rw rw;
};

struct trace_mmiotrace_map {
	struct trace_entry ent;
	struct mmiotrace_map map;
};

struct trace_branch {
	struct trace_entry ent;
	unsigned int line;
	char func[31];
	char file[21];
	char correct;
	char constant;
};

struct syscall_trace_enter {
	struct trace_entry ent;
	int nr;
	long unsigned int args[0];
};

struct syscall_trace_exit {
	struct trace_entry ent;
	int nr;
	long int ret;
};

struct syscall_tp_t {
	long long unsigned int regs;
	long unsigned int syscall_nr;
	long unsigned int ret;
};

struct syscall_tp_t___2 {
	long long unsigned int regs;
	long unsigned int syscall_nr;
	long unsigned int args[6];
};

typedef long unsigned int perf_trace_t[256];

struct filter_pred;

struct prog_entry {
	int target;
	int when_to_branch;
	struct filter_pred *pred;
};

typedef int (*filter_pred_fn_t)(struct filter_pred *, void *);

struct regex;

typedef int (*regex_match_func)(char *, struct regex *, int);

struct regex {
	char pattern[256];
	int len;
	int field_len;
	regex_match_func match;
};

struct filter_pred {
	filter_pred_fn_t fn;
	u64 val;
	struct regex regex;
	short unsigned int *ops;
	struct ftrace_event_field *field;
	int offset;
	int not;
	int op;
};

enum filter_op_ids {
	OP_GLOB = 0,
	OP_NE = 1,
	OP_EQ = 2,
	OP_LE = 3,
	OP_LT = 4,
	OP_GE = 5,
	OP_GT = 6,
	OP_BAND = 7,
	OP_MAX = 8,
};

enum {
	FILT_ERR_NONE = 0,
	FILT_ERR_INVALID_OP = 1,
	FILT_ERR_TOO_MANY_OPEN = 2,
	FILT_ERR_TOO_MANY_CLOSE = 3,
	FILT_ERR_MISSING_QUOTE = 4,
	FILT_ERR_OPERAND_TOO_LONG = 5,
	FILT_ERR_EXPECT_STRING = 6,
	FILT_ERR_EXPECT_DIGIT = 7,
	FILT_ERR_ILLEGAL_FIELD_OP = 8,
	FILT_ERR_FIELD_NOT_FOUND = 9,
	FILT_ERR_ILLEGAL_INTVAL = 10,
	FILT_ERR_BAD_SUBSYS_FILTER = 11,
	FILT_ERR_TOO_MANY_PREDS = 12,
	FILT_ERR_INVALID_FILTER = 13,
	FILT_ERR_IP_FIELD_ONLY = 14,
	FILT_ERR_INVALID_VALUE = 15,
	FILT_ERR_ERRNO = 16,
	FILT_ERR_NO_FILTER = 17,
};

struct filter_parse_error {
	int lasterr;
	int lasterr_pos;
};

typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);

enum {
	INVERT = 1,
	PROCESS_AND = 2,
	PROCESS_OR = 4,
};

enum {
	TOO_MANY_CLOSE = 4294967295,
	TOO_MANY_OPEN = 4294967294,
	MISSING_QUOTE = 4294967293,
};

struct filter_list {
	struct list_head list;
	struct event_filter *filter;
};

struct function_filter_data {
	struct ftrace_ops *ops;
	int first_filter;
	int first_notrace;
};

struct event_trigger_ops;

struct event_command;

struct event_trigger_data {
	long unsigned int count;
	int ref;
	struct event_trigger_ops *ops;
	struct event_command *cmd_ops;
	struct event_filter *filter;
	char *filter_str;
	void *private_data;
	bool paused;
	bool paused_tmp;
	struct list_head list;
	char *name;
	struct list_head named_list;
	struct event_trigger_data *named_data;
};

struct event_trigger_ops {
	void (*func)(struct event_trigger_data *, void *, struct ring_buffer_event *);
	int (*init)(struct event_trigger_ops *, struct event_trigger_data *);
	void (*free)(struct event_trigger_ops *, struct event_trigger_data *);
	int (*print)(struct seq_file *, struct event_trigger_ops *, struct event_trigger_data *);
};

struct event_command {
	struct list_head list;
	char *name;
	enum event_trigger_type trigger_type;
	int flags;
	int (*func)(struct event_command *, struct trace_event_file *, char *, char *, char *);
	int (*reg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg_all)(struct trace_event_file *);
	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
};

struct enable_trigger_data {
	struct trace_event_file *file;
	bool enable;
	bool hist;
};

enum event_command_flags {
	EVENT_CMD_FL_POST_TRIGGER = 1,
	EVENT_CMD_FL_NEEDS_REC = 2,
};

enum bpf_func_id {
	BPF_FUNC_unspec = 0,
	BPF_FUNC_map_lookup_elem = 1,
	BPF_FUNC_map_update_elem = 2,
	BPF_FUNC_map_delete_elem = 3,
	BPF_FUNC_probe_read = 4,
	BPF_FUNC_ktime_get_ns = 5,
	BPF_FUNC_trace_printk = 6,
	BPF_FUNC_get_prandom_u32 = 7,
	BPF_FUNC_get_smp_processor_id = 8,
	BPF_FUNC_skb_store_bytes = 9,
	BPF_FUNC_l3_csum_replace = 10,
	BPF_FUNC_l4_csum_replace = 11,
	BPF_FUNC_tail_call = 12,
	BPF_FUNC_clone_redirect = 13,
	BPF_FUNC_get_current_pid_tgid = 14,
	BPF_FUNC_get_current_uid_gid = 15,
	BPF_FUNC_get_current_comm = 16,
	BPF_FUNC_get_cgroup_classid = 17,
	BPF_FUNC_skb_vlan_push = 18,
	BPF_FUNC_skb_vlan_pop = 19,
	BPF_FUNC_skb_get_tunnel_key = 20,
	BPF_FUNC_skb_set_tunnel_key = 21,
	BPF_FUNC_perf_event_read = 22,
	BPF_FUNC_redirect = 23,
	BPF_FUNC_get_route_realm = 24,
	BPF_FUNC_perf_event_output = 25,
	BPF_FUNC_skb_load_bytes = 26,
	BPF_FUNC_get_stackid = 27,
	BPF_FUNC_csum_diff = 28,
	BPF_FUNC_skb_get_tunnel_opt = 29,
	BPF_FUNC_skb_set_tunnel_opt = 30,
	BPF_FUNC_skb_change_proto = 31,
	BPF_FUNC_skb_change_type = 32,
	BPF_FUNC_skb_under_cgroup = 33,
	BPF_FUNC_get_hash_recalc = 34,
	BPF_FUNC_get_current_task = 35,
	BPF_FUNC_probe_write_user = 36,
	BPF_FUNC_current_task_under_cgroup = 37,
	BPF_FUNC_skb_change_tail = 38,
	BPF_FUNC_skb_pull_data = 39,
	BPF_FUNC_csum_update = 40,
	BPF_FUNC_set_hash_invalid = 41,
	BPF_FUNC_get_numa_node_id = 42,
	BPF_FUNC_skb_change_head = 43,
	BPF_FUNC_xdp_adjust_head = 44,
	BPF_FUNC_probe_read_str = 45,
	BPF_FUNC_get_socket_cookie = 46,
	BPF_FUNC_get_socket_uid = 47,
	BPF_FUNC_set_hash = 48,
	BPF_FUNC_setsockopt = 49,
	BPF_FUNC_skb_adjust_room = 50,
	BPF_FUNC_redirect_map = 51,
	BPF_FUNC_sk_redirect_map = 52,
	BPF_FUNC_sock_map_update = 53,
	BPF_FUNC_xdp_adjust_meta = 54,
	BPF_FUNC_perf_event_read_value = 55,
	BPF_FUNC_perf_prog_read_value = 56,
	BPF_FUNC_getsockopt = 57,
	BPF_FUNC_override_return = 58,
	BPF_FUNC_sock_ops_cb_flags_set = 59,
	BPF_FUNC_msg_redirect_map = 60,
	BPF_FUNC_msg_apply_bytes = 61,
	BPF_FUNC_msg_cork_bytes = 62,
	BPF_FUNC_msg_pull_data = 63,
	BPF_FUNC_bind = 64,
	BPF_FUNC_xdp_adjust_tail = 65,
	BPF_FUNC_skb_get_xfrm_state = 66,
	BPF_FUNC_get_stack = 67,
	BPF_FUNC_skb_load_bytes_relative = 68,
	BPF_FUNC_fib_lookup = 69,
	BPF_FUNC_sock_hash_update = 70,
	BPF_FUNC_msg_redirect_hash = 71,
	BPF_FUNC_sk_redirect_hash = 72,
	BPF_FUNC_lwt_push_encap = 73,
	BPF_FUNC_lwt_seg6_store_bytes = 74,
	BPF_FUNC_lwt_seg6_adjust_srh = 75,
	BPF_FUNC_lwt_seg6_action = 76,
	BPF_FUNC_rc_repeat = 77,
	BPF_FUNC_rc_keydown = 78,
	BPF_FUNC_skb_cgroup_id = 79,
	BPF_FUNC_get_current_cgroup_id = 80,
	BPF_FUNC_get_local_storage = 81,
	BPF_FUNC_sk_select_reuseport = 82,
	BPF_FUNC_skb_ancestor_cgroup_id = 83,
	BPF_FUNC_sk_lookup_tcp = 84,
	BPF_FUNC_sk_lookup_udp = 85,
	BPF_FUNC_sk_release = 86,
	BPF_FUNC_map_push_elem = 87,
	BPF_FUNC_map_pop_elem = 88,
	BPF_FUNC_map_peek_elem = 89,
	BPF_FUNC_msg_push_data = 90,
	BPF_FUNC_msg_pop_data = 91,
	BPF_FUNC_rc_pointer_rel = 92,
	BPF_FUNC_spin_lock = 93,
	BPF_FUNC_spin_unlock = 94,
	BPF_FUNC_sk_fullsock = 95,
	BPF_FUNC_tcp_sock = 96,
	BPF_FUNC_skb_ecn_set_ce = 97,
	BPF_FUNC_get_listener_sock = 98,
	BPF_FUNC_skc_lookup_tcp = 99,
	BPF_FUNC_tcp_check_syncookie = 100,
	BPF_FUNC_sysctl_get_name = 101,
	BPF_FUNC_sysctl_get_current_value = 102,
	BPF_FUNC_sysctl_get_new_value = 103,
	BPF_FUNC_sysctl_set_new_value = 104,
	BPF_FUNC_strtol = 105,
	BPF_FUNC_strtoul = 106,
	BPF_FUNC_sk_storage_get = 107,
	BPF_FUNC_sk_storage_delete = 108,
	BPF_FUNC_send_signal = 109,
	BPF_FUNC_tcp_gen_syncookie = 110,
	BPF_FUNC_skb_output = 111,
	BPF_FUNC_probe_read_user = 112,
	BPF_FUNC_probe_read_kernel = 113,
	BPF_FUNC_probe_read_user_str = 114,
	BPF_FUNC_probe_read_kernel_str = 115,
	BPF_FUNC_tcp_send_ack = 116,
	BPF_FUNC_send_signal_thread = 117,
	BPF_FUNC_jiffies64 = 118,
	BPF_FUNC_read_branch_records = 119,
	BPF_FUNC_get_ns_current_pid_tgid = 120,
	BPF_FUNC_xdp_output = 121,
	BPF_FUNC_get_netns_cookie = 122,
	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
	BPF_FUNC_sk_assign = 124,
	BPF_FUNC_ktime_get_boot_ns = 125,
	BPF_FUNC_seq_printf = 126,
	BPF_FUNC_seq_write = 127,
	BPF_FUNC_sk_cgroup_id = 128,
	BPF_FUNC_sk_ancestor_cgroup_id = 129,
	BPF_FUNC_ringbuf_output = 130,
	BPF_FUNC_ringbuf_reserve = 131,
	BPF_FUNC_ringbuf_submit = 132,
	BPF_FUNC_ringbuf_discard = 133,
	BPF_FUNC_ringbuf_query = 134,
	BPF_FUNC_csum_level = 135,
	BPF_FUNC_skc_to_tcp6_sock = 136,
	BPF_FUNC_skc_to_tcp_sock = 137,
	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
	BPF_FUNC_skc_to_tcp_request_sock = 139,
	BPF_FUNC_skc_to_udp6_sock = 140,
	BPF_FUNC_get_task_stack = 141,
	BPF_FUNC_load_hdr_opt = 142,
	BPF_FUNC_store_hdr_opt = 143,
	BPF_FUNC_reserve_hdr_opt = 144,
	BPF_FUNC_inode_storage_get = 145,
	BPF_FUNC_inode_storage_delete = 146,
	BPF_FUNC_d_path = 147,
	BPF_FUNC_copy_from_user = 148,
	BPF_FUNC_snprintf_btf = 149,
	BPF_FUNC_seq_printf_btf = 150,
	BPF_FUNC_skb_cgroup_classid = 151,
	BPF_FUNC_redirect_neigh = 152,
	BPF_FUNC_per_cpu_ptr = 153,
	BPF_FUNC_this_cpu_ptr = 154,
	BPF_FUNC_redirect_peer = 155,
	BPF_FUNC_task_storage_get = 156,
	BPF_FUNC_task_storage_delete = 157,
	BPF_FUNC_get_current_task_btf = 158,
	BPF_FUNC_bprm_opts_set = 159,
	BPF_FUNC_ktime_get_coarse_ns = 160,
	BPF_FUNC_ima_inode_hash = 161,
	BPF_FUNC_sock_from_file = 162,
	BPF_FUNC_check_mtu = 163,
	BPF_FUNC_for_each_map_elem = 164,
	BPF_FUNC_snprintf = 165,
	BPF_FUNC_sys_bpf = 166,
	BPF_FUNC_btf_find_by_name_kind = 167,
	BPF_FUNC_sys_close = 168,
	BPF_FUNC_timer_init = 169,
	BPF_FUNC_timer_set_callback = 170,
	BPF_FUNC_timer_start = 171,
	BPF_FUNC_timer_cancel = 172,
	__BPF_FUNC_MAX_ID = 173,
};

enum {
	BPF_F_INDEX_MASK = 4294967295,
	BPF_F_CURRENT_CPU = 4294967295,
	BPF_F_CTXLEN_MASK = 0,
};

struct bpf_perf_event_value {
	__u64 counter;
	__u64 enabled;
	__u64 running;
};

struct bpf_raw_tracepoint_args {
	__u64 args[0];
};

enum bpf_task_fd_type {
	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
	BPF_FD_TYPE_TRACEPOINT = 1,
	BPF_FD_TYPE_KPROBE = 2,
	BPF_FD_TYPE_KRETPROBE = 3,
	BPF_FD_TYPE_UPROBE = 4,
	BPF_FD_TYPE_URETPROBE = 5,
};

enum bpf_arg_type {
	ARG_DONTCARE = 0,
	ARG_CONST_MAP_PTR = 1,
	ARG_PTR_TO_MAP_KEY = 2,
	ARG_PTR_TO_MAP_VALUE = 3,
	ARG_PTR_TO_UNINIT_MAP_VALUE = 4,
	ARG_PTR_TO_MAP_VALUE_OR_NULL = 5,
	ARG_PTR_TO_MEM = 6,
	ARG_PTR_TO_MEM_OR_NULL = 7,
	ARG_PTR_TO_UNINIT_MEM = 8,
	ARG_CONST_SIZE = 9,
	ARG_CONST_SIZE_OR_ZERO = 10,
	ARG_PTR_TO_CTX = 11,
	ARG_PTR_TO_CTX_OR_NULL = 12,
	ARG_ANYTHING = 13,
	ARG_PTR_TO_SPIN_LOCK = 14,
	ARG_PTR_TO_SOCK_COMMON = 15,
	ARG_PTR_TO_INT = 16,
	ARG_PTR_TO_LONG = 17,
	ARG_PTR_TO_SOCKET = 18,
	ARG_PTR_TO_SOCKET_OR_NULL = 19,
	ARG_PTR_TO_BTF_ID = 20,
	ARG_PTR_TO_ALLOC_MEM = 21,
	ARG_PTR_TO_ALLOC_MEM_OR_NULL = 22,
	ARG_CONST_ALLOC_SIZE_OR_ZERO = 23,
	ARG_PTR_TO_FUNC = 24,
	ARG_PTR_TO_STACK_OR_NULL = 25,
	ARG_PTR_TO_TIMER = 26,
	__BPF_ARG_TYPE_MAX = 27,
};

enum bpf_return_type {
	RET_INTEGER = 0,
	RET_VOID = 1,
	RET_PTR_TO_MAP_VALUE = 2,
	RET_PTR_TO_MAP_VALUE_OR_NULL = 3,
	RET_PTR_TO_SOCKET_OR_NULL = 4,
	RET_PTR_TO_TCP_SOCK_OR_NULL = 5,
	RET_PTR_TO_SOCK_COMMON_OR_NULL = 6,
	RET_PTR_TO_ALLOC_MEM_OR_NULL = 7,
	RET_PTR_TO_BTF_ID_OR_NULL = 8,
};

struct bpf_func_proto {
	u64 (*func)(u64, u64, u64, u64, u64);
	bool gpl_only;
	bool pkt_access;
	enum bpf_return_type ret_type;
	union {
		struct {
			enum bpf_arg_type arg1_type;
			enum bpf_arg_type arg2_type;
			enum bpf_arg_type arg3_type;
			enum bpf_arg_type arg4_type;
			enum bpf_arg_type arg5_type;
		};
		enum bpf_arg_type arg_type[5];
	};
	int *btf_id;
	bool (*check_btf_id)(u32, u32);
	int *ret_btf_id;
};

enum bpf_access_type {
	BPF_READ = 1,
	BPF_WRITE = 2,
};

struct bpf_verifier_log;

struct bpf_insn_access_aux {
	enum bpf_reg_type reg_type;
	union {
		int ctx_field_size;
		u32 btf_id;
	};
	struct bpf_verifier_log *log;
};

struct bpf_verifier_ops {
	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
	int (*btf_struct_access)(struct bpf_verifier_log *, const struct btf_type *, int, int, enum bpf_access_type, u32 *);
};

struct bpf_event_entry {
	struct perf_event *event;
	struct file *perf_file;
	struct file *map_file;
	struct callback_head rcu;
};

typedef long unsigned int (*bpf_ctx_copy_t)(void *, const void *, long unsigned int, long unsigned int);

typedef struct pt_regs bpf_user_pt_regs_t;

struct bpf_perf_event_data {
	bpf_user_pt_regs_t regs;
	__u64 sample_period;
	__u64 addr;
};

struct perf_event_query_bpf {
	__u32 ids_len;
	__u32 prog_cnt;
	__u32 ids[0];
};

struct bpf_perf_event_data_kern {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event *event;
};

struct bpf_trace_module {
	struct module *module;
	struct list_head list;
};

struct bpf_seq_printf_buf {
	char buf[768];
};

struct bpf_trace_sample_data {
	struct perf_sample_data sds[3];
};

struct bpf_nested_pt_regs {
	struct pt_regs regs[3];
};

struct send_signal_irq_work {
	struct irq_work irq_work;
	struct task_struct *task;
	u32 sig;
};

struct bpf_raw_tp_regs {
	struct pt_regs regs[3];
};

struct kprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int ip;
};

struct kretprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int func;
	long unsigned int ret_ip;
};

struct dyn_event;

struct dyn_event_operations {
	struct list_head list;
	int (*create)(int, const char **);
	int (*show)(struct seq_file *, struct dyn_event *);
	bool (*is_busy)(struct dyn_event *);
	int (*free)(struct dyn_event *);
	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
};

struct dyn_event {
	struct list_head list;
	struct dyn_event_operations *ops;
};

typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);

enum fetch_op {
	FETCH_OP_NOP = 0,
	FETCH_OP_REG = 1,
	FETCH_OP_STACK = 2,
	FETCH_OP_STACKP = 3,
	FETCH_OP_RETVAL = 4,
	FETCH_OP_IMM = 5,
	FETCH_OP_COMM = 6,
	FETCH_OP_ARG = 7,
	FETCH_OP_FOFFS = 8,
	FETCH_OP_DATA = 9,
	FETCH_OP_DEREF = 10,
	FETCH_OP_UDEREF = 11,
	FETCH_OP_ST_RAW = 12,
	FETCH_OP_ST_MEM = 13,
	FETCH_OP_ST_UMEM = 14,
	FETCH_OP_ST_STRING = 15,
	FETCH_OP_ST_USTRING = 16,
	FETCH_OP_MOD_BF = 17,
	FETCH_OP_LP_ARRAY = 18,
	FETCH_OP_END = 19,
	FETCH_NOP_SYMBOL = 20,
};

struct fetch_insn {
	enum fetch_op op;
	union {
		unsigned int param;
		struct {
			unsigned int size;
			int offset;
		};
		struct {
			unsigned char basesize;
			unsigned char lshift;
			unsigned char rshift;
		};
		long unsigned int immediate;
		void *data;
	};
};

struct fetch_type {
	const char *name;
	size_t size;
	int is_signed;
	print_type_func_t print;
	const char *fmt;
	const char *fmttype;
};

struct probe_arg {
	struct fetch_insn *code;
	bool dynamic;
	unsigned int offset;
	unsigned int count;
	const char *name;
	const char *comm;
	char *fmt;
	const struct fetch_type *type;
};

struct trace_uprobe_filter {
	rwlock_t rwlock;
	int nr_systemwide;
	struct list_head perf_events;
};

struct trace_probe_event {
	unsigned int flags;
	struct trace_event_class class;
	struct trace_event_call call;
	struct list_head files;
	struct list_head probes;
	struct trace_uprobe_filter filter[0];
};

struct trace_probe {
	struct list_head list;
	struct trace_probe_event *event;
	ssize_t size;
	unsigned int nr_args;
	struct probe_arg args[0];
};

struct event_file_link {
	struct trace_event_file *file;
	struct list_head list;
};

enum {
	TP_ERR_FILE_NOT_FOUND = 0,
	TP_ERR_NO_REGULAR_FILE = 1,
	TP_ERR_BAD_REFCNT = 2,
	TP_ERR_REFCNT_OPEN_BRACE = 3,
	TP_ERR_BAD_REFCNT_SUFFIX = 4,
	TP_ERR_BAD_UPROBE_OFFS = 5,
	TP_ERR_MAXACT_NO_KPROBE = 6,
	TP_ERR_BAD_MAXACT = 7,
	TP_ERR_MAXACT_TOO_BIG = 8,
	TP_ERR_BAD_PROBE_ADDR = 9,
	TP_ERR_BAD_RETPROBE = 10,
	TP_ERR_NO_GROUP_NAME = 11,
	TP_ERR_GROUP_TOO_LONG = 12,
	TP_ERR_BAD_GROUP_NAME = 13,
	TP_ERR_NO_EVENT_NAME = 14,
	TP_ERR_EVENT_TOO_LONG = 15,
	TP_ERR_BAD_EVENT_NAME = 16,
	TP_ERR_RETVAL_ON_PROBE = 17,
	TP_ERR_BAD_STACK_NUM = 18,
	TP_ERR_BAD_ARG_NUM = 19,
	TP_ERR_BAD_VAR = 20,
	TP_ERR_BAD_REG_NAME = 21,
	TP_ERR_BAD_MEM_ADDR = 22,
	TP_ERR_BAD_IMM = 23,
	TP_ERR_IMMSTR_NO_CLOSE = 24,
	TP_ERR_FILE_ON_KPROBE = 25,
	TP_ERR_BAD_FILE_OFFS = 26,
	TP_ERR_SYM_ON_UPROBE = 27,
	TP_ERR_TOO_MANY_OPS = 28,
	TP_ERR_DEREF_NEED_BRACE = 29,
	TP_ERR_BAD_DEREF_OFFS = 30,
	TP_ERR_DEREF_OPEN_BRACE = 31,
	TP_ERR_COMM_CANT_DEREF = 32,
	TP_ERR_BAD_FETCH_ARG = 33,
	TP_ERR_ARRAY_NO_CLOSE = 34,
	TP_ERR_BAD_ARRAY_SUFFIX = 35,
	TP_ERR_BAD_ARRAY_NUM = 36,
	TP_ERR_ARRAY_TOO_BIG = 37,
	TP_ERR_BAD_TYPE = 38,
	TP_ERR_BAD_STRING = 39,
	TP_ERR_BAD_BITFIELD = 40,
	TP_ERR_ARG_NAME_TOO_LONG = 41,
	TP_ERR_NO_ARG_NAME = 42,
	TP_ERR_BAD_ARG_NAME = 43,
	TP_ERR_USED_ARG_NAME = 44,
	TP_ERR_ARG_TOO_LONG = 45,
	TP_ERR_NO_ARG_BODY = 46,
	TP_ERR_BAD_INSN_BNDRY = 47,
	TP_ERR_FAIL_REG_PROBE = 48,
	TP_ERR_DIFF_PROBE_TYPE = 49,
	TP_ERR_DIFF_ARG_TYPE = 50,
	TP_ERR_SAME_PROBE = 51,
};

struct trace_kprobe {
	struct dyn_event devent;
	struct kretprobe rp;
	long unsigned int *nhit;
	const char *symbol;
	struct trace_probe tp;
};

struct trace_event_raw_cpu {
	struct trace_entry ent;
	u32 state;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_powernv_throttle {
	struct trace_entry ent;
	int chip_id;
	u32 __data_loc_reason;
	int pmax;
	char __data[0];
};

struct trace_event_raw_pstate_sample {
	struct trace_entry ent;
	u32 core_busy;
	u32 scaled_busy;
	u32 from;
	u32 to;
	u64 mperf;
	u64 aperf;
	u64 tsc;
	u32 freq;
	u32 io_boost;
	char __data[0];
};

struct trace_event_raw_cpu_frequency_limits {
	struct trace_entry ent;
	u32 min_freq;
	u32 max_freq;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_start {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_parent;
	u32 __data_loc_pm_ops;
	int event;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_end {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	int error;
	char __data[0];
};

struct trace_event_raw_suspend_resume {
	struct trace_entry ent;
	const char *action;
	int val;
	bool start;
	char __data[0];
};

struct trace_event_raw_wakeup_source {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	char __data[0];
};

struct trace_event_raw_clock {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_power_domain {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_pm_qos_request {
	struct trace_entry ent;
	int pm_qos_class;
	s32 value;
	char __data[0];
};

struct trace_event_raw_pm_qos_update_request_timeout {
	struct trace_entry ent;
	int pm_qos_class;
	s32 value;
	long unsigned int timeout_us;
	char __data[0];
};

struct trace_event_raw_pm_qos_update {
	struct trace_entry ent;
	enum pm_qos_req_action action;
	int prev_value;
	int curr_value;
	char __data[0];
};

struct trace_event_raw_dev_pm_qos_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	enum dev_pm_qos_req_type type;
	s32 new_value;
	char __data[0];
};

struct trace_event_data_offsets_cpu {};

struct trace_event_data_offsets_powernv_throttle {
	u32 reason;
};

struct trace_event_data_offsets_pstate_sample {};

struct trace_event_data_offsets_cpu_frequency_limits {};

struct trace_event_data_offsets_device_pm_callback_start {
	u32 device;
	u32 driver;
	u32 parent;
	u32 pm_ops;
};

struct trace_event_data_offsets_device_pm_callback_end {
	u32 device;
	u32 driver;
};

struct trace_event_data_offsets_suspend_resume {};

struct trace_event_data_offsets_wakeup_source {
	u32 name;
};

struct trace_event_data_offsets_clock {
	u32 name;
};

struct trace_event_data_offsets_power_domain {
	u32 name;
};

struct trace_event_data_offsets_pm_qos_request {};

struct trace_event_data_offsets_pm_qos_update_request_timeout {};

struct trace_event_data_offsets_pm_qos_update {};

struct trace_event_data_offsets_dev_pm_qos_request {
	u32 name;
};

typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);

typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);

typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);

typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);

typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);

typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);

typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);

typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_pm_qos_add_request)(void *, int, s32);

typedef void (*btf_trace_pm_qos_update_request)(void *, int, s32);

typedef void (*btf_trace_pm_qos_remove_request)(void *, int, s32);

typedef void (*btf_trace_pm_qos_update_request_timeout)(void *, int, s32, long unsigned int);

typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

struct trace_event_raw_rpm_internal {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flags;
	int usage_count;
	int disable_depth;
	int runtime_auto;
	int request_pending;
	int irq_safe;
	int child_count;
	char __data[0];
};

struct trace_event_raw_rpm_return_int {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int ip;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_rpm_internal {
	u32 name;
};

struct trace_event_data_offsets_rpm_return_int {
	u32 name;
};

typedef void (*btf_trace_rpm_suspend)(void *, struct device *, int);

typedef void (*btf_trace_rpm_resume)(void *, struct device *, int);

typedef void (*btf_trace_rpm_idle)(void *, struct device *, int);

typedef void (*btf_trace_rpm_return_int)(void *, struct device *, long unsigned int, int);

struct trace_probe_log {
	const char *subsystem;
	const char **argv;
	int argc;
	int index;
};

enum uprobe_filter_ctx {
	UPROBE_FILTER_REGISTER = 0,
	UPROBE_FILTER_UNREGISTER = 1,
	UPROBE_FILTER_MMAP = 2,
};

struct uprobe_consumer {
	int (*handler)(struct uprobe_consumer *, struct pt_regs *);
	int (*ret_handler)(struct uprobe_consumer *, long unsigned int, struct pt_regs *);
	bool (*filter)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);
	struct uprobe_consumer *next;
};

struct uprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int vaddr[0];
};

struct trace_uprobe {
	struct dyn_event devent;
	struct uprobe_consumer consumer;
	struct path path;
	struct inode *inode;
	char *filename;
	long unsigned int offset;
	long unsigned int ref_ctr_offset;
	long unsigned int nhit;
	struct trace_probe tp;
};

struct uprobe_dispatch_data {
	struct trace_uprobe *tu;
	long unsigned int bp_addr;
};

struct uprobe_cpu_buffer {
	struct mutex mutex;
	void *buf;
};

typedef bool (*filter_func_t)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);

struct rnd_state {
	__u32 s1;
	__u32 s2;
	__u32 s3;
	__u32 s4;
};

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

enum xdp_mem_type {
	MEM_TYPE_PAGE_SHARED = 0,
	MEM_TYPE_PAGE_ORDER0 = 1,
	MEM_TYPE_PAGE_POOL = 2,
	MEM_TYPE_ZERO_COPY = 3,
	MEM_TYPE_MAX = 4,
};

struct zero_copy_allocator {
	void (*free)(struct zero_copy_allocator *, long unsigned int);
};

struct bpf_prog_dummy {
	struct bpf_prog prog;
};

struct page_pool;

struct xdp_mem_allocator {
	struct xdp_mem_info mem;
	union {
		void *allocator;
		struct page_pool *page_pool;
		struct zero_copy_allocator *zc_alloc;
	};
	struct rhash_head node;
	struct callback_head rcu;
};

struct trace_event_raw_xdp_exception {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_xdp_bulk_tx {
	struct trace_entry ent;
	int ifindex;
	u32 act;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_redirect_template {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	int err;
	int to_ifindex;
	u32 map_id;
	int map_index;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_kthread {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int sched;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_enqueue {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int to_cpu;
	char __data[0];
};

struct trace_event_raw_xdp_devmap_xmit {
	struct trace_entry ent;
	int map_id;
	u32 act;
	u32 map_index;
	int drops;
	int sent;
	int from_ifindex;
	int to_ifindex;
	int err;
	char __data[0];
};

struct trace_event_raw_mem_disconnect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	char __data[0];
};

struct trace_event_raw_mem_connect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	const struct xdp_rxq_info *rxq;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_mem_return_failed {
	struct trace_entry ent;
	const struct page *page;
	u32 mem_id;
	u32 mem_type;
	char __data[0];
};

struct trace_event_data_offsets_xdp_exception {};

struct trace_event_data_offsets_xdp_bulk_tx {};

struct trace_event_data_offsets_xdp_redirect_template {};

struct trace_event_data_offsets_xdp_cpumap_kthread {};

struct trace_event_data_offsets_xdp_cpumap_enqueue {};

struct trace_event_data_offsets_xdp_devmap_xmit {};

struct trace_event_data_offsets_mem_disconnect {};

struct trace_event_data_offsets_mem_connect {};

struct trace_event_data_offsets_mem_return_failed {};

typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);

typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, int, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, int, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, int, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, int, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct bpf_map *, u32, int, int, const struct net_device *, const struct net_device *, int);

typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);

typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);

typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);

enum bpf_cmd {
	BPF_MAP_CREATE = 0,
	BPF_MAP_LOOKUP_ELEM = 1,
	BPF_MAP_UPDATE_ELEM = 2,
	BPF_MAP_DELETE_ELEM = 3,
	BPF_MAP_GET_NEXT_KEY = 4,
	BPF_PROG_LOAD = 5,
	BPF_OBJ_PIN = 6,
	BPF_OBJ_GET = 7,
	BPF_PROG_ATTACH = 8,
	BPF_PROG_DETACH = 9,
	BPF_PROG_TEST_RUN = 10,
	BPF_PROG_GET_NEXT_ID = 11,
	BPF_MAP_GET_NEXT_ID = 12,
	BPF_PROG_GET_FD_BY_ID = 13,
	BPF_MAP_GET_FD_BY_ID = 14,
	BPF_OBJ_GET_INFO_BY_FD = 15,
	BPF_PROG_QUERY = 16,
	BPF_RAW_TRACEPOINT_OPEN = 17,
	BPF_BTF_LOAD = 18,
	BPF_BTF_GET_FD_BY_ID = 19,
	BPF_TASK_FD_QUERY = 20,
	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
	BPF_MAP_FREEZE = 22,
	BPF_BTF_GET_NEXT_ID = 23,
	BPF_MAP_LOOKUP_BATCH = 24,
	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
	BPF_MAP_UPDATE_BATCH = 26,
	BPF_MAP_DELETE_BATCH = 27,
	BPF_LINK_CREATE = 28,
	BPF_LINK_UPDATE = 29,
	BPF_LINK_GET_FD_BY_ID = 30,
	BPF_LINK_GET_NEXT_ID = 31,
	BPF_ENABLE_STATS = 32,
	BPF_ITER_CREATE = 33,
	BPF_LINK_DETACH = 34,
};

enum {
	BPF_ANY = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST = 2,
	BPF_F_LOCK = 4,
};

enum {
	BPF_F_NO_PREALLOC = 1,
	BPF_F_NO_COMMON_LRU = 2,
	BPF_F_NUMA_NODE = 4,
	BPF_F_RDONLY = 8,
	BPF_F_WRONLY = 16,
	BPF_F_STACK_BUILD_ID = 32,
	BPF_F_ZERO_SEED = 64,
	BPF_F_RDONLY_PROG = 128,
	BPF_F_WRONLY_PROG = 256,
	BPF_F_CLONE = 512,
	BPF_F_MMAPABLE = 1024,
	BPF_F_INNER_MAP = 4096,
};

enum bpf_stats_type {
	BPF_STATS_RUN_TIME = 0,
};

struct bpf_prog_info {
	__u32 type;
	__u32 id;
	__u8 tag[8];
	__u32 jited_prog_len;
	__u32 xlated_prog_len;
	__u64 jited_prog_insns;
	__u64 xlated_prog_insns;
	__u64 load_time;
	__u32 created_by_uid;
	__u32 nr_map_ids;
	__u64 map_ids;
	char name[16];
	__u32 ifindex;
	__u32 gpl_compatible: 1;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 nr_jited_ksyms;
	__u32 nr_jited_func_lens;
	__u64 jited_ksyms;
	__u64 jited_func_lens;
	__u32 btf_id;
	__u32 func_info_rec_size;
	__u64 func_info;
	__u32 nr_func_info;
	__u32 nr_line_info;
	__u64 line_info;
	__u64 jited_line_info;
	__u32 nr_jited_line_info;
	__u32 line_info_rec_size;
	__u32 jited_line_info_rec_size;
	__u32 nr_prog_tags;
	__u64 prog_tags;
	__u64 run_time_ns;
	__u64 run_cnt;
};

struct bpf_map_info {
	__u32 type;
	__u32 id;
	__u32 key_size;
	__u32 value_size;
	__u32 max_entries;
	__u32 map_flags;
	char name[16];
	__u32 ifindex;
	__u32 btf_vmlinux_value_type_id;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 btf_id;
	__u32 btf_key_type_id;
	__u32 btf_value_type_id;
};

struct bpf_btf_info {
	__u64 btf;
	__u32 btf_size;
	__u32 id;
};

struct bpf_spin_lock {
	__u32 val;
};

struct bpf_timer {
	long: 64;
	long: 64;};

struct bpf_link_primer {
	struct bpf_link *link;
	struct file *file;
	int fd;
	u32 id;
};

enum perf_bpf_event_type {
	PERF_BPF_EVENT_UNKNOWN = 0,
	PERF_BPF_EVENT_PROG_LOAD = 1,
	PERF_BPF_EVENT_PROG_UNLOAD = 2,
	PERF_BPF_EVENT_MAX = 3,
};

enum bpf_audit {
	BPF_AUDIT_LOAD = 0,
	BPF_AUDIT_UNLOAD = 1,
	BPF_AUDIT_MAX = 2,
};

struct bpf_tracing_link {
	struct bpf_link link;
	enum bpf_attach_type attach_type;
};

struct bpf_raw_tp_link {
	struct bpf_link link;
	struct bpf_raw_event_map *btp;
};

struct btf_member {
	__u32 name_off;
	__u32 type;
	__u32 offset;
};

enum btf_func_linkage {
	BTF_FUNC_STATIC = 0,
	BTF_FUNC_GLOBAL = 1,
	BTF_FUNC_EXTERN = 2,
};

enum sk_action {
	SK_DROP = 0,
	SK_PASS = 1,
};

struct bpf_verifier_log {
	u32 level;
	char kbuf[1024];
	char *ubuf;
	u32 len_used;
	u32 len_total;
};

struct bpf_subprog_info {
	u32 start;
	u32 linfo_idx;
	u16 stack_depth;
	bool has_tail_call;
	bool is_async_cb;
};

struct bpf_id_pair {
	u32 old;
	u32 cur;
};

struct bpf_verifier_stack_elem;

struct bpf_verifier_state;

struct bpf_verifier_state_list;

struct bpf_insn_aux_data;

struct bpf_verifier_env {
	u32 insn_idx;
	u32 prev_insn_idx;
	struct bpf_prog *prog;
	const struct bpf_verifier_ops *ops;
	struct bpf_verifier_stack_elem *head;
	int stack_size;
	bool strict_alignment;
	bool test_state_freq;
	struct bpf_verifier_state *cur_state;
	struct bpf_verifier_state_list **explored_states;
	struct bpf_verifier_state_list *free_list;
	struct bpf_map *used_maps[64];
	u32 used_map_cnt;
	u32 id_gen;
	bool explore_alu_limits;
	bool allow_ptr_leaks;
	bool allow_ptr_to_map_access;
	bool bpf_capable;
	bool bypass_spec_v1;
	bool bypass_spec_v4;
	bool seen_direct_write;
	struct bpf_insn_aux_data *insn_aux_data;
	const struct bpf_line_info *prev_linfo;
	struct bpf_verifier_log log;
	struct bpf_subprog_info subprog_info[257];
	struct bpf_id_pair idmap_scratch[75];
	struct {
		int *insn_state;
		int *insn_stack;
		int cur_stack;
	} cfg;
	u32 pass_cnt;
	u32 subprog_cnt;
	u32 prev_insn_processed;
	u32 insn_processed;
	u32 prev_jmps_processed;
	u32 jmps_processed;
	u64 verification_time;
	u32 max_states_per_insn;
	u32 total_states;
	u32 peak_states;
	u32 longest_mark_read_walk;
};

struct tnum {
	u64 value;
	u64 mask;
};

enum bpf_reg_liveness {
	REG_LIVE_NONE = 0,
	REG_LIVE_READ32 = 1,
	REG_LIVE_READ64 = 2,
	REG_LIVE_READ = 3,
	REG_LIVE_WRITTEN = 4,
	REG_LIVE_DONE = 8,
};

struct bpf_reg_state {
	enum bpf_reg_type type;
	union {
		u16 range;
		struct {
			struct bpf_map *map_ptr;
			u32 map_uid;
		};
		u32 btf_id;
		u32 mem_size;
		long unsigned int raw;
		u32 subprogno;
	};
	s32 off;
	u32 id;
	u32 ref_obj_id;
	struct tnum var_off;
	s64 smin_value;
	s64 smax_value;
	u64 umin_value;
	u64 umax_value;
	struct bpf_reg_state *parent;
	u32 frameno;
	s32 subreg_def;
	enum bpf_reg_liveness live;
	bool precise;
};

struct bpf_reference_state;

struct bpf_stack_state;

struct bpf_func_state {
	struct bpf_reg_state regs[11];
	int callsite;
	u32 frameno;
	u32 subprogno;
	u32 async_entry_cnt;
	bool in_callback_fn;
	bool in_async_callback_fn;
	int acquired_refs;
	struct bpf_reference_state *refs;
	int allocated_stack;
	struct bpf_stack_state *stack;
};

struct bpf_struct_ops {
	const struct bpf_verifier_ops *verifier_ops;
	int (*init)(struct btf *);
	int (*check_member)(const struct btf_type *, const struct btf_member *);
	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
	int (*reg)(void *);
	void (*unreg)(void *);
	const struct btf_type *type;
	const struct btf_type *value_type;
	const char *name;
	struct btf_func_model func_models[64];
	u32 type_id;
	u32 value_id;
};

typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);

enum bpf_stack_slot_type {
	STACK_INVALID = 0,
	STACK_SPILL = 1,
	STACK_MISC = 2,
	STACK_ZERO = 3,
};

struct bpf_stack_state {
	struct bpf_reg_state spilled_ptr;
	u8 slot_type[8];
};

struct bpf_reference_state {
	int id;
	int insn_idx;
};

struct bpf_idx_pair {
	u32 prev_idx;
	u32 idx;
};

struct bpf_verifier_state {
	struct bpf_func_state *frame[8];
	struct bpf_verifier_state *parent;
	u32 branches;
	u32 insn_idx;
	u32 curframe;
	u32 active_spin_lock;
	bool speculative;
	u32 first_insn_idx;
	u32 last_insn_idx;
	struct bpf_idx_pair *jmp_history;
	u32 jmp_history_cnt;
};

struct bpf_verifier_state_list {
	struct bpf_verifier_state state;
	struct bpf_verifier_state_list *next;
	int miss_cnt;
	int hit_cnt;
};

struct bpf_insn_aux_data {
	union {
		enum bpf_reg_type ptr_type;
		long unsigned int map_ptr_state;
		s32 call_imm;
		u32 alu_limit;
		struct {
			u32 map_index;
			u32 map_off;
		};
		struct {
			enum bpf_reg_type reg_type;
			union {
				u32 btf_id;
				u32 mem_size;
			};
		} btf_var;
	};
	u64 map_key_state;
	int ctx_field_size;
	u32 seen;
	bool sanitize_stack_spill;
	bool zext_dst;
	u8 alu_state;
	unsigned int orig_idx;
	bool prune_point;
};

struct bpf_verifier_stack_elem {
	struct bpf_verifier_state st;
	int insn_idx;
	int prev_insn_idx;
	struct bpf_verifier_stack_elem *next;
};

typedef void (*bpf_insn_print_t)(void *, const char *, ...);

typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);

typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);

struct bpf_insn_cbs {
	bpf_insn_print_t cb_print;
	bpf_insn_revmap_call_t cb_call;
	bpf_insn_print_imm_t cb_imm;
	void *private_data;
};

struct bpf_call_arg_meta {
	struct bpf_map *map_ptr;
	bool raw_mode;
	bool pkt_access;
	int regno;
	int access_size;
	int mem_size;
	u64 msize_max_value;
	int ref_obj_id;
	int map_uid;
	int func_id;
	u32 btf_id;
	u32 subprogno;
};

enum reg_arg_type {
	SRC_OP = 0,
	DST_OP = 1,
	DST_OP_NO_MARK = 2,
};

typedef int (*set_callee_state_fn)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *, int);

enum {
	REASON_BOUNDS = 4294967295,
	REASON_TYPE = 4294967294,
	REASON_PATHS = 4294967293,
	REASON_LIMIT = 4294967292,
	REASON_STACK = 4294967291,
};

struct bpf_sanitize_info {
	struct bpf_insn_aux_data aux;
	bool mask_to_left;
};

enum {
	DISCOVERED = 16,
	EXPLORED = 32,
	FALLTHROUGH = 1,
	BRANCH = 2,
};

enum {
	DONE_EXPLORING = 0,
	KEEP_EXPLORING = 1,
};

struct tree_descr {
	const char *name;
	const struct file_operations *ops;
	int mode;
};

enum bpf_type {
	BPF_TYPE_UNSPEC = 0,
	BPF_TYPE_PROG = 1,
	BPF_TYPE_MAP = 2,
	BPF_TYPE_LINK = 3,
};

struct map_iter {
	void *key;
	bool done;
};

enum {
	OPT_MODE = 0,
};

struct bpf_mount_opts {
	umode_t mode;
};

struct bpf_hrtimer {
	struct hrtimer timer;
	struct bpf_map *map;
	struct bpf_prog *prog;
	void *callback_fn;
	void *value;
};

struct bpf_timer_kern {
	struct bpf_hrtimer *timer;
	struct bpf_spin_lock lock;
};

typedef struct bpf_hrtimer *pto_T_____25;

union bpf_iter_link_info {
	struct {
		__u32 map_fd;
	} map;
};

typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);

struct bpf_iter_reg {
	const char *target;
	bpf_iter_attach_target_t attach_target;
	bpf_iter_detach_target_t detach_target;
	u32 ctx_arg_info_size;
	struct bpf_ctx_arg_aux ctx_arg_info[2];
	const struct bpf_iter_seq_info *seq_info;
};

struct bpf_iter_meta {
	union {
		struct seq_file *seq;
	};
	u64 session_id;
	u64 seq_num;
};

struct bpf_iter_target_info {
	struct list_head list;
	const struct bpf_iter_reg *reg_info;
	u32 btf_id;
};

struct bpf_iter_link {
	struct bpf_link link;
	struct bpf_iter_aux_info aux;
	struct bpf_iter_target_info *tinfo;
};

struct bpf_iter_priv_data {
	struct bpf_iter_target_info *tinfo;
	const struct bpf_iter_seq_info *seq_info;
	struct bpf_prog *prog;
	u64 session_id;
	u64 seq_num;
	bool done_stop;
	long: 56;
	u8 target_private[0];
};

struct bpf_iter_seq_map_info {
	u32 map_id;
};

struct bpf_iter__bpf_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
};

struct bpf_iter_seq_task_common {
	struct pid_namespace *ns;
};

struct bpf_iter_seq_task_info {
	struct bpf_iter_seq_task_common common;
	u32 tid;
};

struct bpf_iter__task {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
};

struct bpf_iter_seq_task_file_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	struct files_struct *files;
	u32 tid;
	u32 fd;
};

struct bpf_iter__task_file {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	u32 fd;
	union {
		struct file *file;
	};
};

struct bpf_iter_seq_prog_info {
	u32 prog_id;
};

struct bpf_iter__bpf_prog {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_prog *prog;
	};
};

struct bpf_iter__bpf_map_elem {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		void *value;
	};
};

struct pcpu_freelist_node;

struct pcpu_freelist_head {
	struct pcpu_freelist_node *first;
	raw_spinlock_t lock;
};

struct pcpu_freelist_node {
	struct pcpu_freelist_node *next;
};

struct pcpu_freelist {
	struct pcpu_freelist_head *freelist;
};

struct bpf_lru_node {
	struct list_head list;
	u16 cpu;
	u8 type;
	u8 ref;
};

struct bpf_lru_list {
	struct list_head lists[3];
	unsigned int counts[2];
	struct list_head *next_inactive_rotation;
	raw_spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_lru_locallist {
	struct list_head lists[2];
	u16 next_steal;
	raw_spinlock_t lock;
};

struct bpf_common_lru {
	struct bpf_lru_list lru_list;
	struct bpf_lru_locallist *local_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);

struct bpf_lru {
	union {
		struct bpf_common_lru common_lru;
		struct bpf_lru_list *percpu_lru;
	};
	del_from_htab_func del_from_htab;
	void *del_arg;
	unsigned int hash_offset;
	unsigned int nr_scans;
	bool percpu;
	long: 56;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bucket {
	struct hlist_nulls_head head;
	raw_spinlock_t lock;
};

struct htab_elem;

struct bpf_htab {
	struct bpf_map map;
	struct bucket *buckets;
	void *elems;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct pcpu_freelist freelist;
		struct bpf_lru lru;
	};
	struct htab_elem **extra_elems;
	atomic_t count;
	u32 n_buckets;
	u32 elem_size;
	u32 hashrnd;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct htab_elem {
	union {
		struct hlist_nulls_node hash_node;
		struct {
			void *padding;
			union {
				struct bpf_htab *htab;
				struct pcpu_freelist_node fnode;
			};
		};
	};
	union {
		struct callback_head rcu;
		struct bpf_lru_node lru_node;
	};
	u32 hash;
	int: 32;
	char key[0];
};

struct bpf_iter_seq_hash_map_info {
	struct bpf_map *map;
	struct bpf_htab *htab;
	void *percpu_value_buf;
	long unsigned int flags;
	u32 bucket_id;
	u32 skip_elems;
};

struct bpf_iter_seq_array_map_info {
	struct bpf_map *map;
	void *percpu_value_buf;
	u32 index;
};

struct prog_poke_elem {
	struct list_head list;
	struct bpf_prog_aux *aux;
};

enum bpf_lru_list_type {
	BPF_LRU_LIST_T_ACTIVE = 0,
	BPF_LRU_LIST_T_INACTIVE = 1,
	BPF_LRU_LIST_T_FREE = 2,
	BPF_LRU_LOCAL_LIST_T_FREE = 3,
	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
};

struct bpf_lpm_trie_key {
	__u32 prefixlen;
	__u8 data[0];
};

struct lpm_trie_node {
	struct callback_head rcu;
	struct lpm_trie_node *child[2];
	u32 prefixlen;
	u32 flags;
	u8 data[0];
};

struct lpm_trie {
	struct bpf_map map;
	struct lpm_trie_node *root;
	size_t n_entries;
	size_t max_prefixlen;
	size_t data_size;
	raw_spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_cgroup_storage_map {
	struct bpf_map map;
	spinlock_t lock;
	struct bpf_prog *prog;
	struct rb_root root;
	struct list_head list;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_queue_stack {
	struct bpf_map map;
	raw_spinlock_t lock;
	u32 head;
	u32 tail;
	u32 size;
	char elements[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	BPF_RB_NO_WAKEUP = 1,
	BPF_RB_FORCE_WAKEUP = 2,
};

enum {
	BPF_RB_AVAIL_DATA = 0,
	BPF_RB_RING_SIZE = 1,
	BPF_RB_CONS_POS = 2,
	BPF_RB_PROD_POS = 3,
};

enum {
	BPF_RINGBUF_BUSY_BIT = 2147483648,
	BPF_RINGBUF_DISCARD_BIT = 1073741824,
	BPF_RINGBUF_HDR_SZ = 8,
};

struct bpf_ringbuf {
	wait_queue_head_t waitq;
	struct irq_work work;
	u64 mask;
	struct page **pages;
	int nr_pages;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t spinlock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int consumer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int producer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_ringbuf_map {
	struct bpf_map map;
	struct bpf_map_memory memory;
	struct bpf_ringbuf *rb;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_ringbuf_hdr {
	u32 len;
	u32 pg_off;
};

struct btf_enum {
	__u32 name_off;
	__s32 val;
};

struct btf_array {
	__u32 type;
	__u32 index_type;
	__u32 nelems;
};

struct btf_param {
	__u32 name_off;
	__u32 type;
};

enum {
	BTF_VAR_STATIC = 0,
	BTF_VAR_GLOBAL_ALLOCATED = 1,
};

struct btf_var {
	__u32 linkage;
};

struct btf_var_secinfo {
	__u32 type;
	__u32 offset;
	__u32 size;
};

struct bpf_flow_keys {
	__u16 nhoff;
	__u16 thoff;
	__u16 addr_proto;
	__u8 is_frag;
	__u8 is_first_frag;
	__u8 is_encap;
	__u8 ip_proto;
	__be16 n_proto;
	__be16 sport;
	__be16 dport;
	union {
		struct {
			__be32 ipv4_src;
			__be32 ipv4_dst;
		};
		struct {
			__u32 ipv6_src[4];
			__u32 ipv6_dst[4];
		};
	};
	__u32 flags;
	__be32 flow_label;
};

struct bpf_sock {
	__u32 bound_dev_if;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 mark;
	__u32 priority;
	__u32 src_ip4;
	__u32 src_ip6[4];
	__u32 src_port;
	__u32 dst_port;
	__u32 dst_ip4;
	__u32 dst_ip6[4];
	__u32 state;
};

struct __sk_buff {
	__u32 len;
	__u32 pkt_type;
	__u32 mark;
	__u32 queue_mapping;
	__u32 protocol;
	__u32 vlan_present;
	__u32 vlan_tci;
	__u32 vlan_proto;
	__u32 priority;
	__u32 ingress_ifindex;
	__u32 ifindex;
	__u32 tc_index;
	__u32 cb[5];
	__u32 hash;
	__u32 tc_classid;
	__u32 data;
	__u32 data_end;
	__u32 napi_id;
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 data_meta;
	union {
		struct bpf_flow_keys *flow_keys;
	};
	__u64 tstamp;
	__u32 wire_len;
	__u32 gso_segs;
	union {
		struct bpf_sock *sk;
	};
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
};

struct sk_msg_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 size;
	union {
		struct bpf_sock *sk;
	};
};

struct sk_reuseport_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 len;
	__u32 eth_protocol;
	__u32 ip_protocol;
	__u32 bind_inany;
	__u32 hash;
};

struct bpf_sock_addr {
	__u32 user_family;
	__u32 user_ip4;
	__u32 user_ip6[4];
	__u32 user_port;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 msg_src_ip4;
	__u32 msg_src_ip6[4];
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_sock_ops {
	__u32 op;
	union {
		__u32 args[4];
		__u32 reply;
		__u32 replylong[4];
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 is_fullsock;
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 bpf_sock_ops_cb_flags;
	__u32 state;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u32 sk_txhash;
	__u64 bytes_received;
	__u64 bytes_acked;
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_cgroup_dev_ctx {
	__u32 access_type;
	__u32 major;
	__u32 minor;
};

struct bpf_sysctl {
	__u32 write;
	__u32 file_pos;
};

struct bpf_sockopt {
	union {
		struct bpf_sock *sk;
	};
	union {
		void *optval;
	};
	union {
		void *optval_end;
	};
	__s32 level;
	__s32 optname;
	__s32 optlen;
	__s32 retval;
};

struct bpf_sk_lookup {
	union {
		struct bpf_sock *sk;
	};
	__u32 family;
	__u32 protocol;
	__u32 remote_ip4;
	__u32 remote_ip6[4];
	__u32 remote_port;
	__u32 local_ip4;
	__u32 local_ip6[4];
	__u32 local_port;
};

struct sk_reuseport_kern {
	struct sk_buff *skb;
	struct sock *sk;
	struct sock *selected_sk;
	void *data_end;
	u32 hash;
	u32 reuseport_id;
	bool bind_inany;
};

struct bpf_flow_dissector {
	struct bpf_flow_keys *flow_keys;
	const struct sk_buff *skb;
	void *data;
	void *data_end;
};

struct inet_listen_hashbucket {
	spinlock_t lock;
	unsigned int count;
	union {
		struct hlist_head head;
		struct hlist_nulls_head nulls_head;
	};
};

struct inet_ehash_bucket;

struct inet_bind_hashbucket;

struct inet_hashinfo {
	struct inet_ehash_bucket *ehash;
	spinlock_t *ehash_locks;
	unsigned int ehash_mask;
	unsigned int ehash_locks_mask;
	struct kmem_cache *bind_bucket_cachep;
	struct inet_bind_hashbucket *bhash;
	unsigned int bhash_size;
	unsigned int lhash2_mask;
	struct inet_listen_hashbucket *lhash2;
	long: 64;
	struct inet_listen_hashbucket listening_hash[4096];
};

struct ip_ra_chain {
	struct ip_ra_chain *next;
	struct sock *sk;
	union {
		void (*destructor)(struct sock *);
		struct sock *saved_sk;
	};
	struct callback_head rcu;
};

struct fib_table {
	struct hlist_node tb_hlist;
	u32 tb_id;
	int tb_num_default;
	struct callback_head rcu;
	long unsigned int *tb_data;
	long unsigned int __data[0];
};

struct inet_peer_base {
	struct rb_root rb_root;
	seqlock_t lock;
	int total;
};

struct tcp_fastopen_context {
	siphash_key_t key[2];
	int num;
	struct callback_head rcu;
};

struct xdp_buff {
	void *data;
	void *data_end;
	void *data_meta;
	void *data_hard_start;
	long unsigned int handle;
	struct xdp_rxq_info *rxq;
};

struct bpf_sock_addr_kern {
	struct sock *sk;
	struct sockaddr *uaddr;
	u64 tmp_reg;
	void *t_ctx;
};

struct bpf_sock_ops_kern {
	struct sock *sk;
	u32 op;
	union {
		u32 args[4];
		u32 reply;
		u32 replylong[4];
	};
	u32 is_fullsock;
	u64 temp;
};

struct bpf_sysctl_kern {
	struct ctl_table_header *head;
	struct ctl_table *table;
	void *cur_val;
	size_t cur_len;
	void *new_val;
	size_t new_len;
	int new_updated;
	int write;
	loff_t *ppos;
	u64 tmp_reg;
};

struct bpf_sockopt_kern {
	struct sock *sk;
	u8 *optval;
	u8 *optval_end;
	s32 level;
	s32 optname;
	s32 optlen;
	s32 retval;
};

struct bpf_sk_lookup_kern {
	u16 family;
	u16 protocol;
	struct {
		__be32 saddr;
		__be32 daddr;
	} v4;
	struct {
		const struct in6_addr *saddr;
		const struct in6_addr *daddr;
	} v6;
	__be16 sport;
	u16 dport;
	struct sock *selected_sk;
	bool no_reuseport;
};

struct sock_reuseport {
	struct callback_head rcu;
	u16 max_socks;
	u16 num_socks;
	unsigned int synq_overflow_ts;
	unsigned int reuseport_id;
	unsigned int bind_inany: 1;
	unsigned int has_conns: 1;
	struct bpf_prog *prog;
	struct sock *socks[0];
};

struct inet_ehash_bucket {
	struct hlist_nulls_head chain;
};

struct inet_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct ack_sample {
	u32 pkts_acked;
	s32 rtt_us;
	u32 in_flight;
};

struct rate_sample {
	u64 prior_mstamp;
	u32 prior_delivered;
	s32 delivered;
	long int interval_us;
	u32 snd_interval_us;
	u32 rcv_interval_us;
	long int rtt_us;
	int losses;
	u32 acked_sacked;
	u32 prior_in_flight;
	bool is_app_limited;
	bool is_retrans;
	bool is_ack_delayed;
};

struct sk_msg_sg {
	u32 start;
	u32 curr;
	u32 end;
	u32 size;
	u32 copybreak;
	bool copy[17];
	struct scatterlist data[19];
};

struct sk_msg {
	struct sk_msg_sg sg;
	void *data;
	void *data_end;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 flags;
	struct sk_buff *skb;
	struct sock *sk_redir;
	struct sock *sk;
	struct list_head list;
};

enum verifier_phase {
	CHECK_META = 0,
	CHECK_TYPE = 1,
};

struct resolve_vertex {
	const struct btf_type *t;
	u32 type_id;
	u16 next_member;
};

enum visit_state {
	NOT_VISITED = 0,
	VISITED = 1,
	RESOLVED = 2,
};

enum resolve_mode {
	RESOLVE_TBD = 0,
	RESOLVE_PTR = 1,
	RESOLVE_STRUCT_OR_ARRAY = 2,
};

struct btf_sec_info {
	u32 off;
	u32 len;
};

struct btf_verifier_env {
	struct btf *btf;
	u8 *visit_states;
	struct resolve_vertex stack[32];
	struct bpf_verifier_log log;
	u32 log_type_id;
	u32 top_stack;
	enum verifier_phase phase;
	enum resolve_mode resolve_mode;
};

struct btf_kind_operations {
	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
	void (*seq_show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct seq_file *);
};

struct bpf_ctx_convert {
	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
	struct xdp_md BPF_PROG_TYPE_XDP_prog;
	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
	struct __sk_buff BPF_PROG_TYPE_CGROUP_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_CGROUP_SKB_kern;
	struct bpf_sock BPF_PROG_TYPE_CGROUP_SOCK_prog;
	struct sock BPF_PROG_TYPE_CGROUP_SOCK_kern;
	struct bpf_sock_addr BPF_PROG_TYPE_CGROUP_SOCK_ADDR_prog;
	struct bpf_sock_addr_kern BPF_PROG_TYPE_CGROUP_SOCK_ADDR_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
	void *BPF_PROG_TYPE_TRACING_prog;
	void *BPF_PROG_TYPE_TRACING_kern;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_prog;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_kern;
	struct bpf_sysctl BPF_PROG_TYPE_CGROUP_SYSCTL_prog;
	struct bpf_sysctl_kern BPF_PROG_TYPE_CGROUP_SYSCTL_kern;
	struct bpf_sockopt BPF_PROG_TYPE_CGROUP_SOCKOPT_prog;
	struct bpf_sockopt_kern BPF_PROG_TYPE_CGROUP_SOCKOPT_kern;
	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
	void *BPF_PROG_TYPE_STRUCT_OPS_prog;
	void *BPF_PROG_TYPE_STRUCT_OPS_kern;
	void *BPF_PROG_TYPE_EXT_prog;
	void *BPF_PROG_TYPE_EXT_kern;
};

enum {
	__ctx_convertBPF_PROG_TYPE_SOCKET_FILTER = 0,
	__ctx_convertBPF_PROG_TYPE_SCHED_CLS = 1,
	__ctx_convertBPF_PROG_TYPE_SCHED_ACT = 2,
	__ctx_convertBPF_PROG_TYPE_XDP = 3,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SKB = 4,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK = 5,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK_ADDR = 6,
	__ctx_convertBPF_PROG_TYPE_LWT_IN = 7,
	__ctx_convertBPF_PROG_TYPE_LWT_OUT = 8,
	__ctx_convertBPF_PROG_TYPE_LWT_XMIT = 9,
	__ctx_convertBPF_PROG_TYPE_LWT_SEG6LOCAL = 10,
	__ctx_convertBPF_PROG_TYPE_SOCK_OPS = 11,
	__ctx_convertBPF_PROG_TYPE_SK_SKB = 12,
	__ctx_convertBPF_PROG_TYPE_SK_MSG = 13,
	__ctx_convertBPF_PROG_TYPE_FLOW_DISSECTOR = 14,
	__ctx_convertBPF_PROG_TYPE_KPROBE = 15,
	__ctx_convertBPF_PROG_TYPE_TRACEPOINT = 16,
	__ctx_convertBPF_PROG_TYPE_PERF_EVENT = 17,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT = 18,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 19,
	__ctx_convertBPF_PROG_TYPE_TRACING = 20,
	__ctx_convertBPF_PROG_TYPE_CGROUP_DEVICE = 21,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SYSCTL = 22,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCKOPT = 23,
	__ctx_convertBPF_PROG_TYPE_SK_REUSEPORT = 24,
	__ctx_convertBPF_PROG_TYPE_SK_LOOKUP = 25,
	__ctx_convertBPF_PROG_TYPE_STRUCT_OPS = 26,
	__ctx_convertBPF_PROG_TYPE_EXT = 27,
};

struct bpf_dispatcher_prog {
	struct bpf_prog *prog;
	refcount_t users;
};

struct bpf_dispatcher {
	struct mutex mutex;
	void *func;
	struct bpf_dispatcher_prog progs[48];
	int num_progs;
	void *image;
	u32 image_off;
};

enum net_device_flags {
	IFF_UP = 1,
	IFF_BROADCAST = 2,
	IFF_DEBUG = 4,
	IFF_LOOPBACK = 8,
	IFF_POINTOPOINT = 16,
	IFF_NOTRAILERS = 32,
	IFF_RUNNING = 64,
	IFF_NOARP = 128,
	IFF_PROMISC = 256,
	IFF_ALLMULTI = 512,
	IFF_MASTER = 1024,
	IFF_SLAVE = 2048,
	IFF_MULTICAST = 4096,
	IFF_PORTSEL = 8192,
	IFF_AUTOMEDIA = 16384,
	IFF_DYNAMIC = 32768,
	IFF_LOWER_UP = 65536,
	IFF_DORMANT = 131072,
	IFF_ECHO = 262144,
};

enum netdev_cmd {
	NETDEV_UP = 1,
	NETDEV_DOWN = 2,
	NETDEV_REBOOT = 3,
	NETDEV_CHANGE = 4,
	NETDEV_REGISTER = 5,
	NETDEV_UNREGISTER = 6,
	NETDEV_CHANGEMTU = 7,
	NETDEV_CHANGEADDR = 8,
	NETDEV_PRE_CHANGEADDR = 9,
	NETDEV_GOING_DOWN = 10,
	NETDEV_CHANGENAME = 11,
	NETDEV_FEAT_CHANGE = 12,
	NETDEV_BONDING_FAILOVER = 13,
	NETDEV_PRE_UP = 14,
	NETDEV_PRE_TYPE_CHANGE = 15,
	NETDEV_POST_TYPE_CHANGE = 16,
	NETDEV_POST_INIT = 17,
	NETDEV_RELEASE = 18,
	NETDEV_NOTIFY_PEERS = 19,
	NETDEV_JOIN = 20,
	NETDEV_CHANGEUPPER = 21,
	NETDEV_RESEND_IGMP = 22,
	NETDEV_PRECHANGEMTU = 23,
	NETDEV_CHANGEINFODATA = 24,
	NETDEV_BONDING_INFO = 25,
	NETDEV_PRECHANGEUPPER = 26,
	NETDEV_CHANGELOWERSTATE = 27,
	NETDEV_UDP_TUNNEL_PUSH_INFO = 28,
	NETDEV_UDP_TUNNEL_DROP_INFO = 29,
	NETDEV_CHANGE_TX_QUEUE_LEN = 30,
	NETDEV_CVLAN_FILTER_PUSH_INFO = 31,
	NETDEV_CVLAN_FILTER_DROP_INFO = 32,
	NETDEV_SVLAN_FILTER_PUSH_INFO = 33,
	NETDEV_SVLAN_FILTER_DROP_INFO = 34,
};

struct netdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct bpf_dtab_netdev;

struct xdp_bulk_queue {
	struct xdp_frame *q[16];
	struct list_head flush_node;
	struct net_device *dev_rx;
	struct bpf_dtab_netdev *obj;
	unsigned int count;
};

struct bpf_dtab;

struct bpf_dtab_netdev {
	struct net_device *dev;
	struct hlist_node index_hlist;
	struct bpf_dtab *dtab;
	struct xdp_bulk_queue *bulkq;
	struct callback_head rcu;
	unsigned int idx;
};

struct bpf_dtab {
	struct bpf_map map;
	struct bpf_dtab_netdev **netdev_map;
	struct list_head *flush_list;
	struct list_head list;
	struct hlist_head *dev_index_head;
	spinlock_t index_lock;
	unsigned int items;
	u32 n_buckets;
	long: 32;
	long: 64;
};

typedef struct bio_vec skb_frag_t;

struct skb_shared_hwtstamps {
	ktime_t hwtstamp;
};

struct skb_shared_info {
	__u8 __unused;
	__u8 meta_len;
	__u8 nr_frags;
	__u8 tx_flags;
	short unsigned int gso_size;
	short unsigned int gso_segs;
	struct sk_buff *frag_list;
	struct skb_shared_hwtstamps hwtstamps;
	unsigned int gso_type;
	u32 tskey;
	atomic_t dataref;
	void *destructor_arg;
	skb_frag_t frags[17];
};

struct ptr_ring {
	int producer;
	spinlock_t producer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int consumer_head;
	int consumer_tail;
	spinlock_t consumer_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int size;
	int batch;
	void **queue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_cpu_map_entry;

struct xdp_bulk_queue___2 {
	void *q[8];
	struct list_head flush_node;
	struct bpf_cpu_map_entry *obj;
	unsigned int count;
};

struct bpf_cpu_map;

struct bpf_cpu_map_entry {
	u32 cpu;
	int map_id;
	u32 qsize;
	struct xdp_bulk_queue___2 *bulkq;
	struct bpf_cpu_map *cmap;
	struct ptr_ring *queue;
	struct task_struct *kthread;
	struct work_struct kthread_stop_wq;
	atomic_t refcnt;
	struct callback_head rcu;
};

struct bpf_cpu_map {
	struct bpf_map map;
	struct bpf_cpu_map_entry **cpu_map;
	struct list_head *flush_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_map_bucket;

struct bpf_local_storage_map {
	struct bpf_map map;
	struct bpf_local_storage_map_bucket *buckets;
	u32 bucket_log;
	u16 elem_size;
	u16 cache_idx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_data;

struct bpf_local_storage {
	struct bpf_local_storage_data *cache[16];
	struct hlist_head list;
	void *owner;
	struct callback_head rcu;
	raw_spinlock_t lock;
};

struct bpf_local_storage_map_bucket {
	struct hlist_head list;
	raw_spinlock_t lock;
};

struct bpf_local_storage_data {
	struct bpf_local_storage_map *smap;
	u8 data[0];
};

struct bpf_local_storage_elem {
	struct hlist_node map_node;
	struct hlist_node snode;
	struct bpf_local_storage *local_storage;
	struct callback_head rcu;
	long: 64;
	struct bpf_local_storage_data sdata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_cache {
	spinlock_t idx_lock;
	u64 idx_usage_counts[16];
};

struct xsk_queue;

struct xdp_umem_page;

struct xdp_umem_fq_reuse;

struct xdp_umem {
	struct xsk_queue *fq;
	struct xsk_queue *cq;
	struct xdp_umem_page *pages;
	u64 chunk_mask;
	u64 size;
	u32 headroom;
	u32 chunk_size_nohr;
	struct user_struct *user;
	long unsigned int address;
	refcount_t users;
	struct work_struct work;
	struct page **pgs;
	u32 npgs;
	u16 queue_id;
	u8 need_wakeup;
	u8 flags;
	int id;
	struct net_device *dev;
	struct xdp_umem_fq_reuse *fq_reuse;
	bool zc;
	spinlock_t xsk_list_lock;
	struct list_head xsk_list;
};

struct xdp_umem_page {
	void *addr;
	dma_addr_t dma;
};

struct xdp_umem_fq_reuse {
	u32 nentries;
	u32 length;
	u64 handles[0];
};

struct xsk_map;

struct xdp_sock;

struct xsk_map_node {
	struct list_head node;
	struct xsk_map *map;
	struct xdp_sock **map_entry;
};

struct xsk_map {
	struct bpf_map map;
	struct list_head *flush_list;
	spinlock_t lock;
	struct xdp_sock *xsk_map[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_sock {
	struct sock sk;
	struct xsk_queue *rx;
	struct net_device *dev;
	struct xdp_umem *umem;
	struct list_head flush_node;
	u16 queue_id;
	bool zc;
	enum {
		XSK_READY = 0,
		XSK_BOUND = 1,
		XSK_UNBOUND = 2,
	} state;
	struct mutex mutex;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xsk_queue *tx;
	struct list_head list;
	spinlock_t tx_completion_lock;
	spinlock_t rx_lock;
	u64 rx_dropped;
	struct list_head map_list;
	spinlock_t map_list_lock;
};

struct rhlist_head {
	struct rhash_head rhead;
	struct rhlist_head *next;
};

struct bpf_prog_offload_ops {
	int (*insn_hook)(struct bpf_verifier_env *, int, int);
	int (*finalize)(struct bpf_verifier_env *);
	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
	int (*prepare)(struct bpf_prog *);
	int (*translate)(struct bpf_prog *);
	void (*destroy)(struct bpf_prog *);
};

struct bpf_offload_dev {
	const struct bpf_prog_offload_ops *ops;
	struct list_head netdevs;
	void *priv;
};

typedef struct ns_common *ns_get_path_helper_t(void *);

struct bpf_offload_netdev {
	struct rhash_head l;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	struct list_head progs;
	struct list_head maps;
	struct list_head offdev_netdevs;
};

struct ns_get_path_bpf_prog_args {
	struct bpf_prog *prog;
	struct bpf_prog_info *info;
};

struct ns_get_path_bpf_map_args {
	struct bpf_offloaded_map *offmap;
	struct bpf_map_info *info;
};

enum bpf_stack_build_id_status {
	BPF_STACK_BUILD_ID_EMPTY = 0,
	BPF_STACK_BUILD_ID_VALID = 1,
	BPF_STACK_BUILD_ID_IP = 2,
};

struct bpf_stack_build_id {
	__s32 status;
	unsigned char build_id[20];
	union {
		__u64 offset;
		__u64 ip;
	};
};

enum {
	BPF_F_SKIP_FIELD_MASK = 255,
	BPF_F_USER_STACK = 256,
	BPF_F_FAST_STACK_CMP = 512,
	BPF_F_REUSE_STACKID = 1024,
	BPF_F_USER_BUILD_ID = 2048,
};

typedef __u32 Elf32_Addr;

typedef __u16 Elf32_Half;

typedef __u32 Elf32_Off;

struct elf32_hdr {
	unsigned char e_ident[16];
	Elf32_Half e_type;
	Elf32_Half e_machine;
	Elf32_Word e_version;
	Elf32_Addr e_entry;
	Elf32_Off e_phoff;
	Elf32_Off e_shoff;
	Elf32_Word e_flags;
	Elf32_Half e_ehsize;
	Elf32_Half e_phentsize;
	Elf32_Half e_phnum;
	Elf32_Half e_shentsize;
	Elf32_Half e_shnum;
	Elf32_Half e_shstrndx;
};

typedef struct elf32_hdr Elf32_Ehdr;

struct elf32_phdr {
	Elf32_Word p_type;
	Elf32_Off p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	Elf32_Word p_filesz;
	Elf32_Word p_memsz;
	Elf32_Word p_flags;
	Elf32_Word p_align;
};

typedef struct elf32_phdr Elf32_Phdr;

typedef struct elf32_note Elf32_Nhdr;

struct stack_map_bucket {
	struct pcpu_freelist_node fnode;
	u32 hash;
	u32 nr;
	u64 data[0];
};

struct bpf_stack_map {
	struct bpf_map map;
	void *elems;
	struct pcpu_freelist freelist;
	u32 n_buckets;
	struct stack_map_bucket *buckets[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct stack_map_irq_work {
	struct irq_work irq_work;
	struct rw_semaphore *sem;
};

enum {
	BPF_F_SYSCTL_BASE_NAME = 1,
};

struct bpf_prog_list {
	struct list_head node;
	struct bpf_prog *prog;
	struct bpf_cgroup_link *link;
	struct bpf_cgroup_storage *storage[2];
};

struct qdisc_skb_cb {
	struct {
		unsigned int pkt_len;
		u16 slave_dev_queue_mapping;
		u16 tc_classid;
	};
	unsigned char data[20];
};

struct bpf_skb_data_end {
	struct qdisc_skb_cb qdisc_cb;
	void *data_meta;
	void *data_end;
};

enum {
	TCPF_ESTABLISHED = 2,
	TCPF_SYN_SENT = 4,
	TCPF_SYN_RECV = 8,
	TCPF_FIN_WAIT1 = 16,
	TCPF_FIN_WAIT2 = 32,
	TCPF_TIME_WAIT = 64,
	TCPF_CLOSE = 128,
	TCPF_CLOSE_WAIT = 256,
	TCPF_LAST_ACK = 512,
	TCPF_LISTEN = 1024,
	TCPF_CLOSING = 2048,
	TCPF_NEW_SYN_RECV = 4096,
};

struct inet_bind_bucket;

struct inet_timewait_sock {
	struct sock_common __tw_common;
	__u32 tw_mark;
	volatile unsigned char tw_substate;
	unsigned char tw_rcv_wscale;
	__be16 tw_sport;
	unsigned int tw_kill: 1;
	unsigned int tw_transparent: 1;
	unsigned int tw_flowlabel: 20;
	unsigned int tw_pad: 2;
	unsigned int tw_tos: 8;
	u32 tw_txhash;
	u32 tw_priority;
	struct timer_list tw_timer;
	struct inet_bind_bucket *tw_tb;
	struct sock_cgroup_data tw_cgrp_data;
};

typedef struct bpf_cgroup_storage *pto_T_____26;

enum sock_type {
	SOCK_STREAM = 1,
	SOCK_DGRAM = 2,
	SOCK_RAW = 3,
	SOCK_RDM = 4,
	SOCK_SEQPACKET = 5,
	SOCK_DCCP = 6,
	SOCK_PACKET = 10,
};

enum {
	IPPROTO_IP = 0,
	IPPROTO_ICMP = 1,
	IPPROTO_IGMP = 2,
	IPPROTO_IPIP = 4,
	IPPROTO_TCP = 6,
	IPPROTO_EGP = 8,
	IPPROTO_PUP = 12,
	IPPROTO_UDP = 17,
	IPPROTO_IDP = 22,
	IPPROTO_TP = 29,
	IPPROTO_DCCP = 33,
	IPPROTO_IPV6 = 41,
	IPPROTO_RSVP = 46,
	IPPROTO_GRE = 47,
	IPPROTO_ESP = 50,
	IPPROTO_AH = 51,
	IPPROTO_MTP = 92,
	IPPROTO_BEETPH = 94,
	IPPROTO_ENCAP = 98,
	IPPROTO_PIM = 103,
	IPPROTO_COMP = 108,
	IPPROTO_SCTP = 132,
	IPPROTO_UDPLITE = 136,
	IPPROTO_MPLS = 137,
	IPPROTO_RAW = 255,
	IPPROTO_MPTCP = 262,
	IPPROTO_MAX = 263,
};

enum sock_flags {
	SOCK_DEAD = 0,
	SOCK_DONE = 1,
	SOCK_URGINLINE = 2,
	SOCK_KEEPOPEN = 3,
	SOCK_LINGER = 4,
	SOCK_DESTROY = 5,
	SOCK_BROADCAST = 6,
	SOCK_TIMESTAMP = 7,
	SOCK_ZAPPED = 8,
	SOCK_USE_WRITE_QUEUE = 9,
	SOCK_DBG = 10,
	SOCK_RCVTSTAMP = 11,
	SOCK_RCVTSTAMPNS = 12,
	SOCK_LOCALROUTE = 13,
	SOCK_QUEUE_SHRUNK = 14,
	SOCK_MEMALLOC = 15,
	SOCK_TIMESTAMPING_RX_SOFTWARE = 16,
	SOCK_FASYNC = 17,
	SOCK_RXQ_OVFL = 18,
	SOCK_ZEROCOPY = 19,
	SOCK_WIFI_STATUS = 20,
	SOCK_NOFCS = 21,
	SOCK_FILTER_LOCKED = 22,
	SOCK_SELECT_ERR_QUEUE = 23,
	SOCK_RCU_FREE = 24,
	SOCK_TXTIME = 25,
	SOCK_XDP = 26,
	SOCK_TSTAMP_NEW = 27,
};

struct reuseport_array {
	struct bpf_map map;
	struct sock *ptrs[0];
};

struct bpf_netns_link {
	struct bpf_link link;
	enum bpf_attach_type type;
	enum netns_bpf_attach_type netns_type;
	struct net *net;
	struct list_head node;
};

enum bpf_struct_ops_state {
	BPF_STRUCT_OPS_STATE_INIT = 0,
	BPF_STRUCT_OPS_STATE_INUSE = 1,
	BPF_STRUCT_OPS_STATE_TOBEFREE = 2,
};

struct bpf_struct_ops_value {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_struct_ops_map {
	struct bpf_map map;
	const struct bpf_struct_ops *st_ops;
	struct mutex lock;
	struct bpf_prog **progs;
	void *image;
	struct bpf_struct_ops_value *uvalue;
	struct bpf_struct_ops_value kvalue;
};

struct bpf_struct_ops_tcp_congestion_ops {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct tcp_congestion_ops data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct super_block___2;

struct file_system_type___2 {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_description *parameters;
	struct dentry___2 * (*mount)(struct file_system_type___2 *, int, const char *, void *);
	void (*kill_sb)(struct super_block___2 *);
	struct module___2 *owner;
	struct file_system_type___2 *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key i_mutex_dir_key;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

struct file___2;

struct kiocb___2;

struct iov_iter___2;

struct poll_table_struct___2;

struct vm_area_struct___2;

struct file_lock___2;

struct page___2;

struct pipe_inode_info___2;

struct seq_file___2;

struct file_operations___2 {
	struct module___2 *owner;
	loff_t (*llseek)(struct file___2 *, loff_t, int);
	ssize_t (*read)(struct file___2 *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file___2 *, const char *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb___2 *, struct iov_iter___2 *);
	ssize_t (*write_iter)(struct kiocb___2 *, struct iov_iter___2 *);
	int (*iopoll)(struct kiocb___2 *, bool);
	int (*iterate)(struct file___2 *, struct dir_context *);
	int (*iterate_shared)(struct file___2 *, struct dir_context *);
	__poll_t (*poll)(struct file___2 *, struct poll_table_struct___2 *);
	long int (*unlocked_ioctl)(struct file___2 *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file___2 *, unsigned int, long unsigned int);
	int (*mmap)(struct file___2 *, struct vm_area_struct___2 *);
	long unsigned int mmap_supported_flags;
	int (*open)(struct inode___2 *, struct file___2 *);
	int (*flush)(struct file___2 *, fl_owner_t);
	int (*release)(struct inode___2 *, struct file___2 *);
	int (*fsync)(struct file___2 *, loff_t, loff_t, int);
	int (*fasync)(int, struct file___2 *, int);
	int (*lock)(struct file___2 *, int, struct file_lock___2 *);
	ssize_t (*sendpage)(struct file___2 *, struct page___2 *, int, size_t, loff_t *, int);
	long unsigned int (*get_unmapped_area)(struct file___2 *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*check_flags)(int);
	int (*flock)(struct file___2 *, int, struct file_lock___2 *);
	ssize_t (*splice_write)(struct pipe_inode_info___2 *, struct file___2 *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file___2 *, loff_t *, struct pipe_inode_info___2 *, size_t, unsigned int);
	int (*setlease)(struct file___2 *, long int, struct file_lock___2 **, void **);
	long int (*fallocate)(struct file___2 *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file___2 *, struct file___2 *);
	ssize_t (*copy_file_range)(struct file___2 *, loff_t, struct file___2 *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file___2 *, loff_t, struct file___2 *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file___2 *, loff_t, loff_t, int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct vmacache___2 {
	u64 seqnum;
	struct vm_area_struct___2 *vmas[4];
};

struct page_frag___2 {
	struct page___2 *page;
	__u32 offset;
	__u32 size;
};

struct perf_event___2;

struct thread_struct___2 {
	struct desc_struct tls_array[3];
	long unsigned int sp;
	short unsigned int es;
	short unsigned int ds;
	short unsigned int fsindex;
	short unsigned int gsindex;
	long unsigned int fsbase;
	long unsigned int gsbase;
	struct perf_event___2 *ptrace_bps[4];
	long unsigned int debugreg6;
	long unsigned int ptrace_dr7;
	long unsigned int cr2;
	long unsigned int trap_nr;
	long unsigned int error_code;
	long unsigned int *io_bitmap_ptr;
	long unsigned int iopl;
	unsigned int io_bitmap_max;
	mm_segment_t addr_limit;
	unsigned int sig_on_uaccess_err: 1;
	unsigned int uaccess_err: 1;
	long: 62;
	long: 64;
	long: 64;
	long: 64;
	struct fpu fpu;
};

struct mm_struct___2;

struct pid___2;

struct cred___2;

struct nsproxy___2;

struct signal_struct___2;

struct css_set___2;

struct perf_event_context___2;

struct vm_struct___2;

struct task_struct___2 {
	struct thread_info thread_info;
	volatile long int state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	struct llist_node wake_entry;
	int on_cpu;
	unsigned int cpu;
	unsigned int wakee_flips;
	long unsigned int wakee_flip_decay_ts;
	struct task_struct___2 *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	const struct sched_class *sched_class;
	struct sched_entity se;
	struct sched_rt_entity rt;
	struct task_group *sched_task_group;
	struct sched_dl_entity dl;
	struct hlist_head preempt_notifiers;
	unsigned int btrace_seq;
	unsigned int policy;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t cpus_mask;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct___2 *mm;
	struct mm_struct___2 *active_mm;
	struct vmacache___2 vmacache;
	struct task_rss_stat rss_stat;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	long unsigned int jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	unsigned int sched_remote_wakeup: 1;
	unsigned int sched_psi_wake_requeue: 1;
	int: 27;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int restore_sigmask: 1;
	unsigned int in_user_fault: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	unsigned int use_memdelay: 1;
	long unsigned int atomic_flags;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	long unsigned int stack_canary;
	struct task_struct___2 *real_parent;
	struct task_struct___2 *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct___2 *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid___2 *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_group;
	struct list_head thread_node;
	struct completion *vfork_done;
	int *set_child_tid;
	int *clear_child_tid;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	u64 start_time;
	u64 real_start_time;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	struct posix_cputimers posix_cputimers;
	const struct cred___2 *ptracer_cred;
	const struct cred___2 *real_cred;
	const struct cred___2 *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	long unsigned int last_switch_count;
	long unsigned int last_switch_time;
	struct fs_struct *fs;
	struct files_struct *files;
	struct nsproxy___2 *nsproxy;
	struct signal_struct___2 *signal;
	struct sighand_struct *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	long unsigned int sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct audit_context *audit_context;
	kuid_t loginuid;
	unsigned int sessionid;
	struct seccomp seccomp;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	struct rb_root_cached pi_waiters;
	struct task_struct___2 *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct backing_dev_info *backing_dev_info;
	struct io_context *io_context;
	struct capture_control *capture_control;
	long unsigned int ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	unsigned int psi_flags;
	u64 acct_rss_mem1;
	u64 acct_vm_mem1;
	u64 acct_timexpd;
	nodemask_t mems_allowed;
	seqcount_t mems_allowed_seq;
	int cpuset_mem_spread_rotor;
	int cpuset_slab_spread_rotor;
	struct css_set___2 *cgroups;
	struct list_head cg_list;
	u32 closid;
	u32 rmid;
	struct robust_list_head *robust_list;
	struct compat_robust_list_head *compat_robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	struct perf_event_context___2 *perf_event_ctxp[2];
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	struct mempolicy *mempolicy;
	short int il_prev;
	short int pref_node_fork;
	int numa_scan_seq;
	unsigned int numa_scan_period;
	unsigned int numa_scan_period_max;
	int numa_preferred_nid;
	long unsigned int numa_migrate_retry;
	u64 node_stamp;
	u64 last_task_numa_placement;
	u64 last_sum_exec_runtime;
	struct callback_head numa_work;
	struct numa_group *numa_group;
	long unsigned int *numa_faults;
	long unsigned int total_numa_faults;
	long unsigned int numa_faults_locality[3];
	long unsigned int numa_pages_migrated;
	struct rseq *rseq;
	u32 rseq_sig;
	long unsigned int rseq_event_mask;
	struct tlbflush_unmap_batch tlb_ubc;
	union {
		refcount_t rcu_users;
		struct callback_head rcu;
	};
	struct pipe_inode_info___2 *splice_pipe;
	struct page_frag___2 task_frag;
	struct task_delay_info *delays;
	int nr_dirtied;
	int nr_dirtied_pause;
	long unsigned int dirty_paused_when;
	int latency_record_count;
	struct latency_record latency_record[32];
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	int curr_ret_stack;
	int curr_ret_depth;
	struct ftrace_ret_stack *ret_stack;
	long long unsigned int ftrace_timestamp;
	atomic_t trace_overrun;
	atomic_t tracing_graph_pause;
	long unsigned int trace;
	long unsigned int trace_recursion;
	struct mem_cgroup *memcg_in_oom;
	gfp_t memcg_oom_gfp_mask;
	int memcg_oom_order;
	unsigned int memcg_nr_pages_over_high;
	struct mem_cgroup *active_memcg;
	struct request_queue *throttle_queue;
	struct uprobe_task *utask;
	unsigned int sequential_io;
	unsigned int sequential_io_avg;
	int pagefault_disabled;
	struct task_struct___2 *oom_reaper_list;
	struct vm_struct___2 *stack_vm_area;
	refcount_t stack_refcount;
	int patch_state;
	void *security;
	void *mce_vaddr;
	__u64 mce_kflags;
	u64 mce_addr;
	__u64 mce_ripv: 1;
	__u64 mce_whole_page: 1;
	__u64 __mce_reserved: 62;
	struct callback_head mce_kill_me;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct thread_struct___2 thread;
};

typedef struct page___2 *pgtable_t___2;

struct address_space___2;

struct dev_pagemap___2;

struct page___2 {
	long unsigned int flags;
	union {
		struct {
			struct list_head lru;
			struct address_space___2 *mapping;
			long unsigned int index;
			long unsigned int private;
		};
		struct {
			dma_addr_t dma_addr;
		};
		struct {
			union {
				struct list_head slab_list;
				struct {
					struct page___2 *next;
					int pages;
					int pobjects;
				};
			};
			struct kmem_cache *slab_cache;
			void *freelist;
			union {
				void *s_mem;
				long unsigned int counters;
				struct {
					unsigned int inuse: 16;
					unsigned int objects: 15;
					unsigned int frozen: 1;
				};
			};
		};
		struct {
			long unsigned int compound_head;
			unsigned char compound_dtor;
			unsigned char compound_order;
			atomic_t compound_mapcount;
		};
		struct {
			long unsigned int _compound_pad_1;
			long unsigned int _compound_pad_2;
			struct list_head deferred_list;
		};
		struct {
			long unsigned int _pt_pad_1;
			pgtable_t___2 pmd_huge_pte;
			long unsigned int _pt_pad_2;
			union {
				struct mm_struct___2 *pt_mm;
				atomic_t pt_frag_refcount;
			};
			spinlock_t ptl;
		};
		struct {
			struct dev_pagemap___2 *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		atomic_t _mapcount;
		unsigned int page_type;
		unsigned int active;
		int units;
	};
	atomic_t _refcount;
	struct mem_cgroup *mem_cgroup;
};

struct pv_mmu_ops___2 {
	void (*flush_tlb_user)();
	void (*flush_tlb_kernel)();
	void (*flush_tlb_one_user)(long unsigned int);
	void (*flush_tlb_others)(const struct cpumask *, const struct flush_tlb_info *);
	void (*tlb_remove_table)(struct mmu_gather *, void *);
	void (*exit_mmap)(struct mm_struct___2 *);
};

struct core_state___2;

struct user_namespace___2;

struct mm_struct___2 {
	struct {
		struct vm_area_struct___2 *mmap;
		struct rb_root mm_rb;
		u64 vmacache_seqnum;
		long unsigned int (*get_unmapped_area)(struct file___2 *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
		long unsigned int mmap_base;
		long unsigned int mmap_legacy_base;
		long unsigned int mmap_compat_base;
		long unsigned int mmap_compat_legacy_base;
		long unsigned int task_size;
		long unsigned int highest_vm_end;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		atomic_t mm_count;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_sem;
		struct list_head mmlist;
		long unsigned int hiwater_rss;
		long unsigned int hiwater_vm;
		long unsigned int total_vm;
		long unsigned int locked_vm;
		atomic64_t pinned_vm;
		long unsigned int data_vm;
		long unsigned int exec_vm;
		long unsigned int stack_vm;
		long unsigned int def_flags;
		spinlock_t arg_lock;
		long unsigned int start_code;
		long unsigned int end_code;
		long unsigned int start_data;
		long unsigned int end_data;
		long unsigned int start_brk;
		long unsigned int brk;
		long unsigned int start_stack;
		long unsigned int arg_start;
		long unsigned int arg_end;
		long unsigned int env_start;
		long unsigned int env_end;
		long unsigned int saved_auxv[46];
		struct mm_rss_stat rss_stat;
		struct linux_binfmt *binfmt;
		mm_context_t context;
		long unsigned int flags;
		struct core_state___2 *core_state;
		spinlock_t ioctx_lock;
		struct kioctx_table *ioctx_table;
		struct task_struct___2 *owner;
		struct user_namespace___2 *user_ns;
		struct file___2 *exe_file;
		struct mmu_notifier_mm *mmu_notifier_mm;
		long unsigned int numa_next_scan;
		long unsigned int numa_scan_offset;
		int numa_scan_seq;
		atomic_t tlb_flush_pending;
		bool tlb_flush_batched;
		struct uprobes_state uprobes_state;
		atomic_long_t hugetlb_usage;
		struct work_struct async_put_work;
	};
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long unsigned int cpu_bitmap[0];
};

struct paravirt_patch_template___2 {
	struct pv_init_ops init;
	struct pv_time_ops time;
	struct pv_cpu_ops cpu;
	struct pv_irq_ops irq;
	struct pv_mmu_ops___2 mmu;
	struct pv_lock_ops lock;
};

struct seq_operations___2 {
	void * (*start)(struct seq_file___2 *, loff_t *);
	void (*stop)(struct seq_file___2 *, void *);
	void * (*next)(struct seq_file___2 *, void *, loff_t *);
	int (*show)(struct seq_file___2 *, void *);
};

struct hw_perf_event___2 {
	union {
		struct {
			u64 config;
			u64 last_tag;
			long unsigned int config_base;
			long unsigned int event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			struct arch_hw_breakpoint info;
			struct list_head bp_list;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct___2 *target;
	void *addr_filters;
	long unsigned int addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

typedef void (*perf_overflow_handler_t___2)(struct perf_event___2 *, struct perf_sample_data *, struct pt_regs *);

struct pmu___2;

struct ring_buffer___2;

struct fasync_struct___2;

struct pid_namespace___2;

struct bpf_prog___2;

struct trace_event_call___2;

struct perf_cgroup___2;

struct perf_event___2 {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	struct perf_event___2 *group_leader;
	struct pmu___2 *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	u64 shadow_ctx_time;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event___2 hw;
	struct perf_event_context___2 *ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event___2 *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct___2 *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct ring_buffer___2 *rb;
	struct list_head rb_entry;
	long unsigned int rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct___2 *fasync;
	int pending_wakeup;
	int pending_kill;
	int pending_disable;
	struct irq_work pending;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	long unsigned int addr_filters_gen;
	struct perf_event___2 *aux_event;
	void (*destroy)(struct perf_event___2 *);
	struct callback_head callback_head;
	struct pid_namespace___2 *ns;
	u64 id;
	u64 (*clock)();
	perf_overflow_handler_t___2 overflow_handler;
	void *overflow_handler_context;
	perf_overflow_handler_t___2 orig_overflow_handler;
	struct bpf_prog___2 *prog;
	struct trace_event_call___2 *tp_event;
	struct event_filter *filter;
	struct ftrace_ops ftrace_ops;
	struct perf_cgroup___2 *cgrp;
	struct list_head sb_list;
};

struct dentry_operations___2;

struct dentry___2 {
	unsigned int d_flags;
	seqcount_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry___2 *d_parent;
	struct qstr d_name;
	struct inode___2 *d_inode;
	unsigned char d_iname[32];
	struct lockref d_lockref;
	const struct dentry_operations___2 *d_op;
	struct super_block___2 *d_sb;
	long unsigned int d_time;
	void *d_fsdata;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct list_head d_child;
	struct list_head d_subdirs;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct address_space_operations___2;

struct address_space___2 {
	struct inode___2 *host;
	struct xarray i_pages;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	struct rw_semaphore i_mmap_rwsem;
	long unsigned int nrpages;
	long unsigned int nrexceptional;
	long unsigned int writeback_index;
	const struct address_space_operations___2 *a_ops;
	long unsigned int flags;
	errseq_t wb_err;
	spinlock_t private_lock;
	struct list_head private_list;
	void *private_data;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct inode_operations___2;

struct block_device___2;

struct inode___2 {
	umode_t i_mode;
	short unsigned int i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations___2 *i_op;
	struct super_block___2 *i_sb;
	struct address_space___2 *i_mapping;
	void *i_security;
	long unsigned int i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	struct timespec64 i_atime;
	struct timespec64 i_mtime;
	struct timespec64 i_ctime;
	spinlock_t i_lock;
	short unsigned int i_bytes;
	u8 i_blkbits;
	u8 i_write_hint;
	blkcnt_t i_blocks;
	long unsigned int i_state;
	struct rw_semaphore i_rwsem;
	long unsigned int dirtied_when;
	long unsigned int dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct bdi_writeback *i_wb;
	int i_wb_frn_winner;
	u16 i_wb_frn_avg_time;
	u16 i_wb_frn_history;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations___2 *i_fop;
		void (*free_inode)(struct inode___2 *);
	};
	struct file_lock_context *i_flctx;
	struct address_space___2 i_data;
	struct list_head i_devices;
	union {
		struct pipe_inode_info___2 *i_pipe;
		struct block_device___2 *i_bdev;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_generation;
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector *i_fsnotify_marks;
	struct fscrypt_info *i_crypt_info;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	void *i_private;
};

struct vfsmount___2;

struct path___2;

struct dentry_operations___2 {
	int (*d_revalidate)(struct dentry___2 *, unsigned int);
	int (*d_weak_revalidate)(struct dentry___2 *, unsigned int);
	int (*d_hash)(const struct dentry___2 *, struct qstr *);
	int (*d_compare)(const struct dentry___2 *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry___2 *);
	int (*d_init)(struct dentry___2 *);
	void (*d_release)(struct dentry___2 *);
	void (*d_prune)(struct dentry___2 *);
	void (*d_iput)(struct dentry___2 *, struct inode___2 *);
	char * (*d_dname)(struct dentry___2 *, char *, int);
	struct vfsmount___2 * (*d_automount)(struct path___2 *);
	int (*d_manage)(const struct path___2 *, bool);
	struct dentry___2 * (*d_real)(struct dentry___2 *, const struct inode___2 *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct quota_format_type___2;

struct mem_dqinfo___2 {
	struct quota_format_type___2 *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	long unsigned int dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
};

struct quota_format_ops___2;

struct quota_info___2 {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode___2 *files[3];
	struct mem_dqinfo___2 info[3];
	const struct quota_format_ops___2 *ops[3];
};

struct rcuwait___2 {
	struct task_struct___2 *task;
};

struct percpu_rw_semaphore___2 {
	struct rcu_sync rss;
	unsigned int *read_count;
	struct rw_semaphore rw_sem;
	struct rcuwait___2 writer;
	int readers_block;
};

struct sb_writers___2 {
	int frozen;
	wait_queue_head_t wait_unfrozen;
	struct percpu_rw_semaphore___2 rw_sem[3];
};

struct super_operations___2;

struct dquot_operations___2;

struct quotactl_ops___2;

struct super_block___2 {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	long unsigned int s_blocksize;
	loff_t s_maxbytes;
	struct file_system_type___2 *s_type;
	const struct super_operations___2 *s_op;
	const struct dquot_operations___2 *dq_op;
	const struct quotactl_ops___2 *s_qcop;
	const struct export_operations *s_export_op;
	long unsigned int s_flags;
	long unsigned int s_iflags;
	long unsigned int s_magic;
	struct dentry___2 *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	void *s_security;
	const struct xattr_handler **s_xattr;
	const struct fscrypt_operations *s_cop;
	struct key *s_master_keys;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device___2 *s_bdev;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	struct quota_info___2 s_dquot;
	struct sb_writers___2 s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	time64_t s_time_min;
	time64_t s_time_max;
	__u32 s_fsnotify_mask;
	struct fsnotify_mark_connector *s_fsnotify_marks;
	char s_id[32];
	uuid_t s_uuid;
	unsigned int s_max_links;
	fmode_t s_mode;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations___2 *s_d_op;
	int cleancache_poolid;
	struct shrinker s_shrink;
	atomic_long_t s_remove_count;
	atomic_long_t s_fsnotify_inode_refs;
	int s_readonly_remount;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace___2 *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	long: 64;
	long: 64;
};

struct vfsmount___2 {
	struct dentry___2 *mnt_root;
	struct super_block___2 *mnt_sb;
	int mnt_flags;
};

struct path___2 {
	struct vfsmount___2 *mnt;
	struct dentry___2 *dentry;
};

struct proc_ns_operations___2;

struct ns_common___2 {
	atomic_long_t stashed;
	const struct proc_ns_operations___2 *ops;
	unsigned int inum;
};

struct ucounts___2;

struct user_namespace___2 {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	atomic_t count;
	struct user_namespace___2 *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common___2 ns;
	long unsigned int flags;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts___2 *ucounts;
	int ucount_max[9];
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct vm_operations_struct___2;

struct vm_area_struct___2 {
	long unsigned int vm_start;
	long unsigned int vm_end;
	struct vm_area_struct___2 *vm_next;
	struct vm_area_struct___2 *vm_prev;
	struct rb_node vm_rb;
	long unsigned int rb_subtree_gap;
	struct mm_struct___2 *vm_mm;
	pgprot_t vm_page_prot;
	long unsigned int vm_flags;
	struct {
		struct rb_node rb;
		long unsigned int rb_subtree_last;
	} shared;
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct___2 *vm_ops;
	long unsigned int vm_pgoff;
	struct file___2 *vm_file;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct mempolicy *vm_policy;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

struct dev_pagemap_ops___2;

struct dev_pagemap___2 {
	struct vmem_altmap altmap;
	struct resource res;
	struct percpu_ref *ref;
	struct percpu_ref internal_ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	const struct dev_pagemap_ops___2 *ops;
};

struct fown_struct___2 {
	rwlock_t lock;
	struct pid___2 *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct file___2 {
	union {
		struct llist_node fu_llist;
		struct callback_head fu_rcuhead;
	} f_u;
	struct path___2 f_path;
	struct inode___2 *f_inode;
	const struct file_operations___2 *f_op;
	spinlock_t f_lock;
	enum rw_hint f_write_hint;
	atomic_long_t f_count;
	unsigned int f_flags;
	fmode_t f_mode;
	struct mutex f_pos_lock;
	loff_t f_pos;
	struct fown_struct___2 f_owner;
	const struct cred___2 *f_cred;
	struct file_ra_state f_ra;
	u64 f_version;
	void *f_security;
	void *private_data;
	struct list_head f_ep_links;
	struct list_head f_tfile_llink;
	struct address_space___2 *f_mapping;
	errseq_t f_wb_err;
};

struct vm_fault___2;

struct vm_operations_struct___2 {
	void (*open)(struct vm_area_struct___2 *);
	void (*close)(struct vm_area_struct___2 *);
	int (*split)(struct vm_area_struct___2 *, long unsigned int);
	int (*mremap)(struct vm_area_struct___2 *);
	int (*mprotect)(struct vm_area_struct___2 *, long unsigned int, long unsigned int, long unsigned int);
	vm_fault_t (*fault)(struct vm_fault___2 *);
	vm_fault_t (*huge_fault)(struct vm_fault___2 *, enum page_entry_size);
	void (*map_pages)(struct vm_fault___2 *, long unsigned int, long unsigned int);
	long unsigned int (*pagesize)(struct vm_area_struct___2 *);
	vm_fault_t (*page_mkwrite)(struct vm_fault___2 *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault___2 *);
	int (*access)(struct vm_area_struct___2 *, long unsigned int, void *, int, int);
	const char * (*name)(struct vm_area_struct___2 *);
	int (*set_policy)(struct vm_area_struct___2 *, struct mempolicy *);
	struct mempolicy * (*get_policy)(struct vm_area_struct___2 *, long unsigned int);
	struct page___2 * (*find_special_page)(struct vm_area_struct___2 *, long unsigned int);
	long unsigned int kabi_reserved1;
};

struct core_thread___2 {
	struct task_struct___2 *task;
	struct core_thread___2 *next;
};

struct core_state___2 {
	atomic_t nr_threads;
	struct core_thread___2 dumper;
	struct completion startup;
};

struct vm_fault___2 {
	struct vm_area_struct___2 *vma;
	unsigned int flags;
	gfp_t gfp_mask;
	long unsigned int pgoff;
	long unsigned int address;
	pmd_t *pmd;
	pud_t *pud;
	pte_t orig_pte;
	struct page___2 *cow_page;
	struct mem_cgroup *memcg;
	struct page___2 *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t___2 prealloc_pte;
};

struct fwnode_operations___2;

struct fwnode_handle___2 {
	struct fwnode_handle___2 *secondary;
	const struct fwnode_operations___2 *ops;
};

struct device___2;

struct fwnode_reference_args___2;

struct fwnode_endpoint___2;

struct fwnode_operations___2 {
	struct fwnode_handle___2 * (*get)(struct fwnode_handle___2 *);
	void (*put)(struct fwnode_handle___2 *);
	bool (*device_is_available)(const struct fwnode_handle___2 *);
	const void * (*device_get_match_data)(const struct fwnode_handle___2 *, const struct device___2 *);
	bool (*property_present)(const struct fwnode_handle___2 *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle___2 *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle___2 *, const char *, const char **, size_t);
	struct fwnode_handle___2 * (*get_parent)(const struct fwnode_handle___2 *);
	struct fwnode_handle___2 * (*get_next_child_node)(const struct fwnode_handle___2 *, struct fwnode_handle___2 *);
	struct fwnode_handle___2 * (*get_named_child_node)(const struct fwnode_handle___2 *, const char *);
	int (*get_reference_args)(const struct fwnode_handle___2 *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args___2 *);
	struct fwnode_handle___2 * (*graph_get_next_endpoint)(const struct fwnode_handle___2 *, struct fwnode_handle___2 *);
	struct fwnode_handle___2 * (*graph_get_remote_endpoint)(const struct fwnode_handle___2 *);
	struct fwnode_handle___2 * (*graph_get_port_parent)(struct fwnode_handle___2 *);
	int (*graph_parse_endpoint)(const struct fwnode_handle___2 *, struct fwnode_endpoint___2 *);
};

struct fwnode_endpoint___2 {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle___2 *local_fwnode;
};

struct fwnode_reference_args___2 {
	struct fwnode_handle___2 *fwnode;
	unsigned int nargs;
	u64 args[8];
};

struct kset___2;

struct kobj_type___2;

struct kernfs_node___2;

struct kobject___2 {
	const char *name;
	struct list_head entry;
	struct kobject___2 *parent;
	struct kset___2 *kset;
	struct kobj_type___2 *ktype;
	struct kernfs_node___2 *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct wakeup_source___2;

struct dev_pm_info___2 {
	pm_message_t power_state;
	unsigned int can_wakeup: 1;
	unsigned int async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	struct list_head entry;
	struct completion completion;
	struct wakeup_source___2 *wakeup;
	bool wakeup_path: 1;
	bool syscore: 1;
	bool no_pm_callbacks: 1;
	unsigned int must_resume: 1;
	unsigned int may_skip_resume: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	unsigned int idle_notification: 1;
	unsigned int request_pending: 1;
	unsigned int deferred_resume: 1;
	unsigned int runtime_auto: 1;
	bool ignore_children: 1;
	unsigned int no_callbacks: 1;
	unsigned int irq_safe: 1;
	unsigned int use_autosuspend: 1;
	unsigned int timer_autosuspends: 1;
	unsigned int memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	int runtime_error;
	int autosuspend_delay;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device___2 *, s32);
	struct dev_pm_qos *qos;
};

struct device_type___2;

struct bus_type___2;

struct device_driver___2;

struct dev_pm_domain___2;

struct dma_map_ops___2;

struct device_node___2;

struct class___2;

struct attribute_group___2;

struct device___2 {
	struct kobject___2 kobj;
	struct device___2 *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type___2 *type;
	struct bus_type___2 *bus;
	struct device_driver___2 *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	struct dev_pm_info___2 power;
	struct dev_pm_domain___2 *pm_domain;
	struct irq_domain *msi_domain;
	struct dev_pin_info *pins;
	struct list_head msi_list;
	const struct dma_map_ops___2 *dma_ops;
	u64 *dma_mask;
	u64 coherent_dma_mask;
	u64 bus_dma_mask;
	long unsigned int dma_pfn_offset;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct dev_archdata archdata;
	struct device_node___2 *of_node;
	struct fwnode_handle___2 *fwnode;
	int numa_node;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	struct class___2 *class;
	const struct attribute_group___2 **groups;
	void (*release)(struct device___2 *);
	struct iommu_group *iommu_group;
	struct iommu_fwspec *iommu_fwspec;
	struct iommu_param *iommu_param;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
};

struct vm_struct___2 {
	struct vm_struct___2 *next;
	void *addr;
	long unsigned int size;
	long unsigned int flags;
	struct page___2 **pages;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

struct upid___2 {
	int nr;
	struct pid_namespace___2 *ns;
};

struct pid_namespace___2 {
	struct kref kref;
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct___2 *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	struct pid_namespace___2 *parent;
	struct vfsmount___2 *proc_mnt;
	struct dentry___2 *proc_self;
	struct dentry___2 *proc_thread_self;
	struct fs_pin *bacct;
	struct user_namespace___2 *user_ns;
	struct ucounts___2 *ucounts;
	struct work_struct proc_work;
	kgid_t pid_gid;
	int hide_pid;
	int reboot;
	struct ns_common___2 ns;
	int max_map_count;
};

struct pid___2 {
	refcount_t count;
	unsigned int level;
	struct hlist_head tasks[4];
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid___2 numbers[1];
};

struct signal_struct___2 {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct___2 *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct___2 *group_exit_task;
	int group_stop_count;
	unsigned int flags;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	int posix_timer_id;
	struct list_head posix_timers;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid___2 *pids[4];
	struct pid___2 *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	struct autogroup *autogroup;
	seqlock_t stats_lock;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	long unsigned int cnvcsw;
	long unsigned int cnivcsw;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	long unsigned int cmin_flt;
	long unsigned int cmaj_flt;
	long unsigned int inblock;
	long unsigned int oublock;
	long unsigned int cinblock;
	long unsigned int coublock;
	long unsigned int maxrss;
	long unsigned int cmaxrss;
	struct task_io_accounting ioac;
	long long unsigned int sum_sched_runtime;
	struct rlimit rlim[16];
	struct pacct_struct pacct;
	struct taskstats *stats;
	unsigned int audit_tty;
	struct tty_audit_buf *tty_audit_buf;
	bool oom_flag_origin;
	short int oom_score_adj;
	short int oom_score_adj_min;
	struct mm_struct___2 *oom_mm;
	struct mutex cred_guard_mutex;
	struct rw_semaphore exec_update_lock;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct cred___2 {
	atomic_t usage;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	void *security;
	struct user_struct *user;
	struct user_namespace___2 *user_ns;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

struct cgroup_namespace___2;

struct nsproxy___2 {
	atomic_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace___2 *pid_ns_for_children;
	struct net___2 *net_ns;
	struct cgroup_namespace___2 *cgroup_ns;
};

struct cgroup_subsys_state___2;

struct cgroup___2;

struct css_set___2 {
	struct cgroup_subsys_state___2 *subsys[12];
	refcount_t refcount;
	struct css_set___2 *dom_cset;
	struct cgroup___2 *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[12];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_preload_node;
	struct list_head mg_node;
	struct cgroup___2 *mg_src_cgrp;
	struct cgroup___2 *mg_dst_cgrp;
	struct css_set___2 *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

struct perf_event_context___2 {
	struct pmu___2 *pmu;
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head active_ctx_list;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	struct list_head pinned_active;
	struct list_head flexible_active;
	int nr_events;
	int nr_active;
	int is_active;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	int rotate_necessary;
	refcount_t refcount;
	struct task_struct___2 *task;
	u64 time;
	u64 timestamp;
	struct perf_event_context___2 *parent_ctx;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	int nr_cgroups;
	void *task_ctx_data;
	struct callback_head callback_head;
};

struct pipe_buffer___2;

struct pipe_inode_info___2 {
	struct mutex mutex;
	wait_queue_head_t wait;
	unsigned int nrbufs;
	unsigned int curbuf;
	unsigned int buffers;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int waiting_writers;
	unsigned int r_counter;
	unsigned int w_counter;
	struct page___2 *tmp_page;
	struct fasync_struct___2 *fasync_readers;
	struct fasync_struct___2 *fasync_writers;
	struct pipe_buffer___2 *bufs;
	struct user_struct *user;
};

struct kiocb___2 {
	struct file___2 *ki_filp;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb___2 *, long int, long int);
	void *private;
	int ki_flags;
	u16 ki_hint;
	u16 ki_ioprio;
	unsigned int ki_cookie;
};

struct iattr___2 {
	unsigned int ia_valid;
	umode_t ia_mode;
	kuid_t ia_uid;
	kgid_t ia_gid;
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file___2 *ia_file;
};

struct dquot___2 {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block___2 *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	long unsigned int dq_flags;
	struct mem_dqblk dq_dqb;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct quota_format_type___2 {
	int qf_fmt_id;
	const struct quota_format_ops___2 *qf_ops;
	struct module___2 *qf_owner;
	struct quota_format_type___2 *qf_next;
};

struct quota_format_ops___2 {
	int (*check_quota_file)(struct super_block___2 *, int);
	int (*read_file_info)(struct super_block___2 *, int);
	int (*write_file_info)(struct super_block___2 *, int);
	int (*free_file_info)(struct super_block___2 *, int);
	int (*read_dqblk)(struct dquot___2 *);
	int (*commit_dqblk)(struct dquot___2 *);
	int (*release_dqblk)(struct dquot___2 *);
	int (*get_next_id)(struct super_block___2 *, struct kqid *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct dquot_operations___2 {
	int (*write_dquot)(struct dquot___2 *);
	struct dquot___2 * (*alloc_dquot)(struct super_block___2 *, int);
	void (*destroy_dquot)(struct dquot___2 *);
	int (*acquire_dquot)(struct dquot___2 *);
	int (*release_dquot)(struct dquot___2 *);
	int (*mark_dirty)(struct dquot___2 *);
	int (*write_info)(struct super_block___2 *, int);
	qsize_t * (*get_reserved_space)(struct inode___2 *);
	int (*get_projid)(struct inode___2 *, kprojid_t *);
	int (*get_inode_usage)(struct inode___2 *, qsize_t *);
	int (*get_next_id)(struct super_block___2 *, struct kqid *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct quotactl_ops___2 {
	int (*quota_on)(struct super_block___2 *, int, int, const struct path___2 *);
	int (*quota_off)(struct super_block___2 *, int);
	int (*quota_enable)(struct super_block___2 *, unsigned int);
	int (*quota_disable)(struct super_block___2 *, unsigned int);
	int (*quota_sync)(struct super_block___2 *, int);
	int (*set_info)(struct super_block___2 *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block___2 *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block___2 *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block___2 *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block___2 *, struct qc_state *);
	int (*rm_xquota)(struct super_block___2 *, unsigned int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct module_kobject___2 {
	struct kobject___2 kobj;
	struct module___2 *mod;
	struct kobject___2 *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct mod_tree_node___2 {
	struct module___2 *mod;
	struct latch_tree_node node;
};

struct module_layout___2 {
	void *base;
	unsigned int size;
	unsigned int text_size;
	unsigned int ro_size;
	unsigned int ro_after_init_size;
	struct mod_tree_node___2 mtn;
};

struct module_attribute___2;

struct kernel_param___2;

struct module___2 {
	enum module_state state;
	struct list_head list;
	char name[56];
	struct module_kobject___2 mkobj;
	struct module_attribute___2 *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject___2 *holders_dir;
	const struct kernel_symbol *syms;
	const s32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param___2 *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const s32 *gpl_crcs;
	bool async_probe_requested;
	const struct kernel_symbol *gpl_future_syms;
	const s32 *gpl_future_crcs;
	unsigned int num_gpl_future_syms;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)();
	long: 64;
	long: 64;
	long: 64;
	struct module_layout___2 core_layout;
	struct module_layout___2 init_layout;
	struct mod_arch_specific arch;
	long unsigned int taints;
	unsigned int num_bugs;
	struct list_head bug_list;
	struct bug_entry *bug_table;
	struct mod_kallsyms *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	void *percpu;
	unsigned int percpu_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call___2 **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	unsigned int num_ftrace_callsites;
	long unsigned int *ftrace_callsites;
	bool klp;
	bool klp_alive;
	struct klp_modinfo *klp_info;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)();
	atomic_t refcnt;
	struct error_injection_entry *ei_funcs;
	unsigned int num_ei_funcs;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
};

struct address_space_operations___2 {
	int (*writepage)(struct page___2 *, struct writeback_control *);
	int (*readpage)(struct file___2 *, struct page___2 *);
	int (*writepages)(struct address_space___2 *, struct writeback_control *);
	int (*set_page_dirty)(struct page___2 *);
	int (*readpages)(struct file___2 *, struct address_space___2 *, struct list_head *, unsigned int);
	int (*write_begin)(struct file___2 *, struct address_space___2 *, loff_t, unsigned int, unsigned int, struct page___2 **, void **);
	int (*write_end)(struct file___2 *, struct address_space___2 *, loff_t, unsigned int, unsigned int, struct page___2 *, void *);
	sector_t (*bmap)(struct address_space___2 *, sector_t);
	void (*invalidatepage)(struct page___2 *, unsigned int, unsigned int);
	int (*releasepage)(struct page___2 *, gfp_t);
	void (*freepage)(struct page___2 *);
	ssize_t (*direct_IO)(struct kiocb___2 *, struct iov_iter___2 *);
	int (*migratepage)(struct address_space___2 *, struct page___2 *, struct page___2 *, enum migrate_mode);
	bool (*isolate_page)(struct page___2 *, isolate_mode_t);
	void (*putback_page)(struct page___2 *);
	int (*launder_page)(struct page___2 *);
	int (*is_partially_uptodate)(struct page___2 *, long unsigned int, long unsigned int);
	void (*is_dirty_writeback)(struct page___2 *, bool *, bool *);
	int (*error_remove_page)(struct address_space___2 *, struct page___2 *);
	int (*swap_activate)(struct swap_info_struct *, struct file___2 *, sector_t *);
	void (*swap_deactivate)(struct file___2 *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct bio_vec___2;

struct iov_iter___2 {
	unsigned int type;
	size_t iov_offset;
	size_t count;
	union {
		const struct iovec *iov;
		const struct kvec *kvec;
		const struct bio_vec___2 *bvec;
		struct pipe_inode_info___2 *pipe;
	};
	union {
		long unsigned int nr_segs;
		struct {
			int idx;
			int start_idx;
		};
	};
};

struct block_device___2 {
	dev_t bd_dev;
	int bd_openers;
	struct inode___2 *bd_inode;
	struct super_block___2 *bd_super;
	struct mutex bd_mutex;
	void *bd_claiming;
	void *bd_holder;
	int bd_holders;
	bool bd_write_holder;
	struct list_head bd_holder_disks;
	struct block_device___2 *bd_contains;
	unsigned int bd_block_size;
	u8 bd_partno;
	struct hd_struct *bd_part;
	unsigned int bd_part_count;
	int bd_invalidated;
	struct gendisk *bd_disk;
	struct request_queue *bd_queue;
	struct backing_dev_info *bd_bdi;
	struct list_head bd_list;
	long unsigned int bd_private;
	int bd_fsfreeze_count;
	struct mutex bd_fsfreeze_mutex;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct inode_operations___2 {
	struct dentry___2 * (*lookup)(struct inode___2 *, struct dentry___2 *, unsigned int);
	const char * (*get_link)(struct dentry___2 *, struct inode___2 *, struct delayed_call *);
	int (*permission)(struct inode___2 *, int);
	struct posix_acl * (*get_acl)(struct inode___2 *, int);
	int (*readlink)(struct dentry___2 *, char *, int);
	int (*create)(struct inode___2 *, struct dentry___2 *, umode_t, bool);
	int (*link)(struct dentry___2 *, struct inode___2 *, struct dentry___2 *);
	int (*unlink)(struct inode___2 *, struct dentry___2 *);
	int (*symlink)(struct inode___2 *, struct dentry___2 *, const char *);
	int (*mkdir)(struct inode___2 *, struct dentry___2 *, umode_t);
	int (*rmdir)(struct inode___2 *, struct dentry___2 *);
	int (*mknod)(struct inode___2 *, struct dentry___2 *, umode_t, dev_t);
	int (*rename)(struct inode___2 *, struct dentry___2 *, struct inode___2 *, struct dentry___2 *, unsigned int);
	int (*setattr)(struct dentry___2 *, struct iattr___2 *);
	int (*getattr)(const struct path___2 *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry___2 *, char *, size_t);
	int (*fiemap)(struct inode___2 *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode___2 *, struct timespec64 *, int);
	int (*atomic_open)(struct inode___2 *, struct dentry___2 *, struct file___2 *, unsigned int, umode_t);
	int (*tmpfile)(struct inode___2 *, struct dentry___2 *, umode_t);
	int (*set_acl)(struct inode___2 *, struct posix_acl *, int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct file_lock_operations___2 {
	void (*fl_copy_lock)(struct file_lock___2 *, struct file_lock___2 *);
	void (*fl_release_private)(struct file_lock___2 *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct lock_manager_operations___2;

struct file_lock___2 {
	struct file_lock___2 *fl_blocker;
	struct list_head fl_list;
	struct hlist_node fl_link;
	struct list_head fl_blocked_requests;
	struct list_head fl_blocked_member;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	unsigned int fl_pid;
	int fl_link_cpu;
	wait_queue_head_t fl_wait;
	struct file___2 *fl_file;
	loff_t fl_start;
	loff_t fl_end;
	struct fasync_struct___2 *fl_fasync;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	const struct file_lock_operations___2 *fl_ops;
	const struct lock_manager_operations___2 *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
	} fl_u;
};

struct lock_manager_operations___2 {
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock___2 *);
	int (*lm_grant)(struct file_lock___2 *, int);
	bool (*lm_break)(struct file_lock___2 *);
	int (*lm_change)(struct file_lock___2 *, int, struct list_head *);
	void (*lm_setup)(struct file_lock___2 *, void **);
	long unsigned int kabi_reserved1;
};

struct fasync_struct___2 {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct___2 *fa_next;
	struct file___2 *fa_file;
	struct callback_head fa_rcu;
};

struct super_operations___2 {
	struct inode___2 * (*alloc_inode)(struct super_block___2 *);
	void (*destroy_inode)(struct inode___2 *);
	void (*free_inode)(struct inode___2 *);
	void (*dirty_inode)(struct inode___2 *, int);
	int (*write_inode)(struct inode___2 *, struct writeback_control *);
	int (*drop_inode)(struct inode___2 *);
	void (*evict_inode)(struct inode___2 *);
	void (*put_super)(struct super_block___2 *);
	int (*sync_fs)(struct super_block___2 *, int);
	int (*freeze_super)(struct super_block___2 *);
	int (*freeze_fs)(struct super_block___2 *);
	int (*thaw_super)(struct super_block___2 *);
	int (*unfreeze_fs)(struct super_block___2 *);
	int (*statfs)(struct dentry___2 *, struct kstatfs *);
	int (*remount_fs)(struct super_block___2 *, int *, char *);
	void (*umount_begin)(struct super_block___2 *);
	int (*show_options)(struct seq_file___2 *, struct dentry___2 *);
	int (*show_devname)(struct seq_file___2 *, struct dentry___2 *);
	int (*show_path)(struct seq_file___2 *, struct dentry___2 *);
	int (*show_stats)(struct seq_file___2 *, struct dentry___2 *);
	ssize_t (*quota_read)(struct super_block___2 *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block___2 *, int, const char *, size_t, loff_t);
	struct dquot___2 ** (*get_dquots)(struct inode___2 *);
	int (*bdev_try_to_free_page)(struct super_block___2 *, struct page___2 *, gfp_t);
	long int (*nr_cached_objects)(struct super_block___2 *, struct shrink_control *);
	long int (*free_cached_objects)(struct super_block___2 *, struct shrink_control *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

typedef void (*poll_queue_proc___2)(struct file___2 *, wait_queue_head_t *, struct poll_table_struct___2 *);

struct poll_table_struct___2 {
	poll_queue_proc___2 _qproc;
	__poll_t _key;
};

struct seq_file___2 {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	loff_t index;
	loff_t read_pos;
	u64 version;
	struct mutex lock;
	const struct seq_operations___2 *op;
	int poll_event;
	const struct file___2 *file;
	void *private;
};

struct dev_pagemap_ops___2 {
	void (*page_free)(struct page___2 *);
	void (*kill)(struct dev_pagemap___2 *);
	void (*cleanup)(struct dev_pagemap___2 *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault___2 *);
};

struct kernfs_root___2;

struct kernfs_elem_dir___2 {
	long unsigned int subdirs;
	struct rb_root children;
	struct kernfs_root___2 *root;
};

struct kernfs_syscall_ops___2;

struct kernfs_root___2 {
	struct kernfs_node___2 *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_ino;
	u32 next_generation;
	struct kernfs_syscall_ops___2 *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
};

struct kernfs_elem_symlink___2 {
	struct kernfs_node___2 *target_kn;
};

struct kernfs_ops___2;

struct kernfs_elem_attr___2 {
	const struct kernfs_ops___2 *ops;
	struct kernfs_open_node *open;
	loff_t size;
	struct kernfs_node___2 *notify_next;
};

struct kernfs_node___2 {
	atomic_t count;
	atomic_t active;
	struct kernfs_node___2 *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	union {
		struct kernfs_elem_dir___2 dir;
		struct kernfs_elem_symlink___2 symlink;
		struct kernfs_elem_attr___2 attr;
	};
	void *priv;
	union kernfs_node_id id;
	short unsigned int flags;
	umode_t mode;
	struct kernfs_iattrs *iattr;
};

struct kernfs_open_file___2;

struct kernfs_ops___2 {
	int (*open)(struct kernfs_open_file___2 *);
	void (*release)(struct kernfs_open_file___2 *);
	int (*seq_show)(struct seq_file___2 *, void *);
	void * (*seq_start)(struct seq_file___2 *, loff_t *);
	void * (*seq_next)(struct seq_file___2 *, void *, loff_t *);
	void (*seq_stop)(struct seq_file___2 *, void *);
	ssize_t (*read)(struct kernfs_open_file___2 *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file___2 *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file___2 *, struct poll_table_struct___2 *);
	int (*mmap)(struct kernfs_open_file___2 *, struct vm_area_struct___2 *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct kernfs_syscall_ops___2 {
	int (*show_options)(struct seq_file___2 *, struct kernfs_root___2 *);
	int (*mkdir)(struct kernfs_node___2 *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node___2 *);
	int (*rename)(struct kernfs_node___2 *, struct kernfs_node___2 *, const char *);
	int (*show_path)(struct seq_file___2 *, struct kernfs_node___2 *, struct kernfs_root___2 *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

struct kernfs_open_file___2 {
	struct kernfs_node___2 *kn;
	struct file___2 *file;
	struct seq_file___2 *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct___2 *vm_ops;
};

struct bin_attribute___2;

struct attribute_group___2 {
	const char *name;
	umode_t (*is_visible)(struct kobject___2 *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject___2 *, struct bin_attribute___2 *, int);
	struct attribute **attrs;
	struct bin_attribute___2 **bin_attrs;
};

struct bin_attribute___2 {
	struct attribute attr;
	size_t size;
	void *private;
	ssize_t (*read)(struct file___2 *, struct kobject___2 *, struct bin_attribute___2 *, char *, loff_t, size_t);
	ssize_t (*write)(struct file___2 *, struct kobject___2 *, struct bin_attribute___2 *, char *, loff_t, size_t);
	int (*mmap)(struct file___2 *, struct kobject___2 *, struct bin_attribute___2 *, struct vm_area_struct___2 *);
};

struct sysfs_ops___2 {
	ssize_t (*show)(struct kobject___2 *, struct attribute *, char *);
	ssize_t (*store)(struct kobject___2 *, struct attribute *, const char *, size_t);
};

struct kset_uevent_ops___2;

struct kset___2 {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject___2 kobj;
	const struct kset_uevent_ops___2 *uevent_ops;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct kobj_type___2 {
	void (*release)(struct kobject___2 *);
	const struct sysfs_ops___2 *sysfs_ops;
	struct attribute **default_attrs;
	const struct attribute_group___2 **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(struct kobject___2 *);
	const void * (*namespace)(struct kobject___2 *);
	void (*get_ownership)(struct kobject___2 *, kuid_t *, kgid_t *);
	long unsigned int kabi_reserved1;
};

struct kset_uevent_ops___2 {
	int (* const filter)(struct kset___2 *, struct kobject___2 *);
	const char * (* const name)(struct kset___2 *, struct kobject___2 *);
	int (* const uevent)(struct kset___2 *, struct kobject___2 *, struct kobj_uevent_env *);
};

struct dev_pm_ops___2 {
	int (*prepare)(struct device___2 *);
	void (*complete)(struct device___2 *);
	int (*suspend)(struct device___2 *);
	int (*resume)(struct device___2 *);
	int (*freeze)(struct device___2 *);
	int (*thaw)(struct device___2 *);
	int (*poweroff)(struct device___2 *);
	int (*restore)(struct device___2 *);
	int (*suspend_late)(struct device___2 *);
	int (*resume_early)(struct device___2 *);
	int (*freeze_late)(struct device___2 *);
	int (*thaw_early)(struct device___2 *);
	int (*poweroff_late)(struct device___2 *);
	int (*restore_early)(struct device___2 *);
	int (*suspend_noirq)(struct device___2 *);
	int (*resume_noirq)(struct device___2 *);
	int (*freeze_noirq)(struct device___2 *);
	int (*thaw_noirq)(struct device___2 *);
	int (*poweroff_noirq)(struct device___2 *);
	int (*restore_noirq)(struct device___2 *);
	int (*runtime_suspend)(struct device___2 *);
	int (*runtime_resume)(struct device___2 *);
	int (*runtime_idle)(struct device___2 *);
};

struct wakeup_source___2 {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	long unsigned int timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	long unsigned int event_count;
	long unsigned int active_count;
	long unsigned int relax_count;
	long unsigned int expire_count;
	long unsigned int wakeup_count;
	struct device___2 *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
};

struct dev_pm_domain___2 {
	struct dev_pm_ops___2 ops;
	void (*detach)(struct device___2 *, bool);
	int (*activate)(struct device___2 *);
	void (*sync)(struct device___2 *);
	void (*dismiss)(struct device___2 *);
};

struct dma_map_ops___2 {
	void * (*alloc)(struct device___2 *, size_t, dma_addr_t *, gfp_t, long unsigned int);
	void (*free)(struct device___2 *, size_t, void *, dma_addr_t, long unsigned int);
	int (*mmap)(struct device___2 *, struct vm_area_struct___2 *, void *, dma_addr_t, size_t, long unsigned int);
	int (*get_sgtable)(struct device___2 *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
	dma_addr_t (*map_page)(struct device___2 *, struct page___2 *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_page)(struct device___2 *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	int (*map_sg)(struct device___2 *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	void (*unmap_sg)(struct device___2 *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	dma_addr_t (*map_resource)(struct device___2 *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_resource)(struct device___2 *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*sync_single_for_cpu)(struct device___2 *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device___2 *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device___2 *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device___2 *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device___2 *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device___2 *, u64);
	u64 (*get_required_mask)(struct device___2 *);
	size_t (*max_mapping_size)(struct device___2 *);
	long unsigned int (*get_merge_boundary)(struct device___2 *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct bus_type___2 {
	const char *name;
	const char *dev_name;
	struct device___2 *dev_root;
	const struct attribute_group___2 **bus_groups;
	const struct attribute_group___2 **dev_groups;
	const struct attribute_group___2 **drv_groups;
	int (*match)(struct device___2 *, struct device_driver___2 *);
	int (*uevent)(struct device___2 *, struct kobj_uevent_env *);
	int (*probe)(struct device___2 *);
	int (*remove)(struct device___2 *);
	void (*shutdown)(struct device___2 *);
	int (*online)(struct device___2 *);
	int (*offline)(struct device___2 *);
	int (*suspend)(struct device___2 *, pm_message_t);
	int (*resume)(struct device___2 *);
	int (*num_vf)(struct device___2 *);
	int (*dma_configure)(struct device___2 *);
	const struct dev_pm_ops___2 *pm;
	const struct iommu_ops *iommu_ops;
	struct subsys_private *p;
	struct lock_class_key lock_key;
	bool need_parent_lock;
};

struct device_driver___2 {
	const char *name;
	struct bus_type___2 *bus;
	struct module___2 *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device___2 *);
	int (*remove)(struct device___2 *);
	void (*shutdown)(struct device___2 *);
	int (*suspend)(struct device___2 *, pm_message_t);
	int (*resume)(struct device___2 *);
	const struct attribute_group___2 **groups;
	const struct attribute_group___2 **dev_groups;
	const struct dev_pm_ops___2 *pm;
	void (*coredump)(struct device___2 *);
	struct driver_private *p;
};

struct device_type___2 {
	const char *name;
	const struct attribute_group___2 **groups;
	int (*uevent)(struct device___2 *, struct kobj_uevent_env *);
	char * (*devnode)(struct device___2 *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device___2 *);
	const struct dev_pm_ops___2 *pm;
};

struct class___2 {
	const char *name;
	struct module___2 *owner;
	const struct attribute_group___2 **class_groups;
	const struct attribute_group___2 **dev_groups;
	struct kobject___2 *dev_kobj;
	int (*dev_uevent)(struct device___2 *, struct kobj_uevent_env *);
	char * (*devnode)(struct device___2 *, umode_t *);
	void (*class_release)(struct class___2 *);
	void (*dev_release)(struct device___2 *);
	int (*shutdown_pre)(struct device___2 *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(struct device___2 *);
	void (*get_ownership)(struct device___2 *, kuid_t *, kgid_t *);
	const struct dev_pm_ops___2 *pm;
	struct subsys_private *p;
	long unsigned int kabi_reserved1;
};

struct device_attribute___2 {
	struct attribute attr;
	ssize_t (*show)(struct device___2 *, struct device_attribute___2 *, char *);
	ssize_t (*store)(struct device___2 *, struct device_attribute___2 *, const char *, size_t);
};

struct device_node___2 {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle___2 fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node___2 *parent;
	struct device_node___2 *child;
	struct device_node___2 *sibling;
	long unsigned int _flags;
	void *data;
};

struct fd___2 {
	struct file___2 *file;
	unsigned int flags;
};

typedef struct poll_table_struct___2 poll_table___2;

struct fqdir___2;

struct netns_ipv4___2 {
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain *ra_chain;
	struct mutex ra_mutex;
	struct fib_rules_ops *rules_ops;
	bool fib_has_custom_rules;
	unsigned int fib_rules_require_fldissect;
	struct fib_table *fib_main;
	struct fib_table *fib_default;
	bool fib_has_custom_local_routes;
	int fib_num_tclassid_users;
	struct hlist_head *fib_table_hash;
	bool fib_offload_disabled;
	struct sock *fibnl;
	struct sock **icmp_sk;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct sock **tcp_sk;
	struct fqdir___2 *fqdir;
	struct xt_table *iptable_filter;
	struct xt_table *iptable_mangle;
	struct xt_table *iptable_raw;
	struct xt_table *arptable_filter;
	struct xt_table *iptable_security;
	struct xt_table *nat_table;
	int sysctl_icmp_echo_ignore_all;
	int sysctl_icmp_echo_ignore_broadcasts;
	int sysctl_icmp_ignore_bogus_error_responses;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	int sysctl_icmp_errors_use_inbound_ifaddr;
	struct local_ports ip_local_ports;
	int sysctl_tcp_ecn;
	int sysctl_tcp_ecn_fallback;
	int sysctl_ip_default_ttl;
	int sysctl_ip_no_pmtu_disc;
	int sysctl_ip_fwd_use_pmtu;
	int sysctl_ip_fwd_update_priority;
	int sysctl_ip_nonlocal_bind;
	int sysctl_ip_dynaddr;
	int sysctl_ip_early_demux;
	int sysctl_raw_l3mdev_accept;
	int sysctl_tcp_early_demux;
	int sysctl_udp_early_demux;
	int sysctl_fwmark_reflect;
	int sysctl_tcp_fwmark_accept;
	int sysctl_tcp_l3mdev_accept;
	int sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_min_snd_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_probes;
	int sysctl_tcp_keepalive_intvl;
	int sysctl_tcp_syn_retries;
	int sysctl_tcp_synack_retries;
	int sysctl_tcp_syncookies;
	int sysctl_tcp_reordering;
	int sysctl_tcp_retries1;
	int sysctl_tcp_retries2;
	int sysctl_tcp_orphan_retries;
	int sysctl_tcp_fin_timeout;
	unsigned int sysctl_tcp_notsent_lowat;
	int sysctl_tcp_tw_reuse;
	int sysctl_tcp_sack;
	int sysctl_tcp_window_scaling;
	int sysctl_tcp_timestamps;
	int sysctl_tcp_early_retrans;
	int sysctl_tcp_recovery;
	int sysctl_tcp_thin_linear_timeouts;
	int sysctl_tcp_slow_start_after_idle;
	int sysctl_tcp_retrans_collapse;
	int sysctl_tcp_stdurg;
	int sysctl_tcp_rfc1337;
	int sysctl_tcp_abort_on_overflow;
	int sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_dsack;
	int sysctl_tcp_app_win;
	int sysctl_tcp_adv_win_scale;
	int sysctl_tcp_frto;
	int sysctl_tcp_nometrics_save;
	int sysctl_tcp_moderate_rcvbuf;
	int sysctl_tcp_tso_win_divisor;
	int sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_challenge_ack_limit;
	int sysctl_tcp_min_tso_segs;
	int sysctl_tcp_min_rtt_wlen;
	int sysctl_tcp_autocorking;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	int sysctl_tcp_wmem[3];
	int sysctl_tcp_rmem[3];
	int sysctl_tcp_comp_sack_nr;
	long unsigned int sysctl_tcp_comp_sack_delay_ns;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct inet_timewait_death_row tcp_death_row;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops *tcp_congestion_control;
	struct tcp_fastopen_context *tcp_fastopen_ctx;
	spinlock_t tcp_fastopen_ctx_lock;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	long unsigned int tfo_active_disable_stamp;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	int sysctl_udp_l3mdev_accept;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_llm_reports;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	long unsigned int *sysctl_local_reserved_ports;
	int sysctl_ip_prot_sock;
	struct list_head mr_tables;
	struct fib_rules_ops *mr_rules_ops;
	int sysctl_fib_multipath_use_neigh;
	int sysctl_fib_multipath_hash_policy;
	int sysctl_tw_timeout;
	int sysctl_tcp_max_orphans;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	siphash_key_t ip_id_key;
	int sysctl_tcp_wan_timestamps;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct net_device___2;

struct sk_buff___2;

struct dst_ops___2 {
	short unsigned int family;
	unsigned int gc_thresh;
	int (*gc)(struct dst_ops___2 *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device___2 *, int);
	struct dst_entry * (*negative_advice)(struct dst_entry *);
	void (*link_failure)(struct sk_buff___2 *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff___2 *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff___2 *);
	int (*local_out)(struct net___2 *, struct sock *, struct sk_buff___2 *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff___2 *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct percpu_counter pcpuc_entries;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_ipv6___2 {
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir___2 *fqdir;
	struct xt_table *ip6table_filter;
	struct xt_table *ip6table_mangle;
	struct xt_table *ip6table_raw;
	struct xt_table *ip6table_security;
	struct xt_table *ip6table_nat;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dst_ops___2 ip6_dst_ops;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	unsigned int ip6_rt_gc_expire;
	long unsigned int ip6_rt_last_gc;
	unsigned int fib6_rules_require_fldissect;
	bool fib6_has_custom_rules;
	struct rt6_info *ip6_prohibit_entry;
	struct rt6_info *ip6_blk_hole_entry;
	struct fib6_table *fib6_local_tbl;
	struct fib_rules_ops *fib6_rules_ops;
	struct sock **icmp_sk;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	struct list_head mr6_tables;
	struct fib_rules_ops *mr6_rules_ops;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	long: 64;
};

struct netns_nf_frag___2 {
	struct fqdir___2 *fqdir;
};

struct bpf_prog_array___2;

struct netns_bpf___2 {
	struct bpf_prog_array___2 *run_array[2];
	struct bpf_prog___2 *progs[2];
	struct list_head links[2];
};

struct netns_xfrm___2 {
	struct list_head state_all;
	struct hlist_head *state_bydst;
	struct hlist_head *state_bysrc;
	struct hlist_head *state_byspi;
	unsigned int state_hmask;
	unsigned int state_num;
	struct work_struct state_hash_work;
	struct list_head policy_all;
	struct hlist_head *policy_byidx;
	unsigned int policy_idx_hmask;
	struct hlist_head policy_inexact[3];
	struct xfrm_policy_hash policy_bydst[3];
	unsigned int policy_count[6];
	struct work_struct policy_hash_work;
	struct xfrm_policy_hthresh policy_hthresh;
	struct list_head inexact_bins;
	struct sock *nlsk;
	struct sock *nlsk_stash;
	u32 sysctl_aevent_etime;
	u32 sysctl_aevent_rseqth;
	int sysctl_larval_drop;
	u32 sysctl_acq_expires;
	struct ctl_table_header *sysctl_hdr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dst_ops___2 xfrm4_dst_ops;
	struct dst_ops___2 xfrm6_dst_ops;
	spinlock_t xfrm_state_lock;
	seqcount_t xfrm_state_hash_generation;
	spinlock_t xfrm_policy_lock;
	struct mutex xfrm_cfg_mutex;
	long: 64;
	long: 64;
};

struct net___2 {
	refcount_t passive;
	refcount_t count;
	spinlock_t rules_mod_lock;
	unsigned int dev_unreg_count;
	unsigned int dev_base_seq;
	int ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace___2 *user_ns;
	struct ucounts___2 *ucounts;
	struct idr netns_ids;
	struct ns_common___2 ns;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	u32 hash_mix;
	struct net_device___2 *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct netns_ipv4___2 ipv4;
	struct netns_mptcp mptcp;
	long: 64;
	long: 64;
	long: 64;
	struct netns_ipv6___2 ipv6;
	struct netns_nf nf;
	struct netns_xt xt;
	struct netns_ct ct;
	struct netns_nftables nft;
	struct netns_nf_frag___2 nf_frag;
	struct ctl_table_header *nf_frag_frags_hdr;
	struct sock *nfnl;
	struct sock *nfnl_stash;
	struct list_head nfnl_acct_list;
	struct list_head nfct_timeout_list;
	struct net_generic *gen;
	struct netns_bpf___2 bpf;
	struct netns_xfrm___2 xfrm;
	u64 net_cookie;
	struct netns_ipvs *ipvs;
	struct netns_mpls mpls;
	struct netns_xdp xdp;
	struct sock *crypto_nlsk;
	struct sock *diag_nlsk;
	long: 64;
	long: 64;
	long: 64;
};

struct cgroup_namespace___2 {
	refcount_t count;
	struct ns_common___2 ns;
	struct user_namespace___2 *user_ns;
	struct ucounts___2 *ucounts;
	struct css_set___2 *root_cset;
};

struct proc_ns_operations___2 {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common___2 * (*get)(struct task_struct___2 *);
	void (*put)(struct ns_common___2 *);
	int (*install)(struct nsproxy___2 *, struct ns_common___2 *);
	struct user_namespace___2 * (*owner)(struct ns_common___2 *);
	struct ns_common___2 * (*get_parent)(struct ns_common___2 *);
};

struct ucounts___2 {
	struct hlist_node node;
	struct user_namespace___2 *ns;
	kuid_t uid;
	int count;
	atomic_t ucount[9];
};

enum perf_event_read_format {
	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
	PERF_FORMAT_ID = 4,
	PERF_FORMAT_GROUP = 8,
	PERF_FORMAT_MAX = 16,
};

enum perf_event_ioc_flags {
	PERF_IOC_FLAG_GROUP = 1,
};

struct perf_ns_link_info {
	__u64 dev;
	__u64 ino;
};

enum {
	NET_NS_INDEX = 0,
	UTS_NS_INDEX = 1,
	IPC_NS_INDEX = 2,
	PID_NS_INDEX = 3,
	USER_NS_INDEX = 4,
	MNT_NS_INDEX = 5,
	CGROUP_NS_INDEX = 6,
	NR_NAMESPACES = 7,
};

enum perf_event_type {
	PERF_RECORD_MMAP = 1,
	PERF_RECORD_LOST = 2,
	PERF_RECORD_COMM = 3,
	PERF_RECORD_EXIT = 4,
	PERF_RECORD_THROTTLE = 5,
	PERF_RECORD_UNTHROTTLE = 6,
	PERF_RECORD_FORK = 7,
	PERF_RECORD_READ = 8,
	PERF_RECORD_SAMPLE = 9,
	PERF_RECORD_MMAP2 = 10,
	PERF_RECORD_AUX = 11,
	PERF_RECORD_ITRACE_START = 12,
	PERF_RECORD_LOST_SAMPLES = 13,
	PERF_RECORD_SWITCH = 14,
	PERF_RECORD_SWITCH_CPU_WIDE = 15,
	PERF_RECORD_NAMESPACES = 16,
	PERF_RECORD_KSYMBOL = 17,
	PERF_RECORD_BPF_EVENT = 18,
	PERF_RECORD_MAX = 19,
};

enum perf_record_ksymbol_type {
	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
	PERF_RECORD_KSYMBOL_TYPE_MAX = 2,
};

struct perf_cpu_context___2;

struct pmu___2 {
	struct list_head entry;
	struct module___2 *module;
	struct device___2 *dev;
	const struct attribute_group___2 **attr_groups;
	const struct attribute_group___2 **attr_update;
	const char *name;
	int type;
	int capabilities;
	int *pmu_disable_count;
	struct perf_cpu_context___2 *pmu_cpu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu___2 *);
	void (*pmu_disable)(struct pmu___2 *);
	int (*event_init)(struct perf_event___2 *);
	void (*event_mapped)(struct perf_event___2 *, struct mm_struct___2 *);
	void (*event_unmapped)(struct perf_event___2 *, struct mm_struct___2 *);
	int (*add)(struct perf_event___2 *, int);
	void (*del)(struct perf_event___2 *, int);
	void (*start)(struct perf_event___2 *, int);
	void (*stop)(struct perf_event___2 *, int);
	void (*read)(struct perf_event___2 *);
	void (*start_txn)(struct pmu___2 *, unsigned int);
	int (*commit_txn)(struct pmu___2 *);
	void (*cancel_txn)(struct pmu___2 *);
	int (*event_idx)(struct perf_event___2 *);
	void (*sched_task)(struct perf_event_context___2 *, bool);
	size_t task_ctx_size;
	void * (*setup_aux)(struct perf_event___2 *, void **, int, bool);
	void (*free_aux)(void *);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event___2 *);
	int (*aux_output_match)(struct perf_event___2 *);
	int (*filter_match)(struct perf_event___2 *);
	int (*check_period)(struct perf_event___2 *, u64);
};

struct kernel_param_ops___2 {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param___2 *);
	int (*get)(char *, const struct kernel_param___2 *);
	void (*free)(void *);
};

struct kparam_array___2;

struct kernel_param___2 {
	const char *name;
	struct module___2 *mod;
	const struct kernel_param_ops___2 *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array___2 *arr;
	};
};

struct kparam_array___2 {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops___2 *ops;
	void *elem;
};

struct module_attribute___2 {
	struct attribute attr;
	ssize_t (*show)(struct module_attribute___2 *, struct module_kobject___2 *, char *);
	ssize_t (*store)(struct module_attribute___2 *, struct module_kobject___2 *, const char *, size_t);
	void (*setup)(struct module___2 *, const char *);
	int (*test)(struct module___2 *);
	void (*free)(struct module___2 *);
};

struct trace_event_class___2;

struct trace_event_call___2 {
	struct list_head list;
	struct trace_event_class___2 *class;
	union {
		char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	struct event_filter *filter;
	void *mod;
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head *perf_events;
	struct bpf_prog_array___2 *prog_array;
	int (*perf_perm)(struct trace_event_call___2 *, struct perf_event___2 *);
};

struct bio_vec___2 {
	struct page___2 *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct bpf_iter_aux_info___2;

typedef int (*bpf_iter_init_seq_priv_t___2)(void *, struct bpf_iter_aux_info___2 *);

struct bpf_map___2;

struct bpf_iter_aux_info___2 {
	struct bpf_map___2 *map;
};

struct bpf_iter_seq_info___2 {
	const struct seq_operations___2 *seq_ops;
	bpf_iter_init_seq_priv_t___2 init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct bpf_prog_aux___2;

struct bpf_map_ops___2 {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map___2 * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map___2 *, struct file___2 *);
	void (*map_free)(struct bpf_map___2 *);
	int (*map_get_next_key)(struct bpf_map___2 *, void *, void *);
	void (*map_release_uref)(struct bpf_map___2 *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map___2 *, void *);
	void * (*map_lookup_elem)(struct bpf_map___2 *, void *);
	int (*map_update_elem)(struct bpf_map___2 *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_map___2 *, void *);
	int (*map_push_elem)(struct bpf_map___2 *, void *, u64);
	int (*map_pop_elem)(struct bpf_map___2 *, void *);
	int (*map_peek_elem)(struct bpf_map___2 *, void *);
	void * (*map_fd_get_ptr)(struct bpf_map___2 *, struct file___2 *, int);
	void (*map_fd_put_ptr)(void *);
	int (*map_gen_lookup)(struct bpf_map___2 *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map___2 *, void *, struct seq_file___2 *);
	int (*map_check_btf)(const struct bpf_map___2 *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map___2 *, struct bpf_prog_aux___2 *);
	void (*map_poke_untrack)(struct bpf_map___2 *, struct bpf_prog_aux___2 *);
	void (*map_poke_run)(struct bpf_map___2 *, u32, struct bpf_prog___2 *, struct bpf_prog___2 *);
	int (*map_direct_value_addr)(const struct bpf_map___2 *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map___2 *, u64, u32 *);
	int (*map_mmap)(struct bpf_map___2 *, struct vm_area_struct___2 *);
	__poll_t (*map_poll)(struct bpf_map___2 *, struct file___2 *, struct poll_table_struct___2 *);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
	int (*map_set_for_each_callback_args)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *);
	int (*map_for_each_callback)(struct bpf_map___2 *, void *, void *, u64);
	const char * const map_btf_name;
	int *map_btf_id;
	const struct bpf_iter_seq_info___2 *iter_seq_info;
};

struct bpf_map___2 {
	const struct bpf_map_ops___2 *ops;
	struct bpf_map___2 *inner_map_meta;
	void *security;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u32 map_flags;
	int spin_lock_off;
	int timer_off;
	u32 id;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	struct btf *btf;
	struct bpf_map_memory memory;
	char name[16];
	u32 btf_vmlinux_value_type_id;
	bool bypass_spec_v1;
	bool frozen;
	long: 16;
	long: 64;
	atomic64_t refcnt;
	atomic64_t usercnt;
	struct work_struct work;
	struct mutex freeze_mutex;
	u64 writecnt;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_trampoline___2;

struct bpf_jit_poke_descriptor___2;

struct bpf_prog_ops___2;

struct bpf_prog_offload___2;

struct bpf_prog_aux___2 {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	struct bpf_prog___2 *linked_prog;
	bool verifier_zext;
	bool offload_requested;
	bool attach_btf_trace;
	bool func_proto_unreliable;
	enum bpf_tramp_prog_type trampoline_prog_type;
	struct bpf_trampoline___2 *trampoline;
	struct hlist_node tramp_hlist;
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog___2 **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor___2 *poke_tab;
	u32 size_poke_tab;
	struct latch_tree_node ksym_tnode;
	struct list_head ksym_lnode;
	const struct bpf_prog_ops___2 *ops;
	struct bpf_map___2 **used_maps;
	struct bpf_prog___2 *prog;
	struct user_struct *user;
	u64 load_time;
	struct bpf_map___2 *cgroup_storage[2];
	char name[16];
	void *security;
	struct bpf_prog_offload___2 *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	u32 num_exentries;
	struct exception_table_entry *extable;
	struct bpf_prog_stats *stats;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
};

struct bpf_prog___2 {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_aux___2 *aux;
	struct sock_fprog_kern *orig_prog;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	union {
		struct sock_filter insns[0];
		struct bpf_insn insnsi[0];
	};
};

struct bpf_offloaded_map___2;

struct bpf_map_dev_ops___2 {
	int (*map_get_next_key)(struct bpf_offloaded_map___2 *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map___2 *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map___2 *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map___2 *, void *);
};

struct bpf_offloaded_map___2 {
	struct bpf_map___2 map;
	struct net_device___2 *netdev;
	const struct bpf_map_dev_ops___2 *dev_ops;
	void *dev_priv;
	struct list_head offloads;
	long: 64;
	long: 64;
	long: 64;
};

typedef rx_handler_result_t rx_handler_func_t___2(struct sk_buff___2 **);

typedef struct {
	struct net___2 *net;
} possible_net_t___2;

struct net_device_ops___2;

struct ethtool_ops___2;

struct xfrmdev_ops___2;

struct header_ops___2;

struct netdev_rx_queue___2;

struct mini_Qdisc___2;

struct netdev_queue___2;

struct Qdisc___2;

struct rtnl_link_ops___2;

struct dcbnl_rtnl_ops___2;

struct net_device___2 {
	char name[16];
	struct hlist_node name_hlist;
	struct dev_ifalias *ifalias;
	long unsigned int mem_end;
	long unsigned int mem_start;
	long unsigned int base_addr;
	int irq;
	long unsigned int state;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct list_head ptype_specific;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	netdev_features_t features;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	netdev_features_t gso_partial_features;
	int ifindex;
	int group;
	struct net_device_stats stats;
	struct netdev_mib mib;
	atomic_long_t rx_dropped;
	atomic_long_t tx_dropped;
	atomic_long_t rx_nohandler;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct net_device_ops___2 *netdev_ops;
	const struct ethtool_ops___2 *ethtool_ops;
	const struct l3mdev_ops *l3mdev_ops;
	const struct ndisc_ops *ndisc_ops;
	const struct xfrmdev_ops___2 *xfrmdev_ops;
	const struct header_ops___2 *header_ops;
	unsigned int flags;
	unsigned int priv_flags;
	short unsigned int gflags;
	short unsigned int padded;
	unsigned char operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned int mtu;
	unsigned int min_mtu;
	unsigned int max_mtu;
	short unsigned int type;
	short unsigned int hard_header_len;
	unsigned char min_header_len;
	short unsigned int needed_headroom;
	short unsigned int needed_tailroom;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	short unsigned int neigh_priv_len;
	short unsigned int dev_id;
	short unsigned int dev_port;
	spinlock_t addr_list_lock;
	unsigned char name_assign_type;
	bool uc_promisc;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	struct kset___2 *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	struct vlan_info *vlan_info;
	struct in_device *ip_ptr;
	struct inet6_dev *ip6_ptr;
	struct wireless_dev *ieee80211_ptr;
	struct wpan_dev *ieee802154_ptr;
	unsigned char *dev_addr;
	struct netdev_rx_queue___2 *_rx;
	unsigned int num_rx_queues;
	unsigned int real_num_rx_queues;
	struct bpf_prog___2 *xdp_prog;
	long unsigned int gro_flush_timeout;
	rx_handler_func_t___2 *rx_handler;
	void *rx_handler_data;
	struct mini_Qdisc___2 *miniq_ingress;
	struct netdev_queue___2 *ingress_queue;
	struct nf_hook_entries *nf_hooks_ingress;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	struct netdev_queue___2 *_tx;
	unsigned int num_tx_queues;
	unsigned int real_num_tx_queues;
	struct Qdisc___2 *qdisc;
	struct hlist_head qdisc_hash[16];
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	int watchdog_timeo;
	struct xps_dev_maps *xps_cpus_map;
	struct xps_dev_maps *xps_rxqs_map;
	struct mini_Qdisc___2 *miniq_egress;
	struct timer_list watchdog_timer;
	int *pcpu_refcnt;
	struct list_head todo_list;
	struct list_head link_watch_list;
	enum {
		NETREG_UNINITIALIZED___2 = 0,
		NETREG_REGISTERED___2 = 1,
		NETREG_UNREGISTERING___2 = 2,
		NETREG_UNREGISTERED___2 = 3,
		NETREG_RELEASED___2 = 4,
		NETREG_DUMMY___2 = 5,
	} reg_state: 8;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED___2 = 0,
		RTNL_LINK_INITIALIZING___2 = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device___2 *);
	struct netpoll_info *npinfo;
	possible_net_t___2 nd_net;
	void *ml_priv;
	enum netdev_ml_priv_type ml_priv_type;
	union {
		struct pcpu_lstats *lstats;
		struct pcpu_sw_netstats *tstats;
		struct pcpu_dstats *dstats;
	};
	struct garp_port *garp_port;
	struct mrp_port *mrp_port;
	struct device___2 dev;
	const struct attribute_group___2 *sysfs_groups[4];
	const struct attribute_group___2 *sysfs_rx_queue_group;
	const struct rtnl_link_ops___2 *rtnl_link_ops;
	unsigned int gso_max_size;
	u16 gso_max_segs;
	const struct dcbnl_rtnl_ops___2 *dcbnl_ops;
	s16 num_tc;
	struct netdev_tc_txq tc_to_txq[16];
	u8 prio_tc_map[16];
	unsigned int fcoe_ddp_xid;
	struct netprio_map *priomap;
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key qdisc_tx_busylock_key;
	struct lock_class_key qdisc_running_key;
	struct lock_class_key qdisc_xmit_lock_key;
	struct lock_class_key addr_list_lock_key;
	bool proto_down;
	unsigned int wol_enabled: 1;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
};

struct bpf_prog_ops___2 {
	int (*test_run)(struct bpf_prog___2 *, const union bpf_attr *, union bpf_attr *);
};

struct bpf_prog_offload___2 {
	struct bpf_prog___2 *prog;
	struct net_device___2 *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct bpf_trampoline___2 {
	struct hlist_node hlist;
	struct mutex mutex;
	refcount_t refcnt;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
	} func;
	struct bpf_prog___2 *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	void *image;
	u64 selector;
};

struct bpf_jit_poke_descriptor___2 {
	void *ip;
	union {
		struct {
			struct bpf_map___2 *map;
			u32 key;
		} tail_call;
	};
	bool ip_stable;
	u8 adj_off;
	u16 reason;
};

struct bpf_prog_array_item___2 {
	struct bpf_prog___2 *prog;
	struct bpf_cgroup_storage *cgroup_storage[2];
};

struct bpf_prog_array___2 {
	struct callback_head rcu;
	struct bpf_prog_array_item___2 items[0];
};

struct sk_buff___2 {
	union {
		struct {
			struct sk_buff___2 *next;
			struct sk_buff___2 *prev;
			union {
				struct net_device___2 *dev;
				long unsigned int dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
	};
	union {
		struct sock *sk;
		int ip_defrag_offset;
	};
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			long unsigned int _skb_refdst;
			void (*destructor)(struct sk_buff___2 *);
		};
		struct list_head tcp_tsorted_anchor;
	};
	long unsigned int _nfct;
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u8 active_extensions;
	__u32 headers_start[0];
	__u8 __pkt_type_offset[0];
	__u8 pkt_type: 3;
	__u8 ignore_df: 1;
	__u8 nf_trace: 1;
	__u8 ip_summed: 2;
	__u8 ooo_okay: 1;
	__u8 l4_hash: 1;
	__u8 sw_hash: 1;
	__u8 wifi_acked_valid: 1;
	__u8 wifi_acked: 1;
	__u8 no_fcs: 1;
	__u8 encapsulation: 1;
	__u8 encap_hdr_csum: 1;
	__u8 csum_valid: 1;
	__u8 __pkt_vlan_present_offset[0];
	__u8 vlan_present: 1;
	__u8 csum_complete_sw: 1;
	__u8 csum_level: 2;
	__u8 csum_not_inet: 1;
	__u8 dst_pending_confirm: 1;
	__u8 ndisc_nodetype: 2;
	__u8 ipvs_property: 1;
	__u8 inner_protocol_type: 1;
	__u8 remcsum_offload: 1;
	__u8 tc_skip_classify: 1;
	__u8 tc_at_ingress: 1;
	__u8 redirected: 1;
	__u8 from_ingress: 1;
	__u16 tc_index;
	union {
		__wsum csum;
		struct {
			__u16 csum_start;
			__u16 csum_offset;
		};
	};
	__u32 priority;
	int skb_iif;
	__u32 hash;
	__be16 vlan_proto;
	__u16 vlan_tci;
	union {
		unsigned int napi_id;
		unsigned int sender_cpu;
	};
	__u32 secmark;
	union {
		__u32 mark;
		__u32 reserved_tailroom;
	};
	union {
		__be16 inner_protocol;
		__u8 inner_ipproto;
	};
	__u16 inner_transport_header;
	__u16 inner_network_header;
	__u16 inner_mac_header;
	__be16 protocol;
	__u16 transport_header;
	__u16 network_header;
	__u16 mac_header;
	__u32 headers_end[0];
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
	struct skb_ext *extensions;
};

struct cgroup_subsys___2;

struct cgroup_subsys_state___2 {
	struct cgroup___2 *cgroup;
	struct cgroup_subsys___2 *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state___2 *parent;
};

struct cgroup_file___2 {
	struct kernfs_node___2 *kn;
	long unsigned int notified_at;
	struct timer_list notify_timer;
};

struct kthread_work___2;

typedef void (*kthread_work_func_t___2)(struct kthread_work___2 *);

struct kthread_worker___2;

struct kthread_work___2 {
	struct list_head node;
	kthread_work_func_t___2 func;
	struct kthread_worker___2 *worker;
	int canceling;
};

struct kthread_delayed_work___2 {
	struct kthread_work___2 work;
	struct timer_list timer;
};

struct psi_group___2 {
	struct mutex avgs_lock;
	struct psi_group_cpu *pcpu;
	u64 avg_total[5];
	u64 avg_last_update;
	u64 avg_next_update;
	struct delayed_work avgs_work;
	u64 total[10];
	long unsigned int avg[15];
	atomic_t poll_scheduled;
	struct kthread_worker___2 *poll_kworker;
	struct kthread_delayed_work___2 poll_work;
	struct mutex trigger_lock;
	struct list_head triggers;
	u32 nr_triggers[5];
	u32 poll_states;
	u64 poll_min_period;
	u64 polling_total[5];
	u64 polling_next_update;
	u64 polling_until;
};

struct cgroup_bpf___2 {
	struct bpf_prog_array___2 *effective[45];
	struct list_head progs[45];
	u32 flags[45];
	struct bpf_prog_array___2 *inactive;
	struct percpu_ref refcnt;
	struct work_struct release_work;
};

struct cgroup_root___2;

struct cgroup_rstat_cpu___2;

struct mbuf_slot___2;

struct sli_event_monitor___2;

struct cgroup___2 {
	struct cgroup_subsys_state___2 self;
	long unsigned int flags;
	int id;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	struct kernfs_node___2 *kn;
	struct cgroup_file___2 procs_file;
	struct cgroup_file___2 events_file;
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state___2 *subsys[12];
	struct cgroup_root___2 *root;
	struct list_head cset_links;
	struct list_head e_csets[12];
	struct cgroup___2 *dom_cgrp;
	struct cgroup___2 *old_dom_cgrp;
	struct cgroup_rstat_cpu___2 *rstat_cpu;
	struct list_head rstat_css_list;
	struct cgroup_base_stat pending_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group___2 psi;
	struct cgroup_bpf___2 bpf;
	atomic_t congestion_count;
	struct cgroup_freezer_state freezer;
	struct mbuf_slot___2 *mbuf;
	struct sli_memlat_stat *sli_memlat_stat_percpu;
	struct sli_schedlat_stat *sli_schedlat_stat_percpu;
	struct sli_event_monitor___2 *cgrp_event_monitor;
	struct sli_notify_ctx *sctx;
	spinlock_t cgrp_mbuf_lock;
	int ancestor_ids[0];
};

struct kthread_worker___2 {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct___2 *task;
	struct kthread_work___2 *current_work;
};

struct mbuf_operations___2;

struct mbuf_slot___2 {
	u32 idx;
	spinlock_t slot_lock;
	struct ratelimit_state ratelimit;
	struct cgroup___2 *owner;
	const struct mbuf_operations___2 *ops;
	struct mbuf_ring *mring;
	struct mbuf_user_desc *udesc;
};

struct mbuf_operations___2 {
	ssize_t (*read)(struct mbuf_slot___2 *, struct mbuf_user_desc *);
	u32 (*next)(struct mbuf_ring *, u32);
	ssize_t (*write)(struct cgroup___2 *, const char *, struct __va_list_tag *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cftype___2;

struct cgroup_subsys___2 {
	struct cgroup_subsys_state___2 * (*css_alloc)(struct cgroup_subsys_state___2 *);
	int (*css_online)(struct cgroup_subsys_state___2 *);
	void (*css_offline)(struct cgroup_subsys_state___2 *);
	void (*css_released)(struct cgroup_subsys_state___2 *);
	void (*css_free)(struct cgroup_subsys_state___2 *);
	void (*css_reset)(struct cgroup_subsys_state___2 *);
	void (*css_rstat_flush)(struct cgroup_subsys_state___2 *, int);
	int (*css_extra_stat_show)(struct seq_file___2 *, struct cgroup_subsys_state___2 *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)();
	int (*can_fork)(struct task_struct___2 *);
	void (*cancel_fork)(struct task_struct___2 *);
	void (*fork)(struct task_struct___2 *);
	void (*exit)(struct task_struct___2 *);
	void (*release)(struct task_struct___2 *);
	void (*bind)(struct cgroup_subsys_state___2 *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	bool broken_hierarchy: 1;
	bool warned_broken_hierarchy: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root___2 *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype___2 *dfl_cftypes;
	struct cftype___2 *legacy_cftypes;
	unsigned int depends_on;
};

struct cgroup_rstat_cpu___2 {
	struct u64_stats_sync bsync;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup___2 *updated_children;
	struct cgroup___2 *updated_next;
};

struct cgroup_root___2 {
	struct kernfs_root___2 *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	struct cgroup___2 cgrp;
	int cgrp_ancestor_id_storage;
	atomic_t nr_cgrps;
	struct list_head root_list;
	unsigned int flags;
	struct idr cgroup_idr;
	char release_agent_path[4096];
	char name[64];
};

struct sli_event_monitor___2 {
	struct list_head event_head;
	struct work_struct sli_event_work;
	struct cgroup___2 *cgrp;
	int period;
	int mbuf_enable;
	int overrun;
	long long unsigned int last_update;
	long long unsigned int schedlat_threshold[7];
	long long unsigned int schedlat_count[7];
	atomic_long_t schedlat_statistics[7];
	long long unsigned int memlat_threshold[6];
	long long unsigned int memlat_count[6];
	atomic_long_t memlat_statistics[6];
	long long unsigned int longterm_threshold[2];
	atomic_long_t longterm_statistics[2];
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct cftype___2 {
	char name[64];
	long unsigned int private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys___2 *ss;
	struct list_head node;
	struct kernfs_ops___2 *kf_ops;
	int (*open)(struct kernfs_open_file___2 *);
	void (*release)(struct kernfs_open_file___2 *);
	u64 (*read_u64)(struct cgroup_subsys_state___2 *, struct cftype___2 *);
	s64 (*read_s64)(struct cgroup_subsys_state___2 *, struct cftype___2 *);
	int (*seq_show)(struct seq_file___2 *, void *);
	void * (*seq_start)(struct seq_file___2 *, loff_t *);
	void * (*seq_next)(struct seq_file___2 *, void *, loff_t *);
	void (*seq_stop)(struct seq_file___2 *, void *);
	int (*write_u64)(struct cgroup_subsys_state___2 *, struct cftype___2 *, u64);
	int (*write_s64)(struct cgroup_subsys_state___2 *, struct cftype___2 *, s64);
	ssize_t (*write)(struct kernfs_open_file___2 *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file___2 *, struct poll_table_struct___2 *);
};

struct perf_cpu_context___2 {
	struct perf_event_context___2 ctx;
	struct perf_event_context___2 *task_ctx;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
	struct perf_cgroup___2 *cgrp;
	struct list_head cgrp_cpuctx_entry;
	struct list_head sched_cb_entry;
	int sched_cb_usage;
	int online;
};

struct perf_addr_filter___2 {
	struct list_head entry;
	struct path___2 path;
	long unsigned int offset;
	long unsigned int size;
	enum perf_addr_filter_action_t action;
};

struct swevent_hlist {
	struct hlist_head heads[256];
	struct callback_head callback_head;
};

struct pmu_event_list {
	raw_spinlock_t lock;
	struct list_head list;
};

struct ring_buffer___2 {
	refcount_t refcount;
	struct callback_head callback_head;
	int nr_pages;
	int overwrite;
	int paused;
	atomic_t poll;
	local_t head;
	unsigned int nest;
	local_t events;
	local_t wakeup;
	local_t lost;
	long int watermark;
	long int aux_watermark;
	spinlock_t event_lock;
	struct list_head event_list;
	atomic_t mmap_count;
	long unsigned int mmap_locked;
	struct user_struct *mmap_user;
	long int aux_head;
	unsigned int aux_nest;
	long int aux_wakeup;
	long unsigned int aux_pgoff;
	int aux_nr_pages;
	int aux_overwrite;
	atomic_t aux_mmap_count;
	long unsigned int aux_mmap_locked;
	void (*free_aux)(void *);
	refcount_t aux_refcount;
	void **aux_pages;
	void *aux_priv;
	struct perf_event_mmap_page *user_page;
	void *data_pages[0];
};

struct perf_cgroup___2 {
	struct cgroup_subsys_state___2 css;
	struct perf_cgroup_info *info;
};

struct perf_output_handle___2 {
	struct perf_event___2 *event;
	struct ring_buffer___2 *rb;
	long unsigned int wakeup;
	long unsigned int size;
	u64 aux_flags;
	union {
		void *addr;
		long unsigned int head;
	};
	int page;
};

struct bpf_perf_event_data_kern___2 {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event___2 *event;
};

struct perf_pmu_events_attr___2 {
	struct device_attribute___2 attr;
	u64 id;
	const char *event_str;
};

struct trace_event_class___2 {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call___2 *, enum trace_reg, void *);
	int (*define_fields)(struct trace_event_call___2 *);
	struct list_head * (*get_fields)(struct trace_event_call___2 *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call___2 *);
};

struct syscall_metadata___2 {
	const char *name;
	int syscall_nr;
	int nb_args;
	const char **types;
	const char **args;
	struct list_head enter_fields;
	struct trace_event_call___2 *enter_event;
	struct trace_event_call___2 *exit_event;
};

struct pipe_buf_operations___2;

struct pipe_buffer___2 {
	struct page___2 *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations___2 *ops;
	unsigned int flags;
	long unsigned int private;
};

struct pipe_buf_operations___2 {
	int (*confirm)(struct pipe_inode_info___2 *, struct pipe_buffer___2 *);
	void (*release)(struct pipe_inode_info___2 *, struct pipe_buffer___2 *);
	int (*steal)(struct pipe_inode_info___2 *, struct pipe_buffer___2 *);
	bool (*get)(struct pipe_inode_info___2 *, struct pipe_buffer___2 *);
};

struct sk_buff_head___2 {
	struct sk_buff___2 *next;
	struct sk_buff___2 *prev;
	__u32 qlen;
	spinlock_t lock;
};

struct ethtool_ops___2 {
	void (*get_drvinfo)(struct net_device___2 *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device___2 *);
	void (*get_regs)(struct net_device___2 *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device___2 *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device___2 *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device___2 *);
	void (*set_msglevel)(struct net_device___2 *, u32);
	int (*nway_reset)(struct net_device___2 *);
	u32 (*get_link)(struct net_device___2 *);
	int (*get_eeprom_len)(struct net_device___2 *);
	int (*get_eeprom)(struct net_device___2 *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device___2 *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device___2 *, struct ethtool_coalesce *);
	int (*set_coalesce)(struct net_device___2 *, struct ethtool_coalesce *);
	void (*get_ringparam)(struct net_device___2 *, struct ethtool_ringparam *);
	int (*set_ringparam)(struct net_device___2 *, struct ethtool_ringparam *);
	void (*get_pauseparam)(struct net_device___2 *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device___2 *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device___2 *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device___2 *, u32, u8 *);
	int (*set_phys_id)(struct net_device___2 *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device___2 *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device___2 *);
	void (*complete)(struct net_device___2 *);
	u32 (*get_priv_flags)(struct net_device___2 *);
	int (*set_priv_flags)(struct net_device___2 *, u32);
	int (*get_sset_count)(struct net_device___2 *, int);
	int (*get_rxnfc)(struct net_device___2 *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device___2 *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device___2 *, struct ethtool_flash *);
	int (*reset)(struct net_device___2 *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device___2 *);
	u32 (*get_rxfh_indir_size)(struct net_device___2 *);
	int (*get_rxfh)(struct net_device___2 *, u32 *, u8 *, u8 *);
	int (*set_rxfh)(struct net_device___2 *, const u32 *, const u8 *, const u8);
	int (*get_rxfh_context)(struct net_device___2 *, u32 *, u8 *, u8 *, u32);
	int (*set_rxfh_context)(struct net_device___2 *, const u32 *, const u8 *, const u8, u32 *, bool);
	void (*get_channels)(struct net_device___2 *, struct ethtool_channels *);
	int (*set_channels)(struct net_device___2 *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device___2 *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device___2 *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device___2 *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device___2 *, struct ethtool_ts_info *);
	int (*get_module_info)(struct net_device___2 *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device___2 *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device___2 *, struct ethtool_eee *);
	int (*set_eee)(struct net_device___2 *, struct ethtool_eee *);
	int (*get_tunable)(struct net_device___2 *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device___2 *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device___2 *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device___2 *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device___2 *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device___2 *, const struct ethtool_link_ksettings *);
	int (*get_fecparam)(struct net_device___2 *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device___2 *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device___2 *, struct ethtool_stats *, u64 *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct inet_frags___2;

struct fqdir___2 {
	long int high_thresh;
	long int low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags___2 *f;
	struct net___2 *net;
	bool dead;
	long: 56;
	long: 64;
	long: 64;
	struct rhashtable rhashtable;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t mem;
	struct work_struct destroy_work;
	long: 64;
};

struct inet_frag_queue___2;

struct inet_frags___2 {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue___2 *, const void *);
	void (*destructor)(struct inet_frag_queue___2 *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct inet_frag_queue___2 {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff___2 *fragments_tail;
	struct sk_buff___2 *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	__u8 flags;
	u16 max_size;
	struct fqdir___2 *fqdir;
	struct callback_head rcu;
};

struct dcbnl_rtnl_ops___2 {
	int (*ieee_getets)(struct net_device___2 *, struct ieee_ets *);
	int (*ieee_setets)(struct net_device___2 *, struct ieee_ets *);
	int (*ieee_getmaxrate)(struct net_device___2 *, struct ieee_maxrate *);
	int (*ieee_setmaxrate)(struct net_device___2 *, struct ieee_maxrate *);
	int (*ieee_getqcn)(struct net_device___2 *, struct ieee_qcn *);
	int (*ieee_setqcn)(struct net_device___2 *, struct ieee_qcn *);
	int (*ieee_getqcnstats)(struct net_device___2 *, struct ieee_qcn_stats *);
	int (*ieee_getpfc)(struct net_device___2 *, struct ieee_pfc *);
	int (*ieee_setpfc)(struct net_device___2 *, struct ieee_pfc *);
	int (*ieee_getapp)(struct net_device___2 *, struct dcb_app *);
	int (*ieee_setapp)(struct net_device___2 *, struct dcb_app *);
	int (*ieee_delapp)(struct net_device___2 *, struct dcb_app *);
	int (*ieee_peer_getets)(struct net_device___2 *, struct ieee_ets *);
	int (*ieee_peer_getpfc)(struct net_device___2 *, struct ieee_pfc *);
	u8 (*getstate)(struct net_device___2 *);
	u8 (*setstate)(struct net_device___2 *, u8);
	void (*getpermhwaddr)(struct net_device___2 *, u8 *);
	void (*setpgtccfgtx)(struct net_device___2 *, int, u8, u8, u8, u8);
	void (*setpgbwgcfgtx)(struct net_device___2 *, int, u8);
	void (*setpgtccfgrx)(struct net_device___2 *, int, u8, u8, u8, u8);
	void (*setpgbwgcfgrx)(struct net_device___2 *, int, u8);
	void (*getpgtccfgtx)(struct net_device___2 *, int, u8 *, u8 *, u8 *, u8 *);
	void (*getpgbwgcfgtx)(struct net_device___2 *, int, u8 *);
	void (*getpgtccfgrx)(struct net_device___2 *, int, u8 *, u8 *, u8 *, u8 *);
	void (*getpgbwgcfgrx)(struct net_device___2 *, int, u8 *);
	void (*setpfccfg)(struct net_device___2 *, int, u8);
	void (*getpfccfg)(struct net_device___2 *, int, u8 *);
	u8 (*setall)(struct net_device___2 *);
	u8 (*getcap)(struct net_device___2 *, int, u8 *);
	int (*getnumtcs)(struct net_device___2 *, int, u8 *);
	int (*setnumtcs)(struct net_device___2 *, int, u8);
	u8 (*getpfcstate)(struct net_device___2 *);
	void (*setpfcstate)(struct net_device___2 *, u8);
	void (*getbcncfg)(struct net_device___2 *, int, u32 *);
	void (*setbcncfg)(struct net_device___2 *, int, u32);
	void (*getbcnrp)(struct net_device___2 *, int, u8 *);
	void (*setbcnrp)(struct net_device___2 *, int, u8);
	int (*setapp)(struct net_device___2 *, u8, u16, u8);
	int (*getapp)(struct net_device___2 *, u8, u16);
	u8 (*getfeatcfg)(struct net_device___2 *, int, u8 *);
	u8 (*setfeatcfg)(struct net_device___2 *, int, u8);
	u8 (*getdcbx)(struct net_device___2 *);
	u8 (*setdcbx)(struct net_device___2 *, u8);
	int (*peer_getappinfo)(struct net_device___2 *, struct dcb_peer_app_info *, u16 *);
	int (*peer_getapptable)(struct net_device___2 *, struct dcb_app *);
	int (*cee_peer_getpg)(struct net_device___2 *, struct cee_pg *);
	int (*cee_peer_getpfc)(struct net_device___2 *, struct cee_pfc *);
	int (*dcbnl_getbuffer)(struct net_device___2 *, struct dcbnl_buffer *);
	int (*dcbnl_setbuffer)(struct net_device___2 *, struct dcbnl_buffer *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct xdp_rxq_info___2 {
	struct net_device___2 *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
};

struct xdp_frame___2 {
	void *data;
	u16 len;
	u16 headroom;
	u16 metasize;
	struct xdp_mem_info mem;
	struct net_device___2 *dev_rx;
};

struct netlink_callback___2 {
	struct sk_buff___2 *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff___2 *, struct netlink_callback___2 *);
	int (*done)(struct netlink_callback___2 *);
	void *data;
	struct module___2 *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	bool strict_check;
	union {
		u8 ctx[48];
		long int args[6];
	};
};

struct header_ops___2 {
	int (*create)(struct sk_buff___2 *, struct net_device___2 *, short unsigned int, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff___2 *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device___2 *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff___2 *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct netdev_queue___2 {
	struct net_device___2 *dev;
	struct Qdisc___2 *qdisc;
	struct Qdisc___2 *qdisc_sleeping;
	struct kobject___2 kobj;
	int numa_node;
	long unsigned int tx_maxrate;
	long unsigned int trans_timeout;
	struct net_device___2 *sb_dev;
	struct xdp_umem *umem;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	long unsigned int trans_start;
	long unsigned int state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dql dql;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct qdisc_skb_head___2 {
	struct sk_buff___2 *head;
	struct sk_buff___2 *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct Qdisc_ops___2;

struct Qdisc___2 {
	int (*enqueue)(struct sk_buff___2 *, struct Qdisc___2 *, struct sk_buff___2 **);
	struct sk_buff___2 * (*dequeue)(struct Qdisc___2 *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops___2 *ops;
	struct qdisc_size_table *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue___2 *dev_queue;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	int padded;
	refcount_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head___2 gso_skb;
	struct qdisc_skb_head___2 q;
	struct gnet_stats_basic_packed bstats;
	seqcount_t running;
	struct gnet_stats_queue qstats;
	long unsigned int state;
	struct Qdisc___2 *next_sched;
	struct sk_buff_head___2 skb_bad_txq;
	spinlock_t busylock;
	spinlock_t seqlock;
	bool empty;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct netdev_rx_queue___2 {
	struct rps_map *rps_map;
	struct rps_dev_flow_table *rps_flow_table;
	struct kobject___2 kobj;
	struct net_device___2 *dev;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info___2 xdp_rxq;
	struct xdp_umem *umem;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long: 64;
	long: 64;
	long: 64;
};

struct netdev_bpf___2 {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog___2 *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			u32 prog_id;
			u32 prog_flags;
		};
		struct {
			struct bpf_offloaded_map___2 *offmap;
		};
		struct {
			struct xdp_umem *umem;
			u16 queue_id;
		} xsk;
	};
};

struct xfrmdev_ops___2 {
	int (*xdo_dev_state_add)(struct xfrm_state *);
	void (*xdo_dev_state_delete)(struct xfrm_state *);
	void (*xdo_dev_state_free)(struct xfrm_state *);
	bool (*xdo_dev_offload_ok)(struct sk_buff___2 *, struct xfrm_state *);
	void (*xdo_dev_state_advance_esn)(struct xfrm_state *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

struct net_device_ops___2 {
	int (*ndo_init)(struct net_device___2 *);
	void (*ndo_uninit)(struct net_device___2 *);
	int (*ndo_open)(struct net_device___2 *);
	int (*ndo_stop)(struct net_device___2 *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff___2 *, struct net_device___2 *);
	netdev_features_t (*ndo_features_check)(struct sk_buff___2 *, struct net_device___2 *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device___2 *, struct sk_buff___2 *, struct net_device___2 *);
	void (*ndo_change_rx_flags)(struct net_device___2 *, int);
	void (*ndo_set_rx_mode)(struct net_device___2 *);
	int (*ndo_set_mac_address)(struct net_device___2 *, void *);
	int (*ndo_validate_addr)(struct net_device___2 *);
	int (*ndo_do_ioctl)(struct net_device___2 *, struct ifreq *, int);
	int (*ndo_set_config)(struct net_device___2 *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device___2 *, int);
	int (*ndo_neigh_setup)(struct net_device___2 *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device___2 *);
	void (*ndo_get_stats64)(struct net_device___2 *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device___2 *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device___2 *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device___2 *);
	int (*ndo_vlan_rx_add_vid)(struct net_device___2 *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device___2 *, __be16, u16);
	void (*ndo_poll_controller)(struct net_device___2 *);
	int (*ndo_netpoll_setup)(struct net_device___2 *, struct netpoll_info *);
	void (*ndo_netpoll_cleanup)(struct net_device___2 *);
	int (*ndo_set_vf_mac)(struct net_device___2 *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device___2 *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device___2 *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device___2 *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device___2 *, int, bool);
	int (*ndo_get_vf_config)(struct net_device___2 *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device___2 *, int, int);
	int (*ndo_get_vf_stats)(struct net_device___2 *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device___2 *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device___2 *, int, struct sk_buff___2 *);
	int (*ndo_set_vf_guid)(struct net_device___2 *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device___2 *, int, bool);
	int (*ndo_setup_tc)(struct net_device___2 *, enum tc_setup_type, void *);
	int (*ndo_fcoe_enable)(struct net_device___2 *);
	int (*ndo_fcoe_disable)(struct net_device___2 *);
	int (*ndo_fcoe_ddp_setup)(struct net_device___2 *, u16, struct scatterlist *, unsigned int);
	int (*ndo_fcoe_ddp_done)(struct net_device___2 *, u16);
	int (*ndo_fcoe_ddp_target)(struct net_device___2 *, u16, struct scatterlist *, unsigned int);
	int (*ndo_fcoe_get_hbainfo)(struct net_device___2 *, struct netdev_fcoe_hbainfo *);
	int (*ndo_fcoe_get_wwn)(struct net_device___2 *, u64 *, int);
	int (*ndo_rx_flow_steer)(struct net_device___2 *, const struct sk_buff___2 *, u16, u32);
	int (*ndo_add_slave)(struct net_device___2 *, struct net_device___2 *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device___2 *, struct net_device___2 *);
	netdev_features_t (*ndo_fix_features)(struct net_device___2 *, netdev_features_t);
	int (*ndo_set_features)(struct net_device___2 *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device___2 *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device___2 *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device___2 *, const unsigned char *, u16, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device___2 *, const unsigned char *, u16);
	int (*ndo_fdb_dump)(struct sk_buff___2 *, struct netlink_callback___2 *, struct net_device___2 *, struct net_device___2 *, int *);
	int (*ndo_fdb_get)(struct sk_buff___2 *, struct nlattr **, struct net_device___2 *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device___2 *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff___2 *, u32, u32, struct net_device___2 *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device___2 *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device___2 *, bool);
	int (*ndo_get_phys_port_id)(struct net_device___2 *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device___2 *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device___2 *, char *, size_t);
	void (*ndo_udp_tunnel_add)(struct net_device___2 *, struct udp_tunnel_info *);
	void (*ndo_udp_tunnel_del)(struct net_device___2 *, struct udp_tunnel_info *);
	void * (*ndo_dfwd_add_station)(struct net_device___2 *, struct net_device___2 *);
	void (*ndo_dfwd_del_station)(struct net_device___2 *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device___2 *, int, u32);
	int (*ndo_get_iflink)(const struct net_device___2 *);
	int (*ndo_change_proto_down)(struct net_device___2 *, bool);
	int (*ndo_fill_metadata_dst)(struct net_device___2 *, struct sk_buff___2 *);
	void (*ndo_set_rx_headroom)(struct net_device___2 *, int);
	int (*ndo_bpf)(struct net_device___2 *, struct netdev_bpf___2 *);
	int (*ndo_xdp_xmit)(struct net_device___2 *, int, struct xdp_frame___2 **, u32);
	int (*ndo_xsk_wakeup)(struct net_device___2 *, u32, u32);
	struct devlink_port * (*ndo_get_devlink_port)(struct net_device___2 *);
	long unsigned int kabi_reserved1;
	struct net_device___2 * (*ndo_get_peer_dev)(struct net_device___2 *);
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct tcf_proto___2;

struct mini_Qdisc___2 {
	struct tcf_proto___2 *filter_list;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	struct callback_head rcu;
};

struct rtnl_link_ops___2 {
	struct list_head list;
	const char *kind;
	size_t priv_size;
	void (*setup)(struct net_device___2 *);
	bool netns_refund;
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net___2 *, struct net_device___2 *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device___2 *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device___2 *, struct list_head *);
	size_t (*get_size)(const struct net_device___2 *);
	int (*fill_info)(struct sk_buff___2 *, const struct net_device___2 *);
	size_t (*get_xstats_size)(const struct net_device___2 *);
	int (*fill_xstats)(struct sk_buff___2 *, const struct net_device___2 *);
	unsigned int (*get_num_tx_queues)();
	unsigned int (*get_num_rx_queues)();
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device___2 *, struct net_device___2 *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device___2 *, const struct net_device___2 *);
	int (*fill_slave_info)(struct sk_buff___2 *, const struct net_device___2 *, const struct net_device___2 *);
	struct net___2 * (*get_link_net)(const struct net_device___2 *);
	size_t (*get_linkxstats_size)(const struct net_device___2 *, int);
	int (*fill_linkxstats)(struct sk_buff___2 *, const struct net_device___2 *, int *, int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct gnet_dump___2 {
	spinlock_t *lock;
	struct sk_buff___2 *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

struct Qdisc_class_ops___2;

struct Qdisc_ops___2 {
	struct Qdisc_ops___2 *next;
	const struct Qdisc_class_ops___2 *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff___2 *, struct Qdisc___2 *, struct sk_buff___2 **);
	struct sk_buff___2 * (*dequeue)(struct Qdisc___2 *);
	struct sk_buff___2 * (*peek)(struct Qdisc___2 *);
	int (*init)(struct Qdisc___2 *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc___2 *);
	void (*destroy)(struct Qdisc___2 *);
	int (*change)(struct Qdisc___2 *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc___2 *);
	int (*change_tx_queue_len)(struct Qdisc___2 *, unsigned int);
	int (*dump)(struct Qdisc___2 *, struct sk_buff___2 *);
	int (*dump_stats)(struct Qdisc___2 *, struct gnet_dump___2 *);
	void (*ingress_block_set)(struct Qdisc___2 *, u32);
	void (*egress_block_set)(struct Qdisc___2 *, u32);
	u32 (*ingress_block_get)(struct Qdisc___2 *);
	u32 (*egress_block_get)(struct Qdisc___2 *);
	struct module___2 *owner;
};

struct tcf_block___2;

struct Qdisc_class_ops___2 {
	unsigned int flags;
	struct netdev_queue___2 * (*select_queue)(struct Qdisc___2 *, struct tcmsg *);
	int (*graft)(struct Qdisc___2 *, long unsigned int, struct Qdisc___2 *, struct Qdisc___2 **, struct netlink_ext_ack *);
	struct Qdisc___2 * (*leaf)(struct Qdisc___2 *, long unsigned int);
	void (*qlen_notify)(struct Qdisc___2 *, long unsigned int);
	long unsigned int (*find)(struct Qdisc___2 *, u32);
	int (*change)(struct Qdisc___2 *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc___2 *, long unsigned int);
	void (*walk)(struct Qdisc___2 *, struct qdisc_walker *);
	struct tcf_block___2 * (*tcf_block)(struct Qdisc___2 *, long unsigned int, struct netlink_ext_ack *);
	long unsigned int (*bind_tcf)(struct Qdisc___2 *, long unsigned int, u32);
	void (*unbind_tcf)(struct Qdisc___2 *, long unsigned int);
	int (*dump)(struct Qdisc___2 *, long unsigned int, struct sk_buff___2 *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc___2 *, long unsigned int, struct gnet_dump___2 *);
};

struct tcf_chain___2;

struct tcf_block___2 {
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net___2 *net;
	struct Qdisc___2 *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain___2 *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

struct tcf_result___2;

struct tcf_proto_ops___2;

struct tcf_proto___2 {
	struct tcf_proto___2 *next;
	void *root;
	int (*classify)(struct sk_buff___2 *, const struct tcf_proto___2 *, struct tcf_result___2 *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops___2 *ops;
	struct tcf_chain___2 *chain;
	spinlock_t lock;
	bool deleting;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

struct tcf_result___2 {
	union {
		struct {
			long unsigned int class;
			u32 classid;
		};
		const struct tcf_proto___2 *goto_tp;
		struct {
			bool ingress;
			struct gnet_stats_queue *qstats;
		};
	};
};

struct tcf_proto_ops___2 {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff___2 *, const struct tcf_proto___2 *, struct tcf_result___2 *);
	int (*init)(struct tcf_proto___2 *);
	void (*destroy)(struct tcf_proto___2 *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto___2 *, u32);
	void (*put)(struct tcf_proto___2 *, void *);
	int (*change)(struct net___2 *, struct sk_buff___2 *, struct tcf_proto___2 *, long unsigned int, u32, struct nlattr **, void **, bool, bool, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto___2 *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto___2 *);
	void (*walk)(struct tcf_proto___2 *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto___2 *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto___2 *, void *);
	void (*hw_del)(struct tcf_proto___2 *, void *);
	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
	void * (*tmplt_create)(struct net___2 *, struct tcf_chain___2 *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	int (*dump)(struct net___2 *, struct tcf_proto___2 *, void *, struct sk_buff___2 *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff___2 *, struct net___2 *, void *);
	struct module___2 *owner;
	int flags;
};

struct tcf_chain___2 {
	struct mutex filter_chain_lock;
	struct tcf_proto___2 *filter_chain;
	struct list_head list;
	struct tcf_block___2 *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops___2 *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct match_token {
	int token;
	const char *pattern;
};

enum {
	MAX_OPT_ARGS = 3,
};

typedef struct {
	char *from;
	char *to;
} substring_t;

typedef int (*remote_function_f)(void *);

struct remote_function_call {
	struct task_struct___2 *p;
	remote_function_f func;
	void *info;
	int ret;
};

typedef void (*event_f)(struct perf_event___2 *, struct perf_cpu_context___2 *, struct perf_event_context___2 *, void *);

struct event_function_struct {
	struct perf_event___2 *event;
	event_f func;
	void *data;
};

enum event_type_t {
	EVENT_FLEXIBLE = 1,
	EVENT_PINNED = 2,
	EVENT_TIME = 4,
	EVENT_CPU = 8,
	EVENT_ALL = 3,
};

struct stop_event_data {
	struct perf_event___2 *event;
	unsigned int restart;
};

struct sched_in_data {
	struct perf_event_context___2 *ctx;
	struct perf_cpu_context___2 *cpuctx;
	int can_add_hw;
};

struct perf_read_data {
	struct perf_event___2 *event;
	bool group;
	int ret;
};

struct perf_read_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

typedef void perf_iterate_f(struct perf_event___2 *, void *);

struct remote_output {
	struct ring_buffer___2 *rb;
	int err;
};

struct perf_task_event {
	struct task_struct___2 *task;
	struct perf_event_context___2 *task_ctx;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 ppid;
		u32 tid;
		u32 ptid;
		u64 time;
	} event_id;
};

struct perf_comm_event {
	struct task_struct___2 *task;
	char *comm;
	int comm_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
	} event_id;
};

struct perf_namespaces_event {
	struct task_struct___2 *task;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 nr_namespaces;
		struct perf_ns_link_info link_info[7];
	} event_id;
};

struct perf_mmap_event {
	struct vm_area_struct___2 *vma;
	const char *file_name;
	int file_size;
	int maj;
	int min;
	u64 ino;
	u64 ino_generation;
	u32 prot;
	u32 flags;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 start;
		u64 len;
		u64 pgoff;
	} event_id;
};

struct perf_switch_event {
	struct task_struct___2 *task;
	struct task_struct___2 *next_prev;
	struct {
		struct perf_event_header header;
		u32 next_prev_pid;
		u32 next_prev_tid;
	} event_id;
};

struct perf_ksymbol_event {
	const char *name;
	int name_len;
	struct {
		struct perf_event_header header;
		u64 addr;
		u32 len;
		u16 ksym_type;
		u16 flags;
	} event_id;
};

struct perf_bpf_event {
	struct bpf_prog___2 *prog;
	struct {
		struct perf_event_header header;
		u16 type;
		u16 flags;
		u32 id;
		u8 tag[8];
	} event_id;
};

struct swevent_htable {
	struct swevent_hlist *swevent_hlist;
	struct mutex hlist_mutex;
	int hlist_refcount;
	int recursion[4];
};

enum perf_probe_config {
	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
};

enum {
	IF_ACT_NONE = 4294967295,
	IF_ACT_FILTER = 0,
	IF_ACT_START = 1,
	IF_ACT_STOP = 2,
	IF_SRC_FILE = 3,
	IF_SRC_KERNEL = 4,
	IF_SRC_FILEADDR = 5,
	IF_SRC_KERNELADDR = 6,
};

enum {
	IF_STATE_ACTION = 0,
	IF_STATE_SOURCE = 1,
	IF_STATE_END = 2,
};

struct perf_aux_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct perf_aux_event___2 {
	struct perf_event_header header;
	u64 offset;
	u64 size;
	u64 flags;
};

enum perf_callchain_context {
	PERF_CONTEXT_HV = 4294967264,
	PERF_CONTEXT_KERNEL = 4294967168,
	PERF_CONTEXT_USER = 4294966784,
	PERF_CONTEXT_GUEST = 4294965248,
	PERF_CONTEXT_GUEST_KERNEL = 4294965120,
	PERF_CONTEXT_GUEST_USER = 4294964736,
	PERF_CONTEXT_MAX = 4294963201,
};

struct callchain_cpus_entries {
	struct callback_head callback_head;
	struct perf_callchain_entry *cpu_entries[0];
};

enum bp_type_idx {
	TYPE_INST = 0,
	TYPE_DATA = 0,
	TYPE_MAX = 1,
};

struct bp_cpuinfo {
	unsigned int cpu_pinned;
	unsigned int *tsk_pinned;
	unsigned int flexible;
};

struct bp_busy_slots {
	unsigned int pinned;
	unsigned int flexible;
};

typedef u8 uprobe_opcode_t;

struct uprobe {
	struct rb_node rb_node;
	refcount_t ref;
	struct rw_semaphore register_rwsem;
	struct rw_semaphore consumer_rwsem;
	struct list_head pending_list;
	struct uprobe_consumer *consumers;
	struct inode___2 *inode;
	loff_t offset;
	loff_t ref_ctr_offset;
	long unsigned int flags;
	struct arch_uprobe arch;
};

struct xol_area {
	wait_queue_head_t wq;
	atomic_t slot_count;
	long unsigned int *bitmap;
	struct vm_special_mapping xol_mapping;
	struct page___2 *pages[2];
	long unsigned int vaddr;
};

struct compact_control;

struct capture_control {
	struct compact_control *cc;
	struct page___2 *page;
};

typedef int filler_t(void *, struct page___2 *);

typedef void (*poll_queue_proc___3)(struct file___2 *, wait_queue_head_t *, struct poll_table_struct *);

struct page_vma_mapped_walk {
	struct page___2 *page;
	struct vm_area_struct___2 *vma;
	long unsigned int address;
	pmd_t *pmd;
	pte_t *pte;
	spinlock_t *ptl;
	unsigned int flags;
};

struct compact_control {
	struct list_head freepages;
	struct list_head migratepages;
	unsigned int nr_freepages;
	unsigned int nr_migratepages;
	long unsigned int free_pfn;
	long unsigned int migrate_pfn;
	long unsigned int fast_start_pfn;
	struct zone *zone;
	long unsigned int total_migrate_scanned;
	long unsigned int total_free_scanned;
	short unsigned int fast_search_fail;
	short int search_order;
	const gfp_t gfp_mask;
	int order;
	int migratetype;
	const unsigned int alloc_flags;
	const int classzone_idx;
	enum migrate_mode mode;
	bool ignore_skip_hint;
	bool no_set_skip_hint;
	bool ignore_block_suitable;
	bool direct_compaction;
	bool whole_zone;
	bool contended;
	bool rescan;
};

struct delayed_uprobe {
	struct list_head list;
	struct uprobe *uprobe;
	struct mm_struct___2 *mm;
};

struct map_info {
	struct map_info *next;
	struct mm_struct___2 *mm;
	long unsigned int vaddr;
};

struct user_return_notifier {
	void (*on_user_return)(struct user_return_notifier *);
	struct hlist_node link;
};

struct parallel_data;

struct padata_priv {
	struct list_head list;
	struct parallel_data *pd;
	int cb_cpu;
	int cpu;
	unsigned int seq_nr;
	int info;
	void (*parallel)(struct padata_priv *);
	void (*serial)(struct padata_priv *);
};

struct padata_cpumask {
	cpumask_var_t pcpu;
	cpumask_var_t cbcpu;
};

struct padata_shell;

struct padata_parallel_queue;

struct padata_serial_queue;

struct parallel_data {
	struct padata_shell *ps;
	struct padata_parallel_queue *pqueue;
	struct padata_serial_queue *squeue;
	atomic_t reorder_objects;
	atomic_t refcnt;
	atomic_t seq_nr;
	unsigned int processed;
	int cpu;
	struct padata_cpumask cpumask;
	struct work_struct reorder_work;
	long: 64;
	long: 64;
	spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct padata_list {
	struct list_head list;
	spinlock_t lock;
};

struct padata_serial_queue {
	struct padata_list serial;
	struct work_struct work;
	struct parallel_data *pd;
};

struct padata_parallel_queue {
	struct padata_list parallel;
	struct padata_list reorder;
	struct work_struct work;
	atomic_t num_obj;
};

struct padata_instance;

struct padata_shell {
	struct padata_instance *pinst;
	struct parallel_data *pd;
	struct parallel_data *opd;
	struct list_head list;
};

struct padata_instance {
	struct hlist_node cpu_online_node;
	struct hlist_node cpu_dead_node;
	struct workqueue_struct *parallel_wq;
	struct workqueue_struct *serial_wq;
	struct list_head pslist;
	struct padata_cpumask cpumask;
	struct padata_cpumask rcpumask;
	cpumask_var_t omask;
	struct blocking_notifier_head cpumask_change_notifier;
	struct kobject___2 kobj;
	struct mutex lock;
	u8 flags;
};

struct padata_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct padata_instance *, struct attribute *, char *);
	ssize_t (*store)(struct padata_instance *, struct attribute *, const char *, size_t);
};

typedef void (*dr_release_t___2)(struct device___2 *, void *);

typedef int (*dr_match_t___2)(struct device___2 *, void *, void *);

enum rseq_cpu_id_state {
	RSEQ_CPU_ID_UNINITIALIZED = 4294967295,
	RSEQ_CPU_ID_REGISTRATION_FAILED = 4294967294,
};

enum rseq_flags {
	RSEQ_FLAG_UNREGISTER = 1,
};

enum rseq_cs_flags {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL = 2,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE = 4,
};

struct rseq_cs {
	__u32 version;
	__u32 flags;
	__u64 start_ip;
	__u64 post_commit_offset;
	__u64 abort_ip;
};

struct trace_event_raw_rseq_update {
	struct trace_entry ent;
	s32 cpu_id;
	char __data[0];
};

struct trace_event_raw_rseq_ip_fixup {
	struct trace_entry ent;
	long unsigned int regs_ip;
	long unsigned int start_ip;
	long unsigned int post_commit_offset;
	long unsigned int abort_ip;
	char __data[0];
};

struct trace_event_data_offsets_rseq_update {};

struct trace_event_data_offsets_rseq_ip_fixup {};

typedef void (*btf_trace_rseq_update)(void *, struct task_struct___2 *);

typedef void (*btf_trace_rseq_ip_fixup)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

struct __key_reference_with_attributes;

typedef struct __key_reference_with_attributes *key_ref_t;

enum positive_aop_returns {
	AOP_WRITEPAGE_ACTIVATE = 524288,
	AOP_TRUNCATED_PAGE = 524289,
};

struct vm_event_state {
	long unsigned int event[85];
};

enum mapping_flags {
	AS_EIO = 0,
	AS_ENOSPC = 1,
	AS_MM_ALL_LOCKS = 2,
	AS_UNEVICTABLE = 3,
	AS_EXITING = 4,
	AS_NO_WRITEBACK_TAGS = 5,
};

enum iter_type {
	ITER_IOVEC = 4,
	ITER_KVEC = 8,
	ITER_BVEC = 16,
	ITER_PIPE = 32,
	ITER_DISCARD = 64,
};

struct pagevec {
	unsigned char nr;
	bool percpu_pvec_drained;
	struct page___2 *pages[15];
};

struct fid {
	union {
		struct {
			u32 ino;
			u32 gen;
			u32 parent_ino;
			u32 parent_gen;
		} i32;
		struct {
			u32 block;
			u16 partref;
			u16 parent_partref;
			u32 generation;
			u32 parent_block;
			u32 parent_generation;
		} udf;
		__u32 raw[0];
	};
};

struct trace_event_raw_mm_filemap_op_page_cache {
	struct trace_entry ent;
	long unsigned int pfn;
	long unsigned int i_ino;
	long unsigned int index;
	dev_t s_dev;
	char __data[0];
};

struct trace_event_raw_filemap_set_wb_err {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t errseq;
	char __data[0];
};

struct trace_event_raw_file_check_and_advance_wb_err {
	struct trace_entry ent;
	struct file___2 *file;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t old;
	errseq_t new;
	char __data[0];
};

struct trace_event_data_offsets_mm_filemap_op_page_cache {};

struct trace_event_data_offsets_filemap_set_wb_err {};

struct trace_event_data_offsets_file_check_and_advance_wb_err {};

typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct page___2 *);

typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct page___2 *);

typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space___2 *, errseq_t);

typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file___2 *, errseq_t);

struct wait_page_key {
	struct page___2 *page;
	int bit_nr;
	int page_match;
};

struct wait_page_queue {
	struct page___2 *page;
	int bit_nr;
	wait_queue_entry_t wait;
};

enum behavior {
	EXCLUSIVE = 0,
	SHARED = 1,
	DROP = 2,
};

struct kmem_cache_order_objects {
	unsigned int x;
};

struct memcg_cache_array;

struct memcg_cache_params {
	struct kmem_cache *root_cache;
	union {
		struct {
			struct memcg_cache_array *memcg_caches;
			struct list_head __root_caches_node;
			struct list_head children;
			bool dying;
		};
		struct {
			struct mem_cgroup *memcg;
			struct list_head children_node;
			struct list_head kmem_caches_node;
			struct percpu_ref refcnt;
			void (*work_fn)(struct kmem_cache *);
			union {
				struct callback_head callback_head;
				struct work_struct work;
			};
		};
	};
};

struct kmem_cache_cpu;

struct kmem_cache_node;

struct kmem_cache {
	struct kmem_cache_cpu *cpu_slab;
	slab_flags_t flags;
	long unsigned int min_partial;
	unsigned int size;
	unsigned int object_size;
	unsigned int offset;
	unsigned int cpu_partial;
	struct kmem_cache_order_objects oo;
	struct kmem_cache_order_objects max;
	struct kmem_cache_order_objects min;
	gfp_t allocflags;
	int refcount;
	void (*ctor)(void *);
	unsigned int inuse;
	unsigned int align;
	unsigned int red_left_pad;
	const char *name;
	struct list_head list;
	struct kobject___2 kobj;
	struct work_struct kobj_remove_work;
	struct memcg_cache_params memcg_params;
	unsigned int max_attr_size;
	struct kset___2 *memcg_kset;
	unsigned int remote_node_defrag_ratio;
	unsigned int useroffset;
	unsigned int usersize;
	struct kmem_cache_node *node[1024];
};

struct memcg_cache_array {
	struct callback_head rcu;
	struct kmem_cache *entries[0];
};

struct kmem_cache_cpu {
	void **freelist;
	long unsigned int tid;
	struct page___2 *page;
	struct page___2 *partial;
};

struct kmem_cache_node {
	spinlock_t list_lock;
	long unsigned int nr_partial;
	struct list_head partial;
	atomic_long_t nr_slabs;
	atomic_long_t total_objects;
	struct list_head full;
};

struct zap_details {
	struct address_space___2 *check_mapping;
	long unsigned int first_index;
	long unsigned int last_index;
};

enum oom_constraint {
	CONSTRAINT_NONE = 0,
	CONSTRAINT_CPUSET = 1,
	CONSTRAINT_MEMORY_POLICY = 2,
	CONSTRAINT_MEMCG = 3,
};

struct oom_control {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct mem_cgroup *memcg;
	const gfp_t gfp_mask;
	const int order;
	long unsigned int totalpages;
	struct task_struct___2 *chosen;
	long unsigned int chosen_points;
	enum oom_constraint constraint;
};

enum compact_priority {
	COMPACT_PRIO_SYNC_FULL = 0,
	MIN_COMPACT_PRIORITY = 0,
	COMPACT_PRIO_SYNC_LIGHT = 1,
	MIN_COMPACT_COSTLY_PRIORITY = 1,
	DEF_COMPACT_PRIORITY = 1,
	COMPACT_PRIO_ASYNC = 2,
	INIT_COMPACT_PRIORITY = 2,
};

enum compact_result {
	COMPACT_NOT_SUITABLE_ZONE = 0,
	COMPACT_SKIPPED = 1,
	COMPACT_DEFERRED = 2,
	COMPACT_INACTIVE = 2,
	COMPACT_NO_SUITABLE_PAGE = 3,
	COMPACT_CONTINUE = 4,
	COMPACT_COMPLETE = 5,
	COMPACT_PARTIAL_SKIPPED = 6,
	COMPACT_CONTENDED = 7,
	COMPACT_SUCCESS = 8,
};

struct trace_event_raw_oom_score_adj_update {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_reclaim_retry_zone {
	struct trace_entry ent;
	int node;
	int zone_idx;
	int order;
	long unsigned int reclaimable;
	long unsigned int available;
	long unsigned int min_wmark;
	int no_progress_loops;
	bool wmark_check;
	char __data[0];
};

struct trace_event_raw_mark_victim {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_wake_reaper {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_start_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_finish_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_skip_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_compact_retry {
	struct trace_entry ent;
	int order;
	int priority;
	int result;
	int retries;
	int max_retries;
	bool ret;
	char __data[0];
};

struct trace_event_data_offsets_oom_score_adj_update {};

struct trace_event_data_offsets_reclaim_retry_zone {};

struct trace_event_data_offsets_mark_victim {};

struct trace_event_data_offsets_wake_reaper {};

struct trace_event_data_offsets_start_task_reaping {};

struct trace_event_data_offsets_finish_task_reaping {};

struct trace_event_data_offsets_skip_task_reaping {};

struct trace_event_data_offsets_compact_retry {};

typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct___2 *);

typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, long unsigned int, long unsigned int, long unsigned int, int, bool);

typedef void (*btf_trace_mark_victim)(void *, int);

typedef void (*btf_trace_wake_reaper)(void *, int);

typedef void (*btf_trace_start_task_reaping)(void *, int);

typedef void (*btf_trace_finish_task_reaping)(void *, int);

typedef void (*btf_trace_skip_task_reaping)(void *, int);

typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);

enum wb_congested_state {
	WB_async_congested = 0,
	WB_sync_congested = 1,
};

enum wb_state {
	WB_registered = 0,
	WB_writeback_running = 1,
	WB_has_dirty_io = 2,
	WB_start_all = 3,
};

enum {
	BLK_RW_ASYNC = 0,
	BLK_RW_SYNC = 1,
};

struct wb_lock_cookie {
	bool locked;
	long unsigned int flags;
};

typedef int (*writepage_t)(struct page___2 *, struct writeback_control *, void *);

struct dirty_throttle_control {
	struct wb_domain *dom;
	struct dirty_throttle_control *gdtc;
	struct bdi_writeback *wb;
	struct fprop_local_percpu *wb_completions;
	long unsigned int avail;
	long unsigned int dirty;
	long unsigned int thresh;
	long unsigned int bg_thresh;
	long unsigned int wb_dirty;
	long unsigned int wb_thresh;
	long unsigned int wb_bg_thresh;
	long unsigned int pos_ratio;
};

typedef void compound_page_dtor(struct page___2 *);

struct trace_event_raw_mm_lru_insertion {
	struct trace_entry ent;
	struct page___2 *page;
	long unsigned int pfn;
	int lru;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_mm_lru_activate {
	struct trace_entry ent;
	struct page___2 *page;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_data_offsets_mm_lru_insertion {};

struct trace_event_data_offsets_mm_lru_activate {};

typedef void (*btf_trace_mm_lru_insertion)(void *, struct page___2 *, int);

typedef void (*btf_trace_mm_lru_activate)(void *, struct page___2 *);

typedef struct {
	long unsigned int val;
} swp_entry_t;

enum pgdat_flags {
	PGDAT_CONGESTED = 0,
	PGDAT_DIRTY = 1,
	PGDAT_WRITEBACK = 2,
	PGDAT_RECLAIM_LOCKED = 3,
};

struct reclaim_stat {
	unsigned int nr_dirty;
	unsigned int nr_unqueued_dirty;
	unsigned int nr_congested;
	unsigned int nr_writeback;
	unsigned int nr_immediate;
	unsigned int nr_activate[2];
	unsigned int nr_ref_keep;
	unsigned int nr_unmap_fail;
};

enum mem_cgroup_protection {
	MEMCG_PROT_NONE = 0,
	MEMCG_PROT_LOW = 1,
	MEMCG_PROT_MIN = 2,
};

struct mem_cgroup_reclaim_cookie {
	pg_data_t *pgdat;
	int priority;
	unsigned int generation;
};

enum ttu_flags {
	TTU_MIGRATION = 1,
	TTU_MUNLOCK = 2,
	TTU_SPLIT_HUGE_PMD = 4,
	TTU_IGNORE_MLOCK = 8,
	TTU_IGNORE_ACCESS = 16,
	TTU_IGNORE_HWPOISON = 32,
	TTU_BATCH_FLUSH = 64,
	TTU_RMAP_LOCKED = 128,
	TTU_SPLIT_FREEZE = 256,
};

struct trace_event_raw_mm_vmscan_kswapd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_wake {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_wakeup_kswapd {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
	struct trace_entry ent;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
	struct trace_entry ent;
	long unsigned int nr_reclaimed;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_start {
	struct trace_entry ent;
	struct shrinker *shr;
	void *shrink;
	int nid;
	long int nr_objects_to_shrink;
	gfp_t gfp_flags;
	long unsigned int cache_items;
	long long unsigned int delta;
	long unsigned int total_scan;
	int priority;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_end {
	struct trace_entry ent;
	struct shrinker *shr;
	int nid;
	void *shrink;
	long int unused_scan;
	long int new_scan;
	int retval;
	long int total_scan;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_isolate {
	struct trace_entry ent;
	int classzone_idx;
	int order;
	long unsigned int nr_requested;
	long unsigned int nr_scanned;
	long unsigned int nr_skipped;
	long unsigned int nr_taken;
	isolate_mode_t isolate_mode;
	int lru;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_writepage {
	struct trace_entry ent;
	long unsigned int pfn;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_active {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_taken;
	long unsigned int nr_active;
	long unsigned int nr_deactivated;
	long unsigned int nr_referenced;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_inactive_list_is_low {
	struct trace_entry ent;
	int nid;
	int reclaim_idx;
	long unsigned int total_inactive;
	long unsigned int inactive;
	long unsigned int total_active;
	long unsigned int active;
	long unsigned int ratio;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_node_reclaim_begin {
	struct trace_entry ent;
	int nid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};

struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};

struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};

struct trace_event_data_offsets_mm_shrink_slab_start {};

struct trace_event_data_offsets_mm_shrink_slab_end {};

struct trace_event_data_offsets_mm_vmscan_lru_isolate {};

struct trace_event_data_offsets_mm_vmscan_writepage {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};

struct trace_event_data_offsets_mm_vmscan_inactive_list_is_low {};

struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};

typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);

typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);

typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long int, long unsigned int, long long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long int, long int, long int);

typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, isolate_mode_t, int);

typedef void (*btf_trace_mm_vmscan_writepage)(void *, struct page___2 *);

typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *, int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int, int);

typedef void (*btf_trace_mm_vmscan_inactive_list_is_low)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, long unsigned int);

struct scan_control {
	long unsigned int nr_to_reclaim;
	nodemask_t *nodemask;
	struct mem_cgroup *target_mem_cgroup;
	unsigned int may_writepage: 1;
	unsigned int may_unmap: 1;
	unsigned int may_swap: 1;
	unsigned int memcg_low_reclaim: 1;
	unsigned int memcg_low_skipped: 1;
	unsigned int hibernation_mode: 1;
	unsigned int compaction_ready: 1;
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};

typedef enum {
	PAGE_KEEP = 0,
	PAGE_ACTIVATE = 1,
	PAGE_SUCCESS = 2,
	PAGE_CLEAN = 3,
} pageout_t;

enum page_references {
	PAGEREF_RECLAIM = 0,
	PAGEREF_RECLAIM_CLEAN = 1,
	PAGEREF_KEEP = 2,
	PAGEREF_ACTIVATE = 3,
};

enum scan_balance {
	SCAN_EQUAL = 0,
	SCAN_FRACT = 1,
	SCAN_ANON = 2,
	SCAN_FILE = 3,
};

enum transparent_hugepage_flag {
	TRANSPARENT_HUGEPAGE_FLAG = 0,
	TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG = 1,
	TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG = 2,
	TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG = 3,
	TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG = 4,
	TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG = 5,
	TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG = 6,
	TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG = 7,
};

enum {
	MPOL_DEFAULT = 0,
	MPOL_PREFERRED = 1,
	MPOL_BIND = 2,
	MPOL_INTERLEAVE = 3,
	MPOL_LOCAL = 4,
	MPOL_MAX = 5,
};

struct shared_policy {
	struct rb_root root;
	rwlock_t lock;
};

struct xattr;

typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);

struct xattr {
	const char *name;
	void *value;
	size_t value_len;
};

struct simple_xattrs {
	struct list_head head;
	spinlock_t lock;
};

struct simple_xattr {
	struct list_head list;
	char *name;
	size_t size;
	char value[0];
};

enum fid_type {
	FILEID_ROOT = 0,
	FILEID_INO32_GEN = 1,
	FILEID_INO32_GEN_PARENT = 2,
	FILEID_BTRFS_WITHOUT_PARENT = 77,
	FILEID_BTRFS_WITH_PARENT = 78,
	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
	FILEID_UDF_WITHOUT_PARENT = 81,
	FILEID_UDF_WITH_PARENT = 82,
	FILEID_NILFS_WITHOUT_PARENT = 97,
	FILEID_NILFS_WITH_PARENT = 98,
	FILEID_FAT_WITHOUT_PARENT = 113,
	FILEID_FAT_WITH_PARENT = 114,
	FILEID_LUSTRE = 151,
	FILEID_INVALID = 255,
};

struct shmem_inode_info {
	spinlock_t lock;
	unsigned int seals;
	long unsigned int flags;
	long unsigned int alloced;
	long unsigned int swapped;
	struct list_head shrinklist;
	struct list_head swaplist;
	struct shared_policy policy;
	struct simple_xattrs xattrs;
	atomic_t stop_eviction;
	struct inode vfs_inode;
};

struct shmem_sb_info {
	long unsigned int max_blocks;
	struct percpu_counter used_blocks;
	long unsigned int max_inodes;
	long unsigned int free_inodes;
	spinlock_t stat_lock;
	umode_t mode;
	unsigned char huge;
	kuid_t uid;
	kgid_t gid;
	struct mempolicy *mpol;
	spinlock_t shrinklist_lock;
	struct list_head shrinklist;
	long unsigned int shrinklist_len;
};

enum sgp_type {
	SGP_READ = 0,
	SGP_CACHE = 1,
	SGP_NOHUGE = 2,
	SGP_HUGE = 3,
	SGP_WRITE = 4,
	SGP_FALLOC = 5,
};

struct shmem_falloc {
	wait_queue_head_t *waitq;
	long unsigned int start;
	long unsigned int next;
	long unsigned int nr_falloced;
	long unsigned int nr_unswapped;
};

struct shmem_options {
	long long unsigned int blocks;
	long long unsigned int inodes;
	struct mempolicy *mpol;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	int huge;
	int seen;
};

enum shmem_param {
	Opt_gid = 0,
	Opt_huge = 1,
	Opt_mode = 2,
	Opt_mpol = 3,
	Opt_nr_blocks = 4,
	Opt_nr_inodes = 5,
	Opt_size = 6,
	Opt_uid = 7,
};

enum pageblock_bits {
	PB_migrate = 0,
	PB_migrate_end = 2,
	PB_migrate_skip = 3,
	NR_PAGEBLOCK_BITS = 4,
};

struct contig_page_info {
	long unsigned int free_pages;
	long unsigned int free_blocks_total;
	long unsigned int free_blocks_suitable;
};

enum writeback_stat_item {
	NR_DIRTY_THRESHOLD = 0,
	NR_DIRTY_BG_THRESHOLD = 1,
	NR_VM_WRITEBACK_STAT_ITEMS = 2,
};

typedef s8 pto_T_____27;

struct radix_tree_iter {
	long unsigned int index;
	long unsigned int next_index;
	long unsigned int tags;
	struct xa_node *node;
};

enum {
	RADIX_TREE_ITER_TAG_MASK = 15,
	RADIX_TREE_ITER_TAGGED = 16,
	RADIX_TREE_ITER_CONTIG = 32,
};

enum mminit_level {
	MMINIT_WARNING = 0,
	MMINIT_VERIFY = 1,
	MMINIT_TRACE = 2,
};

struct pcpu_group_info {
	int nr_units;
	long unsigned int base_offset;
	unsigned int *cpu_map;
};

struct pcpu_alloc_info {
	size_t static_size;
	size_t reserved_size;
	size_t dyn_size;
	size_t unit_size;
	size_t atom_size;
	size_t alloc_size;
	size_t __ai_size;
	int nr_groups;
	struct pcpu_group_info groups[0];
};

struct trace_event_raw_percpu_alloc_percpu {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_free_percpu {
	struct trace_entry ent;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu_fail {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	char __data[0];
};

struct trace_event_raw_percpu_create_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_destroy_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_data_offsets_percpu_alloc_percpu {};

struct trace_event_data_offsets_percpu_free_percpu {};

struct trace_event_data_offsets_percpu_alloc_percpu_fail {};

struct trace_event_data_offsets_percpu_create_chunk {};

struct trace_event_data_offsets_percpu_destroy_chunk {};

typedef void (*btf_trace_percpu_alloc_percpu)(void *, bool, bool, size_t, size_t, void *, int, void *);

typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void *);

typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);

typedef void (*btf_trace_percpu_create_chunk)(void *, void *);

typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);

struct pcpu_block_md {
	int scan_hint;
	int scan_hint_start;
	int contig_hint;
	int contig_hint_start;
	int left_free;
	int right_free;
	int first_free;
	int nr_bits;
};

struct pcpu_chunk {
	struct list_head list;
	int free_bytes;
	struct pcpu_block_md chunk_md;
	void *base_addr;
	long unsigned int *alloc_map;
	long unsigned int *bound_map;
	struct pcpu_block_md *md_blocks;
	void *data;
	bool immutable;
	int start_offset;
	int end_offset;
	int nr_pages;
	int nr_populated;
	int nr_empty_pop_pages;
	long unsigned int populated[0];
};

struct trace_event_raw_kmem_alloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_kmem_alloc_node {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	int node;
	char __data[0];
};

struct trace_event_raw_kmem_free {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	char __data[0];
};

struct trace_event_raw_mm_page_free {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_mm_page_free_batched {
	struct trace_entry ent;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	gfp_t gfp_flags;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_pcpu_drain {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc_extfrag {
	struct trace_entry ent;
	long unsigned int pfn;
	int alloc_order;
	int fallback_order;
	int alloc_migratetype;
	int fallback_migratetype;
	int change_ownership;
	char __data[0];
};

struct trace_event_data_offsets_kmem_alloc {};

struct trace_event_data_offsets_kmem_alloc_node {};

struct trace_event_data_offsets_kmem_free {};

struct trace_event_data_offsets_mm_page_free {};

struct trace_event_data_offsets_mm_page_free_batched {};

struct trace_event_data_offsets_mm_page_alloc {};

struct trace_event_data_offsets_mm_page {};

struct trace_event_data_offsets_mm_page_pcpu_drain {};

struct trace_event_data_offsets_mm_page_alloc_extfrag {};

typedef void (*btf_trace_kmalloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmem_cache_alloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmalloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kmem_cache_alloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kfree)(void *, long unsigned int, const void *);

typedef void (*btf_trace_kmem_cache_free)(void *, long unsigned int, const void *);

typedef void (*btf_trace_mm_page_free)(void *, struct page___2 *, unsigned int);

typedef void (*btf_trace_mm_page_free_batched)(void *, struct page___2 *);

typedef void (*btf_trace_mm_page_alloc)(void *, struct page___2 *, unsigned int, gfp_t, int);

typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page___2 *, unsigned int, int);

typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page___2 *, unsigned int, int);

typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page___2 *, int, int, int, int);

enum slab_state {
	DOWN = 0,
	PARTIAL = 1,
	PARTIAL_NODE = 2,
	UP = 3,
	FULL = 4,
};

struct kmalloc_info_struct {
	const char *name;
	unsigned int size;
};

struct slabinfo {
	long unsigned int active_objs;
	long unsigned int num_objs;
	long unsigned int active_slabs;
	long unsigned int num_slabs;
	long unsigned int shared_avail;
	unsigned int limit;
	unsigned int batchcount;
	unsigned int shared;
	unsigned int objects_per_slab;
	unsigned int cache_order;
};

struct node___2 {
	struct device dev;
	struct list_head access_list;
	struct work_struct node_work;
	struct list_head cache_attrs;
	struct device *cache_dev;
};

typedef struct page___2 *new_page_t(struct page___2 *, long unsigned int);

typedef void free_page_t(struct page___2 *, long unsigned int);

struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;
	enum zone_type high_zoneidx;
	bool spread_dirty_pages;
};

struct trace_event_raw_mm_compaction_isolate_template {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int nr_scanned;
	long unsigned int nr_taken;
	char __data[0];
};

struct trace_event_raw_mm_compaction_migratepages {
	struct trace_entry ent;
	long unsigned int nr_migrated;
	long unsigned int nr_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_begin {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	char __data[0];
};

struct trace_event_raw_mm_compaction_end {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_compaction_try_to_compact_pages {
	struct trace_entry ent;
	int order;
	gfp_t gfp_mask;
	int prio;
	char __data[0];
};

struct trace_event_raw_mm_compaction_suitable_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_compaction_defer_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	unsigned int considered;
	unsigned int defer_shift;
	int order_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_kcompactd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_kcompactd_wake_template {
	struct trace_entry ent;
	int nid;
	int order;
	enum zone_type classzone_idx;
	char __data[0];
};

struct trace_event_data_offsets_mm_compaction_isolate_template {};

struct trace_event_data_offsets_mm_compaction_migratepages {};

struct trace_event_data_offsets_mm_compaction_begin {};

struct trace_event_data_offsets_mm_compaction_end {};

struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};

struct trace_event_data_offsets_mm_compaction_suitable_template {};

struct trace_event_data_offsets_mm_compaction_defer_template {};

struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};

struct trace_event_data_offsets_kcompactd_wake_template {};

typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_migratepages)(void *, long unsigned int, int, struct list_head *);

typedef void (*btf_trace_mm_compaction_begin)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool);

typedef void (*btf_trace_mm_compaction_end)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool, int);

typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);

typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);

typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);

typedef enum {
	ISOLATE_ABORT = 0,
	ISOLATE_NONE = 1,
	ISOLATE_SUCCESS = 2,
} isolate_migrate_t;

struct anon_vma_chain {
	struct vm_area_struct___2 *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct rb_node rb;
	long unsigned int rb_subtree_last;
};

enum lru_status {
	LRU_REMOVED = 0,
	LRU_REMOVED_RETRY = 1,
	LRU_ROTATE = 2,
	LRU_SKIP = 3,
	LRU_RETRY = 4,
};

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, spinlock_t *, void *);

typedef struct {
	long unsigned int pd;
} hugepd_t;

struct follow_page_context {
	struct dev_pagemap *pgmap;
	unsigned int page_mask;
};

enum {
	SWP_USED = 1,
	SWP_WRITEOK = 2,
	SWP_DISCARDABLE = 4,
	SWP_DISCARDING = 8,
	SWP_SOLIDSTATE = 16,
	SWP_CONTINUED = 32,
	SWP_BLKDEV = 64,
	SWP_ACTIVATED = 128,
	SWP_FS = 256,
	SWP_AREA_DISCARD = 512,
	SWP_PAGE_DISCARD = 1024,
	SWP_STABLE_WRITES = 2048,
	SWP_SYNCHRONOUS_IO = 4096,
	SWP_VALID = 8192,
	SWP_SCANNING = 16384,
};

struct copy_subpage_arg {
	struct page___2 *dst;
	struct page___2 *src;
	struct vm_area_struct___2 *vma;
};

struct mm_walk;

struct mm_walk_ops {
	int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_hole)(long unsigned int, long unsigned int, struct mm_walk *);
	int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
	int (*test_walk)(long unsigned int, long unsigned int, struct mm_walk *);
};

struct mm_walk {
	const struct mm_walk_ops *ops;
	struct mm_struct___2 *mm;
	struct vm_area_struct___2 *vma;
	void *private;
};

enum {
	HUGETLB_SHMFS_INODE = 1,
	HUGETLB_ANONHUGE_INODE = 2,
};

struct rmap_walk_control {
	void *arg;
	bool (*rmap_one)(struct page___2 *, struct vm_area_struct___2 *, long unsigned int, void *);
	int (*done)(struct page___2 *);
	struct anon_vma * (*anon_lock)(struct page___2 *);
	bool (*invalid_vma)(struct vm_area_struct___2 *, void *);
};

struct page_referenced_arg {
	int mapcount;
	int referenced;
	long unsigned int vm_flags;
	struct mem_cgroup *memcg;
};

struct vmap_area {
	long unsigned int va_start;
	long unsigned int va_end;
	struct rb_node rb_node;
	struct list_head list;
	union {
		long unsigned int subtree_max_size;
		struct vm_struct *vm;
		struct llist_node purge_list;
	};
};

struct vfree_deferred {
	struct llist_head list;
	struct work_struct wq;
};

enum fit_type {
	NOTHING_FIT = 0,
	FL_FIT_TYPE = 1,
	LE_FIT_TYPE = 2,
	RE_FIT_TYPE = 3,
	NE_FIT_TYPE = 4,
};

struct vmap_block_queue {
	spinlock_t lock;
	struct list_head free;
};

struct vmap_block {
	spinlock_t lock;
	struct vmap_area *va;
	long unsigned int free;
	long unsigned int dirty;
	long unsigned int dirty_min;
	long unsigned int dirty_max;
	struct list_head free_list;
	struct callback_head callback_head;
	struct list_head purge;
};

typedef struct vmap_area *pto_T_____28;

struct page_frag_cache {
	void *va;
	__u16 offset;
	__u16 size;
	unsigned int pagecnt_bias;
	bool pfmemalloc;
};

enum zone_flags {
	ZONE_BOOSTED_WATERMARK = 0,
};

struct mminit_pfnnid_cache {
	long unsigned int last_start;
	long unsigned int last_end;
	int last_nid;
};

struct pcpu_drain {
	struct zone *zone;
	struct work_struct work;
};

struct madvise_walk_private {
	struct mmu_gather *tlb;
	bool pageout;
};

enum {
	BIO_NO_PAGE_REF = 0,
	BIO_CLONED = 1,
	BIO_BOUNCED = 2,
	BIO_USER_MAPPED = 3,
	BIO_NULL_MAPPED = 4,
	BIO_WORKINGSET = 5,
	BIO_QUIET = 6,
	BIO_CHAIN = 7,
	BIO_REFFED = 8,
	BIO_THROTTLED = 9,
	BIO_TRACE_COMPLETION = 10,
	BIO_QUEUE_ENTERED = 11,
	BIO_TRACKED = 12,
	BIO_FLAG_LAST = 13,
};

struct vma_swap_readahead {
	short unsigned int win;
	short unsigned int offset;
	short unsigned int nr_pte;
	pte_t *ptes;
};

union swap_header {
	struct {
		char reserved[4086];
		char magic[10];
	} magic;
	struct {
		char bootbits[1024];
		__u32 version;
		__u32 last_page;
		__u32 nr_badpages;
		unsigned char sws_uuid[16];
		unsigned char sws_volume[16];
		__u32 padding[117];
		__u32 badpages[1];
	} info;
};

struct swap_extent {
	struct rb_node rb_node;
	long unsigned int start_page;
	long unsigned int nr_pages;
	sector_t start_block;
};

struct swap_slots_cache {
	bool lock_initialized;
	struct mutex alloc_lock;
	swp_entry_t *slots;
	int nr;
	int cur;
	spinlock_t free_lock;
	swp_entry_t *slots_ret;
	int n_ret;
};

struct dma_pool {
	struct list_head page_list;
	spinlock_t lock;
	size_t size;
	struct device___2 *dev;
	size_t allocation;
	size_t boundary;
	char name[32];
	struct list_head pools;
};

struct dma_page {
	struct list_head page_list;
	void *vaddr;
	dma_addr_t dma;
	unsigned int in_use;
	unsigned int offset;
};

enum string_size_units {
	STRING_UNITS_10 = 0,
	STRING_UNITS_2 = 1,
};

typedef void (*node_registration_func_t)(struct node___2 *);

struct resv_map {
	struct kref refs;
	spinlock_t lock;
	struct list_head regions;
	long int adds_in_progress;
	struct list_head region_cache;
	long int region_cache_count;
};

struct huge_bootmem_page {
	struct list_head list;
	struct hstate *hstate;
};

struct file_region {
	struct list_head link;
	long int from;
	long int to;
};

enum vma_resv_mode {
	VMA_NEEDS_RESV = 0,
	VMA_COMMIT_RESV = 1,
	VMA_END_RESV = 2,
	VMA_ADD_RESV = 3,
};

struct node_hstate {
	struct kobject___2 *hugepages_kobj;
	struct kobject___2 *hstate_kobjs[2];
};

struct hugetlb_cgroup;

struct nodemask_scratch {
	nodemask_t mask1;
	nodemask_t mask2;
};

struct sp_node {
	struct rb_node nd;
	long unsigned int start;
	long unsigned int end;
	struct mempolicy *policy;
};

struct mempolicy_operations {
	int (*create)(struct mempolicy *, const nodemask_t *);
	void (*rebind)(struct mempolicy *, const nodemask_t *);
};

struct queue_pages {
	struct list_head *pagelist;
	long unsigned int flags;
	nodemask_t *nmask;
	struct vm_area_struct___2 *prev;
};

struct memory_notify {
	long unsigned int start_pfn;
	long unsigned int nr_pages;
	int status_change_nid_normal;
	int status_change_nid_high;
	int status_change_nid;
};

struct rmap_item;

struct mm_slot {
	struct hlist_node link;
	struct list_head mm_list;
	struct rmap_item *rmap_list;
	struct mm_struct___2 *mm;
};

struct stable_node;

struct rmap_item {
	struct rmap_item *rmap_list;
	union {
		struct anon_vma *anon_vma;
		int nid;
	};
	struct mm_struct___2 *mm;
	long unsigned int address;
	unsigned int oldchecksum;
	union {
		struct rb_node node;
		struct {
			struct stable_node *head;
			struct hlist_node hlist;
		};
	};
};

struct ksm_scan {
	struct mm_slot *mm_slot;
	long unsigned int address;
	struct rmap_item **rmap_list;
	long unsigned int seqnr;
};

struct stable_node {
	union {
		struct rb_node node;
		struct {
			struct list_head *head;
			struct {
				struct hlist_node hlist_dup;
				struct list_head list;
			};
		};
	};
	struct hlist_head hlist;
	union {
		long unsigned int kpfn;
		long unsigned int chain_prune_time;
	};
	int rmap_hlist_len;
	int nid;
};

enum get_ksm_page_flags {
	GET_KSM_PAGE_NOLOCK = 0,
	GET_KSM_PAGE_LOCK = 1,
	GET_KSM_PAGE_TRYLOCK = 2,
};

enum stat_item {
	ALLOC_FASTPATH = 0,
	ALLOC_SLOWPATH = 1,
	FREE_FASTPATH = 2,
	FREE_SLOWPATH = 3,
	FREE_FROZEN = 4,
	FREE_ADD_PARTIAL = 5,
	FREE_REMOVE_PARTIAL = 6,
	ALLOC_FROM_PARTIAL = 7,
	ALLOC_SLAB = 8,
	ALLOC_REFILL = 9,
	ALLOC_NODE_MISMATCH = 10,
	FREE_SLAB = 11,
	CPUSLAB_FLUSH = 12,
	DEACTIVATE_FULL = 13,
	DEACTIVATE_EMPTY = 14,
	DEACTIVATE_TO_HEAD = 15,
	DEACTIVATE_TO_TAIL = 16,
	DEACTIVATE_REMOTE_FREES = 17,
	DEACTIVATE_BYPASS = 18,
	ORDER_FALLBACK = 19,
	CMPXCHG_DOUBLE_CPU_FAIL = 20,
	CMPXCHG_DOUBLE_FAIL = 21,
	CPU_PARTIAL_ALLOC = 22,
	CPU_PARTIAL_FREE = 23,
	CPU_PARTIAL_NODE = 24,
	CPU_PARTIAL_DRAIN = 25,
	NR_SLUB_STAT_ITEMS = 26,
};

struct track {
	long unsigned int addr;
	long unsigned int addrs[16];
	int cpu;
	int pid;
	long unsigned int when;
};

enum track_item {
	TRACK_ALLOC = 0,
	TRACK_FREE = 1,
};

struct detached_freelist {
	struct page___2 *page;
	void *tail;
	void *freelist;
	int cnt;
	struct kmem_cache *s;
};

struct location {
	long unsigned int count;
	long unsigned int addr;
	long long int sum_time;
	long int min_time;
	long int max_time;
	long int min_pid;
	long int max_pid;
	long unsigned int cpus[128];
	nodemask_t nodes;
};

struct loc_track {
	long unsigned int max;
	long unsigned int count;
	struct location *loc;
};

enum slab_stat_type {
	SL_ALL = 0,
	SL_PARTIAL = 1,
	SL_CPU = 2,
	SL_OBJECTS = 3,
	SL_TOTAL = 4,
};

struct slab_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kmem_cache *, char *);
	ssize_t (*store)(struct kmem_cache *, const char *, size_t);
};

struct saved_alias {
	struct kmem_cache *s;
	const char *name;
	struct saved_alias *next;
};

enum slab_modes {
	M_NONE = 0,
	M_PARTIAL = 1,
	M_FULL = 2,
	M_FREE = 3,
};

enum {
	MMOP_OFFLINE = 4294967295,
	MMOP_ONLINE_KEEP = 0,
	MMOP_ONLINE_KERNEL = 1,
	MMOP_ONLINE_MOVABLE = 2,
};

typedef void (*online_page_callback_t)(struct page___2 *, unsigned int);

struct memory_block {
	long unsigned int start_section_nr;
	long unsigned int state;
	int section_count;
	int online_type;
	int phys_device;
	void *hw;
	int (*phys_callback)(struct memory_block *);
	struct device dev;
	int nid;
};

typedef int (*walk_memory_blocks_func_t)(struct memory_block *, void *);

struct buffer_head;

typedef void bh_end_io_t(struct buffer_head *, int);

struct buffer_head {
	long unsigned int b_state;
	struct buffer_head *b_this_page;
	struct page___2 *b_page;
	sector_t b_blocknr;
	size_t b_size;
	char *b_data;
	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;
	void *b_private;
	struct list_head b_assoc_buffers;
	struct address_space___2 *b_assoc_map;
	atomic_t b_count;
};

enum bh_state_bits {
	BH_Uptodate = 0,
	BH_Dirty = 1,
	BH_Lock = 2,
	BH_Req = 3,
	BH_Uptodate_Lock = 4,
	BH_Mapped = 5,
	BH_New = 6,
	BH_Async_Read = 7,
	BH_Async_Write = 8,
	BH_Delay = 9,
	BH_Boundary = 10,
	BH_Write_EIO = 11,
	BH_Unwritten = 12,
	BH_Quiet = 13,
	BH_Meta = 14,
	BH_Prio = 15,
	BH_Defer_Completion = 16,
	BH_PrivateStart = 17,
};

struct trace_event_raw_mm_migrate_pages {
	struct trace_entry ent;
	long unsigned int succeeded;
	long unsigned int failed;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_data_offsets_mm_migrate_pages {};

typedef void (*btf_trace_mm_migrate_pages)(void *, long unsigned int, long unsigned int, enum migrate_mode, int);

enum scan_result {
	SCAN_FAIL = 0,
	SCAN_SUCCEED = 1,
	SCAN_PMD_NULL = 2,
	SCAN_EXCEED_NONE_PTE = 3,
	SCAN_PTE_NON_PRESENT = 4,
	SCAN_PAGE_RO = 5,
	SCAN_LACK_REFERENCED_PAGE = 6,
	SCAN_PAGE_NULL = 7,
	SCAN_SCAN_ABORT = 8,
	SCAN_PAGE_COUNT = 9,
	SCAN_PAGE_LRU = 10,
	SCAN_PAGE_LOCK = 11,
	SCAN_PAGE_ANON = 12,
	SCAN_PAGE_COMPOUND = 13,
	SCAN_ANY_PROCESS = 14,
	SCAN_VMA_NULL = 15,
	SCAN_VMA_CHECK = 16,
	SCAN_ADDRESS_RANGE = 17,
	SCAN_SWAP_CACHE_PAGE = 18,
	SCAN_DEL_PAGE_LRU = 19,
	SCAN_ALLOC_HUGE_PAGE_FAIL = 20,
	SCAN_CGROUP_CHARGE_FAIL = 21,
	SCAN_EXCEED_SWAP_PTE = 22,
	SCAN_TRUNCATED = 23,
	SCAN_PAGE_HAS_PRIVATE = 24,
};

struct trace_event_raw_mm_khugepaged_scan_pmd {
	struct trace_entry ent;
	struct mm_struct___2 *mm;
	long unsigned int pfn;
	bool writable;
	int referenced;
	int none_or_zero;
	int status;
	int unmapped;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page {
	struct trace_entry ent;
	struct mm_struct___2 *mm;
	int isolated;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page_isolate {
	struct trace_entry ent;
	long unsigned int pfn;
	int none_or_zero;
	int referenced;
	bool writable;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_collapse_huge_page_swapin {
	struct trace_entry ent;
	struct mm_struct___2 *mm;
	int swapped_in;
	int referenced;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_mm_khugepaged_scan_pmd {};

struct trace_event_data_offsets_mm_collapse_huge_page {};

struct trace_event_data_offsets_mm_collapse_huge_page_isolate {};

struct trace_event_data_offsets_mm_collapse_huge_page_swapin {};

typedef void (*btf_trace_mm_khugepaged_scan_pmd)(void *, struct mm_struct___2 *, struct page___2 *, bool, int, int, int, int);

typedef void (*btf_trace_mm_collapse_huge_page)(void *, struct mm_struct___2 *, int, int);

typedef void (*btf_trace_mm_collapse_huge_page_isolate)(void *, struct page___2 *, int, int, bool, int);

typedef void (*btf_trace_mm_collapse_huge_page_swapin)(void *, struct mm_struct___2 *, int, int, int);

struct mm_slot___2 {
	struct hlist_node hash;
	struct list_head mm_node;
	struct mm_struct___2 *mm;
	int nr_pte_mapped_thp;
	long unsigned int pte_mapped_thp[8];
};

struct khugepaged_scan {
	struct list_head mm_head;
	struct mm_slot___2 *mm_slot;
	long unsigned int address;
};

struct mem_cgroup_tree_per_node {
	struct rb_root rb_root;
	struct rb_node *rb_rightmost;
	spinlock_t lock;
};

struct mem_cgroup_tree {
	struct mem_cgroup_tree_per_node *rb_tree_per_node[1024];
};

struct mem_cgroup_eventfd_list {
	struct list_head list;
	struct eventfd_ctx *eventfd;
};

struct mem_cgroup_event {
	struct mem_cgroup *memcg;
	struct eventfd_ctx *eventfd;
	struct list_head list;
	int (*register_event)(struct mem_cgroup *, struct eventfd_ctx *, const char *);
	void (*unregister_event)(struct mem_cgroup *, struct eventfd_ctx *);
	poll_table pt;
	wait_queue_head_t *wqh;
	wait_queue_entry_t wait;
	struct work_struct remove;
};

struct move_charge_struct {
	spinlock_t lock;
	struct mm_struct___2 *mm;
	struct mem_cgroup *from;
	struct mem_cgroup *to;
	long unsigned int flags;
	long unsigned int precharge;
	long unsigned int moved_charge;
	long unsigned int moved_swap;
	struct task_struct___2 *moving_task;
	wait_queue_head_t waitq;
};

enum res_type {
	_MEM = 0,
	_MEMSWAP = 1,
	_OOM_TYPE = 2,
	_KMEM = 3,
	_TCP = 4,
};

struct oom_wait_info {
	struct mem_cgroup *memcg;
	wait_queue_entry_t wait;
};

enum oom_status {
	OOM_SUCCESS = 0,
	OOM_FAILED = 1,
	OOM_ASYNC = 2,
	OOM_SKIPPED = 3,
};

struct memcg_stock_pcp {
	struct mem_cgroup *cached;
	unsigned int nr_pages;
	struct work_struct work;
	long unsigned int flags;
};

struct memcg_kmem_cache_create_work {
	struct mem_cgroup *memcg;
	struct kmem_cache *cachep;
	struct work_struct work;
};

enum {
	RES_USAGE = 0,
	RES_LIMIT = 1,
	RES_MAX_USAGE = 2,
	RES_FAILCNT = 3,
	RES_SOFT_LIMIT = 4,
};

union mc_target {
	struct page___2 *page;
	swp_entry_t ent;
};

enum mc_target_type {
	MC_TARGET_NONE = 0,
	MC_TARGET_PAGE = 1,
	MC_TARGET_SWAP = 2,
	MC_TARGET_DEVICE = 3,
};

struct uncharge_gather {
	struct mem_cgroup *memcg;
	long unsigned int pgpgout;
	long unsigned int nr_anon;
	long unsigned int nr_file;
	long unsigned int nr_kmem;
	long unsigned int nr_huge;
	long unsigned int nr_shmem;
	struct page___2 *dummy_page;
};

struct numa_stat {
	const char *name;
	unsigned int lru_mask;
};

typedef long int pao_T_____6;

typedef long int pto_T_____29;

enum vmpressure_levels {
	VMPRESSURE_LOW = 0,
	VMPRESSURE_MEDIUM = 1,
	VMPRESSURE_CRITICAL = 2,
	VMPRESSURE_NUM_LEVELS = 3,
};

enum vmpressure_modes {
	VMPRESSURE_NO_PASSTHROUGH = 0,
	VMPRESSURE_HIERARCHY = 1,
	VMPRESSURE_LOCAL = 2,
	VMPRESSURE_NUM_MODES = 3,
};

struct vmpressure_event {
	struct eventfd_ctx *efd;
	enum vmpressure_levels level;
	enum vmpressure_modes mode;
	struct list_head node;
};

struct swap_cgroup_ctrl {
	struct page **map;
	long unsigned int length;
	spinlock_t lock;
};

struct swap_cgroup {
	short unsigned int id;
};

struct hugetlb_cgroup {
	struct cgroup_subsys_state css;
	struct page_counter hugepage[2];
};

enum {
	RES_USAGE___2 = 0,
	RES_LIMIT___2 = 1,
	RES_MAX_USAGE___2 = 2,
	RES_FAILCNT___2 = 3,
};

enum mf_result {
	MF_IGNORED = 0,
	MF_FAILED = 1,
	MF_DELAYED = 2,
	MF_RECOVERED = 3,
};

enum mf_action_page_type {
	MF_MSG_KERNEL = 0,
	MF_MSG_KERNEL_HIGH_ORDER = 1,
	MF_MSG_SLAB = 2,
	MF_MSG_DIFFERENT_COMPOUND = 3,
	MF_MSG_POISONED_HUGE = 4,
	MF_MSG_HUGE = 5,
	MF_MSG_FREE_HUGE = 6,
	MF_MSG_NON_PMD_HUGE = 7,
	MF_MSG_UNMAP_FAILED = 8,
	MF_MSG_DIRTY_SWAPCACHE = 9,
	MF_MSG_CLEAN_SWAPCACHE = 10,
	MF_MSG_DIRTY_MLOCKED_LRU = 11,
	MF_MSG_CLEAN_MLOCKED_LRU = 12,
	MF_MSG_DIRTY_UNEVICTABLE_LRU = 13,
	MF_MSG_CLEAN_UNEVICTABLE_LRU = 14,
	MF_MSG_DIRTY_LRU = 15,
	MF_MSG_CLEAN_LRU = 16,
	MF_MSG_TRUNCATED_LRU = 17,
	MF_MSG_BUDDY = 18,
	MF_MSG_BUDDY_2ND = 19,
	MF_MSG_DAX = 20,
	MF_MSG_UNKNOWN = 21,
};

typedef long unsigned int dax_entry_t;

typedef struct page *new_page_t___2(struct page *, long unsigned int);

typedef void free_page_t___2(struct page *, long unsigned int);

struct __kfifo {
	unsigned int in;
	unsigned int out;
	unsigned int mask;
	unsigned int esize;
	void *data;
};

struct to_kill {
	struct list_head nd;
	struct task_struct *tsk;
	long unsigned int addr;
	short int size_shift;
};

struct page_state {
	long unsigned int mask;
	long unsigned int res;
	enum mf_action_page_type type;
	int (*action)(struct page *, long unsigned int);
};

struct memory_failure_entry {
	long unsigned int pfn;
	int flags;
};

struct memory_failure_cpu {
	struct {
		union {
			struct __kfifo kfifo;
			struct memory_failure_entry *type;
			const struct memory_failure_entry *const_type;
			char (*rectype)[0];
			struct memory_failure_entry *ptr;
			const struct memory_failure_entry *ptr_const;
		};
		struct memory_failure_entry buf[16];
	} fifo;
	spinlock_t lock;
	struct work_struct work;
};

struct memory_isolate_notify {
	long unsigned int start_pfn;
	unsigned int nr_pages;
	unsigned int pages_found;
};

struct trace_event_raw_test_pages_isolated {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int fin_pfn;
	char __data[0];
};

struct trace_event_data_offsets_test_pages_isolated {};

typedef void (*btf_trace_test_pages_isolated)(void *, long unsigned int, long unsigned int, long unsigned int);

enum zs_mapmode {
	ZS_MM_RW = 0,
	ZS_MM_RO = 1,
	ZS_MM_WO = 2,
};

struct zs_pool_stats {
	atomic_long_t pages_compacted;
};

struct pseudo_fs_context {
	const struct super_operations *ops;
	const struct xattr_handler **xattr;
	const struct dentry_operations *dops;
	long unsigned int magic;
};

enum fullness_group {
	ZS_EMPTY = 0,
	ZS_ALMOST_EMPTY = 1,
	ZS_ALMOST_FULL = 2,
	ZS_FULL = 3,
	NR_ZS_FULLNESS = 4,
};

enum zs_stat_type {
	CLASS_EMPTY = 0,
	CLASS_ALMOST_EMPTY = 1,
	CLASS_ALMOST_FULL = 2,
	CLASS_FULL = 3,
	OBJ_ALLOCATED = 4,
	OBJ_USED = 5,
	NR_ZS_STAT_TYPE = 6,
};

struct zs_size_stat {
	long unsigned int objs[6];
};

struct size_class {
	spinlock_t lock;
	struct list_head fullness_list[4];
	int size;
	int objs_per_zspage;
	int pages_per_zspage;
	unsigned int index;
	struct zs_size_stat stats;
};

struct link_free {
	union {
		long unsigned int next;
		long unsigned int handle;
	};
};

struct zs_pool {
	const char *name;
	struct size_class *size_class[255];
	struct kmem_cache *handle_cachep;
	struct kmem_cache *zspage_cachep;
	atomic_long_t pages_allocated;
	struct zs_pool_stats stats;
	struct shrinker shrinker;
	struct inode *inode;
	struct work_struct free_work;
	struct wait_queue_head migration_wait;
	atomic_long_t isolated_pages;
	bool destroying;
};

struct zspage {
	struct {
		unsigned int fullness: 2;
		unsigned int class: 9;
		unsigned int isolated: 3;
		unsigned int magic: 8;
	};
	unsigned int inuse;
	unsigned int freeobj;
	struct page *first_page;
	struct list_head list;
	rwlock_t lock;
};

struct mapping_area {
	char *vm_buf;
	char *vm_addr;
	enum zs_mapmode vm_mm;
};

struct zs_compact_control {
	struct page *s_page;
	struct page *d_page;
	int obj_idx;
};

struct balloon_dev_info {
	long unsigned int isolated_pages;
	spinlock_t pages_lock;
	struct list_head pages;
	int (*migratepage)(struct balloon_dev_info *, struct page *, struct page *, enum migrate_mode);
	struct inode *inode;
};

struct hugetlbfs_inode_info {
	struct shared_policy policy;
	struct inode vfs_inode;
	unsigned int seals;
};

typedef s32 compat_off_t;

struct open_flags {
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;
};

typedef __kernel_long_t __kernel_off_t;

typedef __kernel_off_t off_t;

struct file_dedupe_range_info {
	__s64 dest_fd;
	__u64 dest_offset;
	__u64 bytes_deduped;
	__s32 status;
	__u32 reserved;
};

struct file_dedupe_range {
	__u64 src_offset;
	__u64 src_length;
	__u16 dest_count;
	__u16 reserved1;
	__u32 reserved2;
	struct file_dedupe_range_info info[0];
};

typedef int __kernel_rwf_t;

typedef __kernel_rwf_t rwf_t;

typedef s32 compat_ssize_t;

typedef s64 compat_loff_t;

typedef int filler_t___2(void *, struct page *);

enum vfs_get_super_keying {
	vfs_get_single_super = 0,
	vfs_get_single_reconf_super = 1,
	vfs_get_keyed_super = 2,
	vfs_get_independent_super = 3,
};

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);

struct kobj_map;

struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;
	unsigned int baseminor;
	int minorct;
	char name[64];
	struct cdev *cdev;
};

struct stat {
	__kernel_ulong_t st_dev;
	__kernel_ulong_t st_ino;
	__kernel_ulong_t st_nlink;
	unsigned int st_mode;
	unsigned int st_uid;
	unsigned int st_gid;
	unsigned int __pad0;
	__kernel_ulong_t st_rdev;
	__kernel_long_t st_size;
	__kernel_long_t st_blksize;
	__kernel_long_t st_blocks;
	__kernel_ulong_t st_atime;
	__kernel_ulong_t st_atime_nsec;
	__kernel_ulong_t st_mtime;
	__kernel_ulong_t st_mtime_nsec;
	__kernel_ulong_t st_ctime;
	__kernel_ulong_t st_ctime_nsec;
	__kernel_long_t __unused[3];
};

struct __old_kernel_stat {
	short unsigned int st_dev;
	short unsigned int st_ino;
	short unsigned int st_mode;
	short unsigned int st_nlink;
	short unsigned int st_uid;
	short unsigned int st_gid;
	short unsigned int st_rdev;
	unsigned int st_size;
	unsigned int st_atime;
	unsigned int st_mtime;
	unsigned int st_ctime;
};

struct statx_timestamp {
	__s64 tv_sec;
	__u32 tv_nsec;
	__s32 __reserved;
};

struct statx {
	__u32 stx_mask;
	__u32 stx_blksize;
	__u64 stx_attributes;
	__u32 stx_nlink;
	__u32 stx_uid;
	__u32 stx_gid;
	__u16 stx_mode;
	__u16 __spare0[1];
	__u64 stx_ino;
	__u64 stx_size;
	__u64 stx_blocks;
	__u64 stx_attributes_mask;
	struct statx_timestamp stx_atime;
	struct statx_timestamp stx_btime;
	struct statx_timestamp stx_ctime;
	struct statx_timestamp stx_mtime;
	__u32 stx_rdev_major;
	__u32 stx_rdev_minor;
	__u32 stx_dev_major;
	__u32 stx_dev_minor;
	__u64 __spare2[14];
};

typedef u32 compat_ino_t;

typedef u16 __compat_uid_t;

typedef u16 __compat_gid_t;

typedef u16 compat_mode_t;

typedef u16 compat_dev_t;

typedef u16 compat_nlink_t;

struct compat_stat {
	compat_dev_t st_dev;
	u16 __pad1;
	compat_ino_t st_ino;
	compat_mode_t st_mode;
	compat_nlink_t st_nlink;
	__compat_uid_t st_uid;
	__compat_gid_t st_gid;
	compat_dev_t st_rdev;
	u16 __pad2;
	u32 st_size;
	u32 st_blksize;
	u32 st_blocks;
	u32 st_atime;
	u32 st_atime_nsec;
	u32 st_mtime;
	u32 st_mtime_nsec;
	u32 st_ctime;
	u32 st_ctime_nsec;
	u32 __unused4;
	u32 __unused5;
};

typedef short unsigned int ushort;

struct user_arg_ptr {
	bool is_compat;
	union {
		const char * const *native;
		const compat_uptr_t *compat;
	} ptr;
};

typedef void (*GET_EXECVE_INFO)(int, struct user_arg_ptr, const char *);

enum inode_i_mutex_lock_class {
	I_MUTEX_NORMAL = 0,
	I_MUTEX_PARENT = 1,
	I_MUTEX_CHILD = 2,
	I_MUTEX_XATTR = 3,
	I_MUTEX_NONDIR2 = 4,
	I_MUTEX_PARENT2 = 5,
};

struct name_snapshot {
	struct qstr name;
	unsigned char inline_name[32];
};

struct saved {
	struct path link;
	struct delayed_call done;
	const char *name;
	unsigned int seq;
};

struct nameidata {
	struct path path;
	struct qstr last;
	struct path root;
	struct inode *inode;
	unsigned int flags;
	unsigned int seq;
	unsigned int m_seq;
	int last_type;
	unsigned int depth;
	int total_link_count;
	struct saved *stack;
	struct saved internal[2];
	struct filename *name;
	struct nameidata *saved;
	struct inode *link_inode;
	unsigned int root_seq;
	int dfd;
};

enum {
	LAST_NORM = 0,
	LAST_ROOT = 1,
	LAST_DOT = 2,
	LAST_DOTDOT = 3,
	LAST_BIND = 4,
};

struct mount;

struct mnt_namespace {
	atomic_t count;
	struct ns_common ns;
	struct mount *root;
	struct list_head list;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	u64 seq;
	wait_queue_head_t poll;
	u64 event;
	unsigned int mounts;
	unsigned int pending_mounts;
};

struct mnt_pcp;

struct mountpoint;

struct mount {
	struct hlist_node mnt_hash;
	struct mount *mnt_parent;
	struct dentry *mnt_mountpoint;
	struct vfsmount mnt;
	union {
		struct callback_head mnt_rcu;
		struct llist_node mnt_llist;
	};
	struct mnt_pcp *mnt_pcp;
	struct list_head mnt_mounts;
	struct list_head mnt_child;
	struct list_head mnt_instance;
	const char *mnt_devname;
	struct list_head mnt_list;
	struct list_head mnt_expire;
	struct list_head mnt_share;
	struct list_head mnt_slave_list;
	struct list_head mnt_slave;
	struct mount *mnt_master;
	struct mnt_namespace *mnt_ns;
	struct mountpoint *mnt_mp;
	union {
		struct hlist_node mnt_mp_list;
		struct hlist_node mnt_umount;
	};
	struct list_head mnt_umounting;
	struct fsnotify_mark_connector *mnt_fsnotify_marks;
	__u32 mnt_fsnotify_mask;
	int mnt_id;
	int mnt_group_id;
	int mnt_expiry_mark;
	struct hlist_head mnt_pins;
	struct hlist_head mnt_stuck_children;
};

struct mnt_pcp {
	int mnt_count;
	int mnt_writers;
};

struct mountpoint {
	struct hlist_node m_hash;
	struct dentry *m_dentry;
	struct hlist_head m_list;
	int m_count;
};

enum {
	WALK_FOLLOW = 1,
	WALK_MORE = 2,
};

struct word_at_a_time {
	const long unsigned int one_bits;
	const long unsigned int high_bits;
};

struct f_owner_ex {
	int type;
	__kernel_pid_t pid;
};

struct flock {
	short int l_type;
	short int l_whence;
	__kernel_off_t l_start;
	__kernel_off_t l_len;
	__kernel_pid_t l_pid;
};

struct compat_flock {
	short int l_type;
	short int l_whence;
	compat_off_t l_start;
	compat_off_t l_len;
	compat_pid_t l_pid;
};

struct compat_flock64 {
	short int l_type;
	short int l_whence;
	compat_loff_t l_start;
	compat_loff_t l_len;
	compat_pid_t l_pid;
} __attribute__((packed));

struct fiemap {
	__u64 fm_start;
	__u64 fm_length;
	__u32 fm_flags;
	__u32 fm_mapped_extents;
	__u32 fm_extent_count;
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0];
};

struct file_clone_range {
	__s64 src_fd;
	__u64 src_offset;
	__u64 src_length;
	__u64 dest_offset;
};

typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);

struct space_resv {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

struct nv_get_pid_count {
	u32 count;
};

struct pids {
	u32 pid;
	u32 pad[9];
};

struct nv_get_gram {
	u32 count;
	u32 pad;
	struct pids pid[0];
};

struct nv_cmd {
	u32 u1;
	u32 u2;
	u64 cmd;
	void *data;
};

struct linux_dirent64 {
	u64 d_ino;
	s64 d_off;
	short unsigned int d_reclen;
	unsigned char d_type;
	char d_name[0];
};

struct old_linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_offset;
	short unsigned int d_namlen;
	char d_name[1];
};

struct readdir_callback {
	struct dir_context ctx;
	struct old_linux_dirent *dirent;
	int result;
};

struct linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_off;
	short unsigned int d_reclen;
	char d_name[1];
};

struct getdents_callback {
	struct dir_context ctx;
	struct linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct compat_old_linux_dirent {
	compat_ulong_t d_ino;
	compat_ulong_t d_offset;
	short unsigned int d_namlen;
	char d_name[1];
};

struct compat_readdir_callback {
	struct dir_context ctx;
	struct compat_old_linux_dirent *dirent;
	int result;
};

struct compat_linux_dirent {
	compat_ulong_t d_ino;
	compat_ulong_t d_off;
	short unsigned int d_reclen;
	char d_name[1];
};

struct compat_getdents_callback {
	struct dir_context ctx;
	struct compat_linux_dirent *current_dir;
	struct compat_linux_dirent *previous;
	int count;
	int error;
};

typedef struct {
	long unsigned int fds_bits[16];
} __kernel_fd_set;

typedef __kernel_fd_set fd_set;

struct poll_table_entry {
	struct file *filp;
	__poll_t key;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_address;
};

struct poll_table_page;

struct poll_wqueues {
	poll_table pt;
	struct poll_table_page *table;
	struct task_struct *polling_task;
	int triggered;
	int error;
	int inline_index;
	struct poll_table_entry inline_entries[9];
};

struct poll_table_page {
	struct poll_table_page *next;
	struct poll_table_entry *entry;
	struct poll_table_entry entries[0];
};

enum poll_time_type {
	PT_TIMEVAL = 0,
	PT_OLD_TIMEVAL = 1,
	PT_TIMESPEC = 2,
	PT_OLD_TIMESPEC = 3,
};

typedef struct {
	long unsigned int *in;
	long unsigned int *out;
	long unsigned int *ex;
	long unsigned int *res_in;
	long unsigned int *res_out;
	long unsigned int *res_ex;
} fd_set_bits;

struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};

struct compat_sel_arg_struct {
	compat_ulong_t n;
	compat_uptr_t inp;
	compat_uptr_t outp;
	compat_uptr_t exp;
	compat_uptr_t tvp;
};

enum dentry_d_lock_class {
	DENTRY_D_LOCK_NORMAL = 0,
	DENTRY_D_LOCK_NESTED = 1,
};

struct external_name {
	union {
		atomic_t count;
		struct callback_head head;
	} u;
	unsigned char name[0];
};

enum d_walk_ret {
	D_WALK_CONTINUE = 0,
	D_WALK_QUIT = 1,
	D_WALK_NORETRY = 2,
	D_WALK_SKIP = 3,
};

struct check_mount {
	struct vfsmount *mnt;
	unsigned int mounted;
};

struct select_data {
	struct dentry *start;
	union {
		long int found;
		struct dentry *victim;
	};
	struct list_head dispose;
};

struct fsxattr {
	__u32 fsx_xflags;
	__u32 fsx_extsize;
	__u32 fsx_nextents;
	__u32 fsx_projid;
	__u32 fsx_cowextsize;
	unsigned char fsx_pad[8];
};

enum file_time_flags {
	S_ATIME = 1,
	S_MTIME = 2,
	S_CTIME = 4,
	S_VERSION = 8,
};

struct proc_mounts {
	struct mnt_namespace *ns;
	struct path root;
	int (*show)(struct seq_file *, struct vfsmount *);
	void *cached_mount;
	u64 cached_event;
	loff_t cached_index;
};

enum umount_tree_flags {
	UMOUNT_SYNC = 1,
	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
};

struct simple_transaction_argresp {
	ssize_t size;
	char data[0];
};

struct simple_attr {
	int (*get)(void *, u64 *);
	int (*set)(void *, u64);
	char get_buf[24];
	char set_buf[24];
	void *data;
	const char *fmt;
	struct mutex mutex;
};

struct wb_writeback_work {
	long int nr_pages;
	struct super_block *sb;
	enum writeback_sync_modes sync_mode;
	unsigned int tagged_writepages: 1;
	unsigned int for_kupdate: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_background: 1;
	unsigned int for_sync: 1;
	unsigned int auto_free: 1;
	enum wb_reason reason;
	struct list_head list;
	struct wb_completion *done;
};

struct trace_event_raw_writeback_page_template {
	struct trace_entry ent;
	char name[32];
	long unsigned int ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_writeback_dirty_inode_template {
	struct trace_entry ent;
	char name[32];
	long unsigned int ino;
	long unsigned int state;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_inode_foreign_history {
	struct trace_entry ent;
	char name[32];
	long unsigned int ino;
	unsigned int cgroup_ino;
	unsigned int history;
	char __data[0];
};

struct trace_event_raw_inode_switch_wbs {
	struct trace_entry ent;
	char name[32];
	long unsigned int ino;
	unsigned int old_cgroup_ino;
	unsigned int new_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_track_foreign_dirty {
	struct trace_entry ent;
	char name[32];
	u64 bdi_id;
	long unsigned int ino;
	unsigned int memcg_id;
	unsigned int cgroup_ino;
	unsigned int page_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_flush_foreign {
	struct trace_entry ent;
	char name[32];
	unsigned int cgroup_ino;
	unsigned int frn_bdi_id;
	unsigned int frn_memcg_id;
	char __data[0];
};

struct trace_event_raw_writeback_write_inode_template {
	struct trace_entry ent;
	char name[32];
	long unsigned int ino;
	int sync_mode;
	unsigned int cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_work_class {
	struct trace_entry ent;
	char name[32];
	long int nr_pages;
	dev_t sb_dev;
	int sync_mode;
	int for_kupdate;
	int range_cyclic;
	int for_background;
	int reason;
	unsigned int cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_pages_written {
	struct trace_entry ent;
	long int pages;
	char __data[0];
};

struct trace_event_raw_writeback_class {
	struct trace_entry ent;
	char name[32];
	unsigned int cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_bdi_register {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_wbc_class {
	struct trace_entry ent;
	char name[32];
	long int nr_to_write;
	long int pages_skipped;
	int sync_mode;
	int for_kupdate;
	int for_background;
	int for_reclaim;
	int range_cyclic;
	long int range_start;
	long int range_end;
	unsigned int cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_queue_io {
	struct trace_entry ent;
	char name[32];
	long unsigned int older;
	long int age;
	int moved;
	int reason;
	unsigned int cgroup_ino;
	char __data[0];
};

struct trace_event_raw_global_dirty_state {
	struct trace_entry ent;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_unstable;
	long unsigned int background_thresh;
	long unsigned int dirty_thresh;
	long unsigned int dirty_limit;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	char __data[0];
};

struct trace_event_raw_bdi_dirty_ratelimit {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int write_bw;
	long unsigned int avg_write_bw;
	long unsigned int dirty_rate;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	unsigned int cgroup_ino;
	char __data[0];
};

struct trace_event_raw_balance_dirty_pages {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int limit;
	long unsigned int setpoint;
	long unsigned int dirty;
	long unsigned int bdi_setpoint;
	long unsigned int bdi_dirty;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	unsigned int dirtied;
	unsigned int dirtied_pause;
	long unsigned int paused;
	long int pause;
	long unsigned int period;
	long int think;
	unsigned int cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_sb_inodes_requeue {
	struct trace_entry ent;
	char name[32];
	long unsigned int ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	unsigned int cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_congest_waited_template {
	struct trace_entry ent;
	unsigned int usec_timeout;
	unsigned int usec_delayed;
	char __data[0];
};

struct trace_event_raw_writeback_single_inode_template {
	struct trace_entry ent;
	char name[32];
	long unsigned int ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	long unsigned int writeback_index;
	long int nr_to_write;
	long unsigned int wrote;
	unsigned int cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_inode_template {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ino;
	long unsigned int state;
	__u16 mode;
	long unsigned int dirtied_when;
	char __data[0];
};

struct trace_event_data_offsets_writeback_page_template {};

struct trace_event_data_offsets_writeback_dirty_inode_template {};

struct trace_event_data_offsets_inode_foreign_history {};

struct trace_event_data_offsets_inode_switch_wbs {};

struct trace_event_data_offsets_track_foreign_dirty {};

struct trace_event_data_offsets_flush_foreign {};

struct trace_event_data_offsets_writeback_write_inode_template {};

struct trace_event_data_offsets_writeback_work_class {};

struct trace_event_data_offsets_writeback_pages_written {};

struct trace_event_data_offsets_writeback_class {};

struct trace_event_data_offsets_writeback_bdi_register {};

struct trace_event_data_offsets_wbc_class {};

struct trace_event_data_offsets_writeback_queue_io {};

struct trace_event_data_offsets_global_dirty_state {};

struct trace_event_data_offsets_bdi_dirty_ratelimit {};

struct trace_event_data_offsets_balance_dirty_pages {};

struct trace_event_data_offsets_writeback_sb_inodes_requeue {};

struct trace_event_data_offsets_writeback_congest_waited_template {};

struct trace_event_data_offsets_writeback_single_inode_template {};

struct trace_event_data_offsets_writeback_inode_template {};

typedef void (*btf_trace_writeback_dirty_page)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_wait_on_page_writeback)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);

typedef void (*btf_trace_inode_foreign_history)(void *, struct inode *, struct writeback_control *, unsigned int);

typedef void (*btf_trace_inode_switch_wbs)(void *, struct inode *, struct bdi_writeback *, struct bdi_writeback *);

typedef void (*btf_trace_track_foreign_dirty)(void *, struct page *, struct bdi_writeback *);

typedef void (*btf_trace_flush_foreign)(void *, struct bdi_writeback *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_pages_written)(void *, long int);

typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);

typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);

typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);

typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, long unsigned int, int);

typedef void (*btf_trace_global_dirty_state)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, long unsigned int, long unsigned int);

typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long int, long unsigned int);

typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);

typedef void (*btf_trace_writeback_congestion_wait)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_wait_iff_congested)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);

typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);

typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);

typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);

struct inode_switch_wbs_context {
	struct inode *inode;
	struct bdi_writeback *new_wb;
	struct callback_head callback_head;
	struct work_struct work;
};

struct splice_desc {
	size_t total_len;
	unsigned int len;
	unsigned int flags;
	union {
		void *userptr;
		struct file *file;
		void *data;
	} u;
	loff_t pos;
	loff_t *opos;
	size_t num_spliced;
	bool need_wakeup;
};

typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);

typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);

struct utimbuf {
	__kernel_time_t actime;
	__kernel_time_t modtime;
};

struct old_utimbuf32 {
	old_time32_t actime;
	old_time32_t modtime;
};

typedef int __kernel_daddr_t;

struct ustat {
	__kernel_daddr_t f_tfree;
	__kernel_ino_t f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

typedef s32 compat_daddr_t;

typedef __kernel_fsid_t compat_fsid_t;

struct compat_statfs {
	int f_type;
	int f_bsize;
	int f_blocks;
	int f_bfree;
	int f_bavail;
	int f_files;
	int f_ffree;
	compat_fsid_t f_fsid;
	int f_namelen;
	int f_frsize;
	int f_flags;
	int f_spare[4];
};

struct compat_ustat {
	compat_daddr_t f_tfree;
	compat_ino_t f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct statfs {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__kernel_long_t f_blocks;
	__kernel_long_t f_bfree;
	__kernel_long_t f_bavail;
	__kernel_long_t f_files;
	__kernel_long_t f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct statfs64 {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct compat_statfs64 {
	__u32 f_type;
	__u32 f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__u32 f_namelen;
	__u32 f_frsize;
	__u32 f_flags;
	__u32 f_spare[4];
} __attribute__((packed));

struct ns_get_path_task_args {
	const struct proc_ns_operations *ns_ops;
	struct task_struct *task;
};

struct constant_table {
	const char *name;
	int value;
};

enum legacy_fs_param {
	LEGACY_FS_UNSET_PARAMS = 0,
	LEGACY_FS_MONOLITHIC_PARAMS = 1,
	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
};

struct legacy_fs_context {
	char *legacy_data;
	size_t data_size;
	enum legacy_fs_param param_type;
};

enum fsconfig_command {
	FSCONFIG_SET_FLAG = 0,
	FSCONFIG_SET_STRING = 1,
	FSCONFIG_SET_BINARY = 2,
	FSCONFIG_SET_PATH = 3,
	FSCONFIG_SET_PATH_EMPTY = 4,
	FSCONFIG_SET_FD = 5,
	FSCONFIG_CMD_CREATE = 6,
	FSCONFIG_CMD_RECONFIGURE = 7,
};

struct dax_device;

struct iomap_page_ops;

struct iomap {
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	struct block_device *bdev;
	struct dax_device *dax_dev;
	void *inline_data;
	void *private;
	const struct iomap_page_ops *page_ops;
};

struct iomap_page_ops {
	int (*page_prepare)(struct inode *, loff_t, unsigned int, struct iomap *);
	void (*page_done)(struct inode *, loff_t, unsigned int, struct page *, struct iomap *);
};

struct bh_lru {
	struct buffer_head *bhs[16];
};

struct bh_accounting {
	int nr;
	int ratelimit;
};

typedef struct buffer_head *pto_T_____30;

enum {
	DISK_EVENT_MEDIA_CHANGE = 1,
	DISK_EVENT_EJECT_REQUEST = 2,
};

enum {
	BIOSET_NEED_BVECS = 1,
	BIOSET_NEED_RESCUER = 2,
};

struct bdev_inode {
	struct block_device bdev;
	struct inode vfs_inode;
};

struct blkdev_dio {
	union {
		struct kiocb *iocb;
		struct task_struct *waiter;
	};
	size_t size;
	atomic_t ref;
	bool multi_bio: 1;
	bool should_dirty: 1;
	bool is_sync: 1;
	struct bio bio;
};

struct bd_holder_disk {
	struct list_head list;
	struct gendisk *disk;
	int refcnt;
};

typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);

typedef void dio_submit_t(struct bio *, struct inode *, loff_t);

enum {
	DIO_LOCKING = 1,
	DIO_SKIP_HOLES = 2,
};

struct dio_submit {
	struct bio *bio;
	unsigned int blkbits;
	unsigned int blkfactor;
	unsigned int start_zero_done;
	int pages_in_io;
	sector_t block_in_file;
	unsigned int blocks_available;
	int reap_counter;
	sector_t final_block_in_request;
	int boundary;
	get_block_t *get_block;
	dio_submit_t *submit_io;
	loff_t logical_offset_in_bio;
	sector_t final_block_in_bio;
	sector_t next_block_for_io;
	struct page *cur_page;
	unsigned int cur_page_offset;
	unsigned int cur_page_len;
	sector_t cur_page_block;
	loff_t cur_page_fs_offset;
	struct iov_iter *iter;
	unsigned int head;
	unsigned int tail;
	size_t from;
	size_t to;
};

struct dio {
	int flags;
	int op;
	int op_flags;
	blk_qc_t bio_cookie;
	struct gendisk *bio_disk;
	struct inode *inode;
	loff_t i_size;
	dio_iodone_t *end_io;
	void *private;
	spinlock_t bio_lock;
	int page_errors;
	int is_async;
	bool defer_completion;
	bool should_dirty;
	int io_error;
	long unsigned int refcount;
	struct bio *bio_list;
	struct task_struct *waiter;
	struct kiocb *iocb;
	ssize_t result;
	union {
		struct page *pages[64];
		struct work_struct complete_work;
	};
	long: 64;
};

struct bvec_iter_all {
	struct bio_vec bv;
	int idx;
	unsigned int done;
};

typedef int (*writepage_t___2)(struct page *, struct writeback_control *, void *);

struct mpage_readpage_args {
	struct bio *bio;
	struct page *page;
	unsigned int nr_pages;
	bool is_readahead;
	sector_t last_block_in_bio;
	struct buffer_head map_bh;
	long unsigned int first_logical_block;
	get_block_t *get_block;
};

struct mpage_data {
	struct bio *bio;
	sector_t last_block_in_bio;
	get_block_t *get_block;
	unsigned int use_writepage;
};

typedef u32 nlink_t;

typedef int (*proc_write_t)(struct file *, char *, size_t);

struct proc_dir_entry {
	atomic_t in_use;
	refcount_t refcnt;
	struct list_head pde_openers;
	spinlock_t pde_unload_lock;
	struct completion *pde_unload_completion;
	const struct inode_operations *proc_iops;
	const struct file_operations *proc_fops;
	const struct dentry_operations *proc_dops;
	union {
		const struct seq_operations *seq_ops;
		int (*single_show)(struct seq_file *, void *);
	};
	proc_write_t write;
	void *data;
	unsigned int state_size;
	unsigned int low_ino;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct proc_dir_entry *parent;
	struct rb_root subdir;
	struct rb_node subdir_node;
	char *name;
	umode_t mode;
	u8 namelen;
	char inline_name[0];
};

union proc_op {
	int (*proc_get_link)(struct dentry *, struct path *);
	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
	const char *lsm;
};

struct proc_inode {
	struct pid *pid;
	unsigned int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	struct ctl_table *sysctl_entry;
	struct hlist_node sysctl_inodes;
	const struct proc_ns_operations *ns_ops;
	struct inode vfs_inode;
};

struct proc_fs_info {
	int flag;
	const char *str;
};

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	unsigned char f_handle[0];
};

struct inotify_inode_mark {
	struct fsnotify_mark fsn_mark;
	int wd;
};

struct dnotify_struct {
	struct dnotify_struct *dn_next;
	__u32 dn_mask;
	int dn_fd;
	struct file *dn_filp;
	fl_owner_t dn_owner;
};

struct dnotify_mark {
	struct fsnotify_mark fsn_mark;
	struct dnotify_struct *dn;
};

struct inotify_event_info {
	struct fsnotify_event fse;
	u32 mask;
	int wd;
	u32 sync_cookie;
	int name_len;
	char name[0];
};

struct inotify_event {
	__s32 wd;
	__u32 mask;
	__u32 cookie;
	__u32 len;
	char name[0];
};

enum {
	FAN_EVENT_INIT = 0,
	FAN_EVENT_REPORTED = 1,
	FAN_EVENT_ANSWERED = 2,
	FAN_EVENT_CANCELED = 3,
};

struct fanotify_fid {
	__kernel_fsid_t fsid;
	union {
		unsigned char fh[16];
		unsigned char *ext_fh;
	};
};

struct fanotify_event {
	struct fsnotify_event fse;
	u32 mask;
	u8 fh_type;
	u8 fh_len;
	u16 pad;
	union {
		struct path path;
		struct fanotify_fid fid;
	};
	struct pid *pid;
};

struct fanotify_perm_event {
	struct fanotify_event fae;
	short unsigned int response;
	short unsigned int state;
	int fd;
};

struct fanotify_event_metadata {
	__u32 event_len;
	__u8 vers;
	__u8 reserved;
	__u16 metadata_len;
	__u64 mask;
	__s32 fd;
	__s32 pid;
};

struct fanotify_event_info_header {
	__u8 info_type;
	__u8 pad;
	__u16 len;
};

struct fanotify_event_info_fid {
	struct fanotify_event_info_header hdr;
	__kernel_fsid_t fsid;
	unsigned char handle[0];
};

struct fanotify_response {
	__s32 fd;
	__u32 response;
};

struct cgroupfs_entry {
	struct rb_root subdir;
	struct rb_node subdir_node;
	const char *name;
	struct cgroupfs_entry *parent;
	struct super_block *sb;
	refcount_t refcnt;
	u64 inum;
	int cgroupfs_type;
	int cpu;
	umode_t mode;
	int namelen;
	const struct inode_operations *e_iops;
	const struct file_operations *e_fops;
	const struct dentry_operations *e_dops;
	void *private;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

typedef struct cgroupfs_entry cgroupfs_entry_t;

struct epoll_event {
	__poll_t events;
	__u64 data;
} __attribute__((packed));

struct epoll_filefd {
	struct file *file;
	int fd;
} __attribute__((packed));

struct nested_call_node {
	struct list_head llink;
	void *cookie;
	void *ctx;
};

struct nested_calls {
	struct list_head tasks_call_list;
	spinlock_t lock;
};

struct eventpoll;

struct epitem {
	union {
		struct rb_node rbn;
		struct callback_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;
	int nwait;
	struct list_head pwqlist;
	struct eventpoll *ep;
	struct list_head fllink;
	struct wakeup_source *ws;
	struct epoll_event event;
};

struct eventpoll {
	struct mutex mtx;
	wait_queue_head_t wq;
	wait_queue_head_t poll_wait;
	struct list_head rdllist;
	rwlock_t lock;
	struct rb_root_cached rbr;
	struct epitem *ovflist;
	struct wakeup_source *ws;
	struct user_struct *user;
	struct file *file;
	u64 gen;
	unsigned int napi_id;
};

struct eppoll_entry {
	struct list_head llink;
	struct epitem *base;
	wait_queue_entry_t wait;
	wait_queue_head_t *whead;
};

struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};

struct ep_send_events_data {
	int maxevents;
	struct epoll_event *events;
	int res;
};

struct signalfd_siginfo {
	__u32 ssi_signo;
	__s32 ssi_errno;
	__s32 ssi_code;
	__u32 ssi_pid;
	__u32 ssi_uid;
	__s32 ssi_fd;
	__u32 ssi_tid;
	__u32 ssi_band;
	__u32 ssi_overrun;
	__u32 ssi_trapno;
	__s32 ssi_status;
	__s32 ssi_int;
	__u64 ssi_ptr;
	__u64 ssi_utime;
	__u64 ssi_stime;
	__u64 ssi_addr;
	__u16 ssi_addr_lsb;
	__u16 __pad2;
	__s32 ssi_syscall;
	__u64 ssi_call_addr;
	__u32 ssi_arch;
	__u8 __pad[28];
};

struct signalfd_ctx {
	sigset_t sigmask;
};

struct itimerspec {
	struct timespec it_interval;
	struct timespec it_value;
};

struct timerfd_ctx {
	union {
		struct hrtimer tmr;
		struct alarm alarm;
	} t;
	ktime_t tintv;
	ktime_t moffs;
	wait_queue_head_t wqh;
	u64 ticks;
	int clockid;
	short unsigned int expired;
	short unsigned int settime_flags;
	struct callback_head rcu;
	struct list_head clist;
	spinlock_t cancel_lock;
	bool might_cancel;
};

struct eventfd_ctx {
	struct kref kref;
	wait_queue_head_t wqh;
	__u64 count;
	unsigned int flags;
	int id;
};

enum userfaultfd_state {
	UFFD_STATE_WAIT_API = 0,
	UFFD_STATE_RUNNING = 1,
};

struct userfaultfd_ctx {
	wait_queue_head_t fault_pending_wqh;
	wait_queue_head_t fault_wqh;
	wait_queue_head_t fd_wqh;
	wait_queue_head_t event_wqh;
	struct seqcount refile_seq;
	refcount_t refcount;
	unsigned int flags;
	unsigned int features;
	enum userfaultfd_state state;
	bool released;
	bool mmap_changing;
	struct mm_struct *mm;
};

struct uffd_msg {
	__u8 event;
	__u8 reserved1;
	__u16 reserved2;
	__u32 reserved3;
	union {
		struct {
			__u64 flags;
			__u64 address;
			union {
				__u32 ptid;
			} feat;
		} pagefault;
		struct {
			__u32 ufd;
		} fork;
		struct {
			__u64 from;
			__u64 to;
			__u64 len;
		} remap;
		struct {
			__u64 start;
			__u64 end;
		} remove;
		struct {
			__u64 reserved1;
			__u64 reserved2;
			__u64 reserved3;
		} reserved;
	} arg;
};

struct uffdio_api {
	__u64 api;
	__u64 features;
	__u64 ioctls;
};

struct uffdio_range {
	__u64 start;
	__u64 len;
};

struct uffdio_register {
	struct uffdio_range range;
	__u64 mode;
	__u64 ioctls;
};

struct uffdio_copy {
	__u64 dst;
	__u64 src;
	__u64 len;
	__u64 mode;
	__s64 copy;
};

struct uffdio_zeropage {
	struct uffdio_range range;
	__u64 mode;
	__s64 zeropage;
};

struct userfaultfd_fork_ctx {
	struct userfaultfd_ctx *orig;
	struct userfaultfd_ctx *new;
	struct list_head list;
};

struct userfaultfd_unmap_ctx {
	struct userfaultfd_ctx *ctx;
	long unsigned int start;
	long unsigned int end;
	struct list_head list;
};

struct userfaultfd_wait_queue {
	struct uffd_msg msg;
	wait_queue_entry_t wq;
	struct userfaultfd_ctx *ctx;
	bool waken;
};

struct userfaultfd_wake_range {
	long unsigned int start;
	long unsigned int len;
};

struct kioctx;

struct kioctx_table {
	struct callback_head rcu;
	unsigned int nr;
	struct kioctx *table[0];
};

typedef __kernel_ulong_t aio_context_t;

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	IOCB_CMD_POLL = 5,
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

struct io_event {
	__u64 data;
	__u64 obj;
	__s64 res;
	__s64 res2;
};

struct iocb {
	__u64 aio_data;
	__u32 aio_key;
	__kernel_rwf_t aio_rw_flags;
	__u16 aio_lio_opcode;
	__s16 aio_reqprio;
	__u32 aio_fildes;
	__u64 aio_buf;
	__u64 aio_nbytes;
	__s64 aio_offset;
	__u64 aio_reserved2;
	__u32 aio_flags;
	__u32 aio_resfd;
};

typedef u32 compat_aio_context_t;

typedef int kiocb_cancel_fn(struct kiocb *);

struct aio_ring {
	unsigned int id;
	unsigned int nr;
	unsigned int head;
	unsigned int tail;
	unsigned int magic;
	unsigned int compat_features;
	unsigned int incompat_features;
	unsigned int header_length;
	struct io_event io_events[0];
};

struct kioctx_cpu;

struct ctx_rq_wait;

struct kioctx {
	struct percpu_ref users;
	atomic_t dead;
	struct percpu_ref reqs;
	long unsigned int user_id;
	struct kioctx_cpu *cpu;
	unsigned int req_batch;
	unsigned int max_reqs;
	unsigned int nr_events;
	long unsigned int mmap_base;
	long unsigned int mmap_size;
	struct page **ring_pages;
	long int nr_pages;
	struct rcu_work free_rwork;
	struct ctx_rq_wait *rq_wait;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct {
		atomic_t reqs_available;
		long: 32;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t ctx_lock;
		struct list_head active_reqs;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex ring_lock;
		wait_queue_head_t wait;
		long: 64;
	};
	struct {
		unsigned int tail;
		unsigned int completed_events;
		spinlock_t completion_lock;
		long: 32;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct page *internal_pages[8];
	struct file *aio_ring_file;
	unsigned int id;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kioctx_cpu {
	unsigned int reqs_available;
};

struct ctx_rq_wait {
	struct completion comp;
	atomic_t count;
};

struct fsync_iocb {
	struct file *file;
	struct work_struct work;
	bool datasync;
	struct cred *creds;
};

struct poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool done;
	bool cancelled;
	struct wait_queue_entry wait;
	struct work_struct work;
};

struct aio_kiocb {
	union {
		struct file *ki_filp;
		struct kiocb rw;
		struct fsync_iocb fsync;
		struct poll_iocb poll;
	};
	struct kioctx *ki_ctx;
	kiocb_cancel_fn *ki_cancel;
	struct io_event ki_res;
	struct list_head ki_list;
	refcount_t ki_refcnt;
	struct eventfd_ctx *ki_eventfd;
};

struct aio_poll_table {
	struct poll_table_struct pt;
	struct aio_kiocb *iocb;
	int error;
};

struct __aio_sigset {
	const sigset_t *sigmask;
	size_t sigsetsize;
};

struct __compat_aio_sigset {
	compat_uptr_t sigmask;
	compat_size_t sigsetsize;
};

enum {
	PERCPU_REF_INIT_ATOMIC = 1,
	PERCPU_REF_INIT_DEAD = 2,
	PERCPU_REF_ALLOW_REINIT = 4,
};

struct user_msghdr {
	void *msg_name;
	int msg_namelen;
	struct iovec *msg_iov;
	__kernel_size_t msg_iovlen;
	void *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
};

struct scm_fp_list {
	short int count;
	short int max;
	struct user_struct *user;
	struct file *fp[253];
};

struct unix_skb_parms {
	struct pid *pid;
	kuid_t uid;
	kgid_t gid;
	struct scm_fp_list *fp;
	u32 secid;
	u32 consumed;
};

struct io_uring_sqe {
	__u8 opcode;
	__u8 flags;
	__u16 ioprio;
	__s32 fd;
	__u64 off;
	__u64 addr;
	__u32 len;
	union {
		__kernel_rwf_t rw_flags;
		__u32 fsync_flags;
		__u16 poll_events;
		__u32 sync_range_flags;
		__u32 msg_flags;
		__u32 timeout_flags;
	};
	__u64 user_data;
	union {
		__u16 buf_index;
		__u64 __pad2[3];
	};
};

struct io_uring_cqe {
	__u64 user_data;
	__s32 res;
	__u32 flags;
};

struct io_sqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 flags;
	__u32 dropped;
	__u32 array;
	__u32 resv1;
	__u64 resv2;
};

struct io_cqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 overflow;
	__u32 cqes;
	__u64 resv[2];
};

struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u32 sq_thread_cpu;
	__u32 sq_thread_idle;
	__u32 features;
	__u32 resv[4];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

struct io_uring {
	u32 head;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 tail;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_rings {
	struct io_uring sq;
	struct io_uring cq;
	u32 sq_ring_mask;
	u32 cq_ring_mask;
	u32 sq_ring_entries;
	u32 cq_ring_entries;
	u32 sq_dropped;
	u32 sq_flags;
	u32 cq_overflow;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct io_uring_cqe cqes[0];
};

struct io_mapped_ubuf {
	u64 ubuf;
	size_t len;
	struct bio_vec *bvec;
	unsigned int nr_bvecs;
};

struct async_list {
	spinlock_t lock;
	atomic_t cnt;
	struct list_head list;
	struct file *file;
	off_t io_start;
	size_t io_len;
};

struct io_ring_ctx {
	struct {
		struct percpu_ref refs;
		long: 64;
	};
	struct {
		unsigned int flags;
		bool compat;
		bool account_mem;
		u32 *sq_array;
		unsigned int cached_sq_head;
		unsigned int sq_entries;
		unsigned int sq_mask;
		unsigned int sq_thread_idle;
		unsigned int cached_sq_dropped;
		struct io_uring_sqe *sq_sqes;
		struct list_head defer_list;
		struct list_head timeout_list;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct workqueue_struct *sqo_wq[2];
	struct task_struct *sqo_thread;
	struct mm_struct *sqo_mm;
	wait_queue_head_t sqo_wait;
	struct completion sqo_thread_started;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct {
		unsigned int cached_cq_tail;
		atomic_t cached_cq_overflow;
		unsigned int cq_entries;
		unsigned int cq_mask;
		struct wait_queue_head cq_wait;
		struct fasync_struct *cq_fasync;
		struct eventfd_ctx *cq_ev_fd;
		atomic_t cq_timeouts;
	};
	struct io_rings *rings;
	struct file **user_files;
	unsigned int nr_user_files;
	unsigned int nr_user_bufs;
	struct io_mapped_ubuf *user_bufs;
	struct user_struct *user;
	const struct cred *creds;
	struct completion ctx_done;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct {
		struct mutex uring_lock;
		wait_queue_head_t wait;
		long: 64;
	};
	struct {
		spinlock_t completion_lock;
		bool poll_multi_file;
		struct list_head poll_list;
		struct list_head cancel_list;
		long: 64;
		long: 64;
		long: 64;
	};
	struct async_list pending_async[2];
	struct socket *ring_sock;
	struct list_head task_list;
	spinlock_t task_lock;
};

struct sqe_submit {
	const struct io_uring_sqe *sqe;
	short unsigned int index;
	u32 sequence;
	bool has_user;
	bool needs_lock;
	bool needs_fixed_file;
	u8 opcode;
};

struct io_poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool done;
	bool canceled;
	struct wait_queue_entry wait;
};

struct io_timeout {
	struct file *file;
	struct hrtimer timer;
};

struct io_kiocb {
	union {
		struct file *file;
		struct kiocb rw;
		struct io_poll_iocb poll;
		struct io_timeout timeout;
	};
	struct sqe_submit submit;
	struct io_ring_ctx *ctx;
	struct list_head list;
	struct list_head link_list;
	unsigned int flags;
	refcount_t refs;
	long unsigned int fsize;
	u64 user_data;
	u32 result;
	u32 sequence;
	struct files_struct *files;
	struct fs_struct *fs;
	struct work_struct work;
	struct task_struct *work_task;
	struct list_head task_list;
};

struct io_submit_state {
	struct blk_plug plug;
	void *reqs[8];
	unsigned int free_reqs;
	unsigned int cur_req;
	struct file *file;
	unsigned int fd;
	unsigned int has_refs;
	unsigned int used_refs;
	unsigned int ios_left;
};

struct io_poll_table {
	struct poll_table_struct pt;
	struct io_kiocb *req;
	int error;
};

struct io_wait_queue {
	struct wait_queue_entry wq;
	struct io_ring_ctx *ctx;
	unsigned int to_wait;
	unsigned int nr_timeouts;
};

struct iomap_ops {
	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap *);
	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap *);
};

typedef loff_t (*iomap_actor_t)(struct inode *, loff_t, loff_t, void *, struct iomap *);

struct trace_event_raw_dax_pmd_fault_class {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int vm_start;
	long unsigned int vm_end;
	long unsigned int vm_flags;
	long unsigned int address;
	long unsigned int pgoff;
	long unsigned int max_pgoff;
	dev_t dev;
	unsigned int flags;
	int result;
	char __data[0];
};

struct trace_event_raw_dax_pmd_load_hole_class {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int vm_flags;
	long unsigned int address;
	struct page *zero_page;
	void *radix_entry;
	dev_t dev;
	char __data[0];
};

struct trace_event_raw_dax_pmd_insert_mapping_class {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int vm_flags;
	long unsigned int address;
	long int length;
	u64 pfn_val;
	void *radix_entry;
	dev_t dev;
	int write;
	char __data[0];
};

struct trace_event_raw_dax_pte_fault_class {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int vm_flags;
	long unsigned int address;
	long unsigned int pgoff;
	dev_t dev;
	unsigned int flags;
	int result;
	char __data[0];
};

struct trace_event_raw_dax_insert_mapping {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int vm_flags;
	long unsigned int address;
	void *radix_entry;
	dev_t dev;
	int write;
	char __data[0];
};

struct trace_event_raw_dax_writeback_range_class {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int start_index;
	long unsigned int end_index;
	dev_t dev;
	char __data[0];
};

struct trace_event_raw_dax_writeback_one {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int pgoff;
	long unsigned int pglen;
	dev_t dev;
	char __data[0];
};

struct trace_event_data_offsets_dax_pmd_fault_class {};

struct trace_event_data_offsets_dax_pmd_load_hole_class {};

struct trace_event_data_offsets_dax_pmd_insert_mapping_class {};

struct trace_event_data_offsets_dax_pte_fault_class {};

struct trace_event_data_offsets_dax_insert_mapping {};

struct trace_event_data_offsets_dax_writeback_range_class {};

struct trace_event_data_offsets_dax_writeback_one {};

typedef void (*btf_trace_dax_pmd_fault)(void *, struct inode *, struct vm_fault *, long unsigned int, int);

typedef void (*btf_trace_dax_pmd_fault_done)(void *, struct inode *, struct vm_fault *, long unsigned int, int);

typedef void (*btf_trace_dax_pmd_load_hole)(void *, struct inode *, struct vm_fault *, struct page *, void *);

typedef void (*btf_trace_dax_pmd_load_hole_fallback)(void *, struct inode *, struct vm_fault *, struct page *, void *);

typedef void (*btf_trace_dax_pmd_insert_mapping)(void *, struct inode *, struct vm_fault *, long int, pfn_t, void *);

typedef void (*btf_trace_dax_pte_fault)(void *, struct inode *, struct vm_fault *, int);

typedef void (*btf_trace_dax_pte_fault_done)(void *, struct inode *, struct vm_fault *, int);

typedef void (*btf_trace_dax_load_hole)(void *, struct inode *, struct vm_fault *, int);

typedef void (*btf_trace_dax_insert_pfn_mkwrite_no_entry)(void *, struct inode *, struct vm_fault *, int);

typedef void (*btf_trace_dax_insert_pfn_mkwrite)(void *, struct inode *, struct vm_fault *, int);

typedef void (*btf_trace_dax_insert_mapping)(void *, struct inode *, struct vm_fault *, void *);

typedef void (*btf_trace_dax_writeback_range)(void *, struct inode *, long unsigned int, long unsigned int);

typedef void (*btf_trace_dax_writeback_range_done)(void *, struct inode *, long unsigned int, long unsigned int);

typedef void (*btf_trace_dax_writeback_one)(void *, struct inode *, long unsigned int, long unsigned int);

struct exceptional_entry_key {
	struct xarray *xa;
	long unsigned int entry_start;
};

struct wait_exceptional_entry_queue {
	wait_queue_entry_t wait;
	struct exceptional_entry_key key;
};

typedef __u64 __le64;

struct fscrypt_policy_v1 {
	__u8 version;
	__u8 contents_encryption_mode;
	__u8 filenames_encryption_mode;
	__u8 flags;
	__u8 master_key_descriptor[8];
};

struct fscrypt_policy_v2 {
	__u8 version;
	__u8 contents_encryption_mode;
	__u8 filenames_encryption_mode;
	__u8 flags;
	__u8 __reserved[4];
	__u8 master_key_identifier[16];
};

union fscrypt_policy {
	u8 version;
	struct fscrypt_policy_v1 v1;
	struct fscrypt_policy_v2 v2;
};

struct crypto_skcipher;

struct crypto_cipher;

struct fscrypt_mode;

struct fscrypt_direct_key;

struct fscrypt_info {
	struct crypto_skcipher *ci_ctfm;
	struct crypto_cipher *ci_essiv_tfm;
	struct fscrypt_mode *ci_mode;
	struct inode *ci_inode;
	struct key *ci_master_key;
	struct list_head ci_master_key_link;
	struct fscrypt_direct_key *ci_direct_key;
	union fscrypt_policy ci_policy;
	u8 ci_nonce[16];
};

struct crypto_wait {
	struct completion completion;
	int err;
};

struct crypto_cipher {
	struct crypto_tfm base;
};

struct skcipher_request {
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	struct crypto_async_request base;
	void *__ctx[0];
};

struct crypto_skcipher {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	unsigned int ivsize;
	unsigned int reqsize;
	unsigned int keysize;
	struct crypto_tfm base;
};

struct fscrypt_ctx {
	union {
		struct {
			struct bio *bio;
			struct work_struct work;
		};
		struct list_head free_list;
	};
	u8 flags;
};

struct fscrypt_mode {
	const char *friendly_name;
	const char *cipher_str;
	int keysize;
	int ivsize;
	bool logged_impl_name;
	bool needs_essiv;
};

typedef enum {
	FS_DECRYPT = 0,
	FS_ENCRYPT = 1,
} fscrypt_direction_t;

union fscrypt_iv {
	struct {
		__le64 lblk_num;
		u8 nonce[16];
	};
	u8 raw[32];
};

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
	bool is_ciphertext_name;
};

struct fscrypt_digested_name {
	u32 hash;
	u32 minor_hash;
	u8 digest[16];
};

struct fscrypt_hkdf {
	struct crypto_shash *hmac_tfm;
};

struct fscrypt_symlink_data {
	__le16 len;
	char encrypted_path[1];
} __attribute__((packed));

enum key_state {
	KEY_IS_UNINSTANTIATED = 0,
	KEY_IS_POSITIVE = 1,
};

struct fscrypt_key_specifier {
	__u32 type;
	__u32 __reserved;
	union {
		__u8 __reserved[32];
		__u8 descriptor[8];
		__u8 identifier[16];
	} u;
};

struct fscrypt_add_key_arg {
	struct fscrypt_key_specifier key_spec;
	__u32 raw_size;
	__u32 __reserved[9];
	__u8 raw[0];
};

struct fscrypt_remove_key_arg {
	struct fscrypt_key_specifier key_spec;
	__u32 removal_status_flags;
	__u32 __reserved[5];
};

struct fscrypt_get_key_status_arg {
	struct fscrypt_key_specifier key_spec;
	__u32 __reserved[6];
	__u32 status;
	__u32 status_flags;
	__u32 user_count;
	__u32 __out_reserved[13];
};

struct fscrypt_master_key_secret {
	struct fscrypt_hkdf hkdf;
	u32 size;
	u8 raw[64];
};

struct fscrypt_master_key {
	struct fscrypt_master_key_secret mk_secret;
	struct rw_semaphore mk_secret_sem;
	struct fscrypt_key_specifier mk_spec;
	struct key *mk_users;
	refcount_t mk_refcount;
	struct list_head mk_decrypted_inodes;
	spinlock_t mk_decrypted_inodes_lock;
	struct crypto_skcipher *mk_mode_keys[10];
};

struct skcipher_alg {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	int (*init)(struct crypto_skcipher *);
	void (*exit)(struct crypto_skcipher *);
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
	unsigned int chunksize;
	unsigned int walksize;
	struct crypto_alg base;
};

struct fscrypt_context_v1 {
	u8 version;
	u8 contents_encryption_mode;
	u8 filenames_encryption_mode;
	u8 flags;
	u8 master_key_descriptor[8];
	u8 nonce[16];
};

struct fscrypt_context_v2 {
	u8 version;
	u8 contents_encryption_mode;
	u8 filenames_encryption_mode;
	u8 flags;
	u8 __reserved[4];
	u8 master_key_identifier[16];
	u8 nonce[16];
};

union fscrypt_context {
	u8 version;
	struct fscrypt_context_v1 v1;
	struct fscrypt_context_v2 v2;
};

struct crypto_template;

struct crypto_instance {
	struct crypto_alg alg;
	struct crypto_template *tmpl;
	struct hlist_node list;
	void *__ctx[0];
};

struct rtattr;

struct crypto_template {
	struct list_head list;
	struct hlist_head instances;
	struct module *module;
	struct crypto_instance * (*alloc)(struct rtattr **);
	void (*free)(struct crypto_instance *);
	int (*create)(struct crypto_template *, struct rtattr **);
	char name[128];
};

struct user_key_payload {
	struct callback_head rcu;
	short unsigned int datalen;
	long: 48;
	char data[0];
};

struct fscrypt_key {
	__u32 mode;
	__u8 raw[64];
	__u32 size;
};

struct fscrypt_direct_key {
	struct hlist_node dk_node;
	refcount_t dk_refcount;
	const struct fscrypt_mode *dk_mode;
	struct crypto_skcipher *dk_ctfm;
	u8 dk_descriptor[8];
	u8 dk_raw[64];
};

struct fscrypt_get_policy_ex_arg {
	__u64 policy_size;
	union {
		__u8 version;
		struct fscrypt_policy_v1 v1;
		struct fscrypt_policy_v2 v2;
	} policy;
};

struct flock64 {
	short int l_type;
	short int l_whence;
	__kernel_loff_t l_start;
	__kernel_loff_t l_len;
	__kernel_pid_t l_pid;
};

struct trace_event_raw_locks_get_lock_context {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	unsigned char type;
	struct file_lock_context *ctx;
	char __data[0];
};

struct trace_event_raw_filelock_lock {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_pid;
	unsigned int fl_flags;
	unsigned char fl_type;
	loff_t fl_start;
	loff_t fl_end;
	int ret;
	char __data[0];
};

struct trace_event_raw_filelock_lease {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	char __data[0];
};

struct trace_event_raw_generic_add_lease {
	struct trace_entry ent;
	long unsigned int i_ino;
	int wcount;
	int rcount;
	int icount;
	dev_t s_dev;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	char __data[0];
};

struct trace_event_raw_leases_conflict {
	struct trace_entry ent;
	void *lease;
	void *breaker;
	unsigned int l_fl_flags;
	unsigned int b_fl_flags;
	unsigned char l_fl_type;
	unsigned char b_fl_type;
	bool conflict;
	char __data[0];
};

struct trace_event_data_offsets_locks_get_lock_context {};

struct trace_event_data_offsets_filelock_lock {};

struct trace_event_data_offsets_filelock_lease {};

struct trace_event_data_offsets_generic_add_lease {};

struct trace_event_data_offsets_leases_conflict {};

typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);

typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lock *, struct file_lock *);

struct file_lock_list_struct {
	spinlock_t lock;
	struct hlist_head hlist;
};

struct locks_iterator {
	int li_cpu;
	loff_t li_pos;
};

struct nfs_string {
	unsigned int len;
	const char *data;
};

struct nfs4_mount_data {
	int version;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct nfs_string client_addr;
	struct nfs_string mnt_path;
	struct nfs_string hostname;
	unsigned int host_addrlen;
	struct sockaddr *host_addr;
	int proto;
	int auth_flavourlen;
	int *auth_flavours;
};

struct compat_nfs_string {
	compat_uint_t len;
	compat_uptr_t data;
};

struct compat_nfs4_mount_data_v1 {
	compat_int_t version;
	compat_int_t flags;
	compat_int_t rsize;
	compat_int_t wsize;
	compat_int_t timeo;
	compat_int_t retrans;
	compat_int_t acregmin;
	compat_int_t acregmax;
	compat_int_t acdirmin;
	compat_int_t acdirmax;
	struct compat_nfs_string client_addr;
	struct compat_nfs_string mnt_path;
	struct compat_nfs_string hostname;
	compat_uint_t host_addrlen;
	compat_uptr_t host_addr;
	compat_int_t proto;
	compat_int_t auth_flavourlen;
	compat_uptr_t auth_flavours;
};

typedef u32 compat_caddr_t;

struct ppp_idle {
	__kernel_time_t xmit_idle;
	__kernel_time_t recv_idle;
};

struct ppp_option_data {
	__u8 *ptr;
	__u32 length;
	int transmit;
};

struct mtget {
	long int mt_type;
	long int mt_resid;
	long int mt_dsreg;
	long int mt_gstat;
	long int mt_erreg;
	__kernel_daddr_t mt_fileno;
	__kernel_daddr_t mt_blkno;
};

struct mtpos {
	long int mt_blkno;
};

struct serial_icounter_struct {
	int cts;
	int dsr;
	int rng;
	int dcd;
	int rx;
	int tx;
	int frame;
	int overrun;
	int parity;
	int brk;
	int buf_overrun;
	int reserved[9];
};

struct serial_struct {
	int type;
	int line;
	unsigned int port;
	int irq;
	int flags;
	int xmit_fifo_size;
	int custom_divisor;
	int baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char[1];
	int hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	long unsigned int iomap_base;
};

struct sg_iovec {
	void *iov_base;
	size_t iov_len;
};

typedef struct sg_iovec sg_iovec_t;

struct sg_io_hdr {
	int interface_id;
	int dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	unsigned int dxfer_len;
	void *dxferp;
	unsigned char *cmdp;
	void *sbp;
	unsigned int timeout;
	unsigned int flags;
	int pack_id;
	void *usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	int resid;
	unsigned int duration;
	unsigned int info;
};

typedef struct sg_io_hdr sg_io_hdr_t;

struct sg_req_info {
	char req_state;
	char orphan;
	char sg_io_owned;
	char problem;
	int pack_id;
	void *usr_ptr;
	unsigned int duration;
	int unused;
};

typedef struct sg_req_info sg_req_info_t;

struct sg_io_hdr32 {
	compat_int_t interface_id;
	compat_int_t dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	compat_uint_t dxfer_len;
	compat_uint_t dxferp;
	compat_uptr_t cmdp;
	compat_uptr_t sbp;
	compat_uint_t timeout;
	compat_uint_t flags;
	compat_int_t pack_id;
	compat_uptr_t usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	compat_int_t resid;
	compat_uint_t duration;
	compat_uint_t info;
};

typedef struct sg_io_hdr32 sg_io_hdr32_t;

struct sg_iovec32 {
	compat_uint_t iov_base;
	compat_uint_t iov_len;
};

typedef struct sg_iovec32 sg_iovec32_t;

struct compat_sg_req_info {
	char req_state;
	char orphan;
	char sg_io_owned;
	char problem;
	int pack_id;
	compat_uptr_t usr_ptr;
	unsigned int duration;
	int unused;
};

struct sock_fprog32 {
	short unsigned int len;
	compat_caddr_t filter;
};

struct ppp_option_data32 {
	compat_caddr_t ptr;
	u32 length;
	compat_int_t transmit;
};

struct ppp_idle32 {
	old_time32_t xmit_idle;
	old_time32_t recv_idle;
};

struct mtget32 {
	compat_long_t mt_type;
	compat_long_t mt_resid;
	compat_long_t mt_dsreg;
	compat_long_t mt_gstat;
	compat_long_t mt_erreg;
	compat_daddr_t mt_fileno;
	compat_daddr_t mt_blkno;
};

struct mtpos32 {
	compat_long_t mt_blkno;
};

struct space_resv_32 {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
} __attribute__((packed));

typedef unsigned int __kernel_uid_t;

typedef unsigned int __kernel_gid_t;

struct elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	long unsigned int pr_flag;
	__kernel_uid_t pr_uid;
	__kernel_gid_t pr_gid;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct arch_elf_state {};

struct memelfnote {
	const char *name;
	int type;
	unsigned int datasz;
	void *data;
};

struct elf_thread_core_info {
	struct elf_thread_core_info *next;
	struct task_struct *task;
	struct elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_note_info {
	struct elf_thread_core_info *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct elf32_shdr {
	Elf32_Word sh_name;
	Elf32_Word sh_type;
	Elf32_Word sh_flags;
	Elf32_Addr sh_addr;
	Elf32_Off sh_offset;
	Elf32_Word sh_size;
	Elf32_Word sh_link;
	Elf32_Word sh_info;
	Elf32_Word sh_addralign;
	Elf32_Word sh_entsize;
};

typedef struct user_regs_struct compat_elf_gregset_t;

struct compat_elf_siginfo {
	compat_int_t si_signo;
	compat_int_t si_code;
	compat_int_t si_errno;
};

struct compat_elf_prstatus {
	struct compat_elf_siginfo pr_info;
	short int pr_cursig;
	compat_ulong_t pr_sigpend;
	compat_ulong_t pr_sighold;
	compat_pid_t pr_pid;
	compat_pid_t pr_ppid;
	compat_pid_t pr_pgrp;
	compat_pid_t pr_sid;
	struct old_timeval32 pr_utime;
	struct old_timeval32 pr_stime;
	struct old_timeval32 pr_cutime;
	struct old_timeval32 pr_cstime;
	compat_elf_gregset_t pr_reg;
	compat_int_t pr_fpvalid;
};

struct compat_elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	compat_ulong_t pr_flag;
	__compat_uid_t pr_uid;
	__compat_gid_t pr_gid;
	compat_pid_t pr_pid;
	compat_pid_t pr_ppid;
	compat_pid_t pr_pgrp;
	compat_pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct elf_thread_core_info___2 {
	struct elf_thread_core_info___2 *next;
	struct task_struct *task;
	struct compat_elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_note_info___2 {
	struct elf_thread_core_info___2 *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	compat_siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct mb_cache_entry {
	struct list_head e_list;
	struct hlist_bl_node e_hash_list;
	atomic_t e_refcnt;
	u32 e_key;
	u32 e_referenced: 1;
	u32 e_reusable: 1;
	u64 e_value;
};

struct mb_cache {
	struct hlist_bl_head *c_hash;
	int c_bucket_bits;
	long unsigned int c_max_entries;
	spinlock_t c_list_lock;
	struct list_head c_list;
	long unsigned int c_entry_count;
	struct shrinker c_shrink;
	struct work_struct c_shrink_work;
};

typedef __u32 __le32;

struct posix_acl_xattr_entry {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
};

struct posix_acl_xattr_header {
	__le32 a_version;
};

struct core_name {
	char *corename;
	int used;
	int size;
};

struct iomap_page {
	atomic_t read_count;
	atomic_t write_count;
	long unsigned int uptodate[1];
};

struct iomap_readpage_ctx {
	struct page *cur_page;
	bool cur_page_in_bio;
	bool is_readahead;
	struct bio *bio;
	struct list_head *pages;
};

struct iomap_dio_ops {
	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
};

struct iomap_dio {
	struct kiocb *iocb;
	const struct iomap_dio_ops *dops;
	loff_t i_size;
	loff_t size;
	atomic_t ref;
	unsigned int flags;
	int error;
	bool wait_for_completion;
	union {
		struct {
			struct iov_iter *iter;
			struct task_struct *waiter;
			struct request_queue *last_queue;
			blk_qc_t cookie;
		} submit;
		struct {
			struct work_struct work;
		} aio;
	};
};

struct fiemap_ctx {
	struct fiemap_extent_info *fi;
	struct iomap prev;
};

struct iomap_swapfile_info {
	struct iomap iomap;
	struct swap_info_struct *sis;
	uint64_t lowest_ppage;
	uint64_t highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
};

enum {
	QIF_BLIMITS_B = 0,
	QIF_SPACE_B = 1,
	QIF_ILIMITS_B = 2,
	QIF_INODES_B = 3,
	QIF_BTIME_B = 4,
	QIF_ITIME_B = 5,
};

enum {
	DQF_ROOT_SQUASH_B = 0,
	DQF_SYS_FILE_B = 16,
	DQF_PRIVATE = 17,
};

typedef __kernel_uid32_t qid_t;

enum {
	DQF_INFO_DIRTY_B = 17,
};

enum {
	DQST_LOOKUPS = 0,
	DQST_DROPS = 1,
	DQST_READS = 2,
	DQST_WRITES = 3,
	DQST_CACHE_HITS = 4,
	DQST_ALLOC_DQUOTS = 5,
	DQST_FREE_DQUOTS = 6,
	DQST_SYNCS = 7,
	_DQST_DQSTAT_LAST = 8,
};

struct dqstats {
	long unsigned int stat[8];
	struct percpu_counter counter[8];
};

enum {
	_DQUOT_USAGE_ENABLED = 0,
	_DQUOT_LIMITS_ENABLED = 1,
	_DQUOT_SUSPENDED = 2,
	_DQUOT_STATE_FLAGS = 3,
};

struct quota_module_name {
	int qm_fmt_id;
	char *qm_mod_name;
};

struct dquot_warn {
	struct super_block *w_sb;
	struct kqid w_dq_id;
	short int w_type;
};

struct qtree_fmt_operations {
	void (*mem2disk_dqblk)(void *, struct dquot *);
	void (*disk2mem_dqblk)(struct dquot *, void *);
	int (*is_id)(void *, struct dquot *);
};

struct qtree_mem_dqinfo {
	struct super_block *dqi_sb;
	int dqi_type;
	unsigned int dqi_blocks;
	unsigned int dqi_free_blk;
	unsigned int dqi_free_entry;
	unsigned int dqi_blocksize_bits;
	unsigned int dqi_entry_size;
	unsigned int dqi_usable_bs;
	unsigned int dqi_qtree_depth;
	const struct qtree_fmt_operations *dqi_ops;
};

struct v2_disk_dqheader {
	__le32 dqh_magic;
	__le32 dqh_version;
};

struct v2r0_disk_dqblk {
	__le32 dqb_id;
	__le32 dqb_ihardlimit;
	__le32 dqb_isoftlimit;
	__le32 dqb_curinodes;
	__le32 dqb_bhardlimit;
	__le32 dqb_bsoftlimit;
	__le64 dqb_curspace;
	__le64 dqb_btime;
	__le64 dqb_itime;
};

struct v2r1_disk_dqblk {
	__le32 dqb_id;
	__le32 dqb_pad;
	__le64 dqb_ihardlimit;
	__le64 dqb_isoftlimit;
	__le64 dqb_curinodes;
	__le64 dqb_bhardlimit;
	__le64 dqb_bsoftlimit;
	__le64 dqb_curspace;
	__le64 dqb_btime;
	__le64 dqb_itime;
};

struct v2_disk_dqinfo {
	__le32 dqi_bgrace;
	__le32 dqi_igrace;
	__le32 dqi_flags;
	__le32 dqi_blocks;
	__le32 dqi_free_blk;
	__le32 dqi_free_entry;
};

struct qt_disk_dqdbheader {
	__le32 dqdh_next_free;
	__le32 dqdh_prev_free;
	__le16 dqdh_entries;
	__le16 dqdh_pad1;
	__le32 dqdh_pad2;
};

struct fs_disk_quota {
	__s8 d_version;
	__s8 d_flags;
	__u16 d_fieldmask;
	__u32 d_id;
	__u64 d_blk_hardlimit;
	__u64 d_blk_softlimit;
	__u64 d_ino_hardlimit;
	__u64 d_ino_softlimit;
	__u64 d_bcount;
	__u64 d_icount;
	__s32 d_itimer;
	__s32 d_btimer;
	__u16 d_iwarns;
	__u16 d_bwarns;
	__s32 d_padding2;
	__u64 d_rtb_hardlimit;
	__u64 d_rtb_softlimit;
	__u64 d_rtbcount;
	__s32 d_rtbtimer;
	__u16 d_rtbwarns;
	__s16 d_padding3;
	char d_padding4[8];
};

struct fs_qfilestat {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
};

typedef struct fs_qfilestat fs_qfilestat_t;

struct fs_quota_stat {
	__s8 qs_version;
	__u16 qs_flags;
	__s8 qs_pad;
	fs_qfilestat_t qs_uquota;
	fs_qfilestat_t qs_gquota;
	__u32 qs_incoredqs;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
};

struct fs_qfilestatv {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
	__u32 qfs_pad;
};

struct fs_quota_statv {
	__s8 qs_version;
	__u8 qs_pad1;
	__u16 qs_flags;
	__u32 qs_incoredqs;
	struct fs_qfilestatv qs_uquota;
	struct fs_qfilestatv qs_gquota;
	struct fs_qfilestatv qs_pquota;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
	__u64 qs_pad2[8];
};

struct if_dqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
};

struct if_nextdqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
	__u32 dqb_id;
};

struct if_dqinfo {
	__u64 dqi_bgrace;
	__u64 dqi_igrace;
	__u32 dqi_flags;
	__u32 dqi_valid;
};

struct compat_if_dqblk {
	compat_u64 dqb_bhardlimit;
	compat_u64 dqb_bsoftlimit;
	compat_u64 dqb_curspace;
	compat_u64 dqb_ihardlimit;
	compat_u64 dqb_isoftlimit;
	compat_u64 dqb_curinodes;
	compat_u64 dqb_btime;
	compat_u64 dqb_itime;
	compat_uint_t dqb_valid;
} __attribute__((packed));

struct compat_fs_qfilestat {
	compat_u64 dqb_bhardlimit;
	compat_u64 qfs_nblks;
	compat_uint_t qfs_nextents;
} __attribute__((packed));

struct compat_fs_quota_stat {
	__s8 qs_version;
	char: 8;
	__u16 qs_flags;
	__s8 qs_pad;
	int: 24;
	struct compat_fs_qfilestat qs_uquota;
	struct compat_fs_qfilestat qs_gquota;
	compat_uint_t qs_incoredqs;
	compat_int_t qs_btimelimit;
	compat_int_t qs_itimelimit;
	compat_int_t qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
} __attribute__((packed));

enum {
	QUOTA_NL_C_UNSPEC = 0,
	QUOTA_NL_C_WARNING = 1,
	__QUOTA_NL_C_MAX = 2,
};

enum {
	QUOTA_NL_A_UNSPEC = 0,
	QUOTA_NL_A_QTYPE = 1,
	QUOTA_NL_A_EXCESS_ID = 2,
	QUOTA_NL_A_WARNING = 3,
	QUOTA_NL_A_DEV_MAJOR = 4,
	QUOTA_NL_A_DEV_MINOR = 5,
	QUOTA_NL_A_CAUSED_ID = 6,
	QUOTA_NL_A_PAD = 7,
	__QUOTA_NL_A_MAX = 8,
};

struct proc_maps_private {
	struct inode *inode;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *tail_vma;
	struct mempolicy *task_mempolicy;
};

struct mem_size_stats {
	long unsigned int resident;
	long unsigned int shared_clean;
	long unsigned int shared_dirty;
	long unsigned int private_clean;
	long unsigned int private_dirty;
	long unsigned int referenced;
	long unsigned int anonymous;
	long unsigned int lazyfree;
	long unsigned int anonymous_thp;
	long unsigned int shmem_thp;
	long unsigned int file_thp;
	long unsigned int swap;
	long unsigned int shared_hugetlb;
	long unsigned int private_hugetlb;
	u64 pss;
	u64 pss_anon;
	u64 pss_file;
	u64 pss_shmem;
	u64 pss_locked;
	u64 swap_pss;
	bool check_shmem_swap;
};

enum clear_refs_types {
	CLEAR_REFS_ALL = 1,
	CLEAR_REFS_ANON = 2,
	CLEAR_REFS_MAPPED = 3,
	CLEAR_REFS_SOFT_DIRTY = 4,
	CLEAR_REFS_MM_HIWATER_RSS = 5,
	CLEAR_REFS_LAST = 6,
};

struct clear_refs_private {
	enum clear_refs_types type;
};

typedef struct {
	u64 pme;
} pagemap_entry_t;

struct pagemapread {
	int pos;
	int len;
	pagemap_entry_t *buffer;
	bool show_pfn;
};

struct numa_maps {
	long unsigned int pages;
	long unsigned int anon;
	long unsigned int active;
	long unsigned int writeback;
	long unsigned int mapcount_max;
	long unsigned int dirty;
	long unsigned int swapcache;
	long unsigned int node[1024];
};

struct numa_maps_private {
	struct proc_maps_private proc_maps;
	struct numa_maps md;
};

enum {
	HIDEPID_OFF = 0,
	HIDEPID_NO_ACCESS = 1,
	HIDEPID_INVISIBLE = 2,
};

struct pde_opener {
	struct file *file;
	struct list_head lh;
	bool closing;
	struct completion *c;
};

enum {
	BIAS = 2147483648,
};

struct proc_fs_context {
	struct pid_namespace *pid_ns;
	unsigned int mask;
	int hidepid;
	int gid;
};

enum proc_param {
	Opt_gid___2 = 0,
	Opt_hidepid = 1,
};

struct genradix_root;

struct __genradix {
	struct genradix_root *root;
};

struct syscall_info {
	__u64 sp;
	struct seccomp_data data;
};

typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);

struct pid_entry {
	const char *name;
	unsigned int len;
	umode_t mode;
	const struct inode_operations *iop;
	const struct file_operations *fop;
	union proc_op op;
};

struct limit_names {
	const char *name;
	const char *unit;
};

struct map_files_info {
	long unsigned int start;
	long unsigned int end;
	fmode_t mode;
};

struct tgid_iter {
	unsigned int tgid;
	struct task_struct *task;
};

struct fd_data {
	fmode_t mode;
	unsigned int fd;
};

struct sysctl_restrict_record {
	struct list_head list;
	struct callback_head rcu;
	char procname[4096];
};

struct seq_net_private {
	struct net *net;
};

struct bpf_iter_aux_info;

struct vmcore {
	struct list_head list;
	long long unsigned int paddr;
	long long unsigned int size;
	loff_t offset;
};

typedef struct elf64_note Elf64_Nhdr;

struct kernfs_iattrs {
	kuid_t ia_uid;
	kgid_t ia_gid;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct simple_xattrs xattrs;
};

struct kernfs_super_info {
	struct super_block *sb;
	struct kernfs_root *root;
	const void *ns;
	struct list_head node;
};

enum kernfs_node_flag {
	KERNFS_ACTIVATED = 16,
	KERNFS_NS = 32,
	KERNFS_HAS_SEQ_SHOW = 64,
	KERNFS_HAS_MMAP = 128,
	KERNFS_LOCKDEP = 256,
	KERNFS_SUICIDAL = 1024,
	KERNFS_SUICIDED = 2048,
	KERNFS_EMPTY_DIR = 4096,
	KERNFS_HAS_RELEASE = 8192,
};

struct kernfs_open_node {
	atomic_t refcnt;
	atomic_t event;
	wait_queue_head_t poll;
	struct list_head files;
};

struct config_group;

struct config_item_type;

struct config_item {
	char *ci_name;
	char ci_namebuf[20];
	struct kref ci_kref;
	struct list_head ci_entry;
	struct config_item *ci_parent;
	struct config_group *ci_group;
	const struct config_item_type *ci_type;
	struct dentry *ci_dentry;
};

struct configfs_subsystem;

struct config_group {
	struct config_item cg_item;
	struct list_head cg_children;
	struct configfs_subsystem *cg_subsys;
	struct list_head default_groups;
	struct list_head group_entry;
};

struct configfs_item_operations;

struct configfs_group_operations;

struct configfs_attribute;

struct configfs_bin_attribute;

struct config_item_type {
	struct module *ct_owner;
	struct configfs_item_operations *ct_item_ops;
	struct configfs_group_operations *ct_group_ops;
	struct configfs_attribute **ct_attrs;
	struct configfs_bin_attribute **ct_bin_attrs;
};

struct configfs_item_operations {
	void (*release)(struct config_item *);
	int (*allow_link)(struct config_item *, struct config_item *);
	void (*drop_link)(struct config_item *, struct config_item *);
};

struct configfs_group_operations {
	struct config_item * (*make_item)(struct config_group *, const char *);
	struct config_group * (*make_group)(struct config_group *, const char *);
	int (*commit_item)(struct config_item *);
	void (*disconnect_notify)(struct config_group *, struct config_item *);
	void (*drop_item)(struct config_group *, struct config_item *);
};

struct configfs_attribute {
	const char *ca_name;
	struct module *ca_owner;
	umode_t ca_mode;
	ssize_t (*show)(struct config_item *, char *);
	ssize_t (*store)(struct config_item *, const char *, size_t);
};

struct configfs_bin_attribute {
	struct configfs_attribute cb_attr;
	void *cb_private;
	size_t cb_max_size;
	ssize_t (*read)(struct config_item *, void *, size_t);
	ssize_t (*write)(struct config_item *, const void *, size_t);
};

struct configfs_subsystem {
	struct config_group su_group;
	struct mutex su_mutex;
};

struct configfs_fragment {
	atomic_t frag_count;
	struct rw_semaphore frag_sem;
	bool frag_dead;
};

struct configfs_dirent {
	atomic_t s_count;
	int s_dependent_count;
	struct list_head s_sibling;
	struct list_head s_children;
	int s_links;
	void *s_element;
	int s_type;
	umode_t s_mode;
	struct dentry *s_dentry;
	struct iattr *s_iattr;
	struct configfs_fragment *s_frag;
};

struct configfs_buffer {
	size_t count;
	loff_t pos;
	char *page;
	struct configfs_item_operations *ops;
	struct mutex mutex;
	int needs_read_fill;
	bool read_in_progress;
	bool write_in_progress;
	char *bin_buffer;
	int bin_buffer_size;
	int cb_max_size;
	struct config_item *item;
	struct module *owner;
	union {
		struct configfs_attribute *attr;
		struct configfs_bin_attribute *bin_attr;
	};
};

struct pts_mount_opts {
	int setuid;
	int setgid;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	umode_t ptmxmode;
	int reserve;
	int max;
};

enum {
	Opt_uid___2 = 0,
	Opt_gid___3 = 1,
	Opt_mode___2 = 2,
	Opt_ptmxmode = 3,
	Opt_newinstance = 4,
	Opt_max = 5,
	Opt_err = 6,
};

struct pts_fs_info {
	struct ida allocated_ptys;
	struct pts_mount_opts mount_opts;
	struct super_block *sb;
	struct dentry *ptmx_dentry;
};

struct dcookie_struct {
	struct path path;
	struct list_head hash_list;
};

struct dcookie_user {
	struct list_head next;
};

typedef unsigned int tid_t;

struct transaction_chp_stats_s {
	long unsigned int cs_chp_time;
	__u32 cs_forced_to_close;
	__u32 cs_written;
	__u32 cs_dropped;
};

struct journal_s;

typedef struct journal_s journal_t;

struct journal_head;

struct transaction_s;

typedef struct transaction_s transaction_t;

struct transaction_s {
	journal_t *t_journal;
	tid_t t_tid;
	enum {
		T_RUNNING = 0,
		T_LOCKED = 1,
		T_SWITCH = 2,
		T_FLUSH = 3,
		T_COMMIT = 4,
		T_COMMIT_DFLUSH = 5,
		T_COMMIT_JFLUSH = 6,
		T_COMMIT_CALLBACK = 7,
		T_FINISHED = 8,
	} t_state;
	long unsigned int t_log_start;
	int t_nr_buffers;
	struct journal_head *t_reserved_list;
	struct journal_head *t_buffers;
	struct journal_head *t_forget;
	struct journal_head *t_checkpoint_list;
	struct journal_head *t_checkpoint_io_list;
	struct journal_head *t_shadow_list;
	struct list_head t_inode_list;
	spinlock_t t_handle_lock;
	long unsigned int t_max_wait;
	long unsigned int t_start;
	long unsigned int t_requested;
	struct transaction_chp_stats_s t_chp_stats;
	atomic_t t_updates;
	atomic_t t_outstanding_credits;
	transaction_t *t_cpnext;
	transaction_t *t_cpprev;
	long unsigned int t_expires;
	ktime_t t_start_time;
	atomic_t t_handle_count;
	unsigned int t_synchronous_commit: 1;
	int t_need_data_flush;
	struct list_head t_private_list;
};

struct jbd2_buffer_trigger_type;

struct journal_head {
	struct buffer_head *b_bh;
	int b_jcount;
	unsigned int b_jlist;
	unsigned int b_modified;
	char *b_frozen_data;
	char *b_committed_data;
	transaction_t *b_transaction;
	transaction_t *b_next_transaction;
	struct journal_head *b_tnext;
	struct journal_head *b_tprev;
	transaction_t *b_cp_transaction;
	struct journal_head *b_cpnext;
	struct journal_head *b_cpprev;
	struct jbd2_buffer_trigger_type *b_triggers;
	struct jbd2_buffer_trigger_type *b_frozen_triggers;
};

struct jbd2_buffer_trigger_type {
	void (*t_frozen)(struct jbd2_buffer_trigger_type *, struct buffer_head *, void *, size_t);
	void (*t_abort)(struct jbd2_buffer_trigger_type *, struct buffer_head *);
};

struct jbd2_journal_handle;

typedef struct jbd2_journal_handle handle_t;

struct jbd2_journal_handle {
	union {
		transaction_t *h_transaction;
		journal_t *h_journal;
	};
	handle_t *h_rsv_handle;
	int h_buffer_credits;
	int h_ref;
	int h_err;
	unsigned int h_sync: 1;
	unsigned int h_jdata: 1;
	unsigned int h_reserved: 1;
	unsigned int h_aborted: 1;
	unsigned int h_type: 8;
	unsigned int h_line_no: 16;
	long unsigned int h_start_jiffies;
	unsigned int h_requested_credits;
	unsigned int saved_alloc_context;
};

struct transaction_run_stats_s {
	long unsigned int rs_wait;
	long unsigned int rs_request_delay;
	long unsigned int rs_running;
	long unsigned int rs_locked;
	long unsigned int rs_flushing;
	long unsigned int rs_logging;
	__u32 rs_handle_count;
	__u32 rs_blocks;
	__u32 rs_blocks_logged;
};

struct transaction_stats_s {
	long unsigned int ts_tid;
	long unsigned int ts_requested;
	struct transaction_run_stats_s run;
};

struct journal_superblock_s;

typedef struct journal_superblock_s journal_superblock_t;

struct jbd2_revoke_table_s;

struct journal_s {
	long unsigned int j_flags;
	int j_errno;
	struct buffer_head *j_sb_buffer;
	journal_superblock_t *j_superblock;
	int j_format_version;
	rwlock_t j_state_lock;
	int j_barrier_count;
	struct mutex j_barrier;
	transaction_t *j_running_transaction;
	transaction_t *j_committing_transaction;
	transaction_t *j_checkpoint_transactions;
	wait_queue_head_t j_wait_transaction_locked;
	wait_queue_head_t j_wait_done_commit;
	wait_queue_head_t j_wait_commit;
	wait_queue_head_t j_wait_updates;
	wait_queue_head_t j_wait_reserved;
	struct mutex j_checkpoint_mutex;
	struct buffer_head *j_chkpt_bhs[64];
	long unsigned int j_head;
	long unsigned int j_tail;
	long unsigned int j_free;
	long unsigned int j_first;
	long unsigned int j_last;
	struct block_device *j_dev;
	int j_blocksize;
	long long unsigned int j_blk_offset;
	char j_devname[56];
	struct block_device *j_fs_dev;
	unsigned int j_maxlen;
	atomic_t j_reserved_credits;
	spinlock_t j_list_lock;
	struct inode *j_inode;
	tid_t j_tail_sequence;
	tid_t j_transaction_sequence;
	tid_t j_commit_sequence;
	tid_t j_commit_request;
	__u8 j_uuid[16];
	struct task_struct *j_task;
	int j_max_transaction_buffers;
	long unsigned int j_commit_interval;
	struct timer_list j_commit_timer;
	spinlock_t j_revoke_lock;
	struct jbd2_revoke_table_s *j_revoke;
	struct jbd2_revoke_table_s *j_revoke_table[2];
	struct buffer_head **j_wbuf;
	int j_wbufsize;
	pid_t j_last_sync_writer;
	u64 j_average_commit_time;
	u32 j_min_batch_time;
	u32 j_max_batch_time;
	void (*j_commit_callback)(journal_t *, transaction_t *);
	spinlock_t j_history_lock;
	struct proc_dir_entry *j_proc_entry;
	struct transaction_stats_s j_stats;
	unsigned int j_failed_commit;
	void *j_private;
	struct crypto_shash *j_chksum_driver;
	__u32 j_csum_seed;
};

struct journal_header_s {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
};

typedef struct journal_header_s journal_header_t;

struct journal_superblock_s {
	journal_header_t s_header;
	__be32 s_blocksize;
	__be32 s_maxlen;
	__be32 s_first;
	__be32 s_sequence;
	__be32 s_start;
	__be32 s_errno;
	__be32 s_feature_compat;
	__be32 s_feature_incompat;
	__be32 s_feature_ro_compat;
	__u8 s_uuid[16];
	__be32 s_nr_users;
	__be32 s_dynsuper;
	__be32 s_max_transaction;
	__be32 s_max_trans_data;
	__u8 s_checksum_type;
	__u8 s_padding2[3];
	__u32 s_padding[42];
	__be32 s_checksum;
	__u8 s_users[768];
};

enum jbd_state_bits {
	BH_JBD = 17,
	BH_JWrite = 18,
	BH_Freed = 19,
	BH_Revoked = 20,
	BH_RevokeValid = 21,
	BH_JBDDirty = 22,
	BH_State = 23,
	BH_JournalHead = 24,
	BH_Shadow = 25,
	BH_Verified = 26,
	BH_JBDPrivateStart = 27,
};

struct jbd2_inode {
	transaction_t *i_transaction;
	transaction_t *i_next_transaction;
	struct list_head i_list;
	struct inode *i_vfs_inode;
	long unsigned int i_flags;
	loff_t i_dirty_start;
	loff_t i_dirty_end;
};

struct bgl_lock {
	spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blockgroup_lock {
	struct bgl_lock locks[128];
};

typedef int ext4_grpblk_t;

typedef long long unsigned int ext4_fsblk_t;

typedef __u32 ext4_lblk_t;

typedef unsigned int ext4_group_t;

struct ext4_allocation_request {
	struct inode *inode;
	unsigned int len;
	ext4_lblk_t logical;
	ext4_lblk_t lleft;
	ext4_lblk_t lright;
	ext4_fsblk_t goal;
	ext4_fsblk_t pleft;
	ext4_fsblk_t pright;
	unsigned int flags;
};

struct ext4_system_blocks {
	struct rb_root root;
	struct callback_head rcu;
};

struct ext4_group_desc {
	__le32 bg_block_bitmap_lo;
	__le32 bg_inode_bitmap_lo;
	__le32 bg_inode_table_lo;
	__le16 bg_free_blocks_count_lo;
	__le16 bg_free_inodes_count_lo;
	__le16 bg_used_dirs_count_lo;
	__le16 bg_flags;
	__le32 bg_exclude_bitmap_lo;
	__le16 bg_block_bitmap_csum_lo;
	__le16 bg_inode_bitmap_csum_lo;
	__le16 bg_itable_unused_lo;
	__le16 bg_checksum;
	__le32 bg_block_bitmap_hi;
	__le32 bg_inode_bitmap_hi;
	__le32 bg_inode_table_hi;
	__le16 bg_free_blocks_count_hi;
	__le16 bg_free_inodes_count_hi;
	__le16 bg_used_dirs_count_hi;
	__le16 bg_itable_unused_hi;
	__le32 bg_exclude_bitmap_hi;
	__le16 bg_block_bitmap_csum_hi;
	__le16 bg_inode_bitmap_csum_hi;
	__u32 bg_reserved;
};

struct flex_groups {
	atomic64_t free_clusters;
	atomic_t free_inodes;
	atomic_t used_dirs;
};

struct extent_status {
	struct rb_node rb_node;
	ext4_lblk_t es_lblk;
	ext4_lblk_t es_len;
	ext4_fsblk_t es_pblk;
};

struct ext4_es_tree {
	struct rb_root root;
	struct extent_status *cache_es;
};

struct ext4_es_stats {
	long unsigned int es_stats_shrunk;
	struct percpu_counter es_stats_cache_hits;
	struct percpu_counter es_stats_cache_misses;
	u64 es_stats_scan_time;
	u64 es_stats_max_scan_time;
	struct percpu_counter es_stats_all_cnt;
	struct percpu_counter es_stats_shk_cnt;
};

struct ext4_pending_tree {
	struct rb_root root;
};

struct ext4_inode_info {
	__le32 i_data[15];
	__u32 i_dtime;
	ext4_fsblk_t i_file_acl;
	ext4_group_t i_block_group;
	ext4_lblk_t i_dir_start_lookup;
	long unsigned int i_flags;
	struct rw_semaphore xattr_sem;
	struct list_head i_orphan;
	loff_t i_disksize;
	struct rw_semaphore i_data_sem;
	struct rw_semaphore i_mmap_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;
	spinlock_t i_raw_lock;
	struct timespec64 i_crtime;
	atomic_t i_prealloc_active;
	struct list_head i_prealloc_list;
	spinlock_t i_prealloc_lock;
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;
	unsigned int i_es_shk_nr;
	ext4_lblk_t i_es_shrink_lblk;
	ext4_group_t i_last_alloc_group;
	unsigned int i_reserved_data_blocks;
	ext4_lblk_t i_da_metadata_calc_last_lblock;
	int i_da_metadata_calc_len;
	struct ext4_pending_tree i_pending_tree;
	__u16 i_extra_isize;
	u16 i_inline_off;
	u16 i_inline_size;
	qsize_t i_reserved_quota;
	spinlock_t i_completed_io_lock;
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	atomic_t i_unwritten;
	spinlock_t i_block_reservation_lock;
	tid_t i_sync_tid;
	tid_t i_datasync_tid;
	struct dquot *i_dquot[3];
	__u32 i_csum_seed;
	kprojid_t i_projid;
};

struct ext4_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count_lo;
	__le32 s_r_blocks_count_lo;
	__le32 s_free_blocks_count_lo;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_cluster_size;
	__le32 s_blocks_per_group;
	__le32 s_clusters_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__le16 s_reserved_gdt_blocks;
	__u8 s_journal_uuid[16];
	__le32 s_journal_inum;
	__le32 s_journal_dev;
	__le32 s_last_orphan;
	__le32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_jnl_backup_type;
	__le16 s_desc_size;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__le32 s_mkfs_time;
	__le32 s_jnl_blocks[17];
	__le32 s_blocks_count_hi;
	__le32 s_r_blocks_count_hi;
	__le32 s_free_blocks_count_hi;
	__le16 s_min_extra_isize;
	__le16 s_want_extra_isize;
	__le32 s_flags;
	__le16 s_raid_stride;
	__le16 s_mmp_update_interval;
	__le64 s_mmp_block;
	__le32 s_raid_stripe_width;
	__u8 s_log_groups_per_flex;
	__u8 s_checksum_type;
	__u8 s_encryption_level;
	__u8 s_reserved_pad;
	__le64 s_kbytes_written;
	__le32 s_snapshot_inum;
	__le32 s_snapshot_id;
	__le64 s_snapshot_r_blocks_count;
	__le32 s_snapshot_list;
	__le32 s_error_count;
	__le32 s_first_error_time;
	__le32 s_first_error_ino;
	__le64 s_first_error_block;
	__u8 s_first_error_func[32];
	__le32 s_first_error_line;
	__le32 s_last_error_time;
	__le32 s_last_error_ino;
	__le32 s_last_error_line;
	__le64 s_last_error_block;
	__u8 s_last_error_func[32];
	__u8 s_mount_opts[64];
	__le32 s_usr_quota_inum;
	__le32 s_grp_quota_inum;
	__le32 s_overhead_clusters;
	__le32 s_backup_bgs[2];
	__u8 s_encrypt_algos[4];
	__u8 s_encrypt_pw_salt[16];
	__le32 s_lpf_ino;
	__le32 s_prj_quota_inum;
	__le32 s_checksum_seed;
	__u8 s_wtime_hi;
	__u8 s_mtime_hi;
	__u8 s_mkfs_time_hi;
	__u8 s_lastcheck_hi;
	__u8 s_first_error_time_hi;
	__u8 s_last_error_time_hi;
	__u8 s_pad[2];
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__le32 s_reserved[95];
	__le32 s_checksum;
};

struct mb_cache;

struct ext4_group_info;

struct ext4_locality_group;

struct ext4_li_request;

struct ext4_sb_info {
	long unsigned int s_desc_size;
	long unsigned int s_inodes_per_block;
	long unsigned int s_blocks_per_group;
	long unsigned int s_clusters_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	ext4_group_t s_groups_count;
	ext4_group_t s_blockfile_groups;
	long unsigned int s_overhead;
	unsigned int s_cluster_ratio;
	unsigned int s_cluster_bits;
	loff_t s_bitmap_maxbytes;
	struct buffer_head *s_sbh;
	struct ext4_super_block *s_es;
	struct buffer_head **s_group_desc;
	unsigned int s_mount_opt;
	unsigned int s_mount_opt2;
	unsigned int s_mount_flags;
	unsigned int s_def_mount_opt;
	ext4_fsblk_t s_sb_block;
	atomic64_t s_resv_clusters;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	unsigned int s_inode_readahead_blks;
	unsigned int s_inode_goal;
	u32 s_hash_seed[4];
	int s_def_hash_version;
	int s_hash_unsigned;
	struct percpu_counter s_freeclusters_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct percpu_counter s_dirtyclusters_counter;
	struct percpu_counter s_sra_exceeded_retry_limit;
	struct blockgroup_lock *s_blockgroup_lock;
	struct proc_dir_entry *s_proc;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct super_block *s_sb;
	struct journal_s *s_journal;
	struct list_head s_orphan;
	struct mutex s_orphan_lock;
	long unsigned int s_ext4_flags;
	long unsigned int s_commit_interval;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	struct block_device *journal_bdev;
	char *s_qf_names[3];
	int s_jquota_fmt;
	unsigned int s_want_extra_isize;
	struct ext4_system_blocks *system_blks;
	struct ext4_group_info ***s_group_info;
	struct inode *s_buddy_cache;
	spinlock_t s_md_lock;
	short unsigned int *s_mb_offsets;
	unsigned int *s_mb_maxs;
	unsigned int s_group_info_size;
	unsigned int s_mb_free_pending;
	struct list_head s_freed_data_list;
	long unsigned int s_stripe;
	unsigned int s_mb_stream_request;
	unsigned int s_mb_max_to_scan;
	unsigned int s_mb_min_to_scan;
	unsigned int s_mb_stats;
	unsigned int s_mb_order2_reqs;
	unsigned int s_mb_group_prealloc;
	unsigned int s_mb_max_inode_prealloc;
	unsigned int s_max_dir_size_kb;
	long unsigned int s_mb_last_group;
	long unsigned int s_mb_last_start;
	atomic_t s_bal_reqs;
	atomic_t s_bal_success;
	atomic_t s_bal_allocated;
	atomic_t s_bal_ex_scanned;
	atomic_t s_bal_goals;
	atomic_t s_bal_breaks;
	atomic_t s_bal_2orders;
	spinlock_t s_bal_lock;
	long unsigned int s_mb_buddies_generated;
	long long unsigned int s_mb_generation_time;
	atomic_t s_mb_lost_chunks;
	atomic_t s_mb_preallocated;
	atomic_t s_mb_discarded;
	atomic_t s_lock_busy;
	struct ext4_locality_group *s_locality_groups;
	long unsigned int s_sectors_written_start;
	u64 s_kbytes_written;
	unsigned int s_extent_max_zeroout_kb;
	unsigned int s_log_groups_per_flex;
	struct flex_groups **s_flex_groups;
	ext4_group_t s_flex_groups_allocated;
	struct workqueue_struct *rsv_conversion_wq;
	struct timer_list s_err_report;
	struct ext4_li_request *s_li_request;
	unsigned int s_li_wait_mult;
	struct task_struct *s_mmp_tsk;
	atomic_t s_last_trim_minblks;
	struct crypto_shash *s_chksum_driver;
	__u32 s_csum_seed;
	struct shrinker s_es_shrinker;
	struct list_head s_es_list;
	long int s_es_nr_inode;
	struct ext4_es_stats s_es_stats;
	struct mb_cache *s_ea_block_cache;
	struct mb_cache *s_ea_inode_cache;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t s_es_lock;
	struct ratelimit_state s_err_ratelimit_state;
	struct ratelimit_state s_warning_ratelimit_state;
	struct ratelimit_state s_msg_ratelimit_state;
	struct percpu_rw_semaphore s_writepages_rwsem;
	struct dax_device *s_daxdev;
	long: 64;
};

struct ext4_group_info {
	long unsigned int bb_state;
	struct rb_root bb_free_root;
	ext4_grpblk_t bb_first_free;
	ext4_grpblk_t bb_free;
	ext4_grpblk_t bb_fragments;
	ext4_grpblk_t bb_largest_free_order;
	struct list_head bb_prealloc_list;
	struct rw_semaphore alloc_sem;
	ext4_grpblk_t bb_counters[0];
};

struct ext4_locality_group {
	struct mutex lg_mutex;
	struct list_head lg_prealloc_list[10];
	spinlock_t lg_prealloc_lock;
};

struct ext4_li_request {
	struct super_block *lr_super;
	struct ext4_sb_info *lr_sbi;
	ext4_group_t lr_next_group;
	struct list_head lr_request;
	long unsigned int lr_next_sched;
	long unsigned int lr_timeout;
};

struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
};

typedef enum {
	EXT4_IGET_NORMAL = 0,
	EXT4_IGET_SPECIAL = 1,
	EXT4_IGET_HANDLE = 2,
} ext4_iget_flags;

struct ext4_system_zone {
	struct rb_node node;
	ext4_fsblk_t start_blk;
	unsigned int count;
};

enum {
	EXT4_INODE_SECRM = 0,
	EXT4_INODE_UNRM = 1,
	EXT4_INODE_COMPR = 2,
	EXT4_INODE_SYNC = 3,
	EXT4_INODE_IMMUTABLE = 4,
	EXT4_INODE_APPEND = 5,
	EXT4_INODE_NODUMP = 6,
	EXT4_INODE_NOATIME = 7,
	EXT4_INODE_DIRTY = 8,
	EXT4_INODE_COMPRBLK = 9,
	EXT4_INODE_NOCOMPR = 10,
	EXT4_INODE_ENCRYPT = 11,
	EXT4_INODE_INDEX = 12,
	EXT4_INODE_IMAGIC = 13,
	EXT4_INODE_JOURNAL_DATA = 14,
	EXT4_INODE_NOTAIL = 15,
	EXT4_INODE_DIRSYNC = 16,
	EXT4_INODE_TOPDIR = 17,
	EXT4_INODE_HUGE_FILE = 18,
	EXT4_INODE_EXTENTS = 19,
	EXT4_INODE_VERITY = 20,
	EXT4_INODE_EA_INODE = 21,
	EXT4_INODE_EOFBLOCKS = 22,
	EXT4_INODE_INLINE_DATA = 28,
	EXT4_INODE_PROJINHERIT = 29,
	EXT4_INODE_RESERVED = 31,
};

struct ext4_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[255];
};

struct fname;

struct dir_private_info {
	struct rb_root root;
	struct rb_node *curr_node;
	struct fname *extra_fname;
	loff_t last_pos;
	__u32 curr_hash;
	__u32 curr_minor_hash;
	__u32 next_hash;
};

struct fname {
	__u32 hash;
	__u32 minor_hash;
	struct rb_node rb_hash;
	struct fname *next;
	__u32 inode;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

enum SHIFT_DIRECTION {
	SHIFT_LEFT = 0,
	SHIFT_RIGHT = 1,
};

enum {
	ES_WRITTEN_B = 0,
	ES_UNWRITTEN_B = 1,
	ES_DELAYED_B = 2,
	ES_HOLE_B = 3,
	ES_REFERENCED_B = 4,
	ES_FLAGS = 5,
};

enum {
	EXT4_STATE_JDATA = 0,
	EXT4_STATE_NEW = 1,
	EXT4_STATE_XATTR = 2,
	EXT4_STATE_NO_EXPAND = 3,
	EXT4_STATE_DA_ALLOC_CLOSE = 4,
	EXT4_STATE_EXT_MIGRATE = 5,
	EXT4_STATE_NEWENTRY = 6,
	EXT4_STATE_DIOREAD_LOCK = 7,
	EXT4_STATE_MAY_INLINE_DATA = 8,
	EXT4_STATE_EXT_PRECACHED = 9,
	EXT4_STATE_LUSTRE_EA_INODE = 10,
	EXT4_STATE_VERITY_IN_PROGRESS = 11,
};

struct ext4_iloc {
	struct buffer_head *bh;
	long unsigned int offset;
	ext4_group_t block_group;
};

struct ext4_extent_tail {
	__le32 et_checksum;
};

struct ext4_extent {
	__le32 ee_block;
	__le16 ee_len;
	__le16 ee_start_hi;
	__le32 ee_start_lo;
};

struct ext4_extent_idx {
	__le32 ei_block;
	__le32 ei_leaf_lo;
	__le16 ei_leaf_hi;
	__u16 ei_unused;
};

struct ext4_extent_header {
	__le16 eh_magic;
	__le16 eh_entries;
	__le16 eh_max;
	__le16 eh_depth;
	__le32 eh_generation;
};

struct ext4_ext_path {
	ext4_fsblk_t p_block;
	__u16 p_depth;
	__u16 p_maxdepth;
	struct ext4_extent *p_ext;
	struct ext4_extent_idx *p_idx;
	struct ext4_extent_header *p_hdr;
	struct buffer_head *p_bh;
};

struct partial_cluster {
	ext4_fsblk_t pclu;
	ext4_lblk_t lblk;
	enum {
		initial = 0,
		tofree = 1,
		nofree = 2,
	} state;
};

struct pending_reservation {
	struct rb_node rb_node;
	ext4_lblk_t lclu;
};

struct rsvd_count {
	int ndelonly;
	bool first_do_lblk_found;
	ext4_lblk_t first_do_lblk;
	ext4_lblk_t last_do_lblk;
	struct extent_status *left_es;
	bool partial;
	ext4_lblk_t lclu;
};

struct fsverity_info;

struct fsmap {
	__u32 fmr_device;
	__u32 fmr_flags;
	__u64 fmr_physical;
	__u64 fmr_owner;
	__u64 fmr_offset;
	__u64 fmr_length;
	__u64 fmr_reserved[3];
};

struct ext4_fsmap {
	struct list_head fmr_list;
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	uint64_t fmr_length;
};

struct ext4_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct ext4_fsmap fmh_keys[2];
};

typedef int (*ext4_fsmap_format_t)(struct ext4_fsmap *, void *);

typedef int (*ext4_mballoc_query_range_fn)(struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t, void *);

struct ext4_getfsmap_info {
	struct ext4_fsmap_head *gfi_head;
	ext4_fsmap_format_t gfi_formatter;
	void *gfi_format_arg;
	ext4_fsblk_t gfi_next_fsblk;
	u32 gfi_dev;
	ext4_group_t gfi_agno;
	struct ext4_fsmap gfi_low;
	struct ext4_fsmap gfi_high;
	struct ext4_fsmap gfi_lastfree;
	struct list_head gfi_meta_list;
	bool gfi_last;
};

struct ext4_getfsmap_dev {
	int (*gfd_fn)(struct super_block *, struct ext4_fsmap *, struct ext4_getfsmap_info *);
	u32 gfd_dev;
};

struct dx_hash_info {
	u32 hash;
	u32 minor_hash;
	int hash_version;
	u32 *seed;
};

struct ext4_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size_lo;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks_lo;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_version;
		} linux1;
		struct {
			__u32 h_i_translator;
		} hurd1;
		struct {
			__u32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl_lo;
	__le32 i_size_high;
	__le32 i_obso_faddr;
	union {
		struct {
			__le16 l_i_blocks_high;
			__le16 l_i_file_acl_high;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__le16 l_i_checksum_lo;
			__le16 l_i_reserved;
		} linux2;
		struct {
			__le16 h_i_reserved1;
			__u16 h_i_mode_high;
			__u16 h_i_uid_high;
			__u16 h_i_gid_high;
			__u32 h_i_author;
		} hurd2;
		struct {
			__le16 h_i_reserved1;
			__le16 m_i_file_acl_high;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
	__le16 i_extra_isize;
	__le16 i_checksum_hi;
	__le32 i_ctime_extra;
	__le32 i_mtime_extra;
	__le32 i_atime_extra;
	__le32 i_crtime;
	__le32 i_crtime_extra;
	__le32 i_version_hi;
	__le32 i_projid;
};

struct orlov_stats {
	__u64 free_clusters;
	__u32 free_inodes;
	__u32 used_dirs;
};

typedef struct {
	__le32 *p;
	__le32 key;
	struct buffer_head *bh;
} Indirect;

struct ext4_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	struct dx_hash_info hinfo;
	struct fscrypt_str crypto_buf;
};

struct ext4_xattr_ibody_header {
	__le32 h_magic;
};

struct ext4_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_inum;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

struct ext4_xattr_info {
	const char *name;
	const void *value;
	size_t value_len;
	int name_index;
	int in_inode;
};

struct ext4_xattr_search {
	struct ext4_xattr_entry *first;
	void *base;
	void *end;
	struct ext4_xattr_entry *here;
	int not_found;
};

struct ext4_xattr_ibody_find {
	struct ext4_xattr_search s;
	struct ext4_iloc iloc;
};

typedef short unsigned int __kernel_uid16_t;

typedef short unsigned int __kernel_gid16_t;

typedef __kernel_uid16_t uid16_t;

typedef __kernel_gid16_t gid16_t;

struct ext4_io_end {
	struct list_head list;
	handle_t *handle;
	struct inode *inode;
	struct bio *bio;
	unsigned int flag;
	atomic_t count;
	loff_t offset;
	ssize_t size;
};

typedef struct ext4_io_end ext4_io_end_t;

struct ext4_io_submit {
	struct writeback_control *io_wbc;
	struct bio *io_bio;
	ext4_io_end_t *io_end;
	sector_t io_next_block;
};

struct ext4_xattr_inode_array {
	unsigned int count;
	struct inode *inodes[0];
};

struct mpage_da_data {
	struct inode *inode;
	struct writeback_control *wbc;
	long unsigned int first_page;
	long unsigned int next_page;
	long unsigned int last_page;
	struct ext4_map_blocks map;
	struct ext4_io_submit io_submit;
	unsigned int do_map: 1;
};

struct other_inode {
	long unsigned int orig_ino;
	struct ext4_inode *raw_inode;
};

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

struct ext4_new_group_input {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
};

struct compat_ext4_new_group_input {
	u32 group;
	compat_u64 block_bitmap;
	compat_u64 inode_bitmap;
	compat_u64 inode_table;
	u32 blocks_count;
	u16 reserved_blocks;
	u16 unused;
} __attribute__((packed));

struct ext4_new_group_data {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 mdata_blocks;
	__u32 free_clusters_count;
};

struct move_extent {
	__u32 reserved;
	__u32 donor_fd;
	__u64 orig_start;
	__u64 donor_start;
	__u64 len;
	__u64 moved_len;
};

struct fsmap_head {
	__u32 fmh_iflags;
	__u32 fmh_oflags;
	__u32 fmh_count;
	__u32 fmh_entries;
	__u64 fmh_reserved[6];
	struct fsmap fmh_keys[2];
	struct fsmap fmh_recs[0];
};

struct getfsmap_info {
	struct super_block *gi_sb;
	struct fsmap_head *gi_data;
	unsigned int gi_idx;
	__u32 gi_last_flags;
};

struct ext4_free_data {
	struct list_head efd_list;
	struct rb_node efd_node;
	ext4_group_t efd_group;
	ext4_grpblk_t efd_start_cluster;
	ext4_grpblk_t efd_count;
	tid_t efd_tid;
};

struct ext4_prealloc_space {
	struct list_head pa_inode_list;
	struct list_head pa_group_list;
	union {
		struct list_head pa_tmp_list;
		struct callback_head pa_rcu;
	} u;
	spinlock_t pa_lock;
	atomic_t pa_count;
	unsigned int pa_deleted;
	ext4_fsblk_t pa_pstart;
	ext4_lblk_t pa_lstart;
	ext4_grpblk_t pa_len;
	ext4_grpblk_t pa_free;
	short unsigned int pa_type;
	spinlock_t *pa_obj_lock;
	struct inode *pa_inode;
};

enum {
	MB_INODE_PA = 0,
	MB_GROUP_PA = 1,
};

struct ext4_free_extent {
	ext4_lblk_t fe_logical;
	ext4_grpblk_t fe_start;
	ext4_group_t fe_group;
	ext4_grpblk_t fe_len;
};

struct ext4_allocation_context {
	struct inode *ac_inode;
	struct super_block *ac_sb;
	struct ext4_free_extent ac_o_ex;
	struct ext4_free_extent ac_g_ex;
	struct ext4_free_extent ac_b_ex;
	struct ext4_free_extent ac_f_ex;
	__u16 ac_groups_scanned;
	__u16 ac_found;
	__u16 ac_tail;
	__u16 ac_buddy;
	__u16 ac_flags;
	__u8 ac_status;
	__u8 ac_criteria;
	__u8 ac_2order;
	__u8 ac_op;
	struct page *ac_bitmap_page;
	struct page *ac_buddy_page;
	struct ext4_prealloc_space *ac_pa;
	struct ext4_locality_group *ac_lg;
};

struct ext4_buddy {
	struct page *bd_buddy_page;
	void *bd_buddy;
	struct page *bd_bitmap_page;
	void *bd_bitmap;
	struct ext4_group_info *bd_info;
	struct super_block *bd_sb;
	__u16 bd_blkbits;
	ext4_group_t bd_group;
};

struct sg {
	struct ext4_group_info info;
	ext4_grpblk_t counters[18];
};

struct migrate_struct {
	ext4_lblk_t first_block;
	ext4_lblk_t last_block;
	ext4_lblk_t curr_block;
	ext4_fsblk_t first_pblock;
	ext4_fsblk_t last_pblock;
};

struct mmp_struct {
	__le32 mmp_magic;
	__le32 mmp_seq;
	__le64 mmp_time;
	char mmp_nodename[64];
	char mmp_bdevname[32];
	__le16 mmp_check_interval;
	__le16 mmp_pad1;
	__le32 mmp_pad2[226];
	__le32 mmp_checksum;
};

struct mmpd_data {
	struct buffer_head *bh;
	struct super_block *sb;
};

struct ext4_dir_entry {
	__le32 inode;
	__le16 rec_len;
	__le16 name_len;
	char name[255];
};

struct ext4_dir_entry_tail {
	__le32 det_reserved_zero1;
	__le16 det_rec_len;
	__u8 det_reserved_zero2;
	__u8 det_reserved_ft;
	__le32 det_checksum;
};

typedef enum {
	EITHER = 0,
	INDEX = 1,
	DIRENT = 2,
	DIRENT_HTREE = 3,
} dirblock_type_t;

struct fake_dirent {
	__le32 inode;
	__le16 rec_len;
	u8 name_len;
	u8 file_type;
};

struct dx_countlimit {
	__le16 limit;
	__le16 count;
};

struct dx_entry {
	__le32 hash;
	__le32 block;
};

struct dx_root_info {
	__le32 reserved_zero;
	u8 hash_version;
	u8 info_length;
	u8 indirect_levels;
	u8 unused_flags;
};

struct dx_root {
	struct fake_dirent dot;
	char dot_name[4];
	struct fake_dirent dotdot;
	char dotdot_name[4];
	struct dx_root_info info;
	struct dx_entry entries[0];
};

struct dx_node {
	struct fake_dirent fake;
	struct dx_entry entries[0];
};

struct dx_frame {
	struct buffer_head *bh;
	struct dx_entry *entries;
	struct dx_entry *at;
};

struct dx_map_entry {
	u32 hash;
	u16 offs;
	u16 size;
};

struct dx_tail {
	u32 dt_reserved;
	__le32 dt_checksum;
};

struct ext4_renament {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool is_dir;
	int dir_nlink_delta;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	int inlined;
	struct buffer_head *dir_bh;
	struct ext4_dir_entry_2 *parent_de;
	int dir_inlined;
};

enum bio_post_read_step {
	STEP_INITIAL = 0,
	STEP_DECRYPT = 1,
	STEP_VERITY = 2,
	STEP_MAX = 3,
};

struct bio_post_read_ctx {
	struct bio *bio;
	struct work_struct work;
	unsigned int cur_step;
	unsigned int enabled_steps;
};

enum {
	BLOCK_BITMAP = 0,
	INODE_BITMAP = 1,
	INODE_TABLE = 2,
	GROUP_TABLE_COUNT = 3,
};

struct ext4_rcu_ptr {
	struct callback_head rcu;
	void *ptr;
};

struct ext4_new_flex_group_data {
	struct ext4_new_group_data *groups;
	__u16 *bg_flags;
	ext4_group_t count;
};

enum {
	I_DATA_SEM_NORMAL = 0,
	I_DATA_SEM_OTHER = 1,
	I_DATA_SEM_QUOTA = 2,
};

struct ext4_lazy_init {
	long unsigned int li_state;
	struct list_head li_request_list;
	struct mutex li_list_mtx;
};

struct ext4_journal_cb_entry {
	struct list_head jce_list;
	void (*jce_func)(struct super_block *, struct ext4_journal_cb_entry *, int);
};

struct trace_event_raw_ext4_other_inode_update_time {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t orig_ino;
	uid_t uid;
	gid_t gid;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	uid_t uid;
	gid_t gid;
	__u64 blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_request_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_evict_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int nlink;
	char __data[0];
};

struct trace_event_raw_ext4_drop_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int drop;
	char __data[0];
};

struct trace_event_raw_ext4_nfs_commit_metadata {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_mark_inode_dirty {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_ext4_begin_ordered_truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_ext4__write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_ext4_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	long unsigned int writeback_index;
	int sync_mode;
	char for_kupdate;
	char range_cyclic;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int first_page;
	long int nr_to_write;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 lblk;
	__u32 len;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_ext4_writepages_result {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	int pages_written;
	long int pages_skipped;
	long unsigned int writeback_index;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4__page_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_ext4_invalidatepage_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	unsigned int offset;
	unsigned int length;
	char __data[0];
};

struct trace_event_raw_ext4_discard_blocks {
	struct trace_entry ent;
	dev_t dev;
	__u64 blk;
	__u64 count;
	char __data[0];
};

struct trace_event_raw_ext4__mb_new_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 pa_pstart;
	__u64 pa_lstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_inode_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	__u32 count;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_group_pa {
	struct trace_entry ent;
	dev_t dev;
	__u64 pa_pstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	unsigned int needed;
	char __data[0];
};

struct trace_event_raw_ext4_mb_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	int needed;
	char __data[0];
};

struct trace_event_raw_ext4_request_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_free_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	long unsigned int count;
	int flags;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int datasync;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int wait;
	char __data[0];
};

struct trace_event_raw_ext4_alloc_da_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int data_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 goal_logical;
	int goal_start;
	__u32 goal_group;
	int goal_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	__u16 found;
	__u16 groups;
	__u16 buddy;
	__u16 flags;
	__u16 tail;
	__u8 cr;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_prealloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4__mballoc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4_forget {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	int is_metadata;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_update_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int used_blocks;
	int reserved_data_blocks;
	int quota_claim;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_release_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int freed_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4__bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_direct_IO_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	long unsigned int len;
	int rw;
	char __data[0];
};

struct trace_event_raw_ext4_direct_IO_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	long unsigned int len;
	int rw;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__fallocate_mode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	int mode;
	char __data[0];
};

struct trace_event_raw_ext4_fallocate_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 blocks;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_fastpath {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	ext4_lblk_t i_lblk;
	unsigned int i_len;
	ext4_fsblk_t i_pblk;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int flags;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int mflags;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_load_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_load_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_reserved {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	char __data[0];
};

struct trace_event_raw_ext4__trim {
	struct trace_entry ent;
	int dev_major;
	int dev_minor;
	__u32 group;
	int start;
	int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_handle_unwritten_extents {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	unsigned int allocated;
	ext4_fsblk_t newblk;
	char __data[0];
};

struct trace_event_raw_ext4_get_implied_cluster_alloc_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_put_in_cache {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	ext4_fsblk_t start;
	char __data[0];
};

struct trace_event_raw_ext4_ext_in_cache {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_find_delalloc_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	int reverse;
	int found;
	ext4_lblk_t found_blk;
	char __data[0];
};

struct trace_event_raw_ext4_get_reserved_cluster_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_show_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	short unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_remove_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	ext4_fsblk_t ee_pblk;
	ext4_lblk_t ee_lblk;
	short unsigned int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_leaf {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t ee_lblk;
	ext4_fsblk_t ee_pblk;
	short int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_idx {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space_done {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	short unsigned int eh_entries;
	char __data[0];
};

struct trace_event_raw_ext4__es_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_remove_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t lblk;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	int found;
	char __data[0];
};

struct trace_event_raw_ext4__es_shrink_enter {
	struct trace_entry ent;
	dev_t dev;
	int nr_to_scan;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_collapse_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_insert_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	long long unsigned int scan_time;
	int nr_skipped;
	int retried;
	char __data[0];
};

struct trace_event_raw_ext4_es_insert_delayed_block {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	bool allocated;
	char __data[0];
};

struct trace_event_raw_ext4_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u32 agno;
	u64 bno;
	u64 len;
	u64 owner;
	char __data[0];
};

struct trace_event_raw_ext4_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u64 block;
	u64 len;
	u64 owner;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_ext4_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_error {
	struct trace_entry ent;
	dev_t dev;
	const char *function;
	unsigned int line;
	char __data[0];
};

struct trace_event_data_offsets_ext4_other_inode_update_time {};

struct trace_event_data_offsets_ext4_free_inode {};

struct trace_event_data_offsets_ext4_request_inode {};

struct trace_event_data_offsets_ext4_allocate_inode {};

struct trace_event_data_offsets_ext4_evict_inode {};

struct trace_event_data_offsets_ext4_drop_inode {};

struct trace_event_data_offsets_ext4_nfs_commit_metadata {};

struct trace_event_data_offsets_ext4_mark_inode_dirty {};

struct trace_event_data_offsets_ext4_begin_ordered_truncate {};

struct trace_event_data_offsets_ext4__write_begin {};

struct trace_event_data_offsets_ext4__write_end {};

struct trace_event_data_offsets_ext4_writepages {};

struct trace_event_data_offsets_ext4_da_write_pages {};

struct trace_event_data_offsets_ext4_da_write_pages_extent {};

struct trace_event_data_offsets_ext4_writepages_result {};

struct trace_event_data_offsets_ext4__page_op {};

struct trace_event_data_offsets_ext4_invalidatepage_op {};

struct trace_event_data_offsets_ext4_discard_blocks {};

struct trace_event_data_offsets_ext4__mb_new_pa {};

struct trace_event_data_offsets_ext4_mb_release_inode_pa {};

struct trace_event_data_offsets_ext4_mb_release_group_pa {};

struct trace_event_data_offsets_ext4_discard_preallocations {};

struct trace_event_data_offsets_ext4_mb_discard_preallocations {};

struct trace_event_data_offsets_ext4_request_blocks {};

struct trace_event_data_offsets_ext4_allocate_blocks {};

struct trace_event_data_offsets_ext4_free_blocks {};

struct trace_event_data_offsets_ext4_sync_file_enter {};

struct trace_event_data_offsets_ext4_sync_file_exit {};

struct trace_event_data_offsets_ext4_sync_fs {};

struct trace_event_data_offsets_ext4_alloc_da_blocks {};

struct trace_event_data_offsets_ext4_mballoc_alloc {};

struct trace_event_data_offsets_ext4_mballoc_prealloc {};

struct trace_event_data_offsets_ext4__mballoc {};

struct trace_event_data_offsets_ext4_forget {};

struct trace_event_data_offsets_ext4_da_update_reserve_space {};

struct trace_event_data_offsets_ext4_da_reserve_space {};

struct trace_event_data_offsets_ext4_da_release_space {};

struct trace_event_data_offsets_ext4__bitmap_load {};

struct trace_event_data_offsets_ext4_direct_IO_enter {};

struct trace_event_data_offsets_ext4_direct_IO_exit {};

struct trace_event_data_offsets_ext4__fallocate_mode {};

struct trace_event_data_offsets_ext4_fallocate_exit {};

struct trace_event_data_offsets_ext4_unlink_enter {};

struct trace_event_data_offsets_ext4_unlink_exit {};

struct trace_event_data_offsets_ext4__truncate {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_enter {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_fastpath {};

struct trace_event_data_offsets_ext4__map_blocks_enter {};

struct trace_event_data_offsets_ext4__map_blocks_exit {};

struct trace_event_data_offsets_ext4_ext_load_extent {};

struct trace_event_data_offsets_ext4_load_inode {};

struct trace_event_data_offsets_ext4_journal_start {};

struct trace_event_data_offsets_ext4_journal_start_reserved {};

struct trace_event_data_offsets_ext4__trim {};

struct trace_event_data_offsets_ext4_ext_handle_unwritten_extents {};

struct trace_event_data_offsets_ext4_get_implied_cluster_alloc_exit {};

struct trace_event_data_offsets_ext4_ext_put_in_cache {};

struct trace_event_data_offsets_ext4_ext_in_cache {};

struct trace_event_data_offsets_ext4_find_delalloc_range {};

struct trace_event_data_offsets_ext4_get_reserved_cluster_alloc {};

struct trace_event_data_offsets_ext4_ext_show_extent {};

struct trace_event_data_offsets_ext4_remove_blocks {};

struct trace_event_data_offsets_ext4_ext_rm_leaf {};

struct trace_event_data_offsets_ext4_ext_rm_idx {};

struct trace_event_data_offsets_ext4_ext_remove_space {};

struct trace_event_data_offsets_ext4_ext_remove_space_done {};

struct trace_event_data_offsets_ext4__es_extent {};

struct trace_event_data_offsets_ext4_es_remove_extent {};

struct trace_event_data_offsets_ext4_es_find_extent_range_enter {};

struct trace_event_data_offsets_ext4_es_find_extent_range_exit {};

struct trace_event_data_offsets_ext4_es_lookup_extent_enter {};

struct trace_event_data_offsets_ext4_es_lookup_extent_exit {};

struct trace_event_data_offsets_ext4__es_shrink_enter {};

struct trace_event_data_offsets_ext4_es_shrink_scan_exit {};

struct trace_event_data_offsets_ext4_collapse_range {};

struct trace_event_data_offsets_ext4_insert_range {};

struct trace_event_data_offsets_ext4_es_shrink {};

struct trace_event_data_offsets_ext4_es_insert_delayed_block {};

struct trace_event_data_offsets_ext4_fsmap_class {};

struct trace_event_data_offsets_ext4_getfsmap_class {};

struct trace_event_data_offsets_ext4_shutdown {};

struct trace_event_data_offsets_ext4_error {};

typedef void (*btf_trace_ext4_other_inode_update_time)(void *, struct inode *, ino_t);

typedef void (*btf_trace_ext4_free_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_request_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_allocate_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_ext4_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_nfs_commit_metadata)(void *, struct inode *);

typedef void (*btf_trace_ext4_mark_inode_dirty)(void *, struct inode *, long unsigned int);

typedef void (*btf_trace_ext4_begin_ordered_truncate)(void *, struct inode *, loff_t);

typedef void (*btf_trace_ext4_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_writepages)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages)(void *, struct inode *, long unsigned int, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages_extent)(void *, struct inode *, struct ext4_map_blocks *);

typedef void (*btf_trace_ext4_writepages_result)(void *, struct inode *, struct writeback_control *, int, int);

typedef void (*btf_trace_ext4_writepage)(void *, struct page *);

typedef void (*btf_trace_ext4_readpage)(void *, struct page *);

typedef void (*btf_trace_ext4_releasepage)(void *, struct page *);

typedef void (*btf_trace_ext4_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_discard_blocks)(void *, struct super_block *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_ext4_mb_new_inode_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_new_group_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_inode_pa)(void *, struct ext4_prealloc_space *, long long unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_release_group_pa)(void *, struct super_block *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_discard_preallocations)(void *, struct inode *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_discard_preallocations)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_request_blocks)(void *, struct ext4_allocation_request *);

typedef void (*btf_trace_ext4_allocate_blocks)(void *, struct ext4_allocation_request *, long long unsigned int);

typedef void (*btf_trace_ext4_free_blocks)(void *, struct inode *, __u64, long unsigned int, int);

typedef void (*btf_trace_ext4_sync_file_enter)(void *, struct file *, int);

typedef void (*btf_trace_ext4_sync_file_exit)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_alloc_da_blocks)(void *, struct inode *);

typedef void (*btf_trace_ext4_mballoc_alloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_prealloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_discard)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_free)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_forget)(void *, struct inode *, int, __u64);

typedef void (*btf_trace_ext4_da_update_reserve_space)(void *, struct inode *, int, int);

typedef void (*btf_trace_ext4_da_reserve_space)(void *, struct inode *);

typedef void (*btf_trace_ext4_da_release_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_mb_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_buddy_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_read_block_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_load_inode_bitmap)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_direct_IO_enter)(void *, struct inode *, loff_t, long unsigned int, int);

typedef void (*btf_trace_ext4_direct_IO_exit)(void *, struct inode *, loff_t, long unsigned int, int, int);

typedef void (*btf_trace_ext4_fallocate_enter)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_punch_hole)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_zero_range)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_fallocate_exit)(void *, struct inode *, loff_t, unsigned int, int);

typedef void (*btf_trace_ext4_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_ext4_unlink_exit)(void *, struct dentry *, int);

typedef void (*btf_trace_ext4_truncate_enter)(void *, struct inode *);

typedef void (*btf_trace_ext4_truncate_exit)(void *, struct inode *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_enter)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_fastpath)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ind_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ext_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ind_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_load_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t);

typedef void (*btf_trace_ext4_load_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_journal_start)(void *, struct super_block *, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_reserved)(void *, struct super_block *, int, long unsigned int);

typedef void (*btf_trace_ext4_trim_extent)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_trim_all_free)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_ext_handle_unwritten_extents)(void *, struct inode *, struct ext4_map_blocks *, int, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_get_implied_cluster_alloc_exit)(void *, struct super_block *, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_put_in_cache)(void *, struct inode *, ext4_lblk_t, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_in_cache)(void *, struct inode *, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_find_delalloc_range)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, int, ext4_lblk_t);

typedef void (*btf_trace_ext4_get_reserved_cluster_alloc)(void *, struct inode *, ext4_lblk_t, unsigned int);

typedef void (*btf_trace_ext4_ext_show_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t, short unsigned int);

typedef void (*btf_trace_ext4_remove_blocks)(void *, struct inode *, struct ext4_extent *, ext4_lblk_t, ext4_fsblk_t, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_leaf)(void *, struct inode *, ext4_lblk_t, struct ext4_extent *, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_idx)(void *, struct inode *, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_remove_space)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_ext_remove_space_done)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, struct partial_cluster *, __le16);

typedef void (*btf_trace_ext4_es_insert_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_cache_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_remove_extent)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_exit)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_lookup_extent_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_lookup_extent_exit)(void *, struct inode *, struct extent_status *, int);

typedef void (*btf_trace_ext4_es_shrink_count)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_enter)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_exit)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_collapse_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_insert_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_es_shrink)(void *, struct super_block *, int, u64, int, int);

typedef void (*btf_trace_ext4_es_insert_delayed_block)(void *, struct inode *, struct extent_status *, bool);

typedef void (*btf_trace_ext4_fsmap_low_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_high_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_mapping)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_getfsmap_low_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_high_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_mapping)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_shutdown)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_error)(void *, struct super_block *, const char *, unsigned int);

enum {
	Opt_bsd_df = 0,
	Opt_minix_df = 1,
	Opt_grpid = 2,
	Opt_nogrpid = 3,
	Opt_resgid = 4,
	Opt_resuid = 5,
	Opt_sb = 6,
	Opt_err_cont = 7,
	Opt_err_panic = 8,
	Opt_err_ro = 9,
	Opt_nouid32 = 10,
	Opt_debug = 11,
	Opt_removed = 12,
	Opt_user_xattr = 13,
	Opt_nouser_xattr = 14,
	Opt_acl = 15,
	Opt_noacl = 16,
	Opt_auto_da_alloc = 17,
	Opt_noauto_da_alloc = 18,
	Opt_noload = 19,
	Opt_commit = 20,
	Opt_min_batch_time = 21,
	Opt_max_batch_time = 22,
	Opt_journal_dev = 23,
	Opt_journal_path = 24,
	Opt_journal_checksum = 25,
	Opt_journal_async_commit = 26,
	Opt_abort = 27,
	Opt_data_journal = 28,
	Opt_data_ordered = 29,
	Opt_data_writeback = 30,
	Opt_data_err_abort = 31,
	Opt_data_err_ignore = 32,
	Opt_test_dummy_encryption = 33,
	Opt_usrjquota = 34,
	Opt_grpjquota = 35,
	Opt_offusrjquota = 36,
	Opt_offgrpjquota = 37,
	Opt_jqfmt_vfsold = 38,
	Opt_jqfmt_vfsv0 = 39,
	Opt_jqfmt_vfsv1 = 40,
	Opt_quota = 41,
	Opt_noquota = 42,
	Opt_barrier = 43,
	Opt_nobarrier = 44,
	Opt_err___2 = 45,
	Opt_usrquota = 46,
	Opt_grpquota = 47,
	Opt_prjquota = 48,
	Opt_i_version = 49,
	Opt_dax = 50,
	Opt_stripe = 51,
	Opt_delalloc = 52,
	Opt_nodelalloc = 53,
	Opt_warn_on_error = 54,
	Opt_nowarn_on_error = 55,
	Opt_mblk_io_submit = 56,
	Opt_lazytime = 57,
	Opt_nolazytime = 58,
	Opt_debug_want_extra_isize = 59,
	Opt_nomblk_io_submit = 60,
	Opt_block_validity = 61,
	Opt_noblock_validity = 62,
	Opt_inode_readahead_blks = 63,
	Opt_journal_ioprio = 64,
	Opt_dioread_nolock = 65,
	Opt_dioread_lock = 66,
	Opt_discard = 67,
	Opt_nodiscard = 68,
	Opt_init_itable = 69,
	Opt_noinit_itable = 70,
	Opt_max_dir_size_kb = 71,
	Opt_nojournal_checksum = 72,
	Opt_nombcache = 73,
};

struct mount_opts {
	int token;
	int mount_opt;
	int flags;
};

struct ext4_mount_options {
	long unsigned int s_mount_opt;
	long unsigned int s_mount_opt2;
	kuid_t s_resuid;
	kgid_t s_resgid;
	long unsigned int s_commit_interval;
	u32 s_min_batch_time;
	u32 s_max_batch_time;
	int s_jquota_fmt;
	char *s_qf_names[3];
};

enum {
	attr_noop = 0,
	attr_delayed_allocation_blocks = 1,
	attr_session_write_kbytes = 2,
	attr_lifetime_write_kbytes = 3,
	attr_reserved_clusters = 4,
	attr_sra_exceeded_retry_limit = 5,
	attr_inode_readahead = 6,
	attr_trigger_test_error = 7,
	attr_first_error_time = 8,
	attr_last_error_time = 9,
	attr_feature = 10,
	attr_pointer_ui = 11,
	attr_pointer_atomic = 12,
	attr_journal_task = 13,
};

enum {
	ptr_explicit = 0,
	ptr_ext4_sb_info_offset = 1,
	ptr_ext4_super_block_offset = 2,
};

struct ext4_attr {
	struct attribute attr;
	short int attr_id;
	short int attr_ptr;
	union {
		int offset;
		void *explicit_ptr;
	} u;
};

struct ext4_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__le32 h_checksum;
	__u32 h_reserved[3];
};

struct ext4_xattr_block_find {
	struct ext4_xattr_search s;
	struct buffer_head *bh;
};

typedef struct {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
} ext4_acl_entry;

typedef struct {
	__le32 a_version;
} ext4_acl_header;

typedef int ext2_grpblk_t;

typedef long unsigned int ext2_fsblk_t;

struct ext2_reserve_window {
	ext2_fsblk_t _rsv_start;
	ext2_fsblk_t _rsv_end;
};

struct ext2_reserve_window_node {
	struct rb_node rsv_node;
	__u32 rsv_goal_size;
	__u32 rsv_alloc_hit;
	struct ext2_reserve_window rsv_window;
};

struct ext2_block_alloc_info {
	struct ext2_reserve_window_node rsv_window_node;
	__u32 last_alloc_logical_block;
	ext2_fsblk_t last_alloc_physical_block;
};

struct ext2_super_block;

struct ext2_sb_info {
	long unsigned int s_frag_size;
	long unsigned int s_frags_per_block;
	long unsigned int s_inodes_per_block;
	long unsigned int s_frags_per_group;
	long unsigned int s_blocks_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	long unsigned int s_groups_count;
	long unsigned int s_overhead_last;
	long unsigned int s_blocks_last;
	struct buffer_head *s_sbh;
	struct ext2_super_block *s_es;
	struct buffer_head **s_group_desc;
	long unsigned int s_mount_opt;
	long unsigned int s_sb_block;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	spinlock_t s_next_gen_lock;
	u32 s_next_generation;
	long unsigned int s_dir_count;
	u8 *s_debts;
	struct percpu_counter s_freeblocks_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct blockgroup_lock *s_blockgroup_lock;
	spinlock_t s_rsv_window_lock;
	struct rb_root s_rsv_window_root;
	struct ext2_reserve_window_node s_rsv_window_head;
	spinlock_t s_lock;
	struct mb_cache *s_ea_block_cache;
	struct dax_device *s_daxdev;
};

struct ext2_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count;
	__le32 s_r_blocks_count;
	__le32 s_free_blocks_count;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_frag_size;
	__le32 s_blocks_per_group;
	__le32 s_frags_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__u16 s_padding1;
	__u8 s_journal_uuid[16];
	__u32 s_journal_inum;
	__u32 s_journal_dev;
	__u32 s_last_orphan;
	__u32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_reserved_char_pad;
	__u16 s_reserved_word_pad;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__u32 s_reserved[190];
};

struct ext2_group_desc {
	__le32 bg_block_bitmap;
	__le32 bg_inode_bitmap;
	__le32 bg_inode_table;
	__le16 bg_free_blocks_count;
	__le16 bg_free_inodes_count;
	__le16 bg_used_dirs_count;
	__le16 bg_pad;
	__le32 bg_reserved[3];
};

struct ext2_inode_info {
	__le32 i_data[15];
	__u32 i_flags;
	__u32 i_faddr;
	__u8 i_frag_no;
	__u8 i_frag_size;
	__u16 i_state;
	__u32 i_file_acl;
	__u32 i_dir_acl;
	__u32 i_dtime;
	__u32 i_block_group;
	struct ext2_block_alloc_info *i_block_alloc_info;
	__u32 i_dir_start_lookup;
	rwlock_t i_meta_lock;
	struct rw_semaphore dax_sem;
	struct mutex truncate_mutex;
	struct inode vfs_inode;
	struct list_head i_orphan;
	struct dquot *i_dquot[3];
};

struct ext2_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

typedef struct ext2_dir_entry_2 ext2_dirent;

struct ext2_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_reserved1;
		} linux1;
		struct {
			__le32 h_i_translator;
		} hurd1;
		struct {
			__le32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl;
	__le32 i_dir_acl;
	__le32 i_faddr;
	union {
		struct {
			__u8 l_i_frag;
			__u8 l_i_fsize;
			__u16 i_pad1;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__u32 l_i_reserved2;
		} linux2;
		struct {
			__u8 h_i_frag;
			__u8 h_i_fsize;
			__le16 h_i_mode_high;
			__le16 h_i_uid_high;
			__le16 h_i_gid_high;
			__le32 h_i_author;
		} hurd2;
		struct {
			__u8 m_i_frag;
			__u8 m_i_fsize;
			__u16 m_pad1;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
};

struct ext2_mount_options {
	long unsigned int s_mount_opt;
	kuid_t s_resuid;
	kgid_t s_resgid;
};

enum {
	Opt_bsd_df___2 = 0,
	Opt_minix_df___2 = 1,
	Opt_grpid___2 = 2,
	Opt_nogrpid___2 = 3,
	Opt_resgid___2 = 4,
	Opt_resuid___2 = 5,
	Opt_sb___2 = 6,
	Opt_err_cont___2 = 7,
	Opt_err_panic___2 = 8,
	Opt_err_ro___2 = 9,
	Opt_nouid32___2 = 10,
	Opt_nocheck = 11,
	Opt_debug___2 = 12,
	Opt_oldalloc = 13,
	Opt_orlov = 14,
	Opt_nobh = 15,
	Opt_user_xattr___2 = 16,
	Opt_nouser_xattr___2 = 17,
	Opt_acl___2 = 18,
	Opt_noacl___2 = 19,
	Opt_xip = 20,
	Opt_dax___2 = 21,
	Opt_ignore = 22,
	Opt_err___3 = 23,
	Opt_quota___2 = 24,
	Opt_usrquota___2 = 25,
	Opt_grpquota___2 = 26,
	Opt_reservation = 27,
	Opt_noreservation = 28,
};

struct commit_header {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
	unsigned char h_chksum_type;
	unsigned char h_chksum_size;
	unsigned char h_padding[2];
	__be32 h_chksum[8];
	__be64 h_commit_sec;
	__be32 h_commit_nsec;
};

struct journal_block_tag3_s {
	__be32 t_blocknr;
	__be32 t_flags;
	__be32 t_blocknr_high;
	__be32 t_checksum;
};

typedef struct journal_block_tag3_s journal_block_tag3_t;

struct journal_block_tag_s {
	__be32 t_blocknr;
	__be16 t_checksum;
	__be16 t_flags;
	__be32 t_blocknr_high;
};

typedef struct journal_block_tag_s journal_block_tag_t;

struct jbd2_journal_block_tail {
	__be32 t_checksum;
};

struct jbd2_journal_revoke_header_s {
	journal_header_t r_header;
	__be32 r_count;
};

typedef struct jbd2_journal_revoke_header_s jbd2_journal_revoke_header_t;

struct recovery_info {
	tid_t start_transaction;
	tid_t end_transaction;
	int nr_replays;
	int nr_revokes;
	int nr_revoke_hits;
};

enum passtype {
	PASS_SCAN = 0,
	PASS_REVOKE = 1,
	PASS_REPLAY = 2,
};

struct jbd2_revoke_table_s {
	int hash_size;
	int hash_shift;
	struct list_head *hash_table;
};

struct jbd2_revoke_record_s {
	struct list_head hash;
	tid_t sequence;
	long long unsigned int blocknr;
};

struct trace_event_raw_jbd2_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int result;
	char __data[0];
};

struct trace_event_raw_jbd2_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	char __data[0];
};

struct trace_event_raw_jbd2_end_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	int head;
	char __data[0];
};

struct trace_event_raw_jbd2_submit_inode_data {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_start {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_extend {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int buffer_credits;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int interval;
	int sync;
	int requested_blocks;
	int dirtied_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_run_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int wait;
	long unsigned int request_delay;
	long unsigned int running;
	long unsigned int locked;
	long unsigned int flushing;
	long unsigned int logging;
	__u32 handle_count;
	__u32 blocks;
	__u32 blocks_logged;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int chp_time;
	__u32 forced_to_close;
	__u32 written;
	__u32 dropped;
	char __data[0];
};

struct trace_event_raw_jbd2_update_log_tail {
	struct trace_entry ent;
	dev_t dev;
	tid_t tail_sequence;
	tid_t first_tid;
	long unsigned int block_nr;
	long unsigned int freed;
	char __data[0];
};

struct trace_event_raw_jbd2_write_superblock {
	struct trace_entry ent;
	dev_t dev;
	int write_op;
	char __data[0];
};

struct trace_event_raw_jbd2_lock_buffer_stall {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int stall_ms;
	char __data[0];
};

struct trace_event_data_offsets_jbd2_checkpoint {};

struct trace_event_data_offsets_jbd2_commit {};

struct trace_event_data_offsets_jbd2_end_commit {};

struct trace_event_data_offsets_jbd2_submit_inode_data {};

struct trace_event_data_offsets_jbd2_handle_start {};

struct trace_event_data_offsets_jbd2_handle_extend {};

struct trace_event_data_offsets_jbd2_handle_stats {};

struct trace_event_data_offsets_jbd2_run_stats {};

struct trace_event_data_offsets_jbd2_checkpoint_stats {};

struct trace_event_data_offsets_jbd2_update_log_tail {};

struct trace_event_data_offsets_jbd2_write_superblock {};

struct trace_event_data_offsets_jbd2_lock_buffer_stall {};

typedef void (*btf_trace_jbd2_checkpoint)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_start_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_locking)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_flushing)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_logging)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_drop_transaction)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_end_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_submit_inode_data)(void *, struct inode *);

typedef void (*btf_trace_jbd2_handle_start)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_extend)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int);

typedef void (*btf_trace_jbd2_handle_stats)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int, int, int);

typedef void (*btf_trace_jbd2_run_stats)(void *, dev_t, long unsigned int, struct transaction_run_stats_s *);

typedef void (*btf_trace_jbd2_checkpoint_stats)(void *, dev_t, long unsigned int, struct transaction_chp_stats_s *);

typedef void (*btf_trace_jbd2_update_log_tail)(void *, journal_t *, tid_t, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_write_superblock)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_lock_buffer_stall)(void *, dev_t, long unsigned int);

struct jbd2_stats_proc_session {
	journal_t *journal;
	struct transaction_stats_s *stats;
	int start;
	int max;
};

struct ramfs_mount_opts {
	umode_t mode;
};

struct ramfs_fs_info {
	struct ramfs_mount_opts mount_opts;
};

enum ramfs_param {
	Opt_mode___3 = 0,
};

enum hugetlbfs_size_type {
	NO_SIZE = 0,
	SIZE_STD = 1,
	SIZE_PERCENT = 2,
};

struct hugetlbfs_fs_context {
	struct hstate *hstate;
	long long unsigned int max_size_opt;
	long long unsigned int min_size_opt;
	long int max_hpages;
	long int nr_inodes;
	long int min_hpages;
	enum hugetlbfs_size_type max_val_type;
	enum hugetlbfs_size_type min_val_type;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum hugetlb_param {
	Opt_gid___4 = 0,
	Opt_min_size = 1,
	Opt_mode___4 = 2,
	Opt_nr_inodes___2 = 3,
	Opt_pagesize = 4,
	Opt_size___2 = 5,
	Opt_uid___3 = 6,
};

struct iso_directory_record {
	__u8 length[1];
	__u8 ext_attr_length[1];
	__u8 extent[8];
	__u8 size[8];
	__u8 date[7];
	__u8 flags[1];
	__u8 file_unit_size[1];
	__u8 interleave[1];
	__u8 volume_sequence_number[4];
	__u8 name_len[1];
	char name[0];
};

struct iso_inode_info {
	long unsigned int i_iget5_block;
	long unsigned int i_iget5_offset;
	unsigned int i_first_extent;
	unsigned char i_file_format;
	unsigned char i_format_parm[3];
	long unsigned int i_next_section_block;
	long unsigned int i_next_section_offset;
	off_t i_section_size;
	struct inode vfs_inode;
};

struct nls_table;

struct isofs_sb_info {
	long unsigned int s_ninodes;
	long unsigned int s_nzones;
	long unsigned int s_firstdatazone;
	long unsigned int s_log_zone_size;
	long unsigned int s_max_size;
	int s_rock_offset;
	s32 s_sbsector;
	unsigned char s_joliet_level;
	unsigned char s_mapping;
	unsigned char s_check;
	unsigned char s_session;
	unsigned int s_high_sierra: 1;
	unsigned int s_rock: 2;
	unsigned int s_utf8: 1;
	unsigned int s_cruft: 1;
	unsigned int s_nocompress: 1;
	unsigned int s_hide: 1;
	unsigned int s_showassoc: 1;
	unsigned int s_overriderockperm: 1;
	unsigned int s_uid_set: 1;
	unsigned int s_gid_set: 1;
	umode_t s_fmode;
	umode_t s_dmode;
	kgid_t s_gid;
	kuid_t s_uid;
	struct nls_table *s_nls_iocharset;
};

typedef u16 wchar_t;

struct nls_table {
	const char *charset;
	const char *alias;
	int (*uni2char)(wchar_t, unsigned char *, int);
	int (*char2uni)(const unsigned char *, int, wchar_t *);
	const unsigned char *charset2lower;
	const unsigned char *charset2upper;
	struct module *owner;
	struct nls_table *next;
};

struct cdrom_msf0 {
	__u8 minute;
	__u8 second;
	__u8 frame;
};

union cdrom_addr {
	struct cdrom_msf0 msf;
	int lba;
};

struct cdrom_tocentry {
	__u8 cdte_track;
	__u8 cdte_adr: 4;
	__u8 cdte_ctrl: 4;
	__u8 cdte_format;
	union cdrom_addr cdte_addr;
	__u8 cdte_datamode;
};

struct cdrom_multisession {
	union cdrom_addr addr;
	__u8 xa_flag;
	__u8 addr_format;
};

struct iso_volume_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 data[2041];
};

struct iso_primary_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 unused1[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 unused3[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 opt_type_l_path_table[4];
	__u8 type_m_path_table[4];
	__u8 opt_type_m_path_table[4];
	__u8 root_directory_record[34];
	char volume_set_id[128];
	char publisher_id[128];
	char preparer_id[128];
	char application_id[128];
	char copyright_file_id[37];
	char abstract_file_id[37];
	char bibliographic_file_id[37];
	__u8 creation_date[17];
	__u8 modification_date[17];
	__u8 expiration_date[17];
	__u8 effective_date[17];
	__u8 file_structure_version[1];
	__u8 unused4[1];
	__u8 application_data[512];
	__u8 unused5[653];
};

struct iso_supplementary_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 flags[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 escape[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 opt_type_l_path_table[4];
	__u8 type_m_path_table[4];
	__u8 opt_type_m_path_table[4];
	__u8 root_directory_record[34];
	char volume_set_id[128];
	char publisher_id[128];
	char preparer_id[128];
	char application_id[128];
	char copyright_file_id[37];
	char abstract_file_id[37];
	char bibliographic_file_id[37];
	__u8 creation_date[17];
	__u8 modification_date[17];
	__u8 expiration_date[17];
	__u8 effective_date[17];
	__u8 file_structure_version[1];
	__u8 unused4[1];
	__u8 application_data[512];
	__u8 unused5[653];
};

struct hs_volume_descriptor {
	__u8 foo[8];
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 data[2033];
};

struct hs_primary_descriptor {
	__u8 foo[8];
	__u8 type[1];
	__u8 id[5];
	__u8 version[1];
	__u8 unused1[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 unused3[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 unused4[28];
	__u8 root_directory_record[34];
};

enum isofs_file_format {
	isofs_file_normal = 0,
	isofs_file_sparse = 1,
	isofs_file_compressed = 2,
};

struct iso9660_options {
	unsigned int rock: 1;
	unsigned int joliet: 1;
	unsigned int cruft: 1;
	unsigned int hide: 1;
	unsigned int showassoc: 1;
	unsigned int nocompress: 1;
	unsigned int overriderockperm: 1;
	unsigned int uid_set: 1;
	unsigned int gid_set: 1;
	unsigned int utf8: 1;
	unsigned char map;
	unsigned char check;
	unsigned int blocksize;
	umode_t fmode;
	umode_t dmode;
	kgid_t gid;
	kuid_t uid;
	char *iocharset;
	s32 session;
	s32 sbsector;
};

enum {
	Opt_block = 0,
	Opt_check_r = 1,
	Opt_check_s = 2,
	Opt_cruft = 3,
	Opt_gid___5 = 4,
	Opt_ignore___2 = 5,
	Opt_iocharset = 6,
	Opt_map_a = 7,
	Opt_map_n = 8,
	Opt_map_o = 9,
	Opt_mode___5 = 10,
	Opt_nojoliet = 11,
	Opt_norock = 12,
	Opt_sb___3 = 13,
	Opt_session = 14,
	Opt_uid___4 = 15,
	Opt_unhide = 16,
	Opt_utf8 = 17,
	Opt_err___4 = 18,
	Opt_nocompress = 19,
	Opt_hide = 20,
	Opt_showassoc = 21,
	Opt_dmode = 22,
	Opt_overriderockperm = 23,
};

struct isofs_iget5_callback_data {
	long unsigned int block;
	long unsigned int offset;
};

struct SU_SP_s {
	__u8 magic[2];
	__u8 skip;
};

struct SU_CE_s {
	__u8 extent[8];
	__u8 offset[8];
	__u8 size[8];
};

struct SU_ER_s {
	__u8 len_id;
	__u8 len_des;
	__u8 len_src;
	__u8 ext_ver;
	__u8 data[0];
};

struct RR_RR_s {
	__u8 flags[1];
};

struct RR_PX_s {
	__u8 mode[8];
	__u8 n_links[8];
	__u8 uid[8];
	__u8 gid[8];
};

struct RR_PN_s {
	__u8 dev_high[8];
	__u8 dev_low[8];
};

struct SL_component {
	__u8 flags;
	__u8 len;
	__u8 text[0];
};

struct RR_SL_s {
	__u8 flags;
	struct SL_component link;
};

struct RR_NM_s {
	__u8 flags;
	char name[0];
};

struct RR_CL_s {
	__u8 location[8];
};

struct RR_PL_s {
	__u8 location[8];
};

struct stamp {
	__u8 time[7];
};

struct RR_TF_s {
	__u8 flags;
	struct stamp times[0];
};

struct RR_ZF_s {
	__u8 algorithm[2];
	__u8 parms[2];
	__u8 real_size[8];
};

struct rock_ridge {
	__u8 signature[2];
	__u8 len;
	__u8 version;
	union {
		struct SU_SP_s SP;
		struct SU_CE_s CE;
		struct SU_ER_s ER;
		struct RR_RR_s RR;
		struct RR_PX_s PX;
		struct RR_PN_s PN;
		struct RR_SL_s SL;
		struct RR_NM_s NM;
		struct RR_CL_s CL;
		struct RR_PL_s PL;
		struct RR_TF_s TF;
		struct RR_ZF_s ZF;
	} u;
};

struct rock_state {
	void *buffer;
	unsigned char *chr;
	int len;
	int cont_size;
	int cont_extent;
	int cont_offset;
	int cont_loops;
	struct inode *inode;
};

struct isofs_fid {
	u32 block;
	u16 offset;
	u16 parent_offset;
	u32 generation;
	u32 parent_block;
	u32 parent_generation;
};

enum utf16_endian {
	UTF16_HOST_ENDIAN = 0,
	UTF16_LITTLE_ENDIAN = 1,
	UTF16_BIG_ENDIAN = 2,
};

typedef unsigned char Byte;

typedef long unsigned int uLong;

struct internal_state;

struct z_stream_s {
	const Byte *next_in;
	uLong avail_in;
	uLong total_in;
	Byte *next_out;
	uLong avail_out;
	uLong total_out;
	char *msg;
	struct internal_state *state;
	void *workspace;
	int data_type;
	uLong adler;
	uLong reserved;
};

struct internal_state {
	int dummy;
};

typedef struct z_stream_s z_stream;

typedef z_stream *z_streamp;

struct getdents_callback___2 {
	struct dir_context ctx;
	char *name;
	u64 ino;
	int found;
	int sequence;
};

typedef u32 unicode_t;

struct utf8_table {
	int cmask;
	int cval;
	int shift;
	long int lmask;
	long int lval;
};

typedef unsigned int autofs_wqt_t;

struct autofs_sb_info;

struct autofs_info {
	struct dentry *dentry;
	struct inode *inode;
	int flags;
	struct completion expire_complete;
	struct list_head active;
	struct list_head expiring;
	struct autofs_sb_info *sbi;
	long unsigned int last_used;
	atomic_t count;
	kuid_t uid;
	kgid_t gid;
	struct callback_head rcu;
};

struct autofs_wait_queue;

struct autofs_sb_info {
	u32 magic;
	int pipefd;
	struct file *pipe;
	struct pid *oz_pgrp;
	int version;
	int sub_version;
	int min_proto;
	int max_proto;
	unsigned int flags;
	long unsigned int exp_timeout;
	unsigned int type;
	struct super_block *sb;
	struct mutex wq_mutex;
	struct mutex pipe_mutex;
	spinlock_t fs_lock;
	struct autofs_wait_queue *queues;
	spinlock_t lookup_lock;
	struct list_head active_list;
	struct list_head expiring_list;
	struct callback_head rcu;
};

struct autofs_wait_queue {
	wait_queue_head_t queue;
	struct autofs_wait_queue *next;
	autofs_wqt_t wait_queue_token;
	struct qstr name;
	u32 dev;
	u64 ino;
	kuid_t uid;
	kgid_t gid;
	pid_t pid;
	pid_t tgid;
	int status;
	unsigned int wait_ctr;
};

enum {
	Opt_err___5 = 0,
	Opt_fd = 1,
	Opt_uid___5 = 2,
	Opt_gid___6 = 3,
	Opt_pgrp = 4,
	Opt_minproto = 5,
	Opt_maxproto = 6,
	Opt_indirect = 7,
	Opt_direct = 8,
	Opt_offset = 9,
	Opt_strictexpire = 10,
	Opt_ignore___3 = 11,
};

struct autofs_packet_hdr {
	int proto_version;
	int type;
};

struct autofs_packet_expire {
	struct autofs_packet_hdr hdr;
	int len;
	char name[256];
};

enum {
	AUTOFS_IOC_READY_CMD = 96,
	AUTOFS_IOC_FAIL_CMD = 97,
	AUTOFS_IOC_CATATONIC_CMD = 98,
	AUTOFS_IOC_PROTOVER_CMD = 99,
	AUTOFS_IOC_SETTIMEOUT_CMD = 100,
	AUTOFS_IOC_EXPIRE_CMD = 101,
};

enum autofs_notify {
	NFY_NONE = 0,
	NFY_MOUNT = 1,
	NFY_EXPIRE = 2,
};

enum {
	AUTOFS_IOC_EXPIRE_MULTI_CMD = 102,
	AUTOFS_IOC_PROTOSUBVER_CMD = 103,
	AUTOFS_IOC_ASKUMOUNT_CMD = 112,
};

struct autofs_packet_missing {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

struct autofs_packet_expire_multi {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

union autofs_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_packet_missing missing;
	struct autofs_packet_expire expire;
	struct autofs_packet_expire_multi expire_multi;
};

struct autofs_v5_packet {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	__u32 dev;
	__u64 ino;
	__u32 uid;
	__u32 gid;
	__u32 pid;
	__u32 tgid;
	__u32 len;
	char name[256];
};

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;

typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;

typedef struct autofs_v5_packet autofs_packet_missing_direct_t;

typedef struct autofs_v5_packet autofs_packet_expire_direct_t;

union autofs_v5_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_v5_packet v5_packet;
	autofs_packet_missing_indirect_t missing_indirect;
	autofs_packet_expire_indirect_t expire_indirect;
	autofs_packet_missing_direct_t missing_direct;
	autofs_packet_expire_direct_t expire_direct;
};

struct args_protover {
	__u32 version;
};

struct args_protosubver {
	__u32 sub_version;
};

struct args_openmount {
	__u32 devid;
};

struct args_ready {
	__u32 token;
};

struct args_fail {
	__u32 token;
	__s32 status;
};

struct args_setpipefd {
	__s32 pipefd;
};

struct args_timeout {
	__u64 timeout;
};

struct args_requester {
	__u32 uid;
	__u32 gid;
};

struct args_expire {
	__u32 how;
};

struct args_askumount {
	__u32 may_umount;
};

struct args_in {
	__u32 type;
};

struct args_out {
	__u32 devid;
	__u32 magic;
};

struct args_ismountpoint {
	union {
		struct args_in in;
		struct args_out out;
	};
};

struct autofs_dev_ioctl {
	__u32 ver_major;
	__u32 ver_minor;
	__u32 size;
	__s32 ioctlfd;
	union {
		struct args_protover protover;
		struct args_protosubver protosubver;
		struct args_openmount openmount;
		struct args_ready ready;
		struct args_fail fail;
		struct args_setpipefd setpipefd;
		struct args_timeout timeout;
		struct args_requester requester;
		struct args_expire expire;
		struct args_askumount askumount;
		struct args_ismountpoint ismountpoint;
	};
	char path[0];
};

enum {
	AUTOFS_DEV_IOCTL_VERSION_CMD = 113,
	AUTOFS_DEV_IOCTL_PROTOVER_CMD = 114,
	AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD = 115,
	AUTOFS_DEV_IOCTL_OPENMOUNT_CMD = 116,
	AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD = 117,
	AUTOFS_DEV_IOCTL_READY_CMD = 118,
	AUTOFS_DEV_IOCTL_FAIL_CMD = 119,
	AUTOFS_DEV_IOCTL_SETPIPEFD_CMD = 120,
	AUTOFS_DEV_IOCTL_CATATONIC_CMD = 121,
	AUTOFS_DEV_IOCTL_TIMEOUT_CMD = 122,
	AUTOFS_DEV_IOCTL_REQUESTER_CMD = 123,
	AUTOFS_DEV_IOCTL_EXPIRE_CMD = 124,
	AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD = 125,
	AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD = 126,
};

typedef int (*ioctl_fn)(struct file *, struct autofs_sb_info *, struct autofs_dev_ioctl *);

struct p9_qid {
	u8 type;
	u32 version;
	u64 path;
};

struct p9_wstat {
	u16 size;
	u16 type;
	u32 dev;
	struct p9_qid qid;
	u32 mode;
	u32 atime;
	u32 mtime;
	u64 length;
	const char *name;
	const char *uid;
	const char *gid;
	const char *muid;
	char *extension;
	kuid_t n_uid;
	kgid_t n_gid;
	kuid_t n_muid;
};

struct p9_stat_dotl {
	u64 st_result_mask;
	struct p9_qid qid;
	u32 st_mode;
	kuid_t st_uid;
	kgid_t st_gid;
	u64 st_nlink;
	u64 st_rdev;
	u64 st_size;
	u64 st_blksize;
	u64 st_blocks;
	u64 st_atime_sec;
	u64 st_atime_nsec;
	u64 st_mtime_sec;
	u64 st_mtime_nsec;
	u64 st_ctime_sec;
	u64 st_ctime_nsec;
	u64 st_btime_sec;
	u64 st_btime_nsec;
	u64 st_gen;
	u64 st_data_version;
};

struct p9_rstatfs {
	u32 type;
	u32 bsize;
	u64 blocks;
	u64 bfree;
	u64 bavail;
	u64 files;
	u64 ffree;
	u64 fsid;
	u32 namelen;
};

enum p9_trans_status {
	Connected = 0,
	BeginDisconnect = 1,
	Disconnected = 2,
	Hung = 3,
};

struct p9_trans_module;

struct p9_client {
	spinlock_t lock;
	unsigned int msize;
	unsigned char proto_version;
	struct p9_trans_module *trans_mod;
	enum p9_trans_status status;
	void *trans;
	struct kmem_cache *fcall_cache;
	union {
		struct {
			int rfd;
			int wfd;
		} fd;
		struct {
			u16 port;
			bool privport;
		} tcp;
	} trans_opts;
	struct idr fids;
	struct idr reqs;
	char name[65];
};

struct p9_fid {
	struct p9_client *clnt;
	u32 fid;
	int mode;
	struct p9_qid qid;
	u32 iounit;
	kuid_t uid;
	void *rdir;
	struct hlist_node dlist;
};

enum p9_session_flags {
	V9FS_PROTO_2000U = 1,
	V9FS_PROTO_2000L = 2,
	V9FS_ACCESS_SINGLE = 4,
	V9FS_ACCESS_USER = 8,
	V9FS_ACCESS_CLIENT = 16,
	V9FS_POSIX_ACL = 32,
};

enum p9_cache_modes {
	CACHE_NONE = 0,
	CACHE_MMAP = 1,
	CACHE_LOOSE = 2,
	CACHE_FSCACHE = 3,
	nr__p9_cache_modes = 4,
};

struct v9fs_session_info {
	unsigned char flags;
	unsigned char nodev;
	short unsigned int debug;
	unsigned int afid;
	unsigned int cache;
	char *uname;
	char *aname;
	unsigned int maxdata;
	kuid_t dfltuid;
	kgid_t dfltgid;
	kuid_t uid;
	struct p9_client *clnt;
	struct list_head slist;
	struct rw_semaphore rename_sem;
	long int session_lock_timeout;
};

struct v9fs_inode {
	struct p9_qid qid;
	unsigned int cache_validity;
	struct p9_fid *writeback_fid;
	struct mutex v_mutex;
	struct inode vfs_inode;
};

enum p9_open_mode_t {
	P9_OREAD = 0,
	P9_OWRITE = 1,
	P9_ORDWR = 2,
	P9_OEXEC = 3,
	P9_OTRUNC = 16,
	P9_OREXEC = 32,
	P9_ORCLOSE = 64,
	P9_OAPPEND = 128,
	P9_OEXCL = 4096,
};

enum p9_perm_t {
	P9_DMDIR = 2147483648,
	P9_DMAPPEND = 1073741824,
	P9_DMEXCL = 536870912,
	P9_DMMOUNT = 268435456,
	P9_DMAUTH = 134217728,
	P9_DMTMP = 67108864,
	P9_DMSYMLINK = 33554432,
	P9_DMLINK = 16777216,
	P9_DMDEVICE = 8388608,
	P9_DMNAMEDPIPE = 2097152,
	P9_DMSOCKET = 1048576,
	P9_DMSETUID = 524288,
	P9_DMSETGID = 262144,
	P9_DMSETVTX = 65536,
};

struct p9_iattr_dotl {
	u32 valid;
	u32 mode;
	kuid_t uid;
	kgid_t gid;
	u64 size;
	u64 atime_sec;
	u64 atime_nsec;
	u64 mtime_sec;
	u64 mtime_nsec;
};

struct dotl_openflag_map {
	int open_flag;
	int dotl_flag;
};

struct dotl_iattr_map {
	int iattr_valid;
	int p9_iattr_valid;
};

struct p9_flock {
	u8 type;
	u32 flags;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_getlock {
	u8 type;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_dirent {
	struct p9_qid qid;
	u64 d_off;
	unsigned char d_type;
	char d_name[256];
};

struct p9_rdir {
	int head;
	int tail;
	uint8_t buf[0];
};

struct p9_fcall {
	u32 size;
	u8 id;
	u16 tag;
	size_t offset;
	size_t capacity;
	struct kmem_cache *cache;
	u8 *sdata;
};

struct p9_req_t {
	int status;
	int t_err;
	struct kref refcount;
	wait_queue_head_t wq;
	struct p9_fcall tc;
	struct p9_fcall rc;
	void *aux;
	struct list_head req_list;
};

struct p9_trans_module {
	struct list_head list;
	char *name;
	int maxsize;
	int def;
	struct module *owner;
	int (*create)(struct p9_client *, const char *, char *);
	void (*close)(struct p9_client *);
	int (*request)(struct p9_client *, struct p9_req_t *);
	int (*cancel)(struct p9_client *, struct p9_req_t *);
	int (*cancelled)(struct p9_client *, struct p9_req_t *);
	int (*zc_request)(struct p9_client *, struct p9_req_t *, struct iov_iter *, struct iov_iter *, int, int, int);
	int (*show_options)(struct seq_file *, struct p9_client *);
};

enum {
	Opt_debug___3 = 0,
	Opt_dfltuid = 1,
	Opt_dfltgid = 2,
	Opt_afid = 3,
	Opt_uname = 4,
	Opt_remotename = 5,
	Opt_cache = 6,
	Opt_cachetag = 7,
	Opt_nodevmap = 8,
	Opt_cache_loose = 9,
	Opt_fscache = 10,
	Opt_mmap = 11,
	Opt_access = 12,
	Opt_posixacl = 13,
	Opt_locktimeout = 14,
	Opt_err___6 = 15,
};

struct debugfs_fsdata {
	const struct file_operations *real_fops;
	refcount_t active_users;
	struct completion active_users_drained;
};

struct debugfs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum {
	Opt_uid___6 = 0,
	Opt_gid___7 = 1,
	Opt_mode___6 = 2,
	Opt_err___7 = 3,
};

struct debugfs_fs_info {
	struct debugfs_mount_opts mount_opts;
};

struct debugfs_reg32 {
	char *name;
	long unsigned int offset;
};

struct debugfs_regset32 {
	const struct debugfs_reg32 *regs;
	int nregs;
	void *base;
};

struct array_data {
	void *array;
	u32 elements;
};

struct debugfs_devm_entry {
	int (*read)(struct seq_file *, void *);
	struct device *dev;
};

struct tracefs_dir_ops {
	int (*mkdir)(const char *);
	int (*rmdir)(const char *);
};

struct tracefs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct tracefs_fs_info {
	struct tracefs_mount_opts mount_opts;
};

enum pstore_type_id {
	PSTORE_TYPE_DMESG = 0,
	PSTORE_TYPE_MCE = 1,
	PSTORE_TYPE_CONSOLE = 2,
	PSTORE_TYPE_FTRACE = 3,
	PSTORE_TYPE_PPC_RTAS = 4,
	PSTORE_TYPE_PPC_OF = 5,
	PSTORE_TYPE_PPC_COMMON = 6,
	PSTORE_TYPE_PMSG = 7,
	PSTORE_TYPE_PPC_OPAL = 8,
	PSTORE_TYPE_MAX = 9,
};

struct pstore_info;

struct pstore_record {
	struct pstore_info *psi;
	enum pstore_type_id type;
	u64 id;
	struct timespec64 time;
	char *buf;
	ssize_t size;
	ssize_t ecc_notice_size;
	int count;
	enum kmsg_dump_reason reason;
	unsigned int part;
	bool compressed;
};

struct pstore_info {
	struct module *owner;
	char *name;
	struct semaphore buf_lock;
	char *buf;
	size_t bufsize;
	struct mutex read_mutex;
	int flags;
	void *data;
	int (*open)(struct pstore_info *);
	int (*close)(struct pstore_info *);
	ssize_t (*read)(struct pstore_record *);
	int (*write)(struct pstore_record *);
	int (*write_user)(struct pstore_record *, const char *);
	int (*erase)(struct pstore_record *);
};

struct pstore_ftrace_record {
	long unsigned int ip;
	long unsigned int parent_ip;
	u64 ts;
};

struct pstore_private {
	struct list_head list;
	struct pstore_record *record;
	size_t total_size;
};

struct pstore_ftrace_seq_data {
	const void *ptr;
	size_t off;
	size_t size;
};

enum {
	Opt_kmsg_bytes = 0,
	Opt_err___8 = 1,
};

struct crypto_comp {
	struct crypto_tfm base;
};

struct pstore_zbackend {
	int (*zbufsize)(size_t);
	const char *name;
};

struct efi_variable {
	efi_char16_t VariableName[512];
	efi_guid_t VendorGuid;
	long unsigned int DataSize;
	__u8 Data[1024];
	efi_status_t Status;
	__u32 Attributes;
} __attribute__((packed));

struct efivar_entry {
	struct efi_variable var;
	struct list_head list;
	struct kobject kobj;
	bool scanning;
	bool deleting;
};

typedef u16 ucs2_char_t;

typedef unsigned int __kernel_mode_t;

struct ipc64_perm {
	__kernel_key_t key;
	__kernel_uid32_t uid;
	__kernel_gid32_t gid;
	__kernel_uid32_t cuid;
	__kernel_gid32_t cgid;
	__kernel_mode_t mode;
	unsigned char __pad1[0];
	short unsigned int seq;
	short unsigned int __pad2;
	__kernel_ulong_t __unused1;
	__kernel_ulong_t __unused2;
};

typedef s32 compat_key_t;

typedef u32 __compat_gid32_t;

struct compat_ipc64_perm {
	compat_key_t key;
	__compat_uid32_t uid;
	__compat_gid32_t gid;
	__compat_uid32_t cuid;
	__compat_gid32_t cgid;
	short unsigned int mode;
	short unsigned int __pad1;
	short unsigned int seq;
	short unsigned int __pad2;
	compat_ulong_t unused1;
	compat_ulong_t unused2;
};

struct compat_ipc_perm {
	key_t key;
	__compat_uid_t uid;
	__compat_gid_t gid;
	__compat_uid_t cuid;
	__compat_gid_t cgid;
	compat_mode_t mode;
	short unsigned int seq;
};

struct ipc_perm {
	__kernel_key_t key;
	__kernel_uid_t uid;
	__kernel_gid_t gid;
	__kernel_uid_t cuid;
	__kernel_gid_t cgid;
	__kernel_mode_t mode;
	short unsigned int seq;
};

struct ipc_params {
	key_t key;
	int flg;
	union {
		size_t size;
		int nsems;
	} u;
};

struct ipc_ops {
	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
	int (*associate)(struct kern_ipc_perm *, int);
	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
};

struct ipc_proc_iface {
	const char *path;
	const char *header;
	int ids;
	int (*show)(struct seq_file *, void *);
};

struct ipc_proc_iter {
	struct ipc_namespace *ns;
	struct pid_namespace *pid_ns;
	struct ipc_proc_iface *iface;
};

struct msg_msgseg;

struct msg_msg {
	struct list_head m_list;
	long int m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_msgseg {
	struct msg_msgseg *next;
};

typedef int __kernel_ipc_pid_t;

struct msgbuf {
	__kernel_long_t mtype;
	char mtext[1];
};

struct msg;

struct msqid_ds {
	struct ipc_perm msg_perm;
	struct msg *msg_first;
	struct msg *msg_last;
	__kernel_time_t msg_stime;
	__kernel_time_t msg_rtime;
	__kernel_time_t msg_ctime;
	long unsigned int msg_lcbytes;
	long unsigned int msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	__kernel_ipc_pid_t msg_lspid;
	__kernel_ipc_pid_t msg_lrpid;
};

struct msqid64_ds {
	struct ipc64_perm msg_perm;
	__kernel_time_t msg_stime;
	__kernel_time_t msg_rtime;
	__kernel_time_t msg_ctime;
	long unsigned int msg_cbytes;
	long unsigned int msg_qnum;
	long unsigned int msg_qbytes;
	__kernel_pid_t msg_lspid;
	__kernel_pid_t msg_lrpid;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct msginfo {
	int msgpool;
	int msgmap;
	int msgmax;
	int msgmnb;
	int msgmni;
	int msgssz;
	int msgtql;
	short unsigned int msgseg;
};

typedef u16 compat_ipc_pid_t;

struct compat_msqid64_ds {
	struct compat_ipc64_perm msg_perm;
	compat_ulong_t msg_stime;
	compat_ulong_t msg_stime_high;
	compat_ulong_t msg_rtime;
	compat_ulong_t msg_rtime_high;
	compat_ulong_t msg_ctime;
	compat_ulong_t msg_ctime_high;
	compat_ulong_t msg_cbytes;
	compat_ulong_t msg_qnum;
	compat_ulong_t msg_qbytes;
	compat_pid_t msg_lspid;
	compat_pid_t msg_lrpid;
	compat_ulong_t __unused4;
	compat_ulong_t __unused5;
};

struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;
	time64_t q_rtime;
	time64_t q_ctime;
	long unsigned int q_cbytes;
	long unsigned int q_qnum;
	long unsigned int q_qbytes;
	struct pid *q_lspid;
	struct pid *q_lrpid;
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
	long: 64;
	long: 64;
};

struct msg_receiver {
	struct list_head r_list;
	struct task_struct *r_tsk;
	int r_mode;
	long int r_msgtype;
	long int r_maxsize;
	struct msg_msg *r_msg;
};

struct msg_sender {
	struct list_head list;
	struct task_struct *tsk;
	size_t msgsz;
};

struct compat_msqid_ds {
	struct compat_ipc_perm msg_perm;
	compat_uptr_t msg_first;
	compat_uptr_t msg_last;
	old_time32_t msg_stime;
	old_time32_t msg_rtime;
	old_time32_t msg_ctime;
	compat_ulong_t msg_lcbytes;
	compat_ulong_t msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	compat_ipc_pid_t msg_lspid;
	compat_ipc_pid_t msg_lrpid;
};

struct compat_msgbuf {
	compat_long_t mtype;
	char mtext[1];
};

struct sem;

struct sem_queue;

struct sem_undo;

struct semid_ds {
	struct ipc_perm sem_perm;
	__kernel_time_t sem_otime;
	__kernel_time_t sem_ctime;
	struct sem *sem_base;
	struct sem_queue *sem_pending;
	struct sem_queue **sem_pending_last;
	struct sem_undo *undo;
	short unsigned int sem_nsems;
};

struct sem {
	int semval;
	struct pid *sempid;
	spinlock_t lock;
	struct list_head pending_alter;
	struct list_head pending_const;
	time64_t sem_otime;
};

struct sembuf;

struct sem_queue {
	struct list_head list;
	struct task_struct *sleeper;
	struct sem_undo *undo;
	struct pid *pid;
	int status;
	struct sembuf *sops;
	struct sembuf *blocking;
	int nsops;
	bool alter;
	bool dupsop;
};

struct sem_undo {
	struct list_head list_proc;
	struct callback_head rcu;
	struct sem_undo_list *ulp;
	struct list_head list_id;
	int semid;
	short int *semadj;
};

struct semid64_ds {
	struct ipc64_perm sem_perm;
	__kernel_time_t sem_otime;
	__kernel_ulong_t __unused1;
	__kernel_time_t sem_ctime;
	__kernel_ulong_t __unused2;
	__kernel_ulong_t sem_nsems;
	__kernel_ulong_t __unused3;
	__kernel_ulong_t __unused4;
};

struct sembuf {
	short unsigned int sem_num;
	short int sem_op;
	short int sem_flg;
};

struct seminfo {
	int semmap;
	int semmni;
	int semmns;
	int semmnu;
	int semmsl;
	int semopm;
	int semume;
	int semusz;
	int semvmx;
	int semaem;
};

struct sem_undo_list {
	refcount_t refcnt;
	spinlock_t lock;
	struct list_head list_proc;
};

struct compat_semid64_ds {
	struct compat_ipc64_perm sem_perm;
	compat_ulong_t sem_otime;
	compat_ulong_t sem_otime_high;
	compat_ulong_t sem_ctime;
	compat_ulong_t sem_ctime_high;
	compat_ulong_t sem_nsems;
	compat_ulong_t __unused3;
	compat_ulong_t __unused4;
};

struct sem_array {
	struct kern_ipc_perm sem_perm;
	time64_t sem_ctime;
	struct list_head pending_alter;
	struct list_head pending_const;
	struct list_head list_id;
	int sem_nsems;
	int complex_count;
	unsigned int use_global_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sem sems[0];
};

struct compat_semid_ds {
	struct compat_ipc_perm sem_perm;
	old_time32_t sem_otime;
	old_time32_t sem_ctime;
	compat_uptr_t sem_base;
	compat_uptr_t sem_pending;
	compat_uptr_t sem_pending_last;
	compat_uptr_t undo;
	short unsigned int sem_nsems;
};

struct shmid_ds {
	struct ipc_perm shm_perm;
	int shm_segsz;
	__kernel_time_t shm_atime;
	__kernel_time_t shm_dtime;
	__kernel_time_t shm_ctime;
	__kernel_ipc_pid_t shm_cpid;
	__kernel_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	void *shm_unused2;
	void *shm_unused3;
};

struct shmid64_ds {
	struct ipc64_perm shm_perm;
	size_t shm_segsz;
	__kernel_time_t shm_atime;
	__kernel_time_t shm_dtime;
	__kernel_time_t shm_ctime;
	__kernel_pid_t shm_cpid;
	__kernel_pid_t shm_lpid;
	long unsigned int shm_nattch;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct shminfo64 {
	long unsigned int shmmax;
	long unsigned int shmmin;
	long unsigned int shmmni;
	long unsigned int shmseg;
	long unsigned int shmall;
	long unsigned int __unused1;
	long unsigned int __unused2;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct shminfo {
	int shmmax;
	int shmmin;
	int shmmni;
	int shmseg;
	int shmall;
};

struct shm_info {
	int used_ids;
	__kernel_ulong_t shm_tot;
	__kernel_ulong_t shm_rss;
	__kernel_ulong_t shm_swp;
	__kernel_ulong_t swap_attempts;
	__kernel_ulong_t swap_successes;
};

struct compat_shmid64_ds {
	struct compat_ipc64_perm shm_perm;
	compat_size_t shm_segsz;
	compat_ulong_t shm_atime;
	compat_ulong_t shm_atime_high;
	compat_ulong_t shm_dtime;
	compat_ulong_t shm_dtime_high;
	compat_ulong_t shm_ctime;
	compat_ulong_t shm_ctime_high;
	compat_pid_t shm_cpid;
	compat_pid_t shm_lpid;
	compat_ulong_t shm_nattch;
	compat_ulong_t __unused4;
	compat_ulong_t __unused5;
};

struct shmid_kernel {
	struct kern_ipc_perm shm_perm;
	struct file *shm_file;
	long unsigned int shm_nattch;
	long unsigned int shm_segsz;
	time64_t shm_atim;
	time64_t shm_dtim;
	time64_t shm_ctim;
	struct pid *shm_cprid;
	struct pid *shm_lprid;
	struct user_struct *mlock_user;
	struct task_struct *shm_creator;
	struct list_head shm_clist;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct shm_file_data {
	int id;
	struct ipc_namespace *ns;
	struct file *file;
	const struct vm_operations_struct *vm_ops;
};

struct compat_shmid_ds {
	struct compat_ipc_perm shm_perm;
	int shm_segsz;
	old_time32_t shm_atime;
	old_time32_t shm_dtime;
	old_time32_t shm_ctime;
	compat_ipc_pid_t shm_cpid;
	compat_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	compat_uptr_t shm_unused2;
	compat_uptr_t shm_unused3;
};

struct compat_shminfo64 {
	compat_ulong_t shmmax;
	compat_ulong_t shmmin;
	compat_ulong_t shmmni;
	compat_ulong_t shmseg;
	compat_ulong_t shmall;
	compat_ulong_t __unused1;
	compat_ulong_t __unused2;
	compat_ulong_t __unused3;
	compat_ulong_t __unused4;
};

struct compat_shm_info {
	compat_int_t used_ids;
	compat_ulong_t shm_tot;
	compat_ulong_t shm_rss;
	compat_ulong_t shm_swp;
	compat_ulong_t swap_attempts;
	compat_ulong_t swap_successes;
};

struct compat_ipc_kludge {
	compat_uptr_t msgp;
	compat_long_t msgtyp;
};

struct mqueue_fs_context {
	struct ipc_namespace *ipc_ns;
};

struct posix_msg_tree_node {
	struct rb_node rb_node;
	struct list_head msg_list;
	int priority;
};

struct ext_wait_queue {
	struct task_struct *task;
	struct list_head list;
	struct msg_msg *msg;
	int state;
};

struct mqueue_inode_info {
	spinlock_t lock;
	struct inode vfs_inode;
	wait_queue_head_t wait_q;
	struct rb_root msg_tree;
	struct rb_node *msg_tree_rightmost;
	struct posix_msg_tree_node *node_cache;
	struct mq_attr attr;
	struct sigevent notify;
	struct pid *notify_owner;
	u32 notify_self_exec_id;
	struct user_namespace *notify_user_ns;
	struct user_struct *user;
	struct sock *notify_sock;
	struct sk_buff *notify_cookie;
	struct ext_wait_queue e_wait_q[2];
	long unsigned int qsize;
};

struct compat_mq_attr {
	compat_long_t mq_flags;
	compat_long_t mq_maxmsg;
	compat_long_t mq_msgsize;
	compat_long_t mq_curmsgs;
	compat_long_t __reserved[4];
};

struct key_user {
	struct rb_node node;
	struct mutex cons_lock;
	spinlock_t lock;
	refcount_t usage;
	atomic_t nkeys;
	atomic_t nikeys;
	kuid_t uid;
	int qnkeys;
	int qnbytes;
};

struct assoc_array_edit;

struct assoc_array_ops {
	long unsigned int (*get_key_chunk)(const void *, int);
	long unsigned int (*get_object_key_chunk)(const void *, int);
	bool (*compare_object)(const void *, const void *);
	int (*diff_objects)(const void *, const void *);
	void (*free_object)(void *);
};

struct assoc_array_node {
	struct assoc_array_ptr *back_pointer;
	u8 parent_slot;
	struct assoc_array_ptr *slots[16];
	long unsigned int nr_leaves_on_branch;
};

struct assoc_array_shortcut {
	struct assoc_array_ptr *back_pointer;
	int parent_slot;
	int skip_to_level;
	struct assoc_array_ptr *next_node;
	long unsigned int index_key[0];
};

struct assoc_array_edit {
	struct callback_head rcu;
	struct assoc_array *array;
	const struct assoc_array_ops *ops;
	const struct assoc_array_ops *ops_for_excised_subtree;
	struct assoc_array_ptr *leaf;
	struct assoc_array_ptr **leaf_p;
	struct assoc_array_ptr *dead_leaf;
	struct assoc_array_ptr *new_meta[3];
	struct assoc_array_ptr *excised_meta[1];
	struct assoc_array_ptr *excised_subtree;
	struct assoc_array_ptr **set_backpointers[16];
	struct assoc_array_ptr *set_backpointers_to;
	struct assoc_array_node *adjust_count_on;
	long int adjust_count_by;
	struct {
		struct assoc_array_ptr **ptr;
		struct assoc_array_ptr *to;
	} set[2];
	struct {
		u8 *p;
		u8 to;
	} set_parent_slot[1];
	u8 segment_cache[17];
};

struct keyring_search_context {
	struct keyring_index_key index_key;
	const struct cred *cred;
	struct key_match_data match_data;
	unsigned int flags;
	int (*iterator)(const void *, void *);
	int skipped_ret;
	bool possessed;
	key_ref_t result;
	time64_t now;
};

struct keyring_read_iterator_context {
	size_t buflen;
	size_t count;
	key_serial_t *buffer;
};

struct keyctl_dh_params {
	union {
		__s32 private;
		__s32 priv;
	};
	__s32 prime;
	__s32 base;
};

struct keyctl_kdf_params {
	char *hashname;
	char *otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct keyctl_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
	__u32 __spare[10];
};

struct keyctl_pkey_params {
	__s32 key_id;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	__u32 __spare[7];
};

struct request_key_auth {
	struct callback_head rcu;
	struct key *target_key;
	struct key *dest_keyring;
	const struct cred *cred;
	void *callout_info;
	size_t callout_len;
	pid_t pid;
	char op[8];
};

enum {
	Opt_err___9 = 0,
	Opt_enc = 1,
	Opt_hash = 2,
};

enum hash_algo {
	HASH_ALGO_MD4 = 0,
	HASH_ALGO_MD5 = 1,
	HASH_ALGO_SHA1 = 2,
	HASH_ALGO_RIPE_MD_160 = 3,
	HASH_ALGO_SHA256 = 4,
	HASH_ALGO_SHA384 = 5,
	HASH_ALGO_SHA512 = 6,
	HASH_ALGO_SHA224 = 7,
	HASH_ALGO_RIPE_MD_128 = 8,
	HASH_ALGO_RIPE_MD_256 = 9,
	HASH_ALGO_RIPE_MD_320 = 10,
	HASH_ALGO_WP_256 = 11,
	HASH_ALGO_WP_384 = 12,
	HASH_ALGO_WP_512 = 13,
	HASH_ALGO_TGR_128 = 14,
	HASH_ALGO_TGR_160 = 15,
	HASH_ALGO_TGR_192 = 16,
	HASH_ALGO_SM3_256 = 17,
	HASH_ALGO_STREEBOG_256 = 18,
	HASH_ALGO_STREEBOG_512 = 19,
	HASH_ALGO__LAST = 20,
};

enum tpm_duration {
	TPM_SHORT = 0,
	TPM_MEDIUM = 1,
	TPM_LONG = 2,
	TPM_LONG_LONG = 3,
	TPM_UNDEFINED = 4,
	TPM_NUM_DURATIONS = 4,
};

struct encrypted_key_payload {
	struct callback_head rcu;
	char *format;
	char *master_desc;
	char *datalen;
	u8 *iv;
	u8 *encrypted_data;
	short unsigned int datablob_len;
	short unsigned int decrypted_datalen;
	short unsigned int payload_datalen;
	short unsigned int encrypted_key_format;
	u8 *decrypted_data;
	u8 payload_data[0];
};

struct ecryptfs_session_key {
	u32 flags;
	u32 encrypted_key_size;
	u32 decrypted_key_size;
	u8 encrypted_key[512];
	u8 decrypted_key[64];
};

struct ecryptfs_password {
	u32 password_bytes;
	s32 hash_algo;
	u32 hash_iterations;
	u32 session_key_encryption_key_bytes;
	u32 flags;
	u8 session_key_encryption_key[64];
	u8 signature[17];
	u8 salt[8];
};

struct ecryptfs_private_key {
	u32 key_size;
	u32 data_len;
	u8 signature[17];
	char pki_type[17];
	u8 data[0];
};

struct ecryptfs_auth_tok {
	u16 version;
	u16 token_type;
	u32 flags;
	struct ecryptfs_session_key session_key;
	u8 reserved[32];
	union {
		struct ecryptfs_password password;
		struct ecryptfs_private_key private_key;
	} token;
};

enum {
	Opt_new = 0,
	Opt_load = 1,
	Opt_update = 2,
	Opt_err___10 = 3,
};

enum {
	Opt_default = 0,
	Opt_ecryptfs = 1,
	Opt_enc32 = 2,
	Opt_error = 3,
};

enum derived_key_type {
	ENC_KEY = 0,
	AUTH_KEY = 1,
};

enum ecryptfs_token_types {
	ECRYPTFS_PASSWORD = 0,
	ECRYPTFS_PRIVATE_KEY = 1,
};

struct vfs_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
};

struct vfs_ns_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
	__le32 rootid;
};

struct fs_parameter;

struct sctp_endpoint;

union security_list_options {
	int (*binder_set_context_mgr)(struct task_struct *);
	int (*binder_transaction)(struct task_struct *, struct task_struct *);
	int (*binder_transfer_binder)(struct task_struct *, struct task_struct *);
	int (*binder_transfer_file)(struct task_struct *, struct task_struct *, struct file *);
	int (*ptrace_access_check)(struct task_struct *, unsigned int);
	int (*ptrace_traceme)(struct task_struct *);
	int (*capget)(struct task_struct *, kernel_cap_t *, kernel_cap_t *, kernel_cap_t *);
	int (*capset)(struct cred *, const struct cred *, const kernel_cap_t *, const kernel_cap_t *, const kernel_cap_t *);
	int (*capable)(const struct cred *, struct user_namespace *, int, unsigned int);
	int (*quotactl)(int, int, int, struct super_block *);
	int (*quota_on)(struct dentry *);
	int (*syslog)(int);
	int (*settime)(const struct timespec64 *, const struct timezone *);
	int (*vm_enough_memory)(struct mm_struct *, long int);
	int (*bprm_set_creds)(struct linux_binprm *);
	int (*bprm_check_security)(struct linux_binprm *);
	void (*bprm_committing_creds)(struct linux_binprm *);
	void (*bprm_committed_creds)(struct linux_binprm *);
	int (*fs_context_dup)(struct fs_context *, struct fs_context *);
	int (*fs_context_parse_param)(struct fs_context *, struct fs_parameter *);
	int (*sb_alloc_security)(struct super_block *);
	void (*sb_free_security)(struct super_block *);
	void (*sb_free_mnt_opts)(void *);
	int (*sb_eat_lsm_opts)(char *, void **);
	int (*sb_remount)(struct super_block *, void *);
	int (*sb_kern_mount)(struct super_block *);
	int (*sb_show_options)(struct seq_file *, struct super_block *);
	int (*sb_statfs)(struct dentry *);
	int (*sb_mount)(const char *, const struct path *, const char *, long unsigned int, void *);
	int (*sb_umount)(struct vfsmount *, int);
	int (*sb_pivotroot)(const struct path *, const struct path *);
	int (*sb_set_mnt_opts)(struct super_block *, void *, long unsigned int, long unsigned int *);
	int (*sb_clone_mnt_opts)(const struct super_block *, struct super_block *, long unsigned int, long unsigned int *);
	int (*sb_add_mnt_opt)(const char *, const char *, int, void **);
	int (*move_mount)(const struct path *, const struct path *);
	int (*dentry_init_security)(struct dentry *, int, const struct qstr *, void **, u32 *);
	int (*dentry_create_files_as)(struct dentry *, int, struct qstr *, const struct cred *, struct cred *);
	int (*path_unlink)(const struct path *, struct dentry *);
	int (*path_mkdir)(const struct path *, struct dentry *, umode_t);
	int (*path_rmdir)(const struct path *, struct dentry *);
	int (*path_mknod)(const struct path *, struct dentry *, umode_t, unsigned int);
	int (*path_truncate)(const struct path *);
	int (*path_symlink)(const struct path *, struct dentry *, const char *);
	int (*path_link)(struct dentry *, const struct path *, struct dentry *);
	int (*path_rename)(const struct path *, struct dentry *, const struct path *, struct dentry *);
	int (*path_chmod)(const struct path *, umode_t);
	int (*path_chown)(const struct path *, kuid_t, kgid_t);
	int (*path_chroot)(const struct path *);
	int (*path_notify)(const struct path *, u64, unsigned int);
	int (*inode_alloc_security)(struct inode *);
	void (*inode_free_security)(struct inode *);
	int (*inode_init_security)(struct inode *, struct inode *, const struct qstr *, const char **, void **, size_t *);
	int (*inode_create)(struct inode *, struct dentry *, umode_t);
	int (*inode_link)(struct dentry *, struct inode *, struct dentry *);
	int (*inode_unlink)(struct inode *, struct dentry *);
	int (*inode_symlink)(struct inode *, struct dentry *, const char *);
	int (*inode_mkdir)(struct inode *, struct dentry *, umode_t);
	int (*inode_rmdir)(struct inode *, struct dentry *);
	int (*inode_mknod)(struct inode *, struct dentry *, umode_t, dev_t);
	int (*inode_rename)(struct inode *, struct dentry *, struct inode *, struct dentry *);
	int (*inode_readlink)(struct dentry *);
	int (*inode_follow_link)(struct dentry *, struct inode *, bool);
	int (*inode_permission)(struct inode *, int);
	int (*inode_setattr)(struct dentry *, struct iattr *);
	int (*inode_getattr)(const struct path *);
	int (*inode_setxattr)(struct dentry *, const char *, const void *, size_t, int);
	void (*inode_post_setxattr)(struct dentry *, const char *, const void *, size_t, int);
	int (*inode_getxattr)(struct dentry *, const char *);
	int (*inode_listxattr)(struct dentry *);
	int (*inode_removexattr)(struct dentry *, const char *);
	int (*inode_need_killpriv)(struct dentry *);
	int (*inode_killpriv)(struct dentry *);
	int (*inode_getsecurity)(struct inode *, const char *, void **, bool);
	int (*inode_setsecurity)(struct inode *, const char *, const void *, size_t, int);
	int (*inode_listsecurity)(struct inode *, char *, size_t);
	void (*inode_getsecid)(struct inode *, u32 *);
	int (*inode_copy_up)(struct dentry *, struct cred **);
	int (*inode_copy_up_xattr)(const char *);
	int (*kernfs_init_security)(struct kernfs_node *, struct kernfs_node *);
	int (*file_permission)(struct file *, int);
	int (*file_alloc_security)(struct file *);
	void (*file_free_security)(struct file *);
	int (*file_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap_addr)(long unsigned int);
	int (*mmap_file)(struct file *, long unsigned int, long unsigned int, long unsigned int);
	int (*file_mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int);
	int (*file_lock)(struct file *, unsigned int);
	int (*file_fcntl)(struct file *, unsigned int, long unsigned int);
	void (*file_set_fowner)(struct file *);
	int (*file_send_sigiotask)(struct task_struct *, struct fown_struct *, int);
	int (*file_receive)(struct file *);
	int (*file_open)(struct file *);
	int (*task_alloc)(struct task_struct *, long unsigned int);
	void (*task_free)(struct task_struct *);
	int (*cred_alloc_blank)(struct cred *, gfp_t);
	void (*cred_free)(struct cred *);
	int (*cred_prepare)(struct cred *, const struct cred *, gfp_t);
	void (*cred_transfer)(struct cred *, const struct cred *);
	void (*cred_getsecid)(const struct cred *, u32 *);
	int (*kernel_act_as)(struct cred *, u32);
	int (*kernel_create_files_as)(struct cred *, struct inode *);
	int (*kernel_module_request)(char *);
	int (*kernel_load_data)(enum kernel_load_data_id);
	int (*kernel_read_file)(struct file *, enum kernel_read_file_id);
	int (*kernel_post_read_file)(struct file *, char *, loff_t, enum kernel_read_file_id);
	int (*task_fix_setuid)(struct cred *, const struct cred *, int);
	int (*task_setpgid)(struct task_struct *, pid_t);
	int (*task_getpgid)(struct task_struct *);
	int (*task_getsid)(struct task_struct *);
	void (*task_getsecid)(struct task_struct *, u32 *);
	int (*task_setnice)(struct task_struct *, int);
	int (*task_setioprio)(struct task_struct *, int);
	int (*task_getioprio)(struct task_struct *);
	int (*task_prlimit)(const struct cred *, const struct cred *, unsigned int);
	int (*task_setrlimit)(struct task_struct *, unsigned int, struct rlimit *);
	int (*task_setscheduler)(struct task_struct *);
	int (*task_getscheduler)(struct task_struct *);
	int (*task_movememory)(struct task_struct *);
	int (*task_kill)(struct task_struct *, struct kernel_siginfo *, int, const struct cred *);
	int (*task_prctl)(int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	void (*task_to_inode)(struct task_struct *, struct inode *);
	int (*ipc_permission)(struct kern_ipc_perm *, short int);
	void (*ipc_getsecid)(struct kern_ipc_perm *, u32 *);
	int (*msg_msg_alloc_security)(struct msg_msg *);
	void (*msg_msg_free_security)(struct msg_msg *);
	int (*msg_queue_alloc_security)(struct kern_ipc_perm *);
	void (*msg_queue_free_security)(struct kern_ipc_perm *);
	int (*msg_queue_associate)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgctl)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgsnd)(struct kern_ipc_perm *, struct msg_msg *, int);
	int (*msg_queue_msgrcv)(struct kern_ipc_perm *, struct msg_msg *, struct task_struct *, long int, int);
	int (*shm_alloc_security)(struct kern_ipc_perm *);
	void (*shm_free_security)(struct kern_ipc_perm *);
	int (*shm_associate)(struct kern_ipc_perm *, int);
	int (*shm_shmctl)(struct kern_ipc_perm *, int);
	int (*shm_shmat)(struct kern_ipc_perm *, char *, int);
	int (*sem_alloc_security)(struct kern_ipc_perm *);
	void (*sem_free_security)(struct kern_ipc_perm *);
	int (*sem_associate)(struct kern_ipc_perm *, int);
	int (*sem_semctl)(struct kern_ipc_perm *, int);
	int (*sem_semop)(struct kern_ipc_perm *, struct sembuf *, unsigned int, int);
	int (*netlink_send)(struct sock *, struct sk_buff *);
	void (*d_instantiate)(struct dentry *, struct inode *);
	int (*getprocattr)(struct task_struct *, char *, char **);
	int (*setprocattr)(const char *, void *, size_t);
	int (*ismaclabel)(const char *);
	int (*secid_to_secctx)(u32, char **, u32 *);
	int (*secctx_to_secid)(const char *, u32, u32 *);
	void (*release_secctx)(char *, u32);
	void (*inode_invalidate_secctx)(struct inode *);
	int (*inode_notifysecctx)(struct inode *, void *, u32);
	int (*inode_setsecctx)(struct dentry *, void *, u32);
	int (*inode_getsecctx)(struct inode *, void **, u32 *);
	int (*unix_stream_connect)(struct sock *, struct sock *, struct sock *);
	int (*unix_may_send)(struct socket *, struct socket *);
	int (*socket_create)(int, int, int, int);
	int (*socket_post_create)(struct socket *, int, int, int, int);
	int (*socket_socketpair)(struct socket *, struct socket *);
	int (*socket_bind)(struct socket *, struct sockaddr *, int);
	int (*socket_connect)(struct socket *, struct sockaddr *, int);
	int (*socket_listen)(struct socket *, int);
	int (*socket_accept)(struct socket *, struct socket *);
	int (*socket_sendmsg)(struct socket *, struct msghdr *, int);
	int (*socket_recvmsg)(struct socket *, struct msghdr *, int, int);
	int (*socket_getsockname)(struct socket *);
	int (*socket_getpeername)(struct socket *);
	int (*socket_getsockopt)(struct socket *, int, int);
	int (*socket_setsockopt)(struct socket *, int, int);
	int (*socket_shutdown)(struct socket *, int);
	int (*socket_sock_rcv_skb)(struct sock *, struct sk_buff *);
	int (*socket_getpeersec_stream)(struct socket *, char *, int *, unsigned int);
	int (*socket_getpeersec_dgram)(struct socket *, struct sk_buff *, u32 *);
	int (*sk_alloc_security)(struct sock *, int, gfp_t);
	void (*sk_free_security)(struct sock *);
	void (*sk_clone_security)(const struct sock *, struct sock *);
	void (*sk_getsecid)(struct sock *, u32 *);
	void (*sock_graft)(struct sock *, struct socket *);
	int (*inet_conn_request)(struct sock *, struct sk_buff *, struct request_sock *);
	void (*inet_csk_clone)(struct sock *, const struct request_sock *);
	void (*inet_conn_established)(struct sock *, struct sk_buff *);
	int (*secmark_relabel_packet)(u32);
	void (*secmark_refcount_inc)();
	void (*secmark_refcount_dec)();
	void (*req_classify_flow)(const struct request_sock *, struct flowi *);
	int (*tun_dev_alloc_security)(void **);
	void (*tun_dev_free_security)(void *);
	int (*tun_dev_create)();
	int (*tun_dev_attach_queue)(void *);
	int (*tun_dev_attach)(struct sock *, void *);
	int (*tun_dev_open)(void *);
	int (*sctp_assoc_request)(struct sctp_endpoint *, struct sk_buff *);
	int (*sctp_bind_connect)(struct sock *, int, struct sockaddr *, int);
	void (*sctp_sk_clone)(struct sctp_endpoint *, struct sock *, struct sock *);
	int (*key_alloc)(struct key *, const struct cred *, long unsigned int);
	void (*key_free)(struct key *);
	int (*key_permission)(key_ref_t, const struct cred *, unsigned int);
	int (*key_getsecurity)(struct key *, char **);
	int (*audit_rule_init)(u32, u32, char *, void **);
	int (*audit_rule_known)(struct audit_krule *);
	int (*audit_rule_match)(u32, u32, u32, void *);
	void (*audit_rule_free)(void *);
	int (*bpf)(int, union bpf_attr *, unsigned int);
	int (*bpf_map)(struct bpf_map *, fmode_t);
	int (*bpf_prog)(struct bpf_prog *);
	int (*bpf_map_alloc_security)(struct bpf_map *);
	void (*bpf_map_free_security)(struct bpf_map *);
	int (*bpf_prog_alloc_security)(struct bpf_prog_aux *);
	void (*bpf_prog_free_security)(struct bpf_prog_aux *);
	int (*locked_down)(enum lockdown_reason);
};

struct security_hook_heads {
	struct hlist_head binder_set_context_mgr;
	struct hlist_head binder_transaction;
	struct hlist_head binder_transfer_binder;
	struct hlist_head binder_transfer_file;
	struct hlist_head ptrace_access_check;
	struct hlist_head ptrace_traceme;
	struct hlist_head capget;
	struct hlist_head capset;
	struct hlist_head capable;
	struct hlist_head quotactl;
	struct hlist_head quota_on;
	struct hlist_head syslog;
	struct hlist_head settime;
	struct hlist_head vm_enough_memory;
	struct hlist_head bprm_set_creds;
	struct hlist_head bprm_check_security;
	struct hlist_head bprm_committing_creds;
	struct hlist_head bprm_committed_creds;
	struct hlist_head fs_context_dup;
	struct hlist_head fs_context_parse_param;
	struct hlist_head sb_alloc_security;
	struct hlist_head sb_free_security;
	struct hlist_head sb_free_mnt_opts;
	struct hlist_head sb_eat_lsm_opts;
	struct hlist_head sb_remount;
	struct hlist_head sb_kern_mount;
	struct hlist_head sb_show_options;
	struct hlist_head sb_statfs;
	struct hlist_head sb_mount;
	struct hlist_head sb_umount;
	struct hlist_head sb_pivotroot;
	struct hlist_head sb_set_mnt_opts;
	struct hlist_head sb_clone_mnt_opts;
	struct hlist_head sb_add_mnt_opt;
	struct hlist_head move_mount;
	struct hlist_head dentry_init_security;
	struct hlist_head dentry_create_files_as;
	struct hlist_head path_unlink;
	struct hlist_head path_mkdir;
	struct hlist_head path_rmdir;
	struct hlist_head path_mknod;
	struct hlist_head path_truncate;
	struct hlist_head path_symlink;
	struct hlist_head path_link;
	struct hlist_head path_rename;
	struct hlist_head path_chmod;
	struct hlist_head path_chown;
	struct hlist_head path_chroot;
	struct hlist_head path_notify;
	struct hlist_head inode_alloc_security;
	struct hlist_head inode_free_security;
	struct hlist_head inode_init_security;
	struct hlist_head inode_create;
	struct hlist_head inode_link;
	struct hlist_head inode_unlink;
	struct hlist_head inode_symlink;
	struct hlist_head inode_mkdir;
	struct hlist_head inode_rmdir;
	struct hlist_head inode_mknod;
	struct hlist_head inode_rename;
	struct hlist_head inode_readlink;
	struct hlist_head inode_follow_link;
	struct hlist_head inode_permission;
	struct hlist_head inode_setattr;
	struct hlist_head inode_getattr;
	struct hlist_head inode_setxattr;
	struct hlist_head inode_post_setxattr;
	struct hlist_head inode_getxattr;
	struct hlist_head inode_listxattr;
	struct hlist_head inode_removexattr;
	struct hlist_head inode_need_killpriv;
	struct hlist_head inode_killpriv;
	struct hlist_head inode_getsecurity;
	struct hlist_head inode_setsecurity;
	struct hlist_head inode_listsecurity;
	struct hlist_head inode_getsecid;
	struct hlist_head inode_copy_up;
	struct hlist_head inode_copy_up_xattr;
	struct hlist_head kernfs_init_security;
	struct hlist_head file_permission;
	struct hlist_head file_alloc_security;
	struct hlist_head file_free_security;
	struct hlist_head file_ioctl;
	struct hlist_head mmap_addr;
	struct hlist_head mmap_file;
	struct hlist_head file_mprotect;
	struct hlist_head file_lock;
	struct hlist_head file_fcntl;
	struct hlist_head file_set_fowner;
	struct hlist_head file_send_sigiotask;
	struct hlist_head file_receive;
	struct hlist_head file_open;
	struct hlist_head task_alloc;
	struct hlist_head task_free;
	struct hlist_head cred_alloc_blank;
	struct hlist_head cred_free;
	struct hlist_head cred_prepare;
	struct hlist_head cred_transfer;
	struct hlist_head cred_getsecid;
	struct hlist_head kernel_act_as;
	struct hlist_head kernel_create_files_as;
	struct hlist_head kernel_module_request;
	struct hlist_head kernel_load_data;
	struct hlist_head kernel_read_file;
	struct hlist_head kernel_post_read_file;
	struct hlist_head task_fix_setuid;
	struct hlist_head task_setpgid;
	struct hlist_head task_getpgid;
	struct hlist_head task_getsid;
	struct hlist_head task_getsecid;
	struct hlist_head task_setnice;
	struct hlist_head task_setioprio;
	struct hlist_head task_getioprio;
	struct hlist_head task_prlimit;
	struct hlist_head task_setrlimit;
	struct hlist_head task_setscheduler;
	struct hlist_head task_getscheduler;
	struct hlist_head task_movememory;
	struct hlist_head task_kill;
	struct hlist_head task_prctl;
	struct hlist_head task_to_inode;
	struct hlist_head ipc_permission;
	struct hlist_head ipc_getsecid;
	struct hlist_head msg_msg_alloc_security;
	struct hlist_head msg_msg_free_security;
	struct hlist_head msg_queue_alloc_security;
	struct hlist_head msg_queue_free_security;
	struct hlist_head msg_queue_associate;
	struct hlist_head msg_queue_msgctl;
	struct hlist_head msg_queue_msgsnd;
	struct hlist_head msg_queue_msgrcv;
	struct hlist_head shm_alloc_security;
	struct hlist_head shm_free_security;
	struct hlist_head shm_associate;
	struct hlist_head shm_shmctl;
	struct hlist_head shm_shmat;
	struct hlist_head sem_alloc_security;
	struct hlist_head sem_free_security;
	struct hlist_head sem_associate;
	struct hlist_head sem_semctl;
	struct hlist_head sem_semop;
	struct hlist_head netlink_send;
	struct hlist_head d_instantiate;
	struct hlist_head getprocattr;
	struct hlist_head setprocattr;
	struct hlist_head ismaclabel;
	struct hlist_head secid_to_secctx;
	struct hlist_head secctx_to_secid;
	struct hlist_head release_secctx;
	struct hlist_head inode_invalidate_secctx;
	struct hlist_head inode_notifysecctx;
	struct hlist_head inode_setsecctx;
	struct hlist_head inode_getsecctx;
	struct hlist_head unix_stream_connect;
	struct hlist_head unix_may_send;
	struct hlist_head socket_create;
	struct hlist_head socket_post_create;
	struct hlist_head socket_socketpair;
	struct hlist_head socket_bind;
	struct hlist_head socket_connect;
	struct hlist_head socket_listen;
	struct hlist_head socket_accept;
	struct hlist_head socket_sendmsg;
	struct hlist_head socket_recvmsg;
	struct hlist_head socket_getsockname;
	struct hlist_head socket_getpeername;
	struct hlist_head socket_getsockopt;
	struct hlist_head socket_setsockopt;
	struct hlist_head socket_shutdown;
	struct hlist_head socket_sock_rcv_skb;
	struct hlist_head socket_getpeersec_stream;
	struct hlist_head socket_getpeersec_dgram;
	struct hlist_head sk_alloc_security;
	struct hlist_head sk_free_security;
	struct hlist_head sk_clone_security;
	struct hlist_head sk_getsecid;
	struct hlist_head sock_graft;
	struct hlist_head inet_conn_request;
	struct hlist_head inet_csk_clone;
	struct hlist_head inet_conn_established;
	struct hlist_head secmark_relabel_packet;
	struct hlist_head secmark_refcount_inc;
	struct hlist_head secmark_refcount_dec;
	struct hlist_head req_classify_flow;
	struct hlist_head tun_dev_alloc_security;
	struct hlist_head tun_dev_free_security;
	struct hlist_head tun_dev_create;
	struct hlist_head tun_dev_attach_queue;
	struct hlist_head tun_dev_attach;
	struct hlist_head tun_dev_open;
	struct hlist_head sctp_assoc_request;
	struct hlist_head sctp_bind_connect;
	struct hlist_head sctp_sk_clone;
	struct hlist_head key_alloc;
	struct hlist_head key_free;
	struct hlist_head key_permission;
	struct hlist_head key_getsecurity;
	struct hlist_head audit_rule_init;
	struct hlist_head audit_rule_known;
	struct hlist_head audit_rule_match;
	struct hlist_head audit_rule_free;
	struct hlist_head bpf;
	struct hlist_head bpf_map;
	struct hlist_head bpf_prog;
	struct hlist_head bpf_map_alloc_security;
	struct hlist_head bpf_map_free_security;
	struct hlist_head bpf_prog_alloc_security;
	struct hlist_head bpf_prog_free_security;
	struct hlist_head locked_down;
};

struct security_hook_list {
	struct hlist_node list;
	struct hlist_head *head;
	union security_list_options hook;
	char *lsm;
};

struct lsm_blob_sizes {
	int lbs_cred;
	int lbs_file;
	int lbs_inode;
	int lbs_ipc;
	int lbs_msg_msg;
	int lbs_task;
};

enum lsm_order {
	LSM_ORDER_FIRST = 4294967295,
	LSM_ORDER_MUTABLE = 0,
};

struct lsm_info {
	const char *name;
	enum lsm_order order;
	long unsigned int flags;
	int *enabled;
	int (*init)();
	struct lsm_blob_sizes *blobs;
};

enum lsm_event {
	LSM_POLICY_CHANGE = 0,
};

typedef __u16 __sum16;

struct tcphdr {
	__be16 source;
	__be16 dest;
	__be32 seq;
	__be32 ack_seq;
	__u16 res1: 4;
	__u16 doff: 4;
	__u16 fin: 1;
	__u16 syn: 1;
	__u16 rst: 1;
	__u16 psh: 1;
	__u16 ack: 1;
	__u16 urg: 1;
	__u16 ece: 1;
	__u16 cwr: 1;
	__be16 window;
	__sum16 check;
	__be16 urg_ptr;
};

struct sockaddr_un {
	__kernel_sa_family_t sun_family;
	char sun_path[108];
};

struct unix_address {
	refcount_t refcnt;
	int len;
	unsigned int hash;
	struct sockaddr_un name[0];
};

struct unix_sock {
	struct sock sk;
	struct unix_address *addr;
	struct path path;
	struct mutex iolock;
	struct mutex bindlock;
	struct sock *peer;
	struct list_head link;
	atomic_long_t inflight;
	spinlock_t lock;
	long unsigned int gc_flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq peer_wq;
	wait_queue_entry_t peer_wake;
	long: 64;
	long: 64;
	long: 64;
};

struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	int ipi6_ifindex;
};

struct ipv6_rt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
};

struct ipv6_opt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
};

struct ipv6hdr {
	__u8 priority: 4;
	__u8 version: 4;
	__u8 flow_lbl[3];
	__be16 payload_len;
	__u8 nexthdr;
	__u8 hop_limit;
	struct in6_addr saddr;
	struct in6_addr daddr;
};

struct ip_options {
	__be32 faddr;
	__be32 nexthop;
	unsigned char optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_strictroute: 1;
	unsigned char srr_is_hit: 1;
	unsigned char is_changed: 1;
	unsigned char rr_needaddr: 1;
	unsigned char ts_needtime: 1;
	unsigned char ts_needaddr: 1;
	unsigned char router_alert;
	unsigned char cipso;
	unsigned char __pad2;
	unsigned char __data[0];
};

struct ip_options_rcu {
	struct callback_head rcu;
	struct ip_options opt;
};

struct ipv6_txoptions {
	refcount_t refcnt;
	int tot_len;
	__u16 opt_flen;
	__u16 opt_nflen;
	struct ipv6_opt_hdr *hopopt;
	struct ipv6_opt_hdr *dst0opt;
	struct ipv6_rt_hdr *srcrt;
	struct ipv6_opt_hdr *dst1opt;
	struct callback_head rcu;
};

struct inet_cork {
	unsigned int flags;
	__be32 addr;
	struct ip_options *opt;
	unsigned int fragsize;
	int length;
	struct dst_entry *dst;
	u8 tx_flags;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
	u64 transmit_time;
	u32 mark;
};

struct inet_cork_full {
	struct inet_cork base;
	struct flowi fl;
};

struct ipv6_pinfo;

struct ip_mc_socklist;

struct inet_sock {
	struct sock sk;
	struct ipv6_pinfo *pinet6;
	__be32 inet_saddr;
	__s16 uc_ttl;
	__u16 cmsg_flags;
	__be16 inet_sport;
	__u16 inet_id;
	struct ip_options_rcu *inet_opt;
	int rx_dst_ifindex;
	__u8 tos;
	__u8 min_ttl;
	__u8 mc_ttl;
	__u8 pmtudisc;
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 defer_connect: 1;
	__u8 rcv_tos;
	__u8 convert_csum;
	int uc_index;
	int mc_index;
	__be32 mc_addr;
	struct ip_mc_socklist *mc_list;
	struct inet_cork_full cork;
};

struct inet6_cork {
	struct ipv6_txoptions *opt;
	u8 hop_limit;
	u8 tclass;
};

struct ipv6_mc_socklist;

struct ipv6_ac_socklist;

struct ipv6_fl_socklist;

struct ipv6_pinfo {
	struct in6_addr saddr;
	struct in6_pktinfo sticky_pktinfo;
	const struct in6_addr *daddr_cache;
	__be32 flow_label;
	__u32 frag_size;
	__u16 __unused_1: 7;
	__s16 hop_limit: 9;
	__u16 mc_loop: 1;
	__u16 __unused_2: 6;
	__s16 mcast_hops: 9;
	int ucast_oif;
	int mcast_oif;
	union {
		struct {
			__u16 srcrt: 1;
			__u16 osrcrt: 1;
			__u16 rxinfo: 1;
			__u16 rxoinfo: 1;
			__u16 rxhlim: 1;
			__u16 rxohlim: 1;
			__u16 hopopts: 1;
			__u16 ohopopts: 1;
			__u16 dstopts: 1;
			__u16 odstopts: 1;
			__u16 rxflow: 1;
			__u16 rxtclass: 1;
			__u16 rxpmtu: 1;
			__u16 rxorigdstaddr: 1;
			__u16 recvfragsize: 1;
		} bits;
		__u16 all;
	} rxopt;
	__u16 recverr: 1;
	__u16 sndflow: 1;
	__u16 repflow: 1;
	__u16 pmtudisc: 3;
	__u16 padding: 1;
	__u16 srcprefs: 3;
	__u16 dontfrag: 1;
	__u16 autoflowlabel: 1;
	__u16 autoflowlabel_set: 1;
	__u16 mc_all: 1;
	__u16 rtalert_isolate: 1;
	__u8 min_hopcount;
	__u8 tclass;
	__be32 rcv_flowinfo;
	__u32 dst_cookie;
	__u32 rx_dst_cookie;
	struct ipv6_mc_socklist *ipv6_mc_list;
	struct ipv6_ac_socklist *ipv6_ac_list;
	struct ipv6_fl_socklist *ipv6_fl_list;
	struct ipv6_txoptions *opt;
	struct sk_buff *pktoptions;
	struct sk_buff *rxpmtu;
	struct inet6_cork cork;
};

struct udphdr {
	__be16 source;
	__be16 dest;
	__be16 len;
	__sum16 check;
};

struct ip6_sf_socklist;

struct ipv6_mc_socklist {
	struct in6_addr addr;
	int ifindex;
	unsigned int sfmode;
	struct ipv6_mc_socklist *next;
	rwlock_t sflock;
	struct ip6_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ipv6_ac_socklist {
	struct in6_addr acl_addr;
	int acl_ifindex;
	struct ipv6_ac_socklist *acl_next;
};

struct ip6_flowlabel;

struct ipv6_fl_socklist {
	struct ipv6_fl_socklist *next;
	struct ip6_flowlabel *fl;
	struct callback_head rcu;
};

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	__be32 saddr;
	__be32 daddr;
};

struct ip6_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct in6_addr sl_addr[0];
};

struct ip6_flowlabel {
	struct ip6_flowlabel *next;
	__be32 label;
	atomic_t users;
	struct in6_addr dst;
	struct ipv6_txoptions *opt;
	long unsigned int linger;
	struct callback_head rcu;
	u8 share;
	union {
		struct pid *pid;
		kuid_t uid;
	} owner;
	long unsigned int lastuse;
	long unsigned int expires;
	struct net *fl_net;
};

struct dccp_hdr {
	__be16 dccph_sport;
	__be16 dccph_dport;
	__u8 dccph_doff;
	__u8 dccph_cscov: 4;
	__u8 dccph_ccval: 4;
	__sum16 dccph_checksum;
	__u8 dccph_x: 1;
	__u8 dccph_type: 4;
	__u8 dccph_reserved: 3;
	__u8 dccph_seq2;
	__be16 dccph_seq;
};

struct sctphdr {
	__be16 source;
	__be16 dest;
	__be32 vtag;
	__le32 checksum;
};

struct lsm_network_audit {
	int netif;
	struct sock *sk;
	u16 family;
	__be16 dport;
	__be16 sport;
	union {
		struct {
			__be32 daddr;
			__be32 saddr;
		} v4;
		struct {
			struct in6_addr daddr;
			struct in6_addr saddr;
		} v6;
	} fam;
};

struct lsm_ioctlop_audit {
	struct path path;
	u16 cmd;
};

struct lsm_ibpkey_audit {
	u64 subnet_prefix;
	u16 pkey;
};

struct lsm_ibendport_audit {
	char dev_name[64];
	u8 port;
};

struct apparmor_audit_data;

struct common_audit_data {
	char type;
	union {
		struct path path;
		struct dentry *dentry;
		struct inode *inode;
		struct lsm_network_audit *net;
		int cap;
		int ipc_id;
		struct task_struct *tsk;
		struct {
			key_serial_t key;
			char *key_desc;
		} key_struct;
		char *kmod_name;
		struct lsm_ioctlop_audit *op;
		struct file *file;
		struct lsm_ibpkey_audit *ibpkey;
		struct lsm_ibendport_audit *ibendport;
	} u;
	union {
		struct apparmor_audit_data *apparmor_audit_data;
	};
};

enum audit_mode {
	AUDIT_NORMAL = 0,
	AUDIT_QUIET_DENIED = 1,
	AUDIT_QUIET = 2,
	AUDIT_NOQUIET = 3,
	AUDIT_ALL = 4,
};

enum aa_sfs_type {
	AA_SFS_TYPE_BOOLEAN = 0,
	AA_SFS_TYPE_STRING = 1,
	AA_SFS_TYPE_U64 = 2,
	AA_SFS_TYPE_FOPS = 3,
	AA_SFS_TYPE_DIR = 4,
};

struct aa_sfs_entry {
	const char *name;
	struct dentry *dentry;
	umode_t mode;
	enum aa_sfs_type v_type;
	union {
		bool boolean;
		char *string;
		long unsigned int u64;
		struct aa_sfs_entry *files;
	} v;
	const struct file_operations *file_ops;
};

enum aafs_ns_type {
	AAFS_NS_DIR = 0,
	AAFS_NS_PROFS = 1,
	AAFS_NS_NS = 2,
	AAFS_NS_RAW_DATA = 3,
	AAFS_NS_LOAD = 4,
	AAFS_NS_REPLACE = 5,
	AAFS_NS_REMOVE = 6,
	AAFS_NS_REVISION = 7,
	AAFS_NS_COUNT = 8,
	AAFS_NS_MAX_COUNT = 9,
	AAFS_NS_SIZE = 10,
	AAFS_NS_MAX_SIZE = 11,
	AAFS_NS_OWNER = 12,
	AAFS_NS_SIZEOF = 13,
};

enum aafs_prof_type {
	AAFS_PROF_DIR = 0,
	AAFS_PROF_PROFS = 1,
	AAFS_PROF_NAME = 2,
	AAFS_PROF_MODE = 3,
	AAFS_PROF_ATTACH = 4,
	AAFS_PROF_HASH = 5,
	AAFS_PROF_RAW_DATA = 6,
	AAFS_PROF_RAW_HASH = 7,
	AAFS_PROF_RAW_ABI = 8,
	AAFS_PROF_SIZEOF = 9,
};

enum ib_uverbs_write_cmds {
	IB_USER_VERBS_CMD_GET_CONTEXT = 0,
	IB_USER_VERBS_CMD_QUERY_DEVICE = 1,
	IB_USER_VERBS_CMD_QUERY_PORT = 2,
	IB_USER_VERBS_CMD_ALLOC_PD = 3,
	IB_USER_VERBS_CMD_DEALLOC_PD = 4,
	IB_USER_VERBS_CMD_CREATE_AH = 5,
	IB_USER_VERBS_CMD_MODIFY_AH = 6,
	IB_USER_VERBS_CMD_QUERY_AH = 7,
	IB_USER_VERBS_CMD_DESTROY_AH = 8,
	IB_USER_VERBS_CMD_REG_MR = 9,
	IB_USER_VERBS_CMD_REG_SMR = 10,
	IB_USER_VERBS_CMD_REREG_MR = 11,
	IB_USER_VERBS_CMD_QUERY_MR = 12,
	IB_USER_VERBS_CMD_DEREG_MR = 13,
	IB_USER_VERBS_CMD_ALLOC_MW = 14,
	IB_USER_VERBS_CMD_BIND_MW = 15,
	IB_USER_VERBS_CMD_DEALLOC_MW = 16,
	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17,
	IB_USER_VERBS_CMD_CREATE_CQ = 18,
	IB_USER_VERBS_CMD_RESIZE_CQ = 19,
	IB_USER_VERBS_CMD_DESTROY_CQ = 20,
	IB_USER_VERBS_CMD_POLL_CQ = 21,
	IB_USER_VERBS_CMD_PEEK_CQ = 22,
	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23,
	IB_USER_VERBS_CMD_CREATE_QP = 24,
	IB_USER_VERBS_CMD_QUERY_QP = 25,
	IB_USER_VERBS_CMD_MODIFY_QP = 26,
	IB_USER_VERBS_CMD_DESTROY_QP = 27,
	IB_USER_VERBS_CMD_POST_SEND = 28,
	IB_USER_VERBS_CMD_POST_RECV = 29,
	IB_USER_VERBS_CMD_ATTACH_MCAST = 30,
	IB_USER_VERBS_CMD_DETACH_MCAST = 31,
	IB_USER_VERBS_CMD_CREATE_SRQ = 32,
	IB_USER_VERBS_CMD_MODIFY_SRQ = 33,
	IB_USER_VERBS_CMD_QUERY_SRQ = 34,
	IB_USER_VERBS_CMD_DESTROY_SRQ = 35,
	IB_USER_VERBS_CMD_POST_SRQ_RECV = 36,
	IB_USER_VERBS_CMD_OPEN_XRCD = 37,
	IB_USER_VERBS_CMD_CLOSE_XRCD = 38,
	IB_USER_VERBS_CMD_CREATE_XSRQ = 39,
	IB_USER_VERBS_CMD_OPEN_QP = 40,
};

enum ib_uverbs_create_qp_mask {
	IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1,
};

enum ib_uverbs_wr_opcode {
	IB_UVERBS_WR_RDMA_WRITE = 0,
	IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_UVERBS_WR_SEND = 2,
	IB_UVERBS_WR_SEND_WITH_IMM = 3,
	IB_UVERBS_WR_RDMA_READ = 4,
	IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_UVERBS_WR_LOCAL_INV = 7,
	IB_UVERBS_WR_BIND_MW = 8,
	IB_UVERBS_WR_SEND_WITH_INV = 9,
	IB_UVERBS_WR_TSO = 10,
	IB_UVERBS_WR_RDMA_READ_WITH_INV = 11,
	IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
};

enum ib_uverbs_access_flags {
	IB_UVERBS_ACCESS_LOCAL_WRITE = 1,
	IB_UVERBS_ACCESS_REMOTE_WRITE = 2,
	IB_UVERBS_ACCESS_REMOTE_READ = 4,
	IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8,
	IB_UVERBS_ACCESS_MW_BIND = 16,
	IB_UVERBS_ACCESS_ZERO_BASED = 32,
	IB_UVERBS_ACCESS_ON_DEMAND = 64,
	IB_UVERBS_ACCESS_HUGETLB = 128,
};

struct table_header {
	u16 td_id;
	u16 td_flags;
	u32 td_hilen;
	u32 td_lolen;
	char td_data[0];
};

struct aa_dfa {
	struct kref count;
	u16 flags;
	struct table_header *tables[8];
};

struct aa_policy {
	const char *name;
	char *hname;
	struct list_head list;
	struct list_head profiles;
};

struct aa_labelset {
	rwlock_t lock;
	struct rb_root root;
};

enum label_flags {
	FLAG_HAT = 1,
	FLAG_UNCONFINED = 2,
	FLAG_NULL = 4,
	FLAG_IX_ON_NAME_ERROR = 8,
	FLAG_IMMUTIBLE = 16,
	FLAG_USER_DEFINED = 32,
	FLAG_NO_LIST_REF = 64,
	FLAG_NS_COUNT = 128,
	FLAG_IN_TREE = 256,
	FLAG_PROFILE = 512,
	FLAG_EXPLICIT = 1024,
	FLAG_STALE = 2048,
	FLAG_RENAMED = 4096,
	FLAG_REVOKED = 8192,
};

struct aa_label;

struct aa_proxy {
	struct kref count;
	struct aa_label *label;
};

struct aa_profile;

struct aa_label {
	struct kref count;
	struct rb_node node;
	struct callback_head rcu;
	struct aa_proxy *proxy;
	char *hname;
	long int flags;
	u32 secid;
	int size;
	struct aa_profile *vec[0];
};

struct label_it {
	int i;
	int j;
};

struct aa_policydb {
	struct aa_dfa *dfa;
	unsigned int start[17];
};

struct aa_domain {
	int size;
	char **table;
};

struct aa_file_rules {
	unsigned int start;
	struct aa_dfa *dfa;
	struct aa_domain trans;
};

struct aa_caps {
	kernel_cap_t allow;
	kernel_cap_t audit;
	kernel_cap_t denied;
	kernel_cap_t quiet;
	kernel_cap_t kill;
	kernel_cap_t extended;
};

struct aa_rlimit {
	unsigned int mask;
	struct rlimit limits[16];
};

struct aa_ns;

struct aa_secmark;

struct aa_loaddata;

struct aa_profile {
	struct aa_policy base;
	struct aa_profile *parent;
	struct aa_ns *ns;
	const char *rename;
	const char *attach;
	struct aa_dfa *xmatch;
	int xmatch_len;
	enum audit_mode audit;
	long int mode;
	u32 path_flags;
	const char *disconnected;
	int size;
	struct aa_policydb policy;
	struct aa_file_rules file;
	struct aa_caps caps;
	int xattr_count;
	char **xattrs;
	struct aa_rlimit rlimits;
	int secmark_count;
	struct aa_secmark *secmark;
	struct aa_loaddata *rawdata;
	unsigned char *hash;
	char *dirname;
	struct dentry *dents[9];
	struct rhashtable *data;
	struct aa_label label;
};

struct aa_perms {
	u32 allow;
	u32 audit;
	u32 deny;
	u32 quiet;
	u32 kill;
	u32 stop;
	u32 complain;
	u32 cond;
	u32 hide;
	u32 prompt;
	u16 xindex;
};

struct path_cond {
	kuid_t uid;
	umode_t mode;
};

struct aa_secmark {
	u8 audit;
	u8 deny;
	u32 secid;
	char *label;
};

enum profile_mode {
	APPARMOR_ENFORCE = 0,
	APPARMOR_COMPLAIN = 1,
	APPARMOR_KILL = 2,
	APPARMOR_UNCONFINED = 3,
};

struct aa_data {
	char *key;
	u32 size;
	char *data;
	struct rhash_head head;
};

struct aa_ns_acct {
	int max_size;
	int max_count;
	int size;
	int count;
};

struct aa_ns {
	struct aa_policy base;
	struct aa_ns *parent;
	struct mutex lock;
	struct aa_ns_acct acct;
	struct aa_profile *unconfined;
	struct list_head sub_ns;
	atomic_t uniq_null;
	long int uniq_id;
	int level;
	long int revision;
	wait_queue_head_t wait;
	struct aa_labelset labels;
	struct list_head rawdata_list;
	struct dentry *dents[13];
};

struct aa_loaddata {
	struct kref count;
	struct list_head list;
	struct work_struct work;
	struct dentry *dents[5];
	struct aa_ns *ns;
	char *name;
	size_t size;
	long int revision;
	int abi;
	unsigned char *hash;
	char *data;
};

enum {
	AAFS_LOADDATA_ABI = 0,
	AAFS_LOADDATA_REVISION = 1,
	AAFS_LOADDATA_HASH = 2,
	AAFS_LOADDATA_DATA = 3,
	AAFS_LOADDATA_DIR = 4,
	AAFS_LOADDATA_NDENTS = 5,
};

struct aa_revision {
	struct aa_ns *ns;
	long int last_read;
};

struct multi_transaction {
	struct kref count;
	ssize_t size;
	char data[0];
};

struct apparmor_audit_data {
	int error;
	int type;
	const char *op;
	struct aa_label *label;
	const char *name;
	const char *info;
	u32 request;
	u32 denied;
	union {
		struct {
			struct aa_label *peer;
			union {
				struct {
					const char *target;
					kuid_t ouid;
				} fs;
				struct {
					int rlim;
					long unsigned int max;
				} rlim;
				struct {
					int signal;
					int unmappedsig;
				};
				struct {
					int type;
					int protocol;
					struct sock *peer_sk;
					void *addr;
					int addrlen;
				} net;
			};
		};
		struct {
			struct aa_profile *profile;
			const char *ns;
			long int pos;
		} iface;
		struct {
			const char *src_name;
			const char *type;
			const char *trans;
			const char *data;
			long unsigned int flags;
		} mnt;
	};
};

enum audit_type {
	AUDIT_APPARMOR_AUDIT = 0,
	AUDIT_APPARMOR_ALLOWED = 1,
	AUDIT_APPARMOR_DENIED = 2,
	AUDIT_APPARMOR_HINT = 3,
	AUDIT_APPARMOR_STATUS = 4,
	AUDIT_APPARMOR_ERROR = 5,
	AUDIT_APPARMOR_KILL = 6,
	AUDIT_APPARMOR_AUTO = 7,
};

struct aa_audit_rule {
	struct aa_label *label;
};

struct audit_cache {
	struct aa_profile *profile;
	kernel_cap_t caps;
};

struct aa_task_ctx {
	struct aa_label *nnp;
	struct aa_label *onexec;
	struct aa_label *previous;
	u64 token;
};

struct counted_str {
	struct kref count;
	char name[0];
};

struct match_workbuf {
	unsigned int count;
	unsigned int pos;
	unsigned int len;
	unsigned int size;
	unsigned int history[8];
};

enum path_flags {
	PATH_IS_DIR = 1,
	PATH_CONNECT_PATH = 4,
	PATH_CHROOT_REL = 8,
	PATH_CHROOT_NSCONNECT = 16,
	PATH_DELEGATE_DELETED = 32768,
	PATH_MEDIATE_DELETED = 65536,
};

struct aa_buffers {
	char *buf[2];
};

struct aa_load_ent {
	struct list_head list;
	struct aa_profile *new;
	struct aa_profile *old;
	struct aa_profile *rename;
	const char *ns_name;
};

enum aa_code {
	AA_U8 = 0,
	AA_U16 = 1,
	AA_U32 = 2,
	AA_U64 = 3,
	AA_NAME = 4,
	AA_STRING = 5,
	AA_BLOB = 6,
	AA_STRUCT = 7,
	AA_STRUCTEND = 8,
	AA_LIST = 9,
	AA_LISTEND = 10,
	AA_ARRAY = 11,
	AA_ARRAYEND = 12,
};

struct aa_ext {
	void *start;
	void *end;
	void *pos;
	u32 version;
};

struct nf_hook_state;

typedef unsigned int nf_hookfn(void *, struct sk_buff *, const struct nf_hook_state *);

struct nf_hook_entry {
	nf_hookfn *hook;
	void *priv;
};

struct nf_hook_entries {
	u16 num_hook_entries;
	struct nf_hook_entry hooks[0];
};

struct nf_hook_state {
	unsigned int hook;
	u_int8_t pf;
	struct net_device *in;
	struct net_device *out;
	struct sock *sk;
	struct net *net;
	int (*okfn)(struct net *, struct sock *, struct sk_buff *);
};

struct nf_hook_ops {
	nf_hookfn *hook;
	struct net_device *dev;
	void *priv;
	u_int8_t pf;
	unsigned int hooknum;
	int priority;
};

enum nf_ip_hook_priorities {
	NF_IP_PRI_FIRST = 2147483648,
	NF_IP_PRI_RAW_BEFORE_DEFRAG = 4294966846,
	NF_IP_PRI_CONNTRACK_DEFRAG = 4294966896,
	NF_IP_PRI_RAW = 4294966996,
	NF_IP_PRI_SELINUX_FIRST = 4294967071,
	NF_IP_PRI_CONNTRACK = 4294967096,
	NF_IP_PRI_MANGLE = 4294967146,
	NF_IP_PRI_NAT_DST = 4294967196,
	NF_IP_PRI_FILTER = 0,
	NF_IP_PRI_SECURITY = 50,
	NF_IP_PRI_NAT_SRC = 100,
	NF_IP_PRI_SELINUX_LAST = 225,
	NF_IP_PRI_CONNTRACK_HELPER = 300,
	NF_IP_PRI_CONNTRACK_CONFIRM = 2147483647,
	NF_IP_PRI_LAST = 2147483647,
};

enum nf_ip6_hook_priorities {
	NF_IP6_PRI_FIRST = 2147483648,
	NF_IP6_PRI_RAW_BEFORE_DEFRAG = 4294966846,
	NF_IP6_PRI_CONNTRACK_DEFRAG = 4294966896,
	NF_IP6_PRI_RAW = 4294966996,
	NF_IP6_PRI_SELINUX_FIRST = 4294967071,
	NF_IP6_PRI_CONNTRACK = 4294967096,
	NF_IP6_PRI_MANGLE = 4294967146,
	NF_IP6_PRI_NAT_DST = 4294967196,
	NF_IP6_PRI_FILTER = 0,
	NF_IP6_PRI_SECURITY = 50,
	NF_IP6_PRI_NAT_SRC = 100,
	NF_IP6_PRI_SELINUX_LAST = 225,
	NF_IP6_PRI_CONNTRACK_HELPER = 300,
	NF_IP6_PRI_LAST = 2147483647,
};

struct aa_file_ctx {
	spinlock_t lock;
	struct aa_label *label;
	u32 allow;
};

struct aa_sk_ctx {
	struct aa_label *label;
	struct aa_label *peer;
};

struct tty_file_private {
	struct tty_struct *tty;
	struct file *file;
	struct list_head list;
};

enum devcg_behavior {
	DEVCG_DEFAULT_NONE = 0,
	DEVCG_DEFAULT_ALLOW = 1,
	DEVCG_DEFAULT_DENY = 2,
};

struct dev_exception_item {
	u32 major;
	u32 minor;
	short int type;
	short int access;
	struct list_head list;
	struct callback_head rcu;
};

struct dev_cgroup {
	struct cgroup_subsys_state css;
	struct list_head exceptions;
	enum devcg_behavior behavior;
};

enum {
	CRYPTO_MSG_ALG_REQUEST = 0,
	CRYPTO_MSG_ALG_REGISTER = 1,
	CRYPTO_MSG_ALG_LOADED = 2,
};

struct crypto_larval {
	struct crypto_alg alg;
	struct crypto_alg *adult;
	struct completion completion;
	u32 mask;
};

enum {
	CRYPTOA_UNSPEC = 0,
	CRYPTOA_ALG = 1,
	CRYPTOA_TYPE = 2,
	CRYPTOA_U32 = 3,
	__CRYPTOA_MAX = 4,
};

struct crypto_attr_alg {
	char name[128];
};

struct crypto_attr_type {
	u32 type;
	u32 mask;
};

struct crypto_attr_u32 {
	u32 num;
};

struct rtattr {
	short unsigned int rta_len;
	short unsigned int rta_type;
};

struct crypto_spawn {
	struct list_head list;
	struct crypto_alg *alg;
	struct crypto_instance *inst;
	const struct crypto_type *frontend;
	u32 mask;
};

struct crypto_queue {
	struct list_head list;
	struct list_head *backlog;
	unsigned int qlen;
	unsigned int max_qlen;
};

struct scatter_walk {
	struct scatterlist *sg;
	unsigned int offset;
};

struct aead_request {
	struct crypto_async_request base;
	unsigned int assoclen;
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	void *__ctx[0];
};

struct crypto_aead;

struct aead_alg {
	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
	int (*setauthsize)(struct crypto_aead *, unsigned int);
	int (*encrypt)(struct aead_request *);
	int (*decrypt)(struct aead_request *);
	int (*init)(struct crypto_aead *);
	void (*exit)(struct crypto_aead *);
	unsigned int ivsize;
	unsigned int maxauthsize;
	unsigned int chunksize;
	struct crypto_alg base;
};

struct crypto_aead {
	unsigned int authsize;
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct aead_instance {
	void (*free)(struct aead_instance *);
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct aead_alg alg;
	};
};

struct crypto_aead_spawn {
	struct crypto_spawn base;
};

struct crypto_sync_skcipher;

struct aead_geniv_ctx {
	spinlock_t lock;
	struct crypto_aead *child;
	struct crypto_sync_skcipher *sknull;
	u8 salt[0];
};

struct crypto_rng;

struct rng_alg {
	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
	unsigned int seedsize;
	struct crypto_alg base;
};

struct crypto_rng {
	struct crypto_tfm base;
};

enum crypto_attr_type_t {
	CRYPTOCFGA_UNSPEC = 0,
	CRYPTOCFGA_PRIORITY_VAL = 1,
	CRYPTOCFGA_REPORT_LARVAL = 2,
	CRYPTOCFGA_REPORT_HASH = 3,
	CRYPTOCFGA_REPORT_BLKCIPHER = 4,
	CRYPTOCFGA_REPORT_AEAD = 5,
	CRYPTOCFGA_REPORT_COMPRESS = 6,
	CRYPTOCFGA_REPORT_RNG = 7,
	CRYPTOCFGA_REPORT_CIPHER = 8,
	CRYPTOCFGA_REPORT_AKCIPHER = 9,
	CRYPTOCFGA_REPORT_KPP = 10,
	CRYPTOCFGA_REPORT_ACOMP = 11,
	CRYPTOCFGA_STAT_LARVAL = 12,
	CRYPTOCFGA_STAT_HASH = 13,
	CRYPTOCFGA_STAT_BLKCIPHER = 14,
	CRYPTOCFGA_STAT_AEAD = 15,
	CRYPTOCFGA_STAT_COMPRESS = 16,
	CRYPTOCFGA_STAT_RNG = 17,
	CRYPTOCFGA_STAT_CIPHER = 18,
	CRYPTOCFGA_STAT_AKCIPHER = 19,
	CRYPTOCFGA_STAT_KPP = 20,
	CRYPTOCFGA_STAT_ACOMP = 21,
	__CRYPTOCFGA_MAX = 22,
};

struct crypto_report_aead {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int maxauthsize;
	unsigned int ivsize;
};

struct ablkcipher_walk {
	struct {
		struct page *page;
		unsigned int offset;
	} src;
	struct {
		struct page *page;
		unsigned int offset;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	struct list_head buffers;
	u8 *iv_buffer;
	u8 *iv;
	int flags;
	unsigned int blocksize;
};

struct crypto_report_blkcipher {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

struct ablkcipher_buffer {
	struct list_head entry;
	struct scatter_walk dst;
	unsigned int len;
	void *data;
};

enum {
	ABLKCIPHER_WALK_SLOW = 1,
};

struct blkcipher_walk {
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			u8 *addr;
		} virt;
	} src;
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			u8 *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	void *page;
	u8 *buffer;
	u8 *iv;
	unsigned int ivsize;
	int flags;
	unsigned int walk_blocksize;
	unsigned int cipher_blocksize;
	unsigned int alignmask;
};

enum {
	BLKCIPHER_WALK_PHYS = 1,
	BLKCIPHER_WALK_SLOW = 2,
	BLKCIPHER_WALK_COPY = 4,
	BLKCIPHER_WALK_DIFF = 8,
};

struct crypto_sync_skcipher {
	struct crypto_skcipher base;
};

struct skcipher_instance {
	void (*free)(struct skcipher_instance *);
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct skcipher_alg alg;
	};
};

struct crypto_skcipher_spawn {
	struct crypto_spawn base;
};

struct skcipher_walk {
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} src;
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	struct list_head buffers;
	u8 *page;
	u8 *buffer;
	u8 *oiv;
	void *iv;
	unsigned int ivsize;
	int flags;
	unsigned int blocksize;
	unsigned int stride;
	unsigned int alignmask;
};

struct skcipher_ctx_simple {
	struct crypto_cipher *cipher;
};

enum {
	SKCIPHER_WALK_PHYS = 1,
	SKCIPHER_WALK_SLOW = 2,
	SKCIPHER_WALK_COPY = 4,
	SKCIPHER_WALK_DIFF = 8,
	SKCIPHER_WALK_SLEEP = 16,
};

struct skcipher_walk_buffer {
	struct list_head entry;
	struct scatter_walk dst;
	unsigned int len;
	u8 *data;
	u8 buffer[0];
};

struct hash_alg_common {
	unsigned int digestsize;
	unsigned int statesize;
	struct crypto_alg base;
};

struct ahash_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	struct scatterlist *src;
	u8 *result;
	void *priv;
	void *__ctx[0];
};

struct crypto_ahash;

struct ahash_alg {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	struct hash_alg_common halg;
};

struct crypto_ahash {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_hash_walk {
	char *data;
	unsigned int offset;
	unsigned int alignmask;
	struct page *pg;
	unsigned int entrylen;
	unsigned int total;
	struct scatterlist *sg;
	unsigned int flags;
};

struct ahash_instance {
	struct ahash_alg alg;
};

struct crypto_ahash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_hash {
	char type[64];
	unsigned int blocksize;
	unsigned int digestsize;
};

struct ahash_request_priv {
	crypto_completion_t complete;
	void *data;
	u8 *result;
	u32 flags;
	void *ubuf[0];
};

struct shash_instance {
	struct shash_alg alg;
};

struct crypto_shash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_akcipher {
	char type[64];
};

struct akcipher_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	void *__ctx[0];
};

struct crypto_akcipher {
	struct crypto_tfm base;
};

struct akcipher_alg {
	int (*sign)(struct akcipher_request *);
	int (*verify)(struct akcipher_request *);
	int (*encrypt)(struct akcipher_request *);
	int (*decrypt)(struct akcipher_request *);
	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
	unsigned int (*max_size)(struct crypto_akcipher *);
	int (*init)(struct crypto_akcipher *);
	void (*exit)(struct crypto_akcipher *);
	unsigned int reqsize;
	struct crypto_alg base;
};

struct akcipher_instance {
	void (*free)(struct akcipher_instance *);
	union {
		struct {
			char head[80];
			struct crypto_instance base;
		} s;
		struct akcipher_alg alg;
	};
};

struct crypto_akcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_report_kpp {
	char type[64];
};

struct kpp_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	void *__ctx[0];
};

struct crypto_kpp {
	struct crypto_tfm base;
};

struct kpp_alg {
	int (*set_secret)(struct crypto_kpp *, const void *, unsigned int);
	int (*generate_public_key)(struct kpp_request *);
	int (*compute_shared_secret)(struct kpp_request *);
	unsigned int (*max_size)(struct crypto_kpp *);
	int (*init)(struct crypto_kpp *);
	void (*exit)(struct crypto_kpp *);
	unsigned int reqsize;
	struct crypto_alg base;
};

enum asn1_class {
	ASN1_UNIV = 0,
	ASN1_APPL = 1,
	ASN1_CONT = 2,
	ASN1_PRIV = 3,
};

enum asn1_method {
	ASN1_PRIM = 0,
	ASN1_CONS = 1,
};

enum asn1_tag {
	ASN1_EOC = 0,
	ASN1_BOOL = 1,
	ASN1_INT = 2,
	ASN1_BTS = 3,
	ASN1_OTS = 4,
	ASN1_NULL = 5,
	ASN1_OID = 6,
	ASN1_ODE = 7,
	ASN1_EXT = 8,
	ASN1_REAL = 9,
	ASN1_ENUM = 10,
	ASN1_EPDV = 11,
	ASN1_UTF8STR = 12,
	ASN1_RELOID = 13,
	ASN1_SEQ = 16,
	ASN1_SET = 17,
	ASN1_NUMSTR = 18,
	ASN1_PRNSTR = 19,
	ASN1_TEXSTR = 20,
	ASN1_VIDSTR = 21,
	ASN1_IA5STR = 22,
	ASN1_UNITIM = 23,
	ASN1_GENTIM = 24,
	ASN1_GRASTR = 25,
	ASN1_VISSTR = 26,
	ASN1_GENSTR = 27,
	ASN1_UNISTR = 28,
	ASN1_CHRSTR = 29,
	ASN1_BMPSTR = 30,
	ASN1_LONG_TAG = 31,
};

typedef int (*asn1_action_t)(void *, size_t, unsigned char, const void *, size_t);

struct asn1_decoder {
	const unsigned char *machine;
	size_t machlen;
	const asn1_action_t *actions;
};

enum asn1_opcode {
	ASN1_OP_MATCH = 0,
	ASN1_OP_MATCH_OR_SKIP = 1,
	ASN1_OP_MATCH_ACT = 2,
	ASN1_OP_MATCH_ACT_OR_SKIP = 3,
	ASN1_OP_MATCH_JUMP = 4,
	ASN1_OP_MATCH_JUMP_OR_SKIP = 5,
	ASN1_OP_MATCH_ANY = 8,
	ASN1_OP_MATCH_ANY_OR_SKIP = 9,
	ASN1_OP_MATCH_ANY_ACT = 10,
	ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 11,
	ASN1_OP_COND_MATCH_OR_SKIP = 17,
	ASN1_OP_COND_MATCH_ACT_OR_SKIP = 19,
	ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 21,
	ASN1_OP_COND_MATCH_ANY = 24,
	ASN1_OP_COND_MATCH_ANY_OR_SKIP = 25,
	ASN1_OP_COND_MATCH_ANY_ACT = 26,
	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 27,
	ASN1_OP_COND_FAIL = 28,
	ASN1_OP_COMPLETE = 29,
	ASN1_OP_ACT = 30,
	ASN1_OP_MAYBE_ACT = 31,
	ASN1_OP_END_SEQ = 32,
	ASN1_OP_END_SET = 33,
	ASN1_OP_END_SEQ_OF = 34,
	ASN1_OP_END_SET_OF = 35,
	ASN1_OP_END_SEQ_ACT = 36,
	ASN1_OP_END_SET_ACT = 37,
	ASN1_OP_END_SEQ_OF_ACT = 38,
	ASN1_OP_END_SET_OF_ACT = 39,
	ASN1_OP_RETURN = 40,
	ASN1_OP__NR = 41,
};

enum rsapubkey_actions {
	ACT_rsa_get_e = 0,
	ACT_rsa_get_n = 1,
	NR__rsapubkey_actions = 2,
};

enum rsaprivkey_actions {
	ACT_rsa_get_d = 0,
	ACT_rsa_get_dp = 1,
	ACT_rsa_get_dq = 2,
	ACT_rsa_get_e___2 = 3,
	ACT_rsa_get_n___2 = 4,
	ACT_rsa_get_p = 5,
	ACT_rsa_get_q = 6,
	ACT_rsa_get_qinv = 7,
	NR__rsaprivkey_actions = 8,
};

typedef long unsigned int mpi_limb_t;

struct gcry_mpi {
	int alloced;
	int nlimbs;
	int nbits;
	int sign;
	unsigned int flags;
	mpi_limb_t *d;
};

typedef struct gcry_mpi *MPI;

struct rsa_key {
	const u8 *n;
	const u8 *e;
	const u8 *d;
	const u8 *p;
	const u8 *q;
	const u8 *dp;
	const u8 *dq;
	const u8 *qinv;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	size_t dp_sz;
	size_t dq_sz;
	size_t qinv_sz;
};

struct rsa_mpi_key {
	MPI n;
	MPI e;
	MPI d;
};

struct asn1_decoder;

struct rsa_asn1_template {
	const char *name;
	const u8 *data;
	size_t size;
};

struct pkcs1pad_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct pkcs1pad_inst_ctx {
	struct crypto_akcipher_spawn spawn;
	const struct rsa_asn1_template *digest_info;
};

struct pkcs1pad_request {
	struct scatterlist in_sg[2];
	struct scatterlist out_sg[1];
	uint8_t *in_buf;
	uint8_t *out_buf;
	struct akcipher_request child_req;
};

struct crypto_report_acomp {
	char type[64];
};

struct acomp_req {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int slen;
	unsigned int dlen;
	u32 flags;
	void *__ctx[0];
};

struct crypto_acomp {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct acomp_alg {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	int (*init)(struct crypto_acomp *);
	void (*exit)(struct crypto_acomp *);
	unsigned int reqsize;
	struct crypto_alg base;
};

struct crypto_report_comp {
	char type[64];
};

struct crypto_scomp {
	struct crypto_tfm base;
};

struct scomp_alg {
	void * (*alloc_ctx)(struct crypto_scomp *);
	void (*free_ctx)(struct crypto_scomp *, void *);
	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	struct crypto_alg base;
};

struct scomp_scratch {
	spinlock_t lock;
	void *src;
	void *dst;
};

struct cryptomgr_param {
	struct rtattr *tb[34];
	struct {
		struct rtattr attr;
		struct crypto_attr_type data;
	} type;
	union {
		struct rtattr attr;
		struct {
			struct rtattr attr;
			struct crypto_attr_alg data;
		} alg;
		struct {
			struct rtattr attr;
			struct crypto_attr_u32 data;
		} nu32;
	} attrs[32];
	char template[128];
	struct crypto_larval *larval;
	u32 otype;
	u32 omask;
};

struct crypto_test_param {
	char driver[128];
	char alg[128];
	u32 type;
};

struct hmac_ctx {
	struct crypto_shash *hash;
};

struct md5_state {
	u32 hash[4];
	u32 block[16];
	u64 byte_count;
};

struct sha1_state {
	u32 state[5];
	u64 count;
	u8 buffer[64];
};

typedef void sha1_block_fn(struct sha1_state *, const u8 *, int);

struct sha256_state {
	u32 state[8];
	u64 count;
	u8 buf[64];
};

struct sha512_state {
	u64 state[8];
	u64 count[2];
	u8 buf[128];
};

typedef void sha512_block_fn(struct sha512_state *, const u8 *, int);

struct crypto_cts_ctx {
	struct crypto_skcipher *child;
};

struct crypto_cts_reqctx {
	struct scatterlist sg[2];
	unsigned int offset;
	struct skcipher_request subreq;
};

typedef struct {
	u64 a;
	u64 b;
} u128;

typedef struct {
	__le64 b;
	__le64 a;
} le128;

struct priv {
	struct crypto_skcipher *child;
	struct crypto_cipher *tweak;
};

struct xts_instance_ctx {
	struct crypto_skcipher_spawn spawn;
	char name[128];
};

struct rctx {
	le128 t;
	struct scatterlist *tail;
	struct scatterlist sg[2];
	struct skcipher_request subreq;
};

struct crypto_rfc3686_ctx {
	struct crypto_skcipher *child;
	u8 nonce[4];
};

struct crypto_rfc3686_req_ctx {
	u8 iv[16];
	struct skcipher_request subreq;
};

struct crypto_aes_ctx {
	u32 key_enc[60];
	u32 key_dec[60];
	u32 key_length;
};

struct chksum_ctx {
	u32 key;
};

struct chksum_desc_ctx {
	u32 crc;
};

struct chksum_desc_ctx___2 {
	__u16 crc;
};

struct lzo_ctx {
	void *lzo_comp_mem;
};

struct lzorle_ctx {
	void *lzorle_comp_mem;
};

struct crypto_report_rng {
	char type[64];
	unsigned int seedsize;
};

struct random_ready_callback {
	struct list_head list;
	void (*func)(struct random_ready_callback *);
	struct module *owner;
};

struct drbg_string {
	const unsigned char *buf;
	size_t len;
	struct list_head list;
};

typedef uint32_t drbg_flag_t;

struct drbg_core {
	drbg_flag_t flags;
	__u8 statelen;
	__u8 blocklen_bytes;
	char cra_name[128];
	char backend_cra_name[128];
};

struct drbg_state;

struct drbg_state_ops {
	int (*update)(struct drbg_state *, struct list_head *, int);
	int (*generate)(struct drbg_state *, unsigned char *, unsigned int, struct list_head *);
	int (*crypto_init)(struct drbg_state *);
	int (*crypto_fini)(struct drbg_state *);
};

struct drbg_state {
	struct mutex drbg_mutex;
	unsigned char *V;
	unsigned char *Vbuf;
	unsigned char *C;
	unsigned char *Cbuf;
	size_t reseed_ctr;
	size_t reseed_threshold;
	unsigned char *scratchpad;
	unsigned char *scratchpadbuf;
	void *priv_data;
	struct crypto_skcipher *ctr_handle;
	struct skcipher_request *ctr_req;
	__u8 *outscratchpadbuf;
	__u8 *outscratchpad;
	struct crypto_wait ctr_wait;
	struct scatterlist sg_in;
	struct scatterlist sg_out;
	bool seeded;
	bool pr;
	bool fips_primed;
	unsigned char *prev;
	struct work_struct seed_work;
	struct crypto_rng *jent;
	const struct drbg_state_ops *d_ops;
	const struct drbg_core *core;
	struct drbg_string test_data;
	struct random_ready_callback random_ready;
};

enum drbg_prefixes {
	DRBG_PREFIX0 = 0,
	DRBG_PREFIX1 = 1,
	DRBG_PREFIX2 = 2,
	DRBG_PREFIX3 = 3,
};

struct sdesc {
	struct shash_desc shash;
	char ctx[0];
};

struct rand_data {
	__u64 data;
	__u64 old_data;
	__u64 prev_time;
	__u64 last_delta;
	__s64 last_delta2;
	unsigned int osr;
	unsigned char *mem;
	unsigned int memlocation;
	unsigned int memblocks;
	unsigned int memblocksize;
	unsigned int memaccessloops;
};

struct rand_data;

struct jitterentropy {
	spinlock_t jent_lock;
	struct rand_data *entropy_collector;
};

struct sockaddr_alg_new {
	__u16 salg_family;
	__u8 salg_type[14];
	__u32 salg_feat;
	__u32 salg_mask;
	__u8 salg_name[0];
};

struct af_alg_iv {
	__u32 ivlen;
	__u8 iv[0];
};

struct cmsghdr {
	__kernel_size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

struct net_proto_family {
	int family;
	int (*create)(struct net *, struct socket *, int, int);
	struct module *owner;
};

enum {
	SOCK_WAKE_IO = 0,
	SOCK_WAKE_WAITD = 1,
	SOCK_WAKE_SPACE = 2,
	SOCK_WAKE_URG = 3,
};

struct af_alg_type;

struct alg_sock {
	struct sock sk;
	struct sock *parent;
	atomic_t refcnt;
	atomic_t nokey_refcnt;
	const struct af_alg_type *type;
	void *private;
};

struct af_alg_type {
	void * (*bind)(const char *, u32, u32);
	void (*release)(void *);
	int (*setkey)(void *, const u8 *, unsigned int);
	int (*accept)(void *, struct sock *);
	int (*accept_nokey)(void *, struct sock *);
	int (*setauthsize)(void *, unsigned int);
	struct proto_ops *ops;
	struct proto_ops *ops_nokey;
	struct module *owner;
	char name[14];
};

struct af_alg_control {
	struct af_alg_iv *iv;
	int op;
	unsigned int aead_assoclen;
};

struct af_alg_sgl {
	struct scatterlist sg[17];
	struct page *pages[16];
	unsigned int npages;
};

struct af_alg_tsgl {
	struct list_head list;
	unsigned int cur;
	struct scatterlist sg[0];
};

struct af_alg_rsgl {
	struct af_alg_sgl sgl;
	struct list_head list;
	size_t sg_num_bytes;
};

struct af_alg_async_req {
	struct kiocb *iocb;
	struct sock *sk;
	struct af_alg_rsgl first_rsgl;
	struct af_alg_rsgl *last_rsgl;
	struct list_head rsgl_list;
	struct scatterlist *tsgl;
	unsigned int tsgl_entries;
	unsigned int outlen;
	unsigned int areqlen;
	union {
		struct aead_request aead_req;
		struct skcipher_request skcipher_req;
	} cra_u;
};

struct af_alg_ctx {
	struct list_head tsgl_list;
	void *iv;
	size_t aead_assoclen;
	struct crypto_wait wait;
	size_t used;
	atomic_t rcvused;
	bool more;
	bool merge;
	bool enc;
	bool init;
	unsigned int len;
};

struct alg_type_list {
	const struct af_alg_type *type;
	struct list_head list;
};

struct hash_ctx {
	struct af_alg_sgl sgl;
	u8 *result;
	struct crypto_wait wait;
	unsigned int len;
	bool more;
	struct ahash_request req;
};

struct xor_block_template {
	struct xor_block_template *next;
	const char *name;
	int speed;
	void (*do_2)(long unsigned int, long unsigned int *, long unsigned int *);
	void (*do_3)(long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
	void (*do_4)(long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *);
	void (*do_5)(long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *);
};

typedef s32 dma_cookie_t;

enum dma_status {
	DMA_COMPLETE = 0,
	DMA_IN_PROGRESS = 1,
	DMA_PAUSED = 2,
	DMA_ERROR = 3,
};

enum dma_transaction_type {
	DMA_MEMCPY = 0,
	DMA_XOR = 1,
	DMA_PQ = 2,
	DMA_XOR_VAL = 3,
	DMA_PQ_VAL = 4,
	DMA_MEMSET = 5,
	DMA_MEMSET_SG = 6,
	DMA_INTERRUPT = 7,
	DMA_PRIVATE = 8,
	DMA_ASYNC_TX = 9,
	DMA_SLAVE = 10,
	DMA_CYCLIC = 11,
	DMA_INTERLEAVE = 12,
	DMA_TX_TYPE_END = 13,
};

enum dma_transfer_direction {
	DMA_MEM_TO_MEM = 0,
	DMA_MEM_TO_DEV = 1,
	DMA_DEV_TO_MEM = 2,
	DMA_DEV_TO_DEV = 3,
	DMA_TRANS_NONE = 4,
};

struct data_chunk {
	size_t size;
	size_t icg;
	size_t dst_icg;
	size_t src_icg;
};

struct dma_interleaved_template {
	dma_addr_t src_start;
	dma_addr_t dst_start;
	enum dma_transfer_direction dir;
	bool src_inc;
	bool dst_inc;
	bool src_sgl;
	bool dst_sgl;
	size_t numf;
	size_t frame_size;
	struct data_chunk sgl[0];
};

enum dma_ctrl_flags {
	DMA_PREP_INTERRUPT = 1,
	DMA_CTRL_ACK = 2,
	DMA_PREP_PQ_DISABLE_P = 4,
	DMA_PREP_PQ_DISABLE_Q = 8,
	DMA_PREP_CONTINUE = 16,
	DMA_PREP_FENCE = 32,
	DMA_CTRL_REUSE = 64,
	DMA_PREP_CMD = 128,
};

enum sum_check_bits {
	SUM_CHECK_P = 0,
	SUM_CHECK_Q = 1,
};

enum sum_check_flags {
	SUM_CHECK_P_RESULT = 1,
	SUM_CHECK_Q_RESULT = 2,
};

typedef struct {
	long unsigned int bits[1];
} dma_cap_mask_t;

struct dma_chan_percpu {
	long unsigned int memcpy_count;
	long unsigned int bytes_transferred;
};

struct dma_router {
	struct device *dev;
	void (*route_free)(struct device *, void *);
};

struct dma_device;

struct dma_chan_dev;

struct dma_chan___2 {
	struct dma_device *device;
	dma_cookie_t cookie;
	dma_cookie_t completed_cookie;
	int chan_id;
	struct dma_chan_dev *dev;
	struct list_head device_node;
	struct dma_chan_percpu *local;
	int client_count;
	int table_count;
	struct dma_router *router;
	void *route_data;
	void *private;
};

typedef bool (*dma_filter_fn)(struct dma_chan___2 *, void *);

struct dma_slave_map;

struct dma_filter {
	dma_filter_fn fn;
	int mapcnt;
	const struct dma_slave_map *map;
};

enum dmaengine_alignment {
	DMAENGINE_ALIGN_1_BYTE = 0,
	DMAENGINE_ALIGN_2_BYTES = 1,
	DMAENGINE_ALIGN_4_BYTES = 2,
	DMAENGINE_ALIGN_8_BYTES = 3,
	DMAENGINE_ALIGN_16_BYTES = 4,
	DMAENGINE_ALIGN_32_BYTES = 5,
	DMAENGINE_ALIGN_64_BYTES = 6,
};

enum dma_residue_granularity {
	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
	DMA_RESIDUE_GRANULARITY_BURST = 2,
};

struct dma_async_tx_descriptor;

struct dma_slave_config;

struct dma_tx_state;

struct dma_device {
	unsigned int chancnt;
	unsigned int privatecnt;
	struct list_head channels;
	struct list_head global_node;
	struct dma_filter filter;
	dma_cap_mask_t cap_mask;
	short unsigned int max_xor;
	short unsigned int max_pq;
	enum dmaengine_alignment copy_align;
	enum dmaengine_alignment xor_align;
	enum dmaengine_alignment pq_align;
	enum dmaengine_alignment fill_align;
	int dev_id;
	struct device *dev;
	struct module *owner;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 max_burst;
	bool descriptor_reuse;
	enum dma_residue_granularity residue_granularity;
	int (*device_alloc_chan_resources)(struct dma_chan___2 *);
	void (*device_free_chan_resources)(struct dma_chan___2 *);
	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan___2 *, dma_addr_t, dma_addr_t, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan___2 *, dma_addr_t, dma_addr_t *, unsigned int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan___2 *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan___2 *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan___2 *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan___2 *, dma_addr_t, int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan___2 *, struct scatterlist *, unsigned int, int, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan___2 *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan___2 *, struct scatterlist *, unsigned int, enum dma_transfer_direction, long unsigned int, void *);
	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan___2 *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan___2 *, struct dma_interleaved_template *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan___2 *, dma_addr_t, u64, long unsigned int);
	int (*device_config)(struct dma_chan___2 *, struct dma_slave_config *);
	int (*device_pause)(struct dma_chan___2 *);
	int (*device_resume)(struct dma_chan___2 *);
	int (*device_terminate_all)(struct dma_chan___2 *);
	void (*device_synchronize)(struct dma_chan___2 *);
	enum dma_status (*device_tx_status)(struct dma_chan___2 *, dma_cookie_t, struct dma_tx_state *);
	void (*device_issue_pending)(struct dma_chan___2 *);
};

struct dma_chan_dev {
	struct dma_chan___2 *chan;
	struct device device;
	int dev_id;
	atomic_t *idr_ref;
};

enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
};

struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	u32 src_port_window_size;
	u32 dst_port_window_size;
	bool device_fc;
	unsigned int slave_id;
};

typedef void (*dma_async_tx_callback)(void *);

enum dmaengine_tx_result {
	DMA_TRANS_NOERROR = 0,
	DMA_TRANS_READ_FAILED = 1,
	DMA_TRANS_WRITE_FAILED = 2,
	DMA_TRANS_ABORTED = 3,
};

struct dmaengine_result {
	enum dmaengine_tx_result result;
	u32 residue;
};

typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);

struct dmaengine_unmap_data {
	u16 map_cnt;
	u8 to_cnt;
	u8 from_cnt;
	u8 bidi_cnt;
	struct device *dev;
	struct kref kref;
	size_t len;
	dma_addr_t addr[0];
};

struct dma_async_tx_descriptor {
	dma_cookie_t cookie;
	enum dma_ctrl_flags flags;
	dma_addr_t phys;
	struct dma_chan___2 *chan;
	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
	int (*desc_free)(struct dma_async_tx_descriptor *);
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
	struct dmaengine_unmap_data *unmap;
};

struct dma_tx_state {
	dma_cookie_t last;
	dma_cookie_t used;
	u32 residue;
};

struct dma_slave_map {
	const char *devname;
	const char *slave;
	void *param;
};

enum async_tx_flags {
	ASYNC_TX_XOR_ZERO_DST = 1,
	ASYNC_TX_XOR_DROP_DST = 2,
	ASYNC_TX_ACK = 4,
	ASYNC_TX_FENCE = 8,
	ASYNC_TX_PQ_XOR_DST = 16,
};

struct async_submit_ctl {
	enum async_tx_flags flags;
	struct dma_async_tx_descriptor *depend_tx;
	dma_async_tx_callback cb_fn;
	void *cb_param;
	void *scribble;
};

enum submit_disposition {
	ASYNC_TX_SUBMITTED = 0,
	ASYNC_TX_CHANNEL_SWITCH = 1,
	ASYNC_TX_DIRECT_SUBMIT = 2,
};

struct raid6_calls {
	void (*gen_syndrome)(int, size_t, void **);
	void (*xor_syndrome)(int, int, int, size_t, void **);
	int (*valid)();
	const char *name;
	int prefer;
};

typedef union {
	long unsigned int addr;
	struct page *page;
	dma_addr_t dma;
} addr_conv_t;

enum asymmetric_payload_bits {
	asym_crypto = 0,
	asym_subtype = 1,
	asym_key_ids = 2,
	asym_auth = 3,
};

struct asymmetric_key_id {
	short unsigned int len;
	unsigned char data[0];
};

struct asymmetric_key_ids {
	void *id[2];
};

struct public_key_signature;

struct asymmetric_key_subtype {
	struct module *owner;
	const char *name;
	short unsigned int name_len;
	void (*describe)(const struct key *, struct seq_file *);
	void (*destroy)(void *, void *);
	int (*query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*verify_signature)(const struct key *, const struct public_key_signature *);
};

struct public_key_signature {
	struct asymmetric_key_id *auth_ids[2];
	u8 *s;
	u32 s_size;
	u8 *digest;
	u8 digest_size;
	const char *pkey_algo;
	const char *hash_algo;
	const char *encoding;
};

struct asymmetric_key_parser {
	struct list_head link;
	struct module *owner;
	const char *name;
	int (*parse)(struct key_preparsed_payload *);
};

enum OID {
	OID_id_dsa_with_sha1 = 0,
	OID_id_dsa = 1,
	OID_id_ecdsa_with_sha1 = 2,
	OID_id_ecPublicKey = 3,
	OID_rsaEncryption = 4,
	OID_md2WithRSAEncryption = 5,
	OID_md3WithRSAEncryption = 6,
	OID_md4WithRSAEncryption = 7,
	OID_sha1WithRSAEncryption = 8,
	OID_sha256WithRSAEncryption = 9,
	OID_sha384WithRSAEncryption = 10,
	OID_sha512WithRSAEncryption = 11,
	OID_sha224WithRSAEncryption = 12,
	OID_data = 13,
	OID_signed_data = 14,
	OID_email_address = 15,
	OID_contentType = 16,
	OID_messageDigest = 17,
	OID_signingTime = 18,
	OID_smimeCapabilites = 19,
	OID_smimeAuthenticatedAttrs = 20,
	OID_md2 = 21,
	OID_md4 = 22,
	OID_md5 = 23,
	OID_msIndirectData = 24,
	OID_msStatementType = 25,
	OID_msSpOpusInfo = 26,
	OID_msPeImageDataObjId = 27,
	OID_msIndividualSPKeyPurpose = 28,
	OID_msOutlookExpress = 29,
	OID_certAuthInfoAccess = 30,
	OID_sha1 = 31,
	OID_sha256 = 32,
	OID_sha384 = 33,
	OID_sha512 = 34,
	OID_sha224 = 35,
	OID_commonName = 36,
	OID_surname = 37,
	OID_countryName = 38,
	OID_locality = 39,
	OID_stateOrProvinceName = 40,
	OID_organizationName = 41,
	OID_organizationUnitName = 42,
	OID_title = 43,
	OID_description = 44,
	OID_name = 45,
	OID_givenName = 46,
	OID_initials = 47,
	OID_generationalQualifier = 48,
	OID_subjectKeyIdentifier = 49,
	OID_keyUsage = 50,
	OID_subjectAltName = 51,
	OID_issuerAltName = 52,
	OID_basicConstraints = 53,
	OID_crlDistributionPoints = 54,
	OID_certPolicies = 55,
	OID_authorityKeyIdentifier = 56,
	OID_extKeyUsage = 57,
	OID_gostCPSignA = 58,
	OID_gostCPSignB = 59,
	OID_gostCPSignC = 60,
	OID_gost2012PKey256 = 61,
	OID_gost2012PKey512 = 62,
	OID_gost2012Digest256 = 63,
	OID_gost2012Digest512 = 64,
	OID_gost2012Signature256 = 65,
	OID_gost2012Signature512 = 66,
	OID_gostTC26Sign256A = 67,
	OID_gostTC26Sign256B = 68,
	OID_gostTC26Sign256C = 69,
	OID_gostTC26Sign256D = 70,
	OID_gostTC26Sign512A = 71,
	OID_gostTC26Sign512B = 72,
	OID_gostTC26Sign512C = 73,
	OID__NR = 74,
};

struct public_key {
	void *key;
	u32 keylen;
	enum OID algo;
	void *params;
	u32 paramlen;
	bool key_is_private;
	const char *id_type;
	const char *pkey_algo;
};

enum x509_actions {
	ACT_x509_extract_key_data = 0,
	ACT_x509_extract_name_segment = 1,
	ACT_x509_note_OID = 2,
	ACT_x509_note_issuer = 3,
	ACT_x509_note_not_after = 4,
	ACT_x509_note_not_before = 5,
	ACT_x509_note_params = 6,
	ACT_x509_note_pkey_algo = 7,
	ACT_x509_note_serial = 8,
	ACT_x509_note_signature = 9,
	ACT_x509_note_subject = 10,
	ACT_x509_note_tbs_certificate = 11,
	ACT_x509_process_extension = 12,
	NR__x509_actions = 13,
};

enum x509_akid_actions {
	ACT_x509_akid_note_kid = 0,
	ACT_x509_akid_note_name = 1,
	ACT_x509_akid_note_serial = 2,
	ACT_x509_extract_name_segment___2 = 3,
	ACT_x509_note_OID___2 = 4,
	NR__x509_akid_actions = 5,
};

struct x509_certificate {
	struct x509_certificate *next;
	struct x509_certificate *signer;
	struct public_key *pub;
	struct public_key_signature *sig;
	char *issuer;
	char *subject;
	struct asymmetric_key_id *id;
	struct asymmetric_key_id *skid;
	time64_t valid_from;
	time64_t valid_to;
	const void *tbs;
	unsigned int tbs_size;
	unsigned int raw_sig_size;
	const void *raw_sig;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_subject;
	unsigned int raw_subject_size;
	unsigned int raw_skid_size;
	const void *raw_skid;
	unsigned int index;
	bool seen;
	bool verified;
	bool self_signed;
	bool unsupported_key;
	bool unsupported_sig;
	bool blacklisted;
};

struct x509_parse_context {
	struct x509_certificate *cert;
	long unsigned int data;
	const void *cert_start;
	const void *key;
	size_t key_size;
	const void *params;
	size_t params_size;
	enum OID key_algo;
	enum OID last_oid;
	enum OID algo_oid;
	unsigned char nr_mpi;
	u8 o_size;
	u8 cn_size;
	u8 email_size;
	u16 o_offset;
	u16 cn_offset;
	u16 email_offset;
	unsigned int raw_akid_size;
	const void *raw_akid;
	const void *akid_raw_issuer;
	unsigned int akid_raw_issuer_size;
};

enum pkcs7_actions {
	ACT_pkcs7_check_content_type = 0,
	ACT_pkcs7_extract_cert = 1,
	ACT_pkcs7_note_OID = 2,
	ACT_pkcs7_note_certificate_list = 3,
	ACT_pkcs7_note_content = 4,
	ACT_pkcs7_note_data = 5,
	ACT_pkcs7_note_signed_info = 6,
	ACT_pkcs7_note_signeddata_version = 7,
	ACT_pkcs7_note_signerinfo_version = 8,
	ACT_pkcs7_sig_note_authenticated_attr = 9,
	ACT_pkcs7_sig_note_digest_algo = 10,
	ACT_pkcs7_sig_note_issuer = 11,
	ACT_pkcs7_sig_note_pkey_algo = 12,
	ACT_pkcs7_sig_note_serial = 13,
	ACT_pkcs7_sig_note_set_of_authattrs = 14,
	ACT_pkcs7_sig_note_signature = 15,
	ACT_pkcs7_sig_note_skid = 16,
	NR__pkcs7_actions = 17,
};

struct pkcs7_signed_info {
	struct pkcs7_signed_info *next;
	struct x509_certificate *signer;
	unsigned int index;
	bool unsupported_crypto;
	bool blacklisted;
	const void *msgdigest;
	unsigned int msgdigest_len;
	unsigned int authattrs_len;
	const void *authattrs;
	long unsigned int aa_set;
	time64_t signing_time;
	struct public_key_signature *sig;
};

struct pkcs7_message {
	struct x509_certificate *certs;
	struct x509_certificate *crl;
	struct pkcs7_signed_info *signed_infos;
	u8 version;
	bool have_authattrs;
	enum OID data_type;
	size_t data_len;
	size_t data_hdrlen;
	const void *data;
};

struct pkcs7_parse_context {
	struct pkcs7_message *msg;
	struct pkcs7_signed_info *sinfo;
	struct pkcs7_signed_info **ppsinfo;
	struct x509_certificate *certs;
	struct x509_certificate **ppcerts;
	long unsigned int data;
	enum OID last_oid;
	unsigned int x509_index;
	unsigned int sinfo_index;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_skid;
	unsigned int raw_skid_size;
	bool expect_skid;
};

struct biovec_slab {
	int nr_vecs;
	char *name;
	struct kmem_cache *slab;
};

enum rq_qos_id {
	RQ_QOS_WBT = 0,
	RQ_QOS_LATENCY = 1,
	RQ_QOS_COST = 2,
};

struct rq_qos_ops;

struct rq_qos {
	struct rq_qos_ops *ops;
	struct request_queue *q;
	enum rq_qos_id id;
	struct rq_qos *next;
	struct dentry *debugfs_dir;
};

struct rq_map_data {
	struct page **pages;
	int page_order;
	int nr_entries;
	long unsigned int offset;
	int null_mapped;
	int from_user;
};

struct rq_qos_ops {
	void (*throttle)(struct rq_qos *, struct bio *);
	void (*track)(struct rq_qos *, struct request *, struct bio *);
	void (*merge)(struct rq_qos *, struct request *, struct bio *);
	void (*issue)(struct rq_qos *, struct request *);
	void (*requeue)(struct rq_qos *, struct request *);
	void (*done)(struct rq_qos *, struct request *);
	void (*done_bio)(struct rq_qos *, struct bio *);
	void (*cleanup)(struct rq_qos *, struct bio *);
	void (*queue_depth_changed)(struct rq_qos *);
	void (*exit)(struct rq_qos *);
	const struct blk_mq_debugfs_attr *debugfs_attrs;
};

struct bio_slab {
	struct kmem_cache *slab;
	unsigned int slab_ref;
	unsigned int slab_size;
	char name[8];
};

struct bio_map_data {
	int is_our_pages;
	struct iov_iter iter;
	struct iovec iov[0];
};

enum {
	BLK_MQ_F_SHOULD_MERGE = 1,
	BLK_MQ_F_TAG_SHARED = 2,
	BLK_MQ_F_BLOCKING = 32,
	BLK_MQ_F_NO_SCHED = 64,
	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
	BLK_MQ_S_STOPPED = 0,
	BLK_MQ_S_TAG_ACTIVE = 1,
	BLK_MQ_S_SCHED_RESTART = 2,
	BLK_MQ_MAX_DEPTH = 10240,
	BLK_MQ_CPU_WORK_BATCH = 8,
};

enum {
	WBT_RWQ_BG = 0,
	WBT_RWQ_KSWAPD = 1,
	WBT_RWQ_DISCARD = 2,
	WBT_NUM_RWQ = 3,
};

struct blk_plug_cb;

typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);

struct blk_plug_cb {
	struct list_head list;
	blk_plug_cb_fn callback;
	void *data;
};

enum {
	BLK_MQ_REQ_NOWAIT = 1,
	BLK_MQ_REQ_RESERVED = 2,
	BLK_MQ_REQ_INTERNAL = 4,
	BLK_MQ_REQ_PREEMPT = 8,
};

struct trace_event_raw_block_buffer {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	size_t size;
	char __data[0];
};

struct trace_event_raw_block_rq_requeue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	unsigned int bytes;
	char rwbs[8];
	char comm[16];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_bio_bounce {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_bio_merge {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_queue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_get_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_plug {
	struct trace_entry ent;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_unplug {
	struct trace_entry ent;
	int nr_rq;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_split {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	sector_t new_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_rq_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	unsigned int nr_bios;
	char rwbs[8];
	char __data[0];
};

struct trace_event_data_offsets_block_buffer {};

struct trace_event_data_offsets_block_rq_requeue {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq_complete {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq {
	u32 cmd;
};

struct trace_event_data_offsets_block_bio_bounce {};

struct trace_event_data_offsets_block_bio_complete {};

struct trace_event_data_offsets_block_bio_merge {};

struct trace_event_data_offsets_block_bio_queue {};

struct trace_event_data_offsets_block_get_rq {};

struct trace_event_data_offsets_block_plug {};

struct trace_event_data_offsets_block_unplug {};

struct trace_event_data_offsets_block_split {};

struct trace_event_data_offsets_block_bio_remap {};

struct trace_event_data_offsets_block_rq_remap {};

typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_rq_requeue)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_rq_complete)(void *, struct request *, int, unsigned int);

typedef void (*btf_trace_block_rq_insert)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_rq_issue)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_bio_bounce)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *, int);

typedef void (*btf_trace_block_bio_backmerge)(void *, struct request_queue *, struct request *, struct bio *);

typedef void (*btf_trace_block_bio_frontmerge)(void *, struct request_queue *, struct request *, struct bio *);

typedef void (*btf_trace_block_bio_queue)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_getrq)(void *, struct request_queue *, struct bio *, int);

typedef void (*btf_trace_block_sleeprq)(void *, struct request_queue *, struct bio *, int);

typedef void (*btf_trace_block_plug)(void *, struct request_queue *);

typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);

typedef void (*btf_trace_block_split)(void *, struct request_queue *, struct bio *, unsigned int);

typedef void (*btf_trace_block_bio_remap)(void *, struct request_queue *, struct bio *, dev_t, sector_t);

typedef void (*btf_trace_block_rq_remap)(void *, struct request_queue *, struct request *, dev_t, sector_t);

struct queue_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct request_queue *, char *);
	ssize_t (*store)(struct request_queue *, const char *, size_t);
};

enum {
	REQ_FSEQ_PREFLUSH = 1,
	REQ_FSEQ_DATA = 2,
	REQ_FSEQ_POSTFLUSH = 4,
	REQ_FSEQ_DONE = 8,
	REQ_FSEQ_ACTIONS = 7,
	FLUSH_PENDING_TIMEOUT = 5000,
};

enum blk_default_limits {
	BLK_MAX_SEGMENTS = 128,
	BLK_SAFE_MAX_SECTORS = 255,
	BLK_DEF_MAX_SECTORS = 2560,
	BLK_MAX_SEGMENT_SIZE = 65536,
	BLK_SEG_BOUNDARY_MASK = 4294967295,
};

enum {
	ICQ_EXITED = 4,
	ICQ_DESTROYED = 8,
};

struct req_iterator {
	struct bvec_iter iter;
	struct bio *bio;
};

typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);

typedef bool busy_iter_fn(struct blk_mq_hw_ctx *, struct request *, void *, bool);

enum {
	BLK_MQ_UNIQUE_TAG_BITS = 16,
	BLK_MQ_UNIQUE_TAG_MASK = 65535,
};

enum {
	BLK_MQ_TAG_FAIL = 4294967295,
	BLK_MQ_TAG_MIN = 1,
	BLK_MQ_TAG_MAX = 4294967294,
};

struct mq_inflight {
	struct hd_struct *part;
	unsigned int *inflight;
};

struct flush_busy_ctx_data {
	struct blk_mq_hw_ctx *hctx;
	struct list_head *list;
};

struct dispatch_rq_data {
	struct blk_mq_hw_ctx *hctx;
	struct request *rq;
};

struct blk_mq_qe_pair {
	struct list_head node;
	struct request_queue *q;
	struct elevator_type *type;
};

struct sbq_wait {
	struct sbitmap_queue *sbq;
	struct wait_queue_entry wait;
};

typedef bool busy_tag_iter_fn(struct request *, void *, bool);

struct bt_iter_data {
	struct blk_mq_hw_ctx *hctx;
	busy_iter_fn *fn;
	void *data;
	bool reserved;
};

struct bt_tags_iter_data {
	struct blk_mq_tags *tags;
	busy_tag_iter_fn *fn;
	void *data;
	bool reserved;
};

struct blk_queue_stats {
	struct list_head callbacks;
	spinlock_t lock;
	bool enable_accounting;
};

struct blk_mq_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_ctx *, char *);
	ssize_t (*store)(struct blk_mq_ctx *, const char *, size_t);
};

struct blk_mq_hw_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
	ssize_t (*store)(struct blk_mq_hw_ctx *, const char *, size_t);
};

struct disk_part_iter {
	struct gendisk *disk;
	struct hd_struct *part;
	int idx;
	unsigned int flags;
};

struct hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	long unsigned int start;
};

struct blkpg_ioctl_arg {
	int op;
	int flags;
	int datalen;
	void *data;
};

struct blkpg_partition {
	long long int start;
	long long int length;
	int pno;
	char devname[64];
	char volname[64];
};

struct pr_reservation {
	__u64 key;
	__u32 type;
	__u32 flags;
};

struct pr_registration {
	__u64 old_key;
	__u64 new_key;
	__u32 flags;
	__u32 __pad;
};

struct pr_preempt {
	__u64 old_key;
	__u64 new_key;
	__u32 type;
	__u32 flags;
};

struct pr_clear {
	__u64 key;
	__u32 flags;
	__u32 __pad;
};

struct klist_node;

struct klist {
	spinlock_t k_lock;
	struct list_head k_list;
	void (*get)(struct klist_node *);
	void (*put)(struct klist_node *);
};

struct klist_node {
	void *n_klist;
	struct list_head n_node;
	struct kref n_ref;
};

struct klist_iter {
	struct klist *i_klist;
	struct klist_node *i_cur;
};

struct class_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

enum {
	DISK_EVENT_FLAG_POLL = 1,
	DISK_EVENT_FLAG_UEVENT = 2,
};

struct disk_events {
	struct list_head node;
	struct gendisk *disk;
	spinlock_t lock;
	struct mutex block_mutex;
	int block;
	unsigned int pending;
	unsigned int clearing;
	long int poll_msecs;
	struct delayed_work dwork;
};

struct badblocks {
	struct device *dev;
	int count;
	int unacked_exist;
	int shift;
	u64 *page;
	int changed;
	seqlock_t lock;
	sector_t sector;
	sector_t size;
};

struct blk_major_name {
	struct blk_major_name *next;
	int major;
	char name[16];
};

typedef struct {
	struct page *v;
} Sector;

struct parsed_partitions {
	struct block_device *bdev;
	char name[32];
	struct {
		sector_t from;
		sector_t size;
		int flags;
		bool has_info;
		struct partition_meta_info info;
	} *parts;
	int next;
	int limit;
	bool access_beyond_eod;
	char *pp_buf;
};

enum {
	IOPRIO_WHO_PROCESS = 1,
	IOPRIO_WHO_PGRP = 2,
	IOPRIO_WHO_USER = 3,
};

struct partition {
	unsigned char boot_ind;
	unsigned char head;
	unsigned char sector;
	unsigned char cyl;
	unsigned char sys_ind;
	unsigned char end_head;
	unsigned char end_sector;
	unsigned char end_cyl;
	__le32 start_sect;
	__le32 nr_sects;
};

struct frag {
	struct list_head list;
	u32 group;
	u8 num;
	u8 rec;
	u8 map;
	u8 data[0];
};

struct privhead {
	u16 ver_major;
	u16 ver_minor;
	u64 logical_disk_start;
	u64 logical_disk_size;
	u64 config_start;
	u64 config_size;
	uuid_t disk_id;
};

struct tocblock {
	u8 bitmap1_name[16];
	u64 bitmap1_start;
	u64 bitmap1_size;
	u8 bitmap2_name[16];
	u64 bitmap2_start;
	u64 bitmap2_size;
};

struct vmdb {
	u16 ver_major;
	u16 ver_minor;
	u32 vblk_size;
	u32 vblk_offset;
	u32 last_vblk_seq;
};

struct vblk_comp {
	u8 state[16];
	u64 parent_id;
	u8 type;
	u8 children;
	u16 chunksize;
};

struct vblk_dgrp {
	u8 disk_id[64];
};

struct vblk_disk {
	uuid_t disk_id;
	u8 alt_name[128];
};

struct vblk_part {
	u64 start;
	u64 size;
	u64 volume_offset;
	u64 parent_id;
	u64 disk_id;
	u8 partnum;
};

struct vblk_volu {
	u8 volume_type[16];
	u8 volume_state[16];
	u8 guid[16];
	u8 drive_hint[4];
	u64 size;
	u8 partition_type;
};

struct vblk {
	u8 name[64];
	u64 obj_id;
	u32 sequence;
	u8 flags;
	u8 type;
	union {
		struct vblk_comp comp;
		struct vblk_dgrp dgrp;
		struct vblk_disk disk;
		struct vblk_part part;
		struct vblk_volu volu;
	} vblk;
	struct list_head list;
};

struct ldmdb {
	struct privhead ph;
	struct tocblock toc;
	struct vmdb vm;
	struct list_head v_dgrp;
	struct list_head v_disk;
	struct list_head v_volu;
	struct list_head v_comp;
	struct list_head v_part;
};

struct fat_boot_sector {
	__u8 ignored[3];
	__u8 system_id[8];
	__u8 sector_size[2];
	__u8 sec_per_clus;
	__le16 reserved;
	__u8 fats;
	__u8 dir_entries[2];
	__u8 sectors[2];
	__u8 media;
	__le16 fat_length;
	__le16 secs_track;
	__le16 heads;
	__le32 hidden;
	__le32 total_sect;
	union {
		struct {
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat16;
		struct {
			__le32 length;
			__le16 flags;
			__u8 version[2];
			__le32 root_cluster;
			__le16 info_sector;
			__le16 backup_boot;
			__le16 reserved2[6];
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat32;
	};
};

enum {
	DOS_EXTENDED_PARTITION = 5,
	LINUX_EXTENDED_PARTITION = 133,
	WIN98_EXTENDED_PARTITION = 15,
	SUN_WHOLE_DISK = 5,
	LINUX_SWAP_PARTITION = 130,
	LINUX_DATA_PARTITION = 131,
	LINUX_LVM_PARTITION = 142,
	LINUX_RAID_PARTITION = 253,
	SOLARIS_X86_PARTITION = 130,
	NEW_SOLARIS_X86_PARTITION = 191,
	DM6_AUX1PARTITION = 81,
	DM6_AUX3PARTITION = 83,
	DM6_PARTITION = 84,
	EZD_PARTITION = 85,
	FREEBSD_PARTITION = 165,
	OPENBSD_PARTITION = 166,
	NETBSD_PARTITION = 169,
	BSDI_PARTITION = 183,
	MINIX_PARTITION = 129,
	UNIXWARE_PARTITION = 99,
};

struct _gpt_header {
	__le64 signature;
	__le32 revision;
	__le32 header_size;
	__le32 header_crc32;
	__le32 reserved1;
	__le64 my_lba;
	__le64 alternate_lba;
	__le64 first_usable_lba;
	__le64 last_usable_lba;
	efi_guid_t disk_guid;
	__le64 partition_entry_lba;
	__le32 num_partition_entries;
	__le32 sizeof_partition_entry;
	__le32 partition_entry_array_crc32;
} __attribute__((packed));

typedef struct _gpt_header gpt_header;

struct _gpt_entry_attributes {
	u64 required_to_function: 1;
	u64 reserved: 47;
	u64 type_guid_specific: 16;
};

typedef struct _gpt_entry_attributes gpt_entry_attributes;

struct _gpt_entry {
	efi_guid_t partition_type_guid;
	efi_guid_t unique_partition_guid;
	__le64 starting_lba;
	__le64 ending_lba;
	gpt_entry_attributes attributes;
	efi_char16_t partition_name[36];
};

typedef struct _gpt_entry gpt_entry;

struct _gpt_mbr_record {
	u8 boot_indicator;
	u8 start_head;
	u8 start_sector;
	u8 start_track;
	u8 os_type;
	u8 end_head;
	u8 end_sector;
	u8 end_track;
	__le32 starting_lba;
	__le32 size_in_lba;
};

typedef struct _gpt_mbr_record gpt_mbr_record;

struct _legacy_mbr {
	u8 boot_code[440];
	__le32 unique_mbr_signature;
	__le16 unknown;
	gpt_mbr_record partition_record[4];
	__le16 signature;
} __attribute__((packed));

typedef struct _legacy_mbr legacy_mbr;

struct rq_wait {
	wait_queue_head_t wait;
	atomic_t inflight;
};

struct rq_depth {
	unsigned int max_depth;
	int scale_step;
	bool scaled_max;
	unsigned int queue_depth;
	unsigned int default_depth;
};

typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);

typedef void cleanup_cb_t(struct rq_wait *, void *);

struct rq_qos_wait_data {
	struct wait_queue_entry wq;
	struct task_struct *task;
	struct rq_wait *rqw;
	acquire_inflight_cb_t *cb;
	void *private_data;
	bool got_token;
};

struct request_sense;

struct cdrom_generic_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct request_sense *sense;
	unsigned char data_direction;
	int quiet;
	int timeout;
	void *reserved[1];
};

struct request_sense {
	__u8 error_code: 7;
	__u8 valid: 1;
	__u8 segment_number;
	__u8 sense_key: 4;
	__u8 reserved2: 1;
	__u8 ili: 1;
	__u8 reserved1: 2;
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

struct scsi_ioctl_command {
	unsigned int inlen;
	unsigned int outlen;
	unsigned char data[0];
};

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE = 1,
	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
	SDEV_EVT_FIRST = 1,
	SDEV_EVT_LAST = 8,
	SDEV_EVT_MAXBITS = 9,
};

struct scsi_request {
	unsigned char __cmd[16];
	unsigned char *cmd;
	short unsigned int cmd_len;
	int result;
	unsigned int sense_len;
	unsigned int resid_len;
	int retries;
	void *sense;
};

struct blk_cmd_filter {
	long unsigned int read_ok[4];
	long unsigned int write_ok[4];
};

enum {
	OMAX_SB_LEN = 16,
};

struct bsg_device {
	struct request_queue *queue;
	spinlock_t lock;
	struct hlist_node dev_list;
	refcount_t ref_count;
	char name[20];
	int max_queue;
};

struct bsg_job;

typedef int bsg_job_fn(struct bsg_job *);

struct bsg_buffer {
	unsigned int payload_len;
	int sg_cnt;
	struct scatterlist *sg_list;
};

struct bsg_job {
	struct device *dev;
	struct kref kref;
	unsigned int timeout;
	void *request;
	void *reply;
	unsigned int request_len;
	unsigned int reply_len;
	struct bsg_buffer request_payload;
	struct bsg_buffer reply_payload;
	int result;
	unsigned int reply_payload_rcv_len;
	struct request *bidi_rq;
	struct bio *bidi_bio;
	void *dd_data;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

typedef enum blk_eh_timer_return bsg_timeout_fn(struct request *);

struct bsg_set {
	struct blk_mq_tag_set tag_set;
	bsg_job_fn *job_fn;
	bsg_timeout_fn *timeout_fn;
};

struct blkg_rwstat_sample {
	u64 cnt[5];
};

typedef struct blkcg_policy_data *blkcg_pol_alloc_cpd_fn(gfp_t);

typedef void blkcg_pol_init_cpd_fn(struct blkcg_policy_data *);

typedef void blkcg_pol_free_cpd_fn(struct blkcg_policy_data *);

typedef void blkcg_pol_bind_cpd_fn(struct blkcg_policy_data *);

typedef struct blkg_policy_data *blkcg_pol_alloc_pd_fn(gfp_t, struct request_queue *, struct blkcg *);

typedef void blkcg_pol_init_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_online_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_offline_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_free_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_reset_pd_stats_fn(struct blkg_policy_data *);

typedef size_t blkcg_pol_stat_pd_fn(struct blkg_policy_data *, char *, size_t);

struct blkcg_policy {
	int plid;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	blkcg_pol_alloc_cpd_fn *cpd_alloc_fn;
	blkcg_pol_init_cpd_fn *cpd_init_fn;
	blkcg_pol_free_cpd_fn *cpd_free_fn;
	blkcg_pol_bind_cpd_fn *cpd_bind_fn;
	blkcg_pol_alloc_pd_fn *pd_alloc_fn;
	blkcg_pol_init_pd_fn *pd_init_fn;
	blkcg_pol_online_pd_fn *pd_online_fn;
	blkcg_pol_offline_pd_fn *pd_offline_fn;
	blkcg_pol_free_pd_fn *pd_free_fn;
	blkcg_pol_reset_pd_stats_fn *pd_reset_stats_fn;
	blkcg_pol_stat_pd_fn *pd_stat_fn;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct blkg_conf_ctx {
	struct gendisk *disk;
	struct blkcg_gq *blkg;
	char *body;
};

struct throtl_service_queue {
	struct throtl_service_queue *parent_sq;
	struct list_head queued[2];
	unsigned int nr_queued[2];
	struct rb_root_cached pending_tree;
	unsigned int nr_pending;
	long unsigned int first_pending_disptime;
	struct timer_list pending_timer;
};

struct latency_bucket {
	long unsigned int total_latency;
	int samples;
};

struct avg_latency_bucket {
	long unsigned int latency;
	bool valid;
};

struct throtl_data {
	struct throtl_service_queue service_queue;
	struct request_queue *queue;
	unsigned int nr_queued[2];
	unsigned int throtl_slice;
	struct work_struct dispatch_work;
	unsigned int limit_index;
	bool limit_valid[2];
	long unsigned int low_upgrade_time;
	long unsigned int low_downgrade_time;
	unsigned int scale;
	struct latency_bucket tmp_buckets[18];
	struct avg_latency_bucket avg_buckets[18];
	struct latency_bucket *latency_buckets[2];
	long unsigned int last_calculate_time;
	long unsigned int filtered_latency;
	bool track_bio_latency;
};

struct throtl_grp;

struct throtl_qnode {
	struct list_head node;
	struct bio_list bios;
	struct throtl_grp *tg;
};

struct throtl_grp {
	struct blkg_policy_data pd;
	struct rb_node rb_node;
	struct throtl_data *td;
	struct throtl_service_queue service_queue;
	struct throtl_qnode qnode_on_self[2];
	struct throtl_qnode qnode_on_parent[2];
	long unsigned int disptime;
	unsigned int flags;
	bool has_rules[2];
	uint64_t bps[4];
	uint64_t bps_conf[4];
	unsigned int iops[4];
	unsigned int iops_conf[4];
	uint64_t bytes_disp[2];
	unsigned int io_disp[2];
	long unsigned int last_low_overflow_time[2];
	uint64_t last_bytes_disp[2];
	unsigned int last_io_disp[2];
	long unsigned int last_check_time;
	long unsigned int latency_target;
	long unsigned int latency_target_conf;
	long unsigned int slice_start[2];
	long unsigned int slice_end[2];
	long unsigned int last_finish_time;
	long unsigned int checked_last_finish_time;
	long unsigned int avg_idletime;
	long unsigned int idletime_threshold;
	long unsigned int idletime_threshold_conf;
	unsigned int bio_cnt;
	unsigned int bad_bio_cnt;
	long unsigned int bio_cnt_reset_time;
};

enum tg_state_flags {
	THROTL_TG_PENDING = 1,
	THROTL_TG_WAS_EMPTY = 2,
};

enum {
	LIMIT_LOW = 0,
	LIMIT_MAX = 1,
	LIMIT_CNT = 2,
};

struct blk_iolatency {
	struct rq_qos rqos;
	struct timer_list timer;
	atomic_t enabled;
};

struct iolatency_grp;

struct child_latency_info {
	spinlock_t lock;
	u64 last_scale_event;
	u64 scale_lat;
	u64 nr_samples;
	struct iolatency_grp *scale_grp;
	atomic_t scale_cookie;
};

struct percentile_stats {
	u64 total;
	u64 missed;
};

struct latency_stat {
	union {
		struct percentile_stats ps;
		struct blk_rq_stat rqs;
	};
};

struct iolatency_grp {
	struct blkg_policy_data pd;
	struct latency_stat *stats;
	struct latency_stat cur_stat;
	struct blk_iolatency *blkiolat;
	struct rq_depth rq_depth;
	struct rq_wait rq_wait;
	atomic64_t window_start;
	atomic_t scale_cookie;
	u64 min_lat_nsec;
	u64 cur_win_nsec;
	u64 lat_avg;
	u64 nr_samples;
	bool ssd;
	struct child_latency_info child_lat;
};

enum {
	MILLION = 1000000,
	MIN_PERIOD = 1000,
	MAX_PERIOD = 1000000,
	MARGIN_PCT = 50,
	INUSE_MARGIN_PCT = 10,
	WAITQ_TIMER_MARGIN_PCT = 5,
	VTIME_VALID_DUR = 300000000,
	NR_USAGE_SLOTS = 3,
	MIN_VALID_USAGES = 2,
	HWEIGHT_WHOLE = 65536,
	VTIME_PER_SEC_SHIFT = 37,
	VTIME_PER_SEC = 0,
	VTIME_PER_USEC = 137438,
	VRATE_MIN_PPM = 10000,
	VRATE_MAX_PPM = 100000000,
	VRATE_MIN = 1374,
	VRATE_CLAMP_ADJ_PCT = 4,
	RQ_WAIT_BUSY_PCT = 5,
	UNBUSY_THR_PCT = 75,
	MAX_LAGGING_PERIODS = 10,
	SURPLUS_SCALE_PCT = 125,
	SURPLUS_SCALE_ABS = 1310,
	SURPLUS_MIN_ADJ_DELTA = 1985,
	AUTOP_CYCLE_NSEC = 1410065408,
	IOC_PAGE_SHIFT = 12,
	IOC_PAGE_SIZE = 4096,
	IOC_SECT_TO_PAGE_SHIFT = 3,
	LCOEF_RANDIO_PAGES = 4096,
};

enum ioc_running {
	IOC_IDLE = 0,
	IOC_RUNNING = 1,
	IOC_STOP = 2,
};

enum {
	QOS_ENABLE = 0,
	QOS_CTRL = 1,
	NR_QOS_CTRL_PARAMS = 2,
};

enum {
	QOS_RPPM = 0,
	QOS_RLAT = 1,
	QOS_WPPM = 2,
	QOS_WLAT = 3,
	QOS_MIN = 4,
	QOS_MAX = 5,
	NR_QOS_PARAMS = 6,
};

enum {
	COST_CTRL = 0,
	COST_MODEL = 1,
	NR_COST_CTRL_PARAMS = 2,
};

enum {
	I_LCOEF_RBPS = 0,
	I_LCOEF_RSEQIOPS = 1,
	I_LCOEF_RRANDIOPS = 2,
	I_LCOEF_WBPS = 3,
	I_LCOEF_WSEQIOPS = 4,
	I_LCOEF_WRANDIOPS = 5,
	NR_I_LCOEFS = 6,
};

enum {
	LCOEF_RPAGE = 0,
	LCOEF_RSEQIO = 1,
	LCOEF_RRANDIO = 2,
	LCOEF_WPAGE = 3,
	LCOEF_WSEQIO = 4,
	LCOEF_WRANDIO = 5,
	NR_LCOEFS = 6,
};

enum {
	AUTOP_INVALID = 0,
	AUTOP_HDD = 1,
	AUTOP_SSD_QD1 = 2,
	AUTOP_SSD_DFL = 3,
	AUTOP_SSD_FAST = 4,
};

struct ioc_params {
	u32 qos[6];
	u64 i_lcoefs[6];
	u64 lcoefs[6];
	u32 too_fast_vrate_pct;
	u32 too_slow_vrate_pct;
};

struct ioc_missed {
	u32 nr_met;
	u32 nr_missed;
	u32 last_met;
	u32 last_missed;
};

struct ioc_pcpu_stat {
	struct ioc_missed missed[2];
	u64 rq_wait_ns;
	u64 last_rq_wait_ns;
};

struct ioc {
	struct rq_qos rqos;
	bool enabled;
	struct ioc_params params;
	u32 period_us;
	u32 margin_us;
	u64 vrate_min;
	u64 vrate_max;
	spinlock_t lock;
	struct timer_list timer;
	struct list_head active_iocgs;
	struct ioc_pcpu_stat *pcpu_stat;
	enum ioc_running running;
	atomic64_t vtime_rate;
	seqcount_t period_seqcount;
	u32 period_at;
	u64 period_at_vtime;
	atomic64_t cur_period;
	int busy_level;
	u64 inuse_margin_vtime;
	bool weights_updated;
	atomic_t hweight_gen;
	u64 autop_too_fast_at;
	u64 autop_too_slow_at;
	int autop_idx;
	bool user_qos_params: 1;
	bool user_cost_model: 1;
};

struct ioc_gq {
	struct blkg_policy_data pd;
	struct ioc *ioc;
	u32 cfg_weight;
	u32 weight;
	u32 active;
	u32 inuse;
	u32 last_inuse;
	sector_t cursor;
	atomic64_t vtime;
	atomic64_t done_vtime;
	u64 abs_vdebt;
	u64 last_vtime;
	atomic64_t active_period;
	struct list_head active_list;
	u64 child_active_sum;
	u64 child_inuse_sum;
	int hweight_gen;
	u32 hweight_active;
	u32 hweight_inuse;
	bool has_surplus;
	struct wait_queue_head waitq;
	struct hrtimer waitq_timer;
	struct hrtimer delay_timer;
	int usage_idx;
	u32 usages[3];
	int level;
	struct ioc_gq *ancestors[0];
};

struct ioc_cgrp {
	struct blkcg_policy_data cpd;
	unsigned int dfl_weight;
};

struct ioc_now {
	u64 now_ns;
	u32 now;
	u64 vnow;
	u64 vrate;
};

struct iocg_wait {
	struct wait_queue_entry wait;
	struct bio *bio;
	u64 abs_cost;
	bool committed;
};

struct iocg_wake_ctx {
	struct ioc_gq *iocg;
	u32 hw_inuse;
	s64 vbudget;
};

struct trace_event_raw_iocost_iocg_activate {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u64 vnow;
	u64 vrate;
	u64 last_period;
	u64 cur_period;
	u64 last_vtime;
	u64 vtime;
	u32 weight;
	u32 inuse;
	u64 hweight_active;
	u64 hweight_inuse;
	char __data[0];
};

struct trace_event_raw_iocg_inuse_update {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u32 old_inuse;
	u32 new_inuse;
	u64 old_hweight_inuse;
	u64 new_hweight_inuse;
	char __data[0];
};

struct trace_event_raw_iocost_ioc_vrate_adj {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u64 old_vrate;
	u64 new_vrate;
	int busy_level;
	u32 read_missed_ppm;
	u32 write_missed_ppm;
	u32 rq_wait_pct;
	int nr_lagging;
	int nr_shortages;
	int nr_surpluses;
	char __data[0];
};

struct trace_event_data_offsets_iocost_iocg_activate {
	u32 devname;
	u32 cgroup;
};

struct trace_event_data_offsets_iocg_inuse_update {
	u32 devname;
	u32 cgroup;
};

struct trace_event_data_offsets_iocost_ioc_vrate_adj {
	u32 devname;
};

typedef void (*btf_trace_iocost_iocg_activate)(void *, struct ioc_gq *, const char *, struct ioc_now *, u64, u64, u64);

typedef void (*btf_trace_iocost_inuse_takeback)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_inuse_giveaway)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_inuse_reset)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_ioc_vrate_adj)(void *, struct ioc *, u64, u32 *, u32, int, int, int);

struct deadline_data {
	struct rb_root sort_list[2];
	struct list_head fifo_list[2];
	struct request *next_rq[2];
	unsigned int batching;
	unsigned int starved;
	int fifo_expire[2];
	int fifo_batch;
	int writes_starved;
	int front_merges;
	spinlock_t lock;
	spinlock_t zone_lock;
	struct list_head dispatch;
};

struct trace_event_raw_kyber_latency {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char type[8];
	u8 percentile;
	u8 numerator;
	u8 denominator;
	unsigned int samples;
	char __data[0];
};

struct trace_event_raw_kyber_adjust {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	unsigned int depth;
	char __data[0];
};

struct trace_event_raw_kyber_throttled {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char __data[0];
};

struct trace_event_data_offsets_kyber_latency {};

struct trace_event_data_offsets_kyber_adjust {};

struct trace_event_data_offsets_kyber_throttled {};

typedef void (*btf_trace_kyber_latency)(void *, struct request_queue *, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_kyber_adjust)(void *, struct request_queue *, const char *, unsigned int);

typedef void (*btf_trace_kyber_throttled)(void *, struct request_queue *, const char *);

enum {
	KYBER_READ = 0,
	KYBER_WRITE = 1,
	KYBER_DISCARD = 2,
	KYBER_OTHER = 3,
	KYBER_NUM_DOMAINS = 4,
};

enum {
	KYBER_ASYNC_PERCENT = 75,
};

enum {
	KYBER_LATENCY_SHIFT = 2,
	KYBER_GOOD_BUCKETS = 4,
	KYBER_LATENCY_BUCKETS = 8,
};

enum {
	KYBER_TOTAL_LATENCY = 0,
	KYBER_IO_LATENCY = 1,
};

struct kyber_cpu_latency {
	atomic_t buckets[48];
};

struct kyber_ctx_queue {
	spinlock_t lock;
	struct list_head rq_list[4];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kyber_queue_data {
	struct request_queue *q;
	struct sbitmap_queue domain_tokens[4];
	unsigned int async_depth;
	struct kyber_cpu_latency *cpu_latency;
	struct timer_list timer;
	unsigned int latency_buckets[48];
	long unsigned int latency_timeout[3];
	int domain_p99[3];
	u64 latency_targets[3];
};

struct kyber_hctx_data {
	spinlock_t lock;
	struct list_head rqs[4];
	unsigned int cur_domain;
	unsigned int batching;
	struct kyber_ctx_queue *kcqs;
	struct sbitmap kcq_map[4];
	struct sbq_wait domain_wait[4];
	struct sbq_wait_state *domain_ws[4];
	atomic_t wait_index[4];
};

struct flush_kcq_data {
	struct kyber_hctx_data *khd;
	unsigned int sched_domain;
	struct list_head *list;
};

struct bfq_entity;

struct bfq_service_tree {
	struct rb_root active;
	struct rb_root idle;
	struct bfq_entity *first_idle;
	struct bfq_entity *last_idle;
	u64 vtime;
	long unsigned int wsum;
};

struct bfq_sched_data;

struct bfq_entity {
	struct rb_node rb_node;
	bool on_st;
	u64 start;
	u64 finish;
	struct rb_root *tree;
	u64 min_start;
	int service;
	int budget;
	int dev_weight;
	int weight;
	int new_weight;
	int orig_weight;
	struct bfq_entity *parent;
	struct bfq_sched_data *my_sched_data;
	struct bfq_sched_data *sched_data;
	int prio_changed;
	bool in_groups_with_pending_reqs;
};

struct bfq_sched_data {
	struct bfq_entity *in_service_entity;
	struct bfq_entity *next_in_service;
	struct bfq_service_tree service_tree[3];
	long unsigned int bfq_class_idle_last_service;
};

struct bfq_weight_counter {
	unsigned int weight;
	unsigned int num_active;
	struct rb_node weights_node;
};

struct bfq_ttime {
	u64 last_end_request;
	u64 ttime_total;
	long unsigned int ttime_samples;
	u64 ttime_mean;
};

struct bfq_data;

struct bfq_io_cq;

struct bfq_queue {
	int ref;
	struct bfq_data *bfqd;
	short unsigned int ioprio;
	short unsigned int ioprio_class;
	short unsigned int new_ioprio;
	short unsigned int new_ioprio_class;
	u64 last_serv_time_ns;
	unsigned int inject_limit;
	long unsigned int decrease_time_jif;
	struct bfq_queue *new_bfqq;
	struct rb_node pos_node;
	struct rb_root *pos_root;
	struct rb_root sort_list;
	struct request *next_rq;
	int queued[2];
	int allocated;
	int meta_pending;
	struct list_head fifo;
	struct bfq_entity entity;
	struct bfq_weight_counter *weight_counter;
	int max_budget;
	long unsigned int budget_timeout;
	int dispatched;
	long unsigned int flags;
	struct list_head bfqq_list;
	struct bfq_ttime ttime;
	u32 seek_history;
	struct hlist_node burst_list_node;
	sector_t last_request_pos;
	unsigned int requests_within_timer;
	pid_t pid;
	struct bfq_io_cq *bic;
	long unsigned int wr_cur_max_time;
	long unsigned int soft_rt_next_start;
	long unsigned int last_wr_start_finish;
	unsigned int wr_coeff;
	long unsigned int last_idle_bklogged;
	long unsigned int service_from_backlogged;
	long unsigned int service_from_wr;
	long unsigned int wr_start_at_switch_to_srt;
	long unsigned int split_time;
	long unsigned int first_IO_time;
	u32 max_service_rate;
	struct bfq_queue *waker_bfqq;
	struct hlist_node woken_list_node;
	struct hlist_head woken_list;
};

struct bfq_group;

struct bfq_data {
	struct request_queue *queue;
	struct list_head dispatch;
	struct bfq_group *root_group;
	struct rb_root_cached queue_weights_tree;
	unsigned int num_groups_with_pending_reqs;
	unsigned int busy_queues[3];
	int wr_busy_queues;
	int queued;
	int rq_in_driver;
	bool nonrot_with_queueing;
	int max_rq_in_driver;
	int hw_tag_samples;
	int hw_tag;
	int budgets_assigned;
	struct hrtimer idle_slice_timer;
	struct bfq_queue *in_service_queue;
	sector_t last_position;
	sector_t in_serv_last_pos;
	u64 last_completion;
	struct bfq_queue *last_completed_rq_bfqq;
	u64 last_empty_occupied_ns;
	bool wait_dispatch;
	struct request *waited_rq;
	bool rqs_injected;
	u64 first_dispatch;
	u64 last_dispatch;
	ktime_t last_budget_start;
	ktime_t last_idling_start;
	long unsigned int last_idling_start_jiffies;
	int peak_rate_samples;
	u32 sequential_samples;
	u64 tot_sectors_dispatched;
	u32 last_rq_max_size;
	u64 delta_from_first;
	u32 peak_rate;
	int bfq_max_budget;
	struct list_head active_list;
	struct list_head idle_list;
	u64 bfq_fifo_expire[2];
	unsigned int bfq_back_penalty;
	unsigned int bfq_back_max;
	u32 bfq_slice_idle;
	int bfq_user_max_budget;
	unsigned int bfq_timeout;
	unsigned int bfq_requests_within_timer;
	bool strict_guarantees;
	long unsigned int last_ins_in_burst;
	long unsigned int bfq_burst_interval;
	int burst_size;
	struct bfq_entity *burst_parent_entity;
	long unsigned int bfq_large_burst_thresh;
	bool large_burst;
	struct hlist_head burst_list;
	bool low_latency;
	unsigned int bfq_wr_coeff;
	unsigned int bfq_wr_max_time;
	unsigned int bfq_wr_rt_max_time;
	unsigned int bfq_wr_min_idle_time;
	long unsigned int bfq_wr_min_inter_arr_async;
	unsigned int bfq_wr_max_softrt_rate;
	u64 rate_dur_prod;
	struct bfq_queue oom_bfqq;
	spinlock_t lock;
	struct bfq_io_cq *bio_bic;
	struct bfq_queue *bio_bfqq;
	unsigned int word_depths[4];
};

struct bfq_io_cq {
	struct io_cq icq;
	struct bfq_queue *bfqq[2];
	int ioprio;
	uint64_t blkcg_serial_nr;
	bool saved_has_short_ttime;
	bool saved_IO_bound;
	bool saved_in_large_burst;
	bool was_in_burst_list;
	unsigned int saved_weight;
	long unsigned int saved_wr_coeff;
	long unsigned int saved_last_wr_start_finish;
	long unsigned int saved_wr_start_at_switch_to_srt;
	unsigned int saved_wr_cur_max_time;
	struct bfq_ttime saved_ttime;
};

struct bfqg_stats {};

struct bfq_group {
	struct blkg_policy_data pd;
	char blkg_path[128];
	int ref;
	struct bfq_entity entity;
	struct bfq_sched_data sched_data;
	void *bfqd;
	struct bfq_queue *async_bfqq[16];
	struct bfq_queue *async_idle_bfqq;
	struct bfq_entity *my_entity;
	int active_entities;
	struct rb_root rq_pos_tree;
	struct bfqg_stats stats;
};

enum bfqq_state_flags {
	BFQQF_just_created = 0,
	BFQQF_busy = 1,
	BFQQF_wait_request = 2,
	BFQQF_non_blocking_wait_rq = 3,
	BFQQF_fifo_expire = 4,
	BFQQF_has_short_ttime = 5,
	BFQQF_sync = 6,
	BFQQF_IO_bound = 7,
	BFQQF_in_large_burst = 8,
	BFQQF_softrt_update = 9,
	BFQQF_coop = 10,
	BFQQF_split_coop = 11,
	BFQQF_has_waker = 12,
};

enum bfqq_expiration {
	BFQQE_TOO_IDLE = 0,
	BFQQE_BUDGET_TIMEOUT = 1,
	BFQQE_BUDGET_EXHAUSTED = 2,
	BFQQE_NO_MORE_REQUESTS = 3,
	BFQQE_PREEMPTED = 4,
};

struct bfq_group_data {
	struct blkcg_policy_data pd;
	unsigned int weight;
};

struct cdrom_read_audio {
	union cdrom_addr addr;
	__u8 addr_format;
	int nframes;
	__u8 *buf;
};

struct compat_hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	u32 start;
};

struct compat_cdrom_read_audio {
	union cdrom_addr addr;
	u8 addr_format;
	compat_int_t nframes;
	compat_caddr_t buf;
};

struct compat_cdrom_generic_command {
	unsigned char cmd[12];
	compat_caddr_t buffer;
	compat_uint_t buflen;
	compat_int_t stat;
	compat_caddr_t sense;
	unsigned char data_direction;
	compat_int_t quiet;
	compat_int_t timeout;
	compat_caddr_t reserved[1];
};

struct compat_blkpg_ioctl_arg {
	compat_int_t op;
	compat_int_t flags;
	compat_int_t datalen;
	compat_caddr_t data;
};

enum bip_flags {
	BIP_BLOCK_INTEGRITY = 1,
	BIP_MAPPED_INTEGRITY = 2,
	BIP_CTRL_NOCHECK = 4,
	BIP_DISK_NOCHECK = 8,
	BIP_IP_CHECKSUM = 16,
};

enum blk_integrity_flags {
	BLK_INTEGRITY_VERIFY = 1,
	BLK_INTEGRITY_GENERATE = 2,
	BLK_INTEGRITY_DEVICE_CAPABLE = 4,
	BLK_INTEGRITY_IP_CHECKSUM = 8,
};

struct integrity_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_integrity *, char *);
	ssize_t (*store)(struct blk_integrity *, const char *, size_t);
};

enum t10_dif_type {
	T10_PI_TYPE0_PROTECTION = 0,
	T10_PI_TYPE1_PROTECTION = 1,
	T10_PI_TYPE2_PROTECTION = 2,
	T10_PI_TYPE3_PROTECTION = 3,
};

struct t10_pi_tuple {
	__be16 guard_tag;
	__be16 app_tag;
	__be32 ref_tag;
};

typedef __be16 csum_fn(void *, unsigned int);

struct virtio_device_id {
	__u32 device;
	__u32 vendor;
};

typedef __u16 __virtio16;

typedef __u32 __virtio32;

typedef __u64 __virtio64;

struct vring_desc {
	__virtio64 addr;
	__virtio32 len;
	__virtio16 flags;
	__virtio16 next;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[0];
};

struct vring_used_elem {
	__virtio32 id;
	__virtio32 len;
};

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	struct vring_used_elem ring[0];
};

struct vring {
	unsigned int num;
	struct vring_desc *desc;
	struct vring_avail *avail;
	struct vring_used *used;
};

struct vringh {
	bool little_endian;
	bool event_indices;
	bool weak_barriers;
	u16 last_avail_idx;
	u16 last_used_idx;
	u32 completed;
	struct vring vring;
	void (*notify)(struct vringh *);
};

struct virtio_device;

typedef void vrh_callback_t(struct virtio_device *, struct vringh *);

struct virtio_config_ops;

struct vringh_config_ops;

struct virtio_device {
	int index;
	bool failed;
	bool config_enabled;
	bool config_change_pending;
	spinlock_t config_lock;
	struct device dev;
	struct virtio_device_id id;
	const struct virtio_config_ops *config;
	const struct vringh_config_ops *vringh_config;
	struct list_head vqs;
	u64 features;
	void *priv;
};

struct vringh_config_ops {
	int (*find_vrhs)(struct virtio_device *, unsigned int, struct vringh **, vrh_callback_t **);
	void (*del_vrhs)(struct virtio_device *);
};

struct virtqueue {
	struct list_head list;
	void (*callback)(struct virtqueue *);
	const char *name;
	struct virtio_device *vdev;
	unsigned int index;
	unsigned int num_free;
	void *priv;
};

typedef void vq_callback_t(struct virtqueue *);

struct virtio_config_ops {
	void (*get)(struct virtio_device *, unsigned int, void *, unsigned int);
	void (*set)(struct virtio_device *, unsigned int, const void *, unsigned int);
	u32 (*generation)(struct virtio_device *);
	u8 (*get_status)(struct virtio_device *);
	void (*set_status)(struct virtio_device *, u8);
	void (*reset)(struct virtio_device *);
	int (*find_vqs)(struct virtio_device *, unsigned int, struct virtqueue **, vq_callback_t **, const char * const *, const bool *, struct irq_affinity *);
	void (*del_vqs)(struct virtio_device *);
	u64 (*get_features)(struct virtio_device *);
	int (*finalize_features)(struct virtio_device *);
	const char * (*bus_name)(struct virtio_device *);
	int (*set_vq_affinity)(struct virtqueue *, const struct cpumask *);
	const struct cpumask * (*get_vq_affinity)(struct virtio_device *, int);
};

struct irq_poll;

typedef int irq_poll_fn(struct irq_poll *, int);

struct irq_poll {
	struct list_head list;
	long unsigned int state;
	int weight;
	irq_poll_fn *poll;
};

struct dim_sample {
	ktime_t time;
	u32 pkt_ctr;
	u32 byte_ctr;
	u16 event_ctr;
	u32 comp_ctr;
};

struct dim_stats {
	int ppms;
	int bpms;
	int epms;
	int cpms;
	int cpe_ratio;
};

struct dim {
	u8 state;
	struct dim_stats prev_stats;
	struct dim_sample start_sample;
	struct dim_sample measuring_sample;
	struct work_struct work;
	void *priv;
	u8 profile_ix;
	u8 mode;
	u8 tune_state;
	u8 steps_right;
	u8 steps_left;
	u8 tired;
};

enum rdma_nl_counter_mode {
	RDMA_COUNTER_MODE_NONE = 0,
	RDMA_COUNTER_MODE_AUTO = 1,
	RDMA_COUNTER_MODE_MANUAL = 2,
	RDMA_COUNTER_MODE_MAX = 3,
};

enum rdma_nl_counter_mask {
	RDMA_COUNTER_MASK_QP_TYPE = 1,
};

enum rdma_restrack_type {
	RDMA_RESTRACK_PD = 0,
	RDMA_RESTRACK_CQ = 1,
	RDMA_RESTRACK_QP = 2,
	RDMA_RESTRACK_CM_ID = 3,
	RDMA_RESTRACK_MR = 4,
	RDMA_RESTRACK_CTX = 5,
	RDMA_RESTRACK_COUNTER = 6,
	RDMA_RESTRACK_MAX = 7,
};

struct rdma_restrack_entry {
	bool valid;
	struct kref kref;
	struct completion comp;
	struct task_struct *task;
	const char *kern_name;
	enum rdma_restrack_type type;
	bool user;
	u32 id;
};

struct rdma_link_ops {
	struct list_head list;
	const char *type;
	int (*newlink)(const char *, struct net_device *);
};

struct auto_mode_param {
	int qp_type;
};

struct rdma_counter_mode {
	enum rdma_nl_counter_mode mode;
	enum rdma_nl_counter_mask mask;
	struct auto_mode_param param;
};

struct rdma_hw_stats;

struct rdma_port_counter {
	struct rdma_counter_mode mode;
	struct rdma_hw_stats *hstats;
	unsigned int num_counters;
	struct mutex lock;
};

struct rdma_hw_stats {
	struct mutex lock;
	long unsigned int timestamp;
	long unsigned int lifespan;
	const char * const *names;
	int num_counters;
	u64 value[0];
};

struct ib_device;

struct rdma_counter {
	struct rdma_restrack_entry res;
	struct ib_device *device;
	uint32_t id;
	struct kref kref;
	struct rdma_counter_mode mode;
	struct mutex lock;
	struct rdma_hw_stats *stats;
	u8 port;
};

enum rdma_driver_id {
	RDMA_DRIVER_UNKNOWN = 0,
	RDMA_DRIVER_MLX5 = 1,
	RDMA_DRIVER_MLX4 = 2,
	RDMA_DRIVER_CXGB3 = 3,
	RDMA_DRIVER_CXGB4 = 4,
	RDMA_DRIVER_MTHCA = 5,
	RDMA_DRIVER_BNXT_RE = 6,
	RDMA_DRIVER_OCRDMA = 7,
	RDMA_DRIVER_NES = 8,
	RDMA_DRIVER_I40IW = 9,
	RDMA_DRIVER_VMW_PVRDMA = 10,
	RDMA_DRIVER_QEDR = 11,
	RDMA_DRIVER_HNS = 12,
	RDMA_DRIVER_USNIC = 13,
	RDMA_DRIVER_RXE = 14,
	RDMA_DRIVER_HFI1 = 15,
	RDMA_DRIVER_QIB = 16,
	RDMA_DRIVER_EFA = 17,
	RDMA_DRIVER_SIW = 18,
};

enum ib_cq_notify_flags {
	IB_CQ_SOLICITED = 1,
	IB_CQ_NEXT_COMP = 2,
	IB_CQ_SOLICITED_MASK = 3,
	IB_CQ_REPORT_MISSED_EVENTS = 4,
};

struct ib_mad_hdr;

enum rdma_link_layer {
	IB_LINK_LAYER_UNSPECIFIED = 0,
	IB_LINK_LAYER_INFINIBAND = 1,
	IB_LINK_LAYER_ETHERNET = 2,
};

enum rdma_netdev_t {
	RDMA_NETDEV_OPA_VNIC = 0,
	RDMA_NETDEV_IPOIB = 1,
};

enum ib_srq_attr_mask {
	IB_SRQ_MAX_WR = 1,
	IB_SRQ_LIMIT = 2,
};

enum ib_mr_type {
	IB_MR_TYPE_MEM_REG = 0,
	IB_MR_TYPE_SG_GAPS = 1,
	IB_MR_TYPE_DM = 2,
	IB_MR_TYPE_USER = 3,
	IB_MR_TYPE_DMA = 4,
	IB_MR_TYPE_INTEGRITY = 5,
};

enum ib_uverbs_advise_mr_advice {
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = 0,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = 1,
};

struct uverbs_attr_bundle;

enum ib_mw_type {
	IB_MW_TYPE_1 = 1,
	IB_MW_TYPE_2 = 2,
};

struct ib_umem_odp;

struct iw_cm_id;

struct iw_cm_conn_param;

struct ib_qp;

struct ib_send_wr;

struct ib_recv_wr;

struct ib_cq;

struct ib_wc;

struct ib_srq;

struct ib_grh;

struct ib_device_attr;

struct ib_udata;

struct ib_device_modify;

struct ib_port_attr;

struct ib_port_modify;

struct ib_port_immutable;

struct rdma_netdev_alloc_params;

union ib_gid;

struct ib_gid_attr;

struct ib_ucontext;

struct ib_pd;

struct ib_ah;

struct rdma_ah_attr;

struct ib_srq_init_attr;

struct ib_srq_attr;

struct ib_qp_init_attr;

struct ib_qp_attr;

struct ib_cq_init_attr;

struct ib_mr;

struct ib_sge;

struct ib_mr_status;

struct ib_mw;

struct ib_fmr;

struct ib_fmr_attr;

struct ib_xrcd;

struct ib_flow;

struct ib_flow_attr;

struct ib_flow_action;

struct ib_flow_action_attrs_esp;

struct ib_wq;

struct ib_wq_init_attr;

struct ib_wq_attr;

struct ib_rwq_ind_table;

struct ib_rwq_ind_table_init_attr;

struct ib_dm;

struct ib_dm_alloc_attr;

struct ib_dm_mr_attr;

struct ib_counters;

struct ib_counters_read_attr;

struct ib_device_ops {
	struct module *owner;
	enum rdma_driver_id driver_id;
	u32 uverbs_abi_ver;
	unsigned int uverbs_no_driver_id_binding: 1;
	int (*post_send)(struct ib_qp *, const struct ib_send_wr *, const struct ib_send_wr **);
	int (*post_recv)(struct ib_qp *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	void (*drain_rq)(struct ib_qp *);
	void (*drain_sq)(struct ib_qp *);
	int (*poll_cq)(struct ib_cq *, int, struct ib_wc *);
	int (*peek_cq)(struct ib_cq *, int);
	int (*req_notify_cq)(struct ib_cq *, enum ib_cq_notify_flags);
	int (*req_ncomp_notif)(struct ib_cq *, int);
	int (*post_srq_recv)(struct ib_srq *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	int (*process_mad)(struct ib_device *, int, u8, const struct ib_wc *, const struct ib_grh *, const struct ib_mad_hdr *, size_t, struct ib_mad_hdr *, size_t *, u16 *);
	int (*query_device)(struct ib_device *, struct ib_device_attr *, struct ib_udata *);
	int (*modify_device)(struct ib_device *, int, struct ib_device_modify *);
	void (*get_dev_fw_str)(struct ib_device *, char *);
	const struct cpumask * (*get_vector_affinity)(struct ib_device *, int);
	int (*query_port)(struct ib_device *, u8, struct ib_port_attr *);
	int (*modify_port)(struct ib_device *, u8, int, struct ib_port_modify *);
	int (*get_port_immutable)(struct ib_device *, u8, struct ib_port_immutable *);
	enum rdma_link_layer (*get_link_layer)(struct ib_device *, u8);
	struct net_device * (*get_netdev)(struct ib_device *, u8);
	struct net_device * (*alloc_rdma_netdev)(struct ib_device *, u8, enum rdma_netdev_t, const char *, unsigned char, void (*)(struct net_device *));
	int (*rdma_netdev_get_params)(struct ib_device *, u8, enum rdma_netdev_t, struct rdma_netdev_alloc_params *);
	int (*query_gid)(struct ib_device *, u8, int, union ib_gid *);
	int (*add_gid)(const struct ib_gid_attr *, void **);
	int (*del_gid)(const struct ib_gid_attr *, void **);
	int (*query_pkey)(struct ib_device *, u8, u16, u16 *);
	int (*alloc_ucontext)(struct ib_ucontext *, struct ib_udata *);
	void (*dealloc_ucontext)(struct ib_ucontext *);
	int (*mmap)(struct ib_ucontext *, struct vm_area_struct *);
	void (*disassociate_ucontext)(struct ib_ucontext *);
	int (*alloc_pd)(struct ib_pd *, struct ib_udata *);
	void (*dealloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*create_ah)(struct ib_ah *, struct rdma_ah_attr *, u32, struct ib_udata *);
	int (*modify_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*query_ah)(struct ib_ah *, struct rdma_ah_attr *);
	void (*destroy_ah)(struct ib_ah *, u32);
	int (*create_srq)(struct ib_srq *, struct ib_srq_init_attr *, struct ib_udata *);
	int (*modify_srq)(struct ib_srq *, struct ib_srq_attr *, enum ib_srq_attr_mask, struct ib_udata *);
	int (*query_srq)(struct ib_srq *, struct ib_srq_attr *);
	void (*destroy_srq)(struct ib_srq *, struct ib_udata *);
	struct ib_qp * (*create_qp)(struct ib_pd *, struct ib_qp_init_attr *, struct ib_udata *);
	int (*modify_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_udata *);
	int (*query_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_qp_init_attr *);
	int (*destroy_qp)(struct ib_qp *, struct ib_udata *);
	int (*create_cq)(struct ib_cq *, const struct ib_cq_init_attr *, struct ib_udata *);
	int (*modify_cq)(struct ib_cq *, u16, u16);
	void (*destroy_cq)(struct ib_cq *, struct ib_udata *);
	int (*resize_cq)(struct ib_cq *, int, struct ib_udata *);
	struct ib_mr * (*get_dma_mr)(struct ib_pd *, int);
	struct ib_mr * (*reg_user_mr)(struct ib_pd *, u64, u64, u64, int, struct ib_udata *);
	int (*rereg_user_mr)(struct ib_mr *, int, u64, u64, u64, int, struct ib_pd *, struct ib_udata *);
	int (*dereg_mr)(struct ib_mr *, struct ib_udata *);
	struct ib_mr * (*alloc_mr)(struct ib_pd *, enum ib_mr_type, u32, struct ib_udata *);
	struct ib_mr * (*alloc_mr_integrity)(struct ib_pd *, u32, u32);
	int (*advise_mr)(struct ib_pd *, enum ib_uverbs_advise_mr_advice, u32, struct ib_sge *, u32, struct uverbs_attr_bundle *);
	int (*map_mr_sg)(struct ib_mr *, struct scatterlist *, int, unsigned int *);
	int (*check_mr_status)(struct ib_mr *, u32, struct ib_mr_status *);
	struct ib_mw * (*alloc_mw)(struct ib_pd *, enum ib_mw_type, struct ib_udata *);
	int (*dealloc_mw)(struct ib_mw *);
	struct ib_fmr * (*alloc_fmr)(struct ib_pd *, int, struct ib_fmr_attr *);
	int (*map_phys_fmr)(struct ib_fmr *, u64 *, int, u64);
	int (*unmap_fmr)(struct list_head *);
	int (*dealloc_fmr)(struct ib_fmr *);
	void (*invalidate_range)(struct ib_umem_odp *, long unsigned int, long unsigned int);
	int (*attach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*detach_mcast)(struct ib_qp *, union ib_gid *, u16);
	struct ib_xrcd * (*alloc_xrcd)(struct ib_device *, struct ib_udata *);
	int (*dealloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	struct ib_flow * (*create_flow)(struct ib_qp *, struct ib_flow_attr *, int, struct ib_udata *);
	int (*destroy_flow)(struct ib_flow *);
	struct ib_flow_action * (*create_flow_action_esp)(struct ib_device *, const struct ib_flow_action_attrs_esp *, struct uverbs_attr_bundle *);
	int (*destroy_flow_action)(struct ib_flow_action *);
	int (*modify_flow_action_esp)(struct ib_flow_action *, const struct ib_flow_action_attrs_esp *, struct uverbs_attr_bundle *);
	int (*set_vf_link_state)(struct ib_device *, int, u8, int);
	int (*get_vf_config)(struct ib_device *, int, u8, struct ifla_vf_info *);
	int (*get_vf_stats)(struct ib_device *, int, u8, struct ifla_vf_stats *);
	int (*set_vf_guid)(struct ib_device *, int, u8, u64, int);
	struct ib_wq * (*create_wq)(struct ib_pd *, struct ib_wq_init_attr *, struct ib_udata *);
	void (*destroy_wq)(struct ib_wq *, struct ib_udata *);
	int (*modify_wq)(struct ib_wq *, struct ib_wq_attr *, u32, struct ib_udata *);
	struct ib_rwq_ind_table * (*create_rwq_ind_table)(struct ib_device *, struct ib_rwq_ind_table_init_attr *, struct ib_udata *);
	int (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *);
	struct ib_dm * (*alloc_dm)(struct ib_device *, struct ib_ucontext *, struct ib_dm_alloc_attr *, struct uverbs_attr_bundle *);
	int (*dealloc_dm)(struct ib_dm *, struct uverbs_attr_bundle *);
	struct ib_mr * (*reg_dm_mr)(struct ib_pd *, struct ib_dm *, struct ib_dm_mr_attr *, struct uverbs_attr_bundle *);
	struct ib_counters * (*create_counters)(struct ib_device *, struct uverbs_attr_bundle *);
	int (*destroy_counters)(struct ib_counters *);
	int (*read_counters)(struct ib_counters *, struct ib_counters_read_attr *, struct uverbs_attr_bundle *);
	int (*map_mr_sg_pi)(struct ib_mr *, struct scatterlist *, int, unsigned int *, struct scatterlist *, int, unsigned int *);
	struct rdma_hw_stats * (*alloc_hw_stats)(struct ib_device *, u8);
	int (*get_hw_stats)(struct ib_device *, struct rdma_hw_stats *, u8, int);
	int (*init_port)(struct ib_device *, u8, struct kobject *);
	int (*fill_res_entry)(struct sk_buff *, struct rdma_restrack_entry *);
	int (*enable_driver)(struct ib_device *);
	void (*dealloc_driver)(struct ib_device *);
	void (*iw_add_ref)(struct ib_qp *);
	void (*iw_rem_ref)(struct ib_qp *);
	struct ib_qp * (*iw_get_qp)(struct ib_device *, int);
	int (*iw_connect)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_accept)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_reject)(struct iw_cm_id *, const void *, u8);
	int (*iw_create_listen)(struct iw_cm_id *, int);
	int (*iw_destroy_listen)(struct iw_cm_id *);
	int (*counter_bind_qp)(struct rdma_counter *, struct ib_qp *);
	int (*counter_unbind_qp)(struct ib_qp *);
	int (*counter_dealloc)(struct rdma_counter *);
	struct rdma_hw_stats * (*counter_alloc_stats)(struct rdma_counter *);
	int (*counter_update_stats)(struct rdma_counter *);
	size_t size_ib_ah;
	size_t size_ib_cq;
	size_t size_ib_pd;
	size_t size_ib_srq;
	size_t size_ib_ucontext;
};

struct ib_cache {
	rwlock_t lock;
};

struct ib_core_device {
	struct device dev;
	possible_net_t rdma_net;
	struct kobject *ports_kobj;
	struct list_head port_list;
	struct ib_device *owner;
};

enum ib_atomic_cap {
	IB_ATOMIC_NONE = 0,
	IB_ATOMIC_HCA = 1,
	IB_ATOMIC_GLOB = 2,
};

struct ib_odp_caps {
	uint64_t general_caps;
	struct {
		uint32_t rc_odp_caps;
		uint32_t uc_odp_caps;
		uint32_t ud_odp_caps;
		uint32_t xrc_odp_caps;
	} per_transport_caps;
};

struct ib_rss_caps {
	u32 supported_qpts;
	u32 max_rwq_indirection_tables;
	u32 max_rwq_indirection_table_size;
};

struct ib_tm_caps {
	u32 max_rndv_hdr_size;
	u32 max_num_tags;
	u32 flags;
	u32 max_ops;
	u32 max_sge;
};

struct ib_cq_caps {
	u16 max_cq_moderation_count;
	u16 max_cq_moderation_period;
};

struct ib_device_attr {
	u64 fw_ver;
	__be64 sys_image_guid;
	u64 max_mr_size;
	u64 page_size_cap;
	u32 vendor_id;
	u32 vendor_part_id;
	u32 hw_ver;
	int max_qp;
	int max_qp_wr;
	u64 device_cap_flags;
	int max_send_sge;
	int max_recv_sge;
	int max_sge_rd;
	int max_cq;
	int max_cqe;
	int max_mr;
	int max_pd;
	int max_qp_rd_atom;
	int max_ee_rd_atom;
	int max_res_rd_atom;
	int max_qp_init_rd_atom;
	int max_ee_init_rd_atom;
	enum ib_atomic_cap atomic_cap;
	enum ib_atomic_cap masked_atomic_cap;
	int max_ee;
	int max_rdd;
	int max_mw;
	int max_raw_ipv6_qp;
	int max_raw_ethy_qp;
	int max_mcast_grp;
	int max_mcast_qp_attach;
	int max_total_mcast_qp_attach;
	int max_ah;
	int max_fmr;
	int max_map_per_fmr;
	int max_srq;
	int max_srq_wr;
	int max_srq_sge;
	unsigned int max_fast_reg_page_list_len;
	unsigned int max_pi_fast_reg_page_list_len;
	u16 max_pkeys;
	u8 local_ca_ack_delay;
	int sig_prot_cap;
	int sig_guard_cap;
	struct ib_odp_caps odp_caps;
	uint64_t timestamp_mask;
	uint64_t hca_core_clock;
	struct ib_rss_caps rss_caps;
	u32 max_wq_type_rq;
	u32 raw_packet_caps;
	struct ib_tm_caps tm_caps;
	struct ib_cq_caps cq_caps;
	u64 max_dm_size;
};

struct rdma_restrack_root;

struct uapi_definition;

struct ib_port_data;

struct ib_device {
	struct device *dma_device;
	struct ib_device_ops ops;
	char name[64];
	struct callback_head callback_head;
	struct list_head event_handler_list;
	struct rw_semaphore event_handler_rwsem;
	spinlock_t event_handler_lock;
	struct rw_semaphore client_data_rwsem;
	struct xarray client_data;
	struct mutex unregistration_lock;
	struct ib_cache cache;
	struct ib_port_data *port_data;
	int num_comp_vectors;
	union {
		struct device dev;
		struct ib_core_device coredev;
	};
	const struct attribute_group *groups[3];
	u64 uverbs_cmd_mask;
	u64 uverbs_ex_cmd_mask;
	char node_desc[64];
	__be64 node_guid;
	u32 local_dma_lkey;
	u16 is_switch: 1;
	u16 kverbs_provider: 1;
	u16 use_cq_dim: 1;
	u8 node_type;
	u8 phys_port_cnt;
	struct ib_device_attr attrs;
	struct attribute_group *hw_stats_ag;
	struct rdma_hw_stats *hw_stats;
	u32 index;
	struct rdma_restrack_root *res;
	const struct uapi_definition *driver_def;
	refcount_t refcount;
	struct completion unreg_completion;
	struct work_struct unregistration_work;
	const struct rdma_link_ops *link_ops;
	struct mutex compat_devs_mutex;
	struct xarray compat_devs;
	char iw_ifname[16];
	u32 iw_driver_flags;
};

enum ib_signature_type {
	IB_SIG_TYPE_NONE = 0,
	IB_SIG_TYPE_T10_DIF = 1,
};

enum ib_t10_dif_bg_type {
	IB_T10DIF_CRC = 0,
	IB_T10DIF_CSUM = 1,
};

struct ib_t10_dif_domain {
	enum ib_t10_dif_bg_type bg_type;
	u16 pi_interval;
	u16 bg;
	u16 app_tag;
	u32 ref_tag;
	bool ref_remap;
	bool app_escape;
	bool ref_escape;
	u16 apptag_check_mask;
};

struct ib_sig_domain {
	enum ib_signature_type sig_type;
	union {
		struct ib_t10_dif_domain dif;
	} sig;
};

struct ib_sig_attrs {
	u8 check_mask;
	struct ib_sig_domain mem;
	struct ib_sig_domain wire;
	int meta_length;
};

enum ib_sig_err_type {
	IB_SIG_BAD_GUARD = 0,
	IB_SIG_BAD_REFTAG = 1,
	IB_SIG_BAD_APPTAG = 2,
};

struct ib_sig_err {
	enum ib_sig_err_type err_type;
	u32 expected;
	u32 actual;
	u64 sig_err_offset;
	u32 key;
};

enum ib_uverbs_flow_action_esp_keymat {
	IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM = 0,
};

struct ib_uverbs_flow_action_esp_keymat_aes_gcm {
	__u64 iv;
	__u32 iv_algo;
	__u32 salt;
	__u32 icv_len;
	__u32 key_len;
	__u32 aes_key[8];
};

enum ib_uverbs_flow_action_esp_replay {
	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE = 0,
	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP = 1,
};

struct ib_uverbs_flow_action_esp_replay_bmp {
	__u32 size;
};

union ib_gid {
	u8 raw[16];
	struct {
		__be64 subnet_prefix;
		__be64 interface_id;
	} global;
};

enum ib_gid_type {
	IB_GID_TYPE_IB = 0,
	IB_GID_TYPE_ROCE = 0,
	IB_GID_TYPE_ROCE_UDP_ENCAP = 1,
	IB_GID_TYPE_SIZE = 2,
};

struct ib_gid_attr {
	struct net_device *ndev;
	struct ib_device *device;
	union ib_gid gid;
	enum ib_gid_type gid_type;
	u16 index;
	u8 port_num;
};

struct ib_cq_init_attr {
	unsigned int cqe;
	u32 comp_vector;
	u32 flags;
};

struct ib_dm_mr_attr {
	u64 length;
	u64 offset;
	u32 access_flags;
};

struct ib_dm_alloc_attr {
	u64 length;
	u32 alignment;
	u32 flags;
};

enum ib_mtu {
	IB_MTU_256 = 1,
	IB_MTU_512 = 2,
	IB_MTU_1024 = 3,
	IB_MTU_2048 = 4,
	IB_MTU_4096 = 5,
};

enum ib_port_state {
	IB_PORT_NOP = 0,
	IB_PORT_DOWN = 1,
	IB_PORT_INIT = 2,
	IB_PORT_ARMED = 3,
	IB_PORT_ACTIVE = 4,
	IB_PORT_ACTIVE_DEFER = 5,
};

struct ib_port_attr {
	u64 subnet_prefix;
	enum ib_port_state state;
	enum ib_mtu max_mtu;
	enum ib_mtu active_mtu;
	int gid_tbl_len;
	unsigned int ip_gids: 1;
	u32 port_cap_flags;
	u32 max_msg_sz;
	u32 bad_pkey_cntr;
	u32 qkey_viol_cntr;
	u16 pkey_tbl_len;
	u32 sm_lid;
	u32 lid;
	u8 lmc;
	u8 max_vl_num;
	u8 sm_sl;
	u8 subnet_timeout;
	u8 init_type_reply;
	u8 active_width;
	u8 active_speed;
	u8 phys_state;
	u16 port_cap_flags2;
};

struct ib_device_modify {
	u64 sys_image_guid;
	char node_desc[64];
};

struct ib_port_modify {
	u32 set_port_cap_mask;
	u32 clr_port_cap_mask;
	u8 init_type;
};

enum ib_event_type {
	IB_EVENT_CQ_ERR = 0,
	IB_EVENT_QP_FATAL = 1,
	IB_EVENT_QP_REQ_ERR = 2,
	IB_EVENT_QP_ACCESS_ERR = 3,
	IB_EVENT_COMM_EST = 4,
	IB_EVENT_SQ_DRAINED = 5,
	IB_EVENT_PATH_MIG = 6,
	IB_EVENT_PATH_MIG_ERR = 7,
	IB_EVENT_DEVICE_FATAL = 8,
	IB_EVENT_PORT_ACTIVE = 9,
	IB_EVENT_PORT_ERR = 10,
	IB_EVENT_LID_CHANGE = 11,
	IB_EVENT_PKEY_CHANGE = 12,
	IB_EVENT_SM_CHANGE = 13,
	IB_EVENT_SRQ_ERR = 14,
	IB_EVENT_SRQ_LIMIT_REACHED = 15,
	IB_EVENT_QP_LAST_WQE_REACHED = 16,
	IB_EVENT_CLIENT_REREGISTER = 17,
	IB_EVENT_GID_CHANGE = 18,
	IB_EVENT_WQ_FATAL = 19,
};

typedef void (*ib_comp_handler)(struct ib_cq *, void *);

enum ib_poll_context {
	IB_POLL_DIRECT = 0,
	IB_POLL_SOFTIRQ = 1,
	IB_POLL_WORKQUEUE = 2,
	IB_POLL_UNBOUND_WORKQUEUE = 3,
};

struct ib_uobject;

struct ib_event;

struct ib_cq {
	struct ib_device *device;
	struct ib_uobject *uobject;
	ib_comp_handler comp_handler;
	void (*event_handler)(struct ib_event *, void *);
	void *cq_context;
	int cqe;
	atomic_t usecnt;
	enum ib_poll_context poll_ctx;
	struct ib_wc *wc;
	union {
		struct irq_poll iop;
		struct work_struct work;
	};
	struct workqueue_struct *comp_wq;
	struct dim *dim;
	struct rdma_restrack_entry res;
};

enum ib_qp_type {
	IB_QPT_SMI = 0,
	IB_QPT_GSI = 1,
	IB_QPT_RC = 2,
	IB_QPT_UC = 3,
	IB_QPT_UD = 4,
	IB_QPT_RAW_IPV6 = 5,
	IB_QPT_RAW_ETHERTYPE = 6,
	IB_QPT_RAW_PACKET = 8,
	IB_QPT_XRC_INI = 9,
	IB_QPT_XRC_TGT = 10,
	IB_QPT_MAX = 11,
	IB_QPT_DRIVER = 255,
	IB_QPT_RESERVED1 = 4096,
	IB_QPT_RESERVED2 = 4097,
	IB_QPT_RESERVED3 = 4098,
	IB_QPT_RESERVED4 = 4099,
	IB_QPT_RESERVED5 = 4100,
	IB_QPT_RESERVED6 = 4101,
	IB_QPT_RESERVED7 = 4102,
	IB_QPT_RESERVED8 = 4103,
	IB_QPT_RESERVED9 = 4104,
	IB_QPT_RESERVED10 = 4105,
};

struct ib_qp_security;

struct ib_qp {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	spinlock_t mr_lock;
	int mrs_used;
	struct list_head rdma_mrs;
	struct list_head sig_mrs;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct list_head xrcd_list;
	atomic_t usecnt;
	struct list_head open_list;
	struct ib_qp *real_qp;
	struct ib_uobject *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	const struct ib_gid_attr *av_sgid_attr;
	const struct ib_gid_attr *alt_path_sgid_attr;
	u32 qp_num;
	u32 max_write_sge;
	u32 max_read_sge;
	enum ib_qp_type qp_type;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	struct ib_qp_security *qp_sec;
	u8 port;
	bool integrity_en;
	struct rdma_restrack_entry res;
	struct rdma_counter *counter;
};

enum ib_srq_type {
	IB_SRQT_BASIC = 0,
	IB_SRQT_XRC = 1,
	IB_SRQT_TM = 2,
};

struct ib_srq {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	enum ib_srq_type srq_type;
	atomic_t usecnt;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
				u32 srq_num;
			} xrc;
		};
	} ext;
};

enum ib_wq_state {
	IB_WQS_RESET = 0,
	IB_WQS_RDY = 1,
	IB_WQS_ERR = 2,
};

enum ib_wq_type {
	IB_WQT_RQ = 0,
};

struct ib_wq {
	struct ib_device *device;
	struct ib_uobject *uobject;
	void *wq_context;
	void (*event_handler)(struct ib_event *, void *);
	struct ib_pd *pd;
	struct ib_cq *cq;
	u32 wq_num;
	enum ib_wq_state state;
	enum ib_wq_type wq_type;
	atomic_t usecnt;
};

struct ib_event {
	struct ib_device *device;
	union {
		struct ib_cq *cq;
		struct ib_qp *qp;
		struct ib_srq *srq;
		struct ib_wq *wq;
		u8 port_num;
	} element;
	enum ib_event_type event;
};

struct ib_global_route {
	const struct ib_gid_attr *sgid_attr;
	union ib_gid dgid;
	u32 flow_label;
	u8 sgid_index;
	u8 hop_limit;
	u8 traffic_class;
};

struct ib_grh {
	__be32 version_tclass_flow;
	__be16 paylen;
	u8 next_hdr;
	u8 hop_limit;
	union ib_gid sgid;
	union ib_gid dgid;
};

struct ib_mr_status {
	u32 fail_status;
	struct ib_sig_err sig_err;
};

enum rdma_ah_attr_type {
	RDMA_AH_ATTR_TYPE_UNDEFINED = 0,
	RDMA_AH_ATTR_TYPE_IB = 1,
	RDMA_AH_ATTR_TYPE_ROCE = 2,
	RDMA_AH_ATTR_TYPE_OPA = 3,
};

struct ib_ah_attr {
	u16 dlid;
	u8 src_path_bits;
};

struct roce_ah_attr {
	u8 dmac[6];
};

struct opa_ah_attr {
	u32 dlid;
	u8 src_path_bits;
	bool make_grd;
};

struct rdma_ah_attr {
	struct ib_global_route grh;
	u8 sl;
	u8 static_rate;
	u8 port_num;
	u8 ah_flags;
	enum rdma_ah_attr_type type;
	union {
		struct ib_ah_attr ib;
		struct roce_ah_attr roce;
		struct opa_ah_attr opa;
	};
};

enum ib_wc_status {
	IB_WC_SUCCESS = 0,
	IB_WC_LOC_LEN_ERR = 1,
	IB_WC_LOC_QP_OP_ERR = 2,
	IB_WC_LOC_EEC_OP_ERR = 3,
	IB_WC_LOC_PROT_ERR = 4,
	IB_WC_WR_FLUSH_ERR = 5,
	IB_WC_MW_BIND_ERR = 6,
	IB_WC_BAD_RESP_ERR = 7,
	IB_WC_LOC_ACCESS_ERR = 8,
	IB_WC_REM_INV_REQ_ERR = 9,
	IB_WC_REM_ACCESS_ERR = 10,
	IB_WC_REM_OP_ERR = 11,
	IB_WC_RETRY_EXC_ERR = 12,
	IB_WC_RNR_RETRY_EXC_ERR = 13,
	IB_WC_LOC_RDD_VIOL_ERR = 14,
	IB_WC_REM_INV_RD_REQ_ERR = 15,
	IB_WC_REM_ABORT_ERR = 16,
	IB_WC_INV_EECN_ERR = 17,
	IB_WC_INV_EEC_STATE_ERR = 18,
	IB_WC_FATAL_ERR = 19,
	IB_WC_RESP_TIMEOUT_ERR = 20,
	IB_WC_GENERAL_ERR = 21,
};

enum ib_wc_opcode {
	IB_WC_SEND = 0,
	IB_WC_RDMA_WRITE = 1,
	IB_WC_RDMA_READ = 2,
	IB_WC_COMP_SWAP = 3,
	IB_WC_FETCH_ADD = 4,
	IB_WC_LSO = 5,
	IB_WC_LOCAL_INV = 6,
	IB_WC_REG_MR = 7,
	IB_WC_MASKED_COMP_SWAP = 8,
	IB_WC_MASKED_FETCH_ADD = 9,
	IB_WC_RECV = 128,
	IB_WC_RECV_RDMA_WITH_IMM = 129,
};

struct ib_cqe {
	void (*done)(struct ib_cq *, struct ib_wc *);
};

struct ib_wc {
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	enum ib_wc_status status;
	enum ib_wc_opcode opcode;
	u32 vendor_err;
	u32 byte_len;
	struct ib_qp *qp;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
	u32 src_qp;
	u32 slid;
	int wc_flags;
	u16 pkey_index;
	u8 sl;
	u8 dlid_path_bits;
	u8 port_num;
	u8 smac[6];
	u16 vlan_id;
	u8 network_hdr_type;
};

struct ib_srq_attr {
	u32 max_wr;
	u32 max_sge;
	u32 srq_limit;
};

struct ib_xrcd {
	struct ib_device *device;
	atomic_t usecnt;
	struct inode *inode;
	struct mutex tgt_qp_mutex;
	struct list_head tgt_qp_list;
};

struct ib_srq_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	struct ib_srq_attr attr;
	enum ib_srq_type srq_type;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
			} xrc;
			struct {
				u32 max_num_tags;
			} tag_matching;
		};
	} ext;
};

struct ib_qp_cap {
	u32 max_send_wr;
	u32 max_recv_wr;
	u32 max_send_sge;
	u32 max_recv_sge;
	u32 max_inline_data;
	u32 max_rdma_ctxs;
};

enum ib_sig_type {
	IB_SIGNAL_ALL_WR = 0,
	IB_SIGNAL_REQ_WR = 1,
};

struct ib_qp_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct ib_qp_cap cap;
	enum ib_sig_type sq_sig_type;
	enum ib_qp_type qp_type;
	u32 create_flags;
	u8 port_num;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	u32 source_qpn;
};

struct ib_rwq_ind_table {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 ind_tbl_num;
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum ib_qp_state {
	IB_QPS_RESET = 0,
	IB_QPS_INIT = 1,
	IB_QPS_RTR = 2,
	IB_QPS_RTS = 3,
	IB_QPS_SQD = 4,
	IB_QPS_SQE = 5,
	IB_QPS_ERR = 6,
};

enum ib_mig_state {
	IB_MIG_MIGRATED = 0,
	IB_MIG_REARM = 1,
	IB_MIG_ARMED = 2,
};

struct ib_qp_attr {
	enum ib_qp_state qp_state;
	enum ib_qp_state cur_qp_state;
	enum ib_mtu path_mtu;
	enum ib_mig_state path_mig_state;
	u32 qkey;
	u32 rq_psn;
	u32 sq_psn;
	u32 dest_qp_num;
	int qp_access_flags;
	struct ib_qp_cap cap;
	struct rdma_ah_attr ah_attr;
	struct rdma_ah_attr alt_ah_attr;
	u16 pkey_index;
	u16 alt_pkey_index;
	u8 en_sqd_async_notify;
	u8 sq_draining;
	u8 max_rd_atomic;
	u8 max_dest_rd_atomic;
	u8 min_rnr_timer;
	u8 port_num;
	u8 timeout;
	u8 retry_cnt;
	u8 rnr_retry;
	u8 alt_port_num;
	u8 alt_timeout;
	u32 rate_limit;
};

enum ib_wr_opcode {
	IB_WR_RDMA_WRITE = 0,
	IB_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_WR_SEND = 2,
	IB_WR_SEND_WITH_IMM = 3,
	IB_WR_RDMA_READ = 4,
	IB_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_WR_LSO = 10,
	IB_WR_SEND_WITH_INV = 9,
	IB_WR_RDMA_READ_WITH_INV = 11,
	IB_WR_LOCAL_INV = 7,
	IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
	IB_WR_REG_MR = 32,
	IB_WR_REG_MR_INTEGRITY = 33,
	IB_WR_RESERVED1 = 240,
	IB_WR_RESERVED2 = 241,
	IB_WR_RESERVED3 = 242,
	IB_WR_RESERVED4 = 243,
	IB_WR_RESERVED5 = 244,
	IB_WR_RESERVED6 = 245,
	IB_WR_RESERVED7 = 246,
	IB_WR_RESERVED8 = 247,
	IB_WR_RESERVED9 = 248,
	IB_WR_RESERVED10 = 249,
};

struct ib_sge {
	u64 addr;
	u32 length;
	u32 lkey;
};

struct ib_send_wr {
	struct ib_send_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
	enum ib_wr_opcode opcode;
	int send_flags;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
};

struct ib_ah {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	const struct ib_gid_attr *sgid_attr;
	enum rdma_ah_attr_type type;
};

struct ib_mr {
	struct ib_device *device;
	struct ib_pd *pd;
	u32 lkey;
	u32 rkey;
	u64 iova;
	u64 length;
	unsigned int page_size;
	enum ib_mr_type type;
	bool need_inval;
	union {
		struct ib_uobject *uobject;
		struct list_head qp_entry;
	};
	struct ib_dm *dm;
	struct ib_sig_attrs *sig_attrs;
	struct rdma_restrack_entry res;
};

struct ib_recv_wr {
	struct ib_recv_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
};

struct ib_fmr_attr {
	int max_pages;
	int max_maps;
	u8 page_shift;
};

struct ib_rdmacg_object {};

struct ib_uverbs_file;

struct ib_ucontext {
	struct ib_device *device;
	struct ib_uverbs_file *ufile;
	bool closing;
	bool cleanup_retryable;
	struct ib_rdmacg_object cg_obj;
	struct rdma_restrack_entry res;
};

struct uverbs_api_object;

struct ib_uobject {
	u64 user_handle;
	struct ib_uverbs_file *ufile;
	struct ib_ucontext *context;
	void *object;
	struct list_head list;
	struct ib_rdmacg_object cg_obj;
	int id;
	struct kref ref;
	atomic_t usecnt;
	struct callback_head rcu;
	const struct uverbs_api_object *uapi_object;
};

struct ib_udata {
	const void *inbuf;
	void *outbuf;
	size_t inlen;
	size_t outlen;
};

struct ib_pd {
	u32 local_dma_lkey;
	u32 flags;
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 unsafe_global_rkey;
	struct ib_mr *__internal_mr;
	struct rdma_restrack_entry res;
};

struct ib_wq_init_attr {
	void *wq_context;
	enum ib_wq_type wq_type;
	u32 max_wr;
	u32 max_sge;
	struct ib_cq *cq;
	void (*event_handler)(struct ib_event *, void *);
	u32 create_flags;
};

struct ib_wq_attr {
	enum ib_wq_state wq_state;
	enum ib_wq_state curr_wq_state;
	u32 flags;
	u32 flags_mask;
};

struct ib_rwq_ind_table_init_attr {
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum port_pkey_state {
	IB_PORT_PKEY_NOT_VALID = 0,
	IB_PORT_PKEY_VALID = 1,
	IB_PORT_PKEY_LISTED = 2,
};

struct ib_port_pkey {
	enum port_pkey_state state;
	u16 pkey_index;
	u8 port_num;
	struct list_head qp_list;
	struct list_head to_error_list;
	struct ib_qp_security *sec;
};

struct ib_ports_pkeys;

struct ib_qp_security {
	struct ib_qp *qp;
	struct ib_device *dev;
	struct mutex mutex;
	struct ib_ports_pkeys *ports_pkeys;
	struct list_head shared_qp_list;
	void *security;
	bool destroying;
	atomic_t error_list_count;
	struct completion error_complete;
	int error_comps_pending;
};

struct ib_ports_pkeys {
	struct ib_port_pkey main;
	struct ib_port_pkey alt;
};

struct ib_dm {
	struct ib_device *device;
	u32 length;
	u32 flags;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

struct ib_mw {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	u32 rkey;
	enum ib_mw_type type;
};

struct ib_fmr {
	struct ib_device *device;
	struct ib_pd *pd;
	struct list_head list;
	u32 lkey;
	u32 rkey;
};

enum ib_flow_attr_type {
	IB_FLOW_ATTR_NORMAL = 0,
	IB_FLOW_ATTR_ALL_DEFAULT = 1,
	IB_FLOW_ATTR_MC_DEFAULT = 2,
	IB_FLOW_ATTR_SNIFFER = 3,
};

enum ib_flow_spec_type {
	IB_FLOW_SPEC_ETH = 32,
	IB_FLOW_SPEC_IB = 34,
	IB_FLOW_SPEC_IPV4 = 48,
	IB_FLOW_SPEC_IPV6 = 49,
	IB_FLOW_SPEC_ESP = 52,
	IB_FLOW_SPEC_TCP = 64,
	IB_FLOW_SPEC_UDP = 65,
	IB_FLOW_SPEC_VXLAN_TUNNEL = 80,
	IB_FLOW_SPEC_GRE = 81,
	IB_FLOW_SPEC_MPLS = 96,
	IB_FLOW_SPEC_INNER = 256,
	IB_FLOW_SPEC_ACTION_TAG = 4096,
	IB_FLOW_SPEC_ACTION_DROP = 4097,
	IB_FLOW_SPEC_ACTION_HANDLE = 4098,
	IB_FLOW_SPEC_ACTION_COUNT = 4099,
};

struct ib_flow_eth_filter {
	u8 dst_mac[6];
	u8 src_mac[6];
	__be16 ether_type;
	__be16 vlan_tag;
	u8 real_sz[0];
};

struct ib_flow_spec_eth {
	u32 type;
	u16 size;
	struct ib_flow_eth_filter val;
	struct ib_flow_eth_filter mask;
};

struct ib_flow_ib_filter {
	__be16 dlid;
	__u8 sl;
	u8 real_sz[0];
};

struct ib_flow_spec_ib {
	u32 type;
	u16 size;
	struct ib_flow_ib_filter val;
	struct ib_flow_ib_filter mask;
};

struct ib_flow_ipv4_filter {
	__be32 src_ip;
	__be32 dst_ip;
	u8 proto;
	u8 tos;
	u8 ttl;
	u8 flags;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv4 {
	u32 type;
	u16 size;
	struct ib_flow_ipv4_filter val;
	struct ib_flow_ipv4_filter mask;
};

struct ib_flow_ipv6_filter {
	u8 src_ip[16];
	u8 dst_ip[16];
	__be32 flow_label;
	u8 next_hdr;
	u8 traffic_class;
	u8 hop_limit;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv6 {
	u32 type;
	u16 size;
	struct ib_flow_ipv6_filter val;
	struct ib_flow_ipv6_filter mask;
};

struct ib_flow_tcp_udp_filter {
	__be16 dst_port;
	__be16 src_port;
	u8 real_sz[0];
};

struct ib_flow_spec_tcp_udp {
	u32 type;
	u16 size;
	struct ib_flow_tcp_udp_filter val;
	struct ib_flow_tcp_udp_filter mask;
};

struct ib_flow_tunnel_filter {
	__be32 tunnel_id;
	u8 real_sz[0];
};

struct ib_flow_spec_tunnel {
	u32 type;
	u16 size;
	struct ib_flow_tunnel_filter val;
	struct ib_flow_tunnel_filter mask;
};

struct ib_flow_esp_filter {
	__be32 spi;
	__be32 seq;
	u8 real_sz[0];
};

struct ib_flow_spec_esp {
	u32 type;
	u16 size;
	struct ib_flow_esp_filter val;
	struct ib_flow_esp_filter mask;
};

struct ib_flow_gre_filter {
	__be16 c_ks_res0_ver;
	__be16 protocol;
	__be32 key;
	u8 real_sz[0];
};

struct ib_flow_spec_gre {
	u32 type;
	u16 size;
	struct ib_flow_gre_filter val;
	struct ib_flow_gre_filter mask;
};

struct ib_flow_mpls_filter {
	__be32 tag;
	u8 real_sz[0];
};

struct ib_flow_spec_mpls {
	u32 type;
	u16 size;
	struct ib_flow_mpls_filter val;
	struct ib_flow_mpls_filter mask;
};

struct ib_flow_spec_action_tag {
	enum ib_flow_spec_type type;
	u16 size;
	u32 tag_id;
};

struct ib_flow_spec_action_drop {
	enum ib_flow_spec_type type;
	u16 size;
};

struct ib_flow_spec_action_handle {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_flow_action *act;
};

enum ib_flow_action_type {
	IB_FLOW_ACTION_UNSPECIFIED = 0,
	IB_FLOW_ACTION_ESP = 1,
};

struct ib_flow_action {
	struct ib_device *device;
	struct ib_uobject *uobject;
	enum ib_flow_action_type type;
	atomic_t usecnt;
};

struct ib_flow_spec_action_count {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_counters *counters;
};

struct ib_counters {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

union ib_flow_spec {
	struct {
		u32 type;
		u16 size;
	};
	struct ib_flow_spec_eth eth;
	struct ib_flow_spec_ib ib;
	struct ib_flow_spec_ipv4 ipv4;
	struct ib_flow_spec_tcp_udp tcp_udp;
	struct ib_flow_spec_ipv6 ipv6;
	struct ib_flow_spec_tunnel tunnel;
	struct ib_flow_spec_esp esp;
	struct ib_flow_spec_gre gre;
	struct ib_flow_spec_mpls mpls;
	struct ib_flow_spec_action_tag flow_tag;
	struct ib_flow_spec_action_drop drop;
	struct ib_flow_spec_action_handle action;
	struct ib_flow_spec_action_count flow_count;
};

struct ib_flow_attr {
	enum ib_flow_attr_type type;
	u16 size;
	u16 priority;
	u32 flags;
	u8 num_of_specs;
	u8 port;
	union ib_flow_spec flows[0];
};

struct ib_flow {
	struct ib_qp *qp;
	struct ib_device *device;
	struct ib_uobject *uobject;
};

struct ib_flow_action_attrs_esp_keymats {
	enum ib_uverbs_flow_action_esp_keymat protocol;
	union {
		struct ib_uverbs_flow_action_esp_keymat_aes_gcm aes_gcm;
	} keymat;
};

struct ib_flow_action_attrs_esp_replays {
	enum ib_uverbs_flow_action_esp_replay protocol;
	union {
		struct ib_uverbs_flow_action_esp_replay_bmp bmp;
	} replay;
};

struct ib_flow_spec_list {
	struct ib_flow_spec_list *next;
	union ib_flow_spec spec;
};

struct ib_flow_action_attrs_esp {
	struct ib_flow_action_attrs_esp_keymats *keymat;
	struct ib_flow_action_attrs_esp_replays *replay;
	struct ib_flow_spec_list *encap;
	u32 esn;
	u32 spi;
	u32 seq;
	u32 tfc_pad;
	u64 flags;
	u64 hard_limit_pkts;
};

struct ib_pkey_cache;

struct ib_gid_table;

struct ib_port_cache {
	u64 subnet_prefix;
	struct ib_pkey_cache *pkey;
	struct ib_gid_table *gid;
	u8 lmc;
	enum ib_port_state port_state;
};

struct ib_port_immutable {
	int pkey_tbl_len;
	int gid_tbl_len;
	u32 core_cap_flags;
	u32 max_mad_size;
};

struct ib_port_data {
	struct ib_device *ib_dev;
	struct ib_port_immutable immutable;
	spinlock_t pkey_list_lock;
	struct list_head pkey_list;
	struct ib_port_cache cache;
	spinlock_t netdev_lock;
	struct net_device *netdev;
	struct hlist_node ndev_hash_link;
	struct rdma_port_counter port_counter;
	struct rdma_hw_stats *hw_stats;
};

struct rdma_netdev_alloc_params {
	size_t sizeof_priv;
	unsigned int txqs;
	unsigned int rxqs;
	void *param;
	int (*initialize_rdma_netdev)(struct ib_device *, u8, struct net_device *, void *);
};

struct ib_counters_read_attr {
	u64 *counters_buff;
	u32 ncounters;
	u32 flags;
};

enum wbt_flags {
	WBT_TRACKED = 1,
	WBT_READ = 2,
	WBT_KSWAPD = 4,
	WBT_DISCARD = 8,
	WBT_NR_BITS = 4,
};

enum {
	WBT_STATE_ON_DEFAULT = 1,
	WBT_STATE_ON_MANUAL = 2,
};

struct rq_wb {
	unsigned int wb_background;
	unsigned int wb_normal;
	short int enable_state;
	unsigned int unknown_cnt;
	u64 win_nsec;
	u64 cur_win_nsec;
	struct blk_stat_callback *cb;
	u64 sync_issue;
	void *sync_cookie;
	unsigned int wc;
	long unsigned int last_issue;
	long unsigned int last_comp;
	long unsigned int min_lat_nsec;
	struct rq_qos rqos;
	struct rq_wait rq_wait[3];
	struct rq_depth rq_depth;
};

struct trace_event_raw_wbt_stat {
	struct trace_entry ent;
	char name[32];
	s64 rmean;
	u64 rmin;
	u64 rmax;
	s64 rnr_samples;
	s64 rtime;
	s64 wmean;
	u64 wmin;
	u64 wmax;
	s64 wnr_samples;
	s64 wtime;
	char __data[0];
};

struct trace_event_raw_wbt_lat {
	struct trace_entry ent;
	char name[32];
	long unsigned int lat;
	char __data[0];
};

struct trace_event_raw_wbt_step {
	struct trace_entry ent;
	char name[32];
	const char *msg;
	int step;
	long unsigned int window;
	unsigned int bg;
	unsigned int normal;
	unsigned int max;
	char __data[0];
};

struct trace_event_raw_wbt_timer {
	struct trace_entry ent;
	char name[32];
	unsigned int status;
	int step;
	unsigned int inflight;
	char __data[0];
};

struct trace_event_data_offsets_wbt_stat {};

struct trace_event_data_offsets_wbt_lat {};

struct trace_event_data_offsets_wbt_step {};

struct trace_event_data_offsets_wbt_timer {};

typedef void (*btf_trace_wbt_stat)(void *, struct backing_dev_info *, struct blk_rq_stat *);

typedef void (*btf_trace_wbt_lat)(void *, struct backing_dev_info *, long unsigned int);

typedef void (*btf_trace_wbt_step)(void *, struct backing_dev_info *, const char *, int, long unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_wbt_timer)(void *, struct backing_dev_info *, unsigned int, int, unsigned int);

enum {
	RWB_DEF_DEPTH = 16,
	RWB_WINDOW_NSEC = 100000000,
	RWB_MIN_WRITE_SAMPLES = 3,
	RWB_UNKNOWN_BUMP = 5,
};

enum {
	LAT_OK = 1,
	LAT_UNKNOWN = 2,
	LAT_UNKNOWN_WRITES = 3,
	LAT_EXCEEDED = 4,
};

struct wbt_wait_data {
	struct rq_wb *rwb;
	enum wbt_flags wb_acct;
	long unsigned int rw;
};

struct show_busy_params {
	struct seq_file *m;
	struct blk_mq_hw_ctx *hctx;
};

typedef void (*swap_func_t)(void *, void *, int);

typedef int (*cmp_func_t)(const void *, const void *);

typedef int (*cmp_r_func_t)(const void *, const void *, const void *);

struct siprand_state {
	long unsigned int v0;
	long unsigned int v1;
	long unsigned int v2;
	long unsigned int v3;
};

typedef __kernel_long_t __kernel_ptrdiff_t;

typedef __kernel_ptrdiff_t ptrdiff_t;

struct region {
	unsigned int start;
	unsigned int off;
	unsigned int group_len;
	unsigned int end;
};

enum {
	REG_OP_ISFREE = 0,
	REG_OP_ALLOC = 1,
	REG_OP_RELEASE = 2,
};

typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);

typedef void sg_free_fn(struct scatterlist *, unsigned int);

struct sg_page_iter {
	struct scatterlist *sg;
	unsigned int sg_pgoffset;
	unsigned int __nents;
	int __pg_advance;
};

struct sg_dma_page_iter {
	struct sg_page_iter base;
};

struct sg_mapping_iter {
	struct page *page;
	void *addr;
	size_t length;
	size_t consumed;
	struct sg_page_iter piter;
	unsigned int __offset;
	unsigned int __remaining;
	unsigned int __flags;
};

typedef int (*cmp_func)(void *, const struct list_head *, const struct list_head *);

struct csum_state {
	__wsum csum;
	size_t off;
};

struct rhltable {
	struct rhashtable ht;
};

struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhlist_head *list;
	struct rhashtable_walker walker;
	unsigned int slot;
	unsigned int skip;
	bool end_of_table;
};

union nested_table {
	union nested_table *table;
	struct rhash_lock_head *bucket;
};

struct once_work {
	struct work_struct work;
	struct static_key_true *key;
};

struct genradix_iter {
	size_t offset;
	size_t pos;
};

struct genradix_node {
	union {
		struct genradix_node *children[512];
		u8 data[4096];
	};
};

struct test_fail {
	const char *str;
	unsigned int base;
};

struct test_s8 {
	const char *str;
	unsigned int base;
	s8 expected_res;
};

struct test_u8 {
	const char *str;
	unsigned int base;
	u8 expected_res;
};

struct test_s16 {
	const char *str;
	unsigned int base;
	s16 expected_res;
};

struct test_u16 {
	const char *str;
	unsigned int base;
	u16 expected_res;
};

struct test_s32 {
	const char *str;
	unsigned int base;
	s32 expected_res;
};

struct test_u32 {
	const char *str;
	unsigned int base;
	u32 expected_res;
};

struct test_s64 {
	const char *str;
	unsigned int base;
	s64 expected_res;
};

struct test_u64 {
	const char *str;
	unsigned int base;
	u64 expected_res;
};

struct test_ll {
	const char *str;
	unsigned int base;
	long long int expected_res;
};

struct test_ull {
	const char *str;
	unsigned int base;
	long long unsigned int expected_res;
};

struct reciprocal_value {
	u32 m;
	u8 sh1;
	u8 sh2;
};

struct reciprocal_value_adv {
	u32 m;
	u8 sh;
	u8 exp;
	bool is_wide_m;
};

enum devm_ioremap_type {
	DEVM_IOREMAP = 0,
	DEVM_IOREMAP_NC = 1,
	DEVM_IOREMAP_UC = 2,
	DEVM_IOREMAP_WC = 3,
};

struct pcim_iomap_devres {
	void *table[6];
};

enum {
	LOGIC_PIO_INDIRECT = 0,
	LOGIC_PIO_CPU_MMIO = 1,
};

struct logic_pio_host_ops;

struct logic_pio_hwaddr {
	struct list_head list;
	struct fwnode_handle *fwnode;
	resource_size_t hw_start;
	resource_size_t io_start;
	resource_size_t size;
	long unsigned int flags;
	void *hostdata;
	const struct logic_pio_host_ops *ops;
};

struct logic_pio_host_ops {
	u32 (*in)(void *, long unsigned int, size_t);
	void (*out)(void *, long unsigned int, u32, size_t);
	u32 (*ins)(void *, long unsigned int, void *, size_t, unsigned int);
	void (*outs)(void *, long unsigned int, const void *, size_t, unsigned int);
};

struct btree_head {
	long unsigned int *node;
	mempool_t *mempool;
	int height;
};

struct btree_geo {
	int keylen;
	int no_pairs;
	int no_longs;
};

typedef void (*visitor128_t)(void *, long unsigned int, u64, u64, size_t);

typedef void (*visitorl_t)(void *, long unsigned int, long unsigned int, size_t);

typedef void (*visitor32_t)(void *, long unsigned int, u32, size_t);

typedef void (*visitor64_t)(void *, long unsigned int, u64, size_t);

struct interval_tree_node {
	struct rb_node rb;
	long unsigned int start;
	long unsigned int last;
	long unsigned int __subtree_last;
};

enum assoc_array_walk_status {
	assoc_array_walk_tree_empty = 0,
	assoc_array_walk_found_terminal_node = 1,
	assoc_array_walk_found_wrong_shortcut = 2,
};

struct assoc_array_walk_result {
	struct {
		struct assoc_array_node *node;
		int level;
		int slot;
	} terminal_node;
	struct {
		struct assoc_array_shortcut *shortcut;
		int level;
		int sc_level;
		long unsigned int sc_segments;
		long unsigned int dissimilarity;
	} wrong_shortcut;
};

struct assoc_array_delete_collapse_context {
	struct assoc_array_node *node;
	const void *skip_leaf;
	int slot;
};

struct xxh32_state {
	uint32_t total_len_32;
	uint32_t large_len;
	uint32_t v1;
	uint32_t v2;
	uint32_t v3;
	uint32_t v4;
	uint32_t mem32[4];
	uint32_t memsize;
};

struct xxh64_state {
	uint64_t total_len;
	uint64_t v1;
	uint64_t v2;
	uint64_t v3;
	uint64_t v4;
	uint64_t mem64[4];
	uint32_t memsize;
};

struct gen_pool_chunk {
	struct list_head next_chunk;
	atomic_long_t avail;
	phys_addr_t phys_addr;
	void *owner;
	long unsigned int start_addr;
	long unsigned int end_addr;
	long unsigned int bits[0];
};

struct genpool_data_align {
	int align;
};

struct genpool_data_fixed {
	long unsigned int offset;
};

typedef struct {
	unsigned char op;
	unsigned char bits;
	short unsigned int val;
} code;

typedef enum {
	HEAD = 0,
	FLAGS = 1,
	TIME = 2,
	OS = 3,
	EXLEN = 4,
	EXTRA = 5,
	NAME = 6,
	COMMENT = 7,
	HCRC = 8,
	DICTID = 9,
	DICT = 10,
	TYPE = 11,
	TYPEDO = 12,
	STORED = 13,
	COPY = 14,
	TABLE = 15,
	LENLENS = 16,
	CODELENS = 17,
	LEN = 18,
	LENEXT = 19,
	DIST = 20,
	DISTEXT = 21,
	MATCH = 22,
	LIT = 23,
	CHECK = 24,
	LENGTH = 25,
	DONE = 26,
	BAD = 27,
	MEM = 28,
	SYNC = 29,
} inflate_mode;

struct inflate_state {
	inflate_mode mode;
	int last;
	int wrap;
	int havedict;
	int flags;
	unsigned int dmax;
	long unsigned int check;
	long unsigned int total;
	unsigned int wbits;
	unsigned int wsize;
	unsigned int whave;
	unsigned int write;
	unsigned char *window;
	long unsigned int hold;
	unsigned int bits;
	unsigned int length;
	unsigned int offset;
	unsigned int extra;
	const code *lencode;
	const code *distcode;
	unsigned int lenbits;
	unsigned int distbits;
	unsigned int ncode;
	unsigned int nlen;
	unsigned int ndist;
	unsigned int have;
	code *next;
	short unsigned int lens[320];
	short unsigned int work[288];
	code codes[2048];
};

union uu {
	short unsigned int us;
	unsigned char b[2];
};

typedef unsigned int uInt;

typedef enum {
	CODES = 0,
	LENS = 1,
	DISTS = 2,
} codetype;

struct inflate_workspace {
	struct inflate_state inflate_state;
	unsigned char working_window[32768];
};

typedef unsigned char uch;

typedef short unsigned int ush;

typedef long unsigned int ulg;

struct ct_data_s {
	union {
		ush freq;
		ush code;
	} fc;
	union {
		ush dad;
		ush len;
	} dl;
};

typedef struct ct_data_s ct_data;

struct static_tree_desc_s {
	const ct_data *static_tree;
	const int *extra_bits;
	int extra_base;
	int elems;
	int max_length;
};

typedef struct static_tree_desc_s static_tree_desc;

struct tree_desc_s {
	ct_data *dyn_tree;
	int max_code;
	static_tree_desc *stat_desc;
};

typedef ush Pos;

typedef unsigned int IPos;

struct deflate_state {
	z_streamp strm;
	int status;
	Byte *pending_buf;
	ulg pending_buf_size;
	Byte *pending_out;
	int pending;
	int noheader;
	Byte data_type;
	Byte method;
	int last_flush;
	uInt w_size;
	uInt w_bits;
	uInt w_mask;
	Byte *window;
	ulg window_size;
	Pos *prev;
	Pos *head;
	uInt ins_h;
	uInt hash_size;
	uInt hash_bits;
	uInt hash_mask;
	uInt hash_shift;
	long int block_start;
	uInt match_length;
	IPos prev_match;
	int match_available;
	uInt strstart;
	uInt match_start;
	uInt lookahead;
	uInt prev_length;
	uInt max_chain_length;
	uInt max_lazy_match;
	int level;
	int strategy;
	uInt good_match;
	int nice_match;
	struct ct_data_s dyn_ltree[573];
	struct ct_data_s dyn_dtree[61];
	struct ct_data_s bl_tree[39];
	struct tree_desc_s l_desc;
	struct tree_desc_s d_desc;
	struct tree_desc_s bl_desc;
	ush bl_count[16];
	int heap[573];
	int heap_len;
	int heap_max;
	uch depth[573];
	uch *l_buf;
	uInt lit_bufsize;
	uInt last_lit;
	ush *d_buf;
	ulg opt_len;
	ulg static_len;
	ulg compressed_len;
	uInt matches;
	int last_eob_len;
	ush bi_buf;
	int bi_valid;
};

typedef struct deflate_state deflate_state;

struct deflate_workspace {
	deflate_state deflate_memory;
	Byte *window_memory;
	Pos *prev_memory;
	Pos *head_memory;
	char *overlay_memory;
};

typedef struct deflate_workspace deflate_workspace;

typedef enum {
	need_more = 0,
	block_done = 1,
	finish_started = 2,
	finish_done = 3,
} block_state;

typedef block_state (*compress_func)(deflate_state *, int);

struct config_s {
	ush good_length;
	ush max_lazy;
	ush nice_length;
	ush max_chain;
	compress_func func;
};

typedef struct config_s config;

typedef struct tree_desc_s tree_desc;

typedef struct {
	const uint8_t *externalDict;
	size_t extDictSize;
	const uint8_t *prefixEnd;
	size_t prefixSize;
} LZ4_streamDecode_t_internal;

typedef union {
	long long unsigned int table[4];
	LZ4_streamDecode_t_internal internal_donotuse;
} LZ4_streamDecode_t;

typedef uint8_t BYTE;

typedef uint16_t U16;

typedef uint32_t U32;

typedef uint64_t U64;

typedef uintptr_t uptrval;

typedef enum {
	noDict = 0,
	withPrefix64k = 1,
	usingExtDict = 2,
} dict_directive;

typedef enum {
	endOnOutputSize = 0,
	endOnInputSize = 1,
} endCondition_directive;

typedef enum {
	decode_full_block = 0,
	partial_decode = 1,
} earlyEnd_directive;

enum xz_mode {
	XZ_SINGLE = 0,
	XZ_PREALLOC = 1,
	XZ_DYNALLOC = 2,
};

enum xz_ret {
	XZ_OK = 0,
	XZ_STREAM_END = 1,
	XZ_UNSUPPORTED_CHECK = 2,
	XZ_MEM_ERROR = 3,
	XZ_MEMLIMIT_ERROR = 4,
	XZ_FORMAT_ERROR = 5,
	XZ_OPTIONS_ERROR = 6,
	XZ_DATA_ERROR = 7,
	XZ_BUF_ERROR = 8,
};

struct xz_buf {
	const uint8_t *in;
	size_t in_pos;
	size_t in_size;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
};

struct xz_dec;

typedef uint64_t vli_type;

enum xz_check {
	XZ_CHECK_NONE = 0,
	XZ_CHECK_CRC32 = 1,
	XZ_CHECK_CRC64 = 4,
	XZ_CHECK_SHA256 = 10,
};

struct xz_dec_hash {
	vli_type unpadded;
	vli_type uncompressed;
	uint32_t crc32;
};

struct xz_dec_lzma2;

struct xz_dec_bcj;

struct xz_dec {
	enum {
		SEQ_STREAM_HEADER = 0,
		SEQ_BLOCK_START = 1,
		SEQ_BLOCK_HEADER = 2,
		SEQ_BLOCK_UNCOMPRESS = 3,
		SEQ_BLOCK_PADDING = 4,
		SEQ_BLOCK_CHECK = 5,
		SEQ_INDEX = 6,
		SEQ_INDEX_PADDING = 7,
		SEQ_INDEX_CRC32 = 8,
		SEQ_STREAM_FOOTER = 9,
	} sequence;
	uint32_t pos;
	vli_type vli;
	size_t in_start;
	size_t out_start;
	uint32_t crc32;
	enum xz_check check_type;
	enum xz_mode mode;
	bool allow_buf_error;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		uint32_t size;
	} block_header;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		vli_type count;
		struct xz_dec_hash hash;
	} block;
	struct {
		enum {
			SEQ_INDEX_COUNT = 0,
			SEQ_INDEX_UNPADDED = 1,
			SEQ_INDEX_UNCOMPRESSED = 2,
		} sequence;
		vli_type size;
		vli_type count;
		struct xz_dec_hash hash;
	} index;
	struct {
		size_t pos;
		size_t size;
		uint8_t buf[1024];
	} temp;
	struct xz_dec_lzma2 *lzma2;
	struct xz_dec_bcj *bcj;
	bool bcj_active;
};

enum lzma_state {
	STATE_LIT_LIT = 0,
	STATE_MATCH_LIT_LIT = 1,
	STATE_REP_LIT_LIT = 2,
	STATE_SHORTREP_LIT_LIT = 3,
	STATE_MATCH_LIT = 4,
	STATE_REP_LIT = 5,
	STATE_SHORTREP_LIT = 6,
	STATE_LIT_MATCH = 7,
	STATE_LIT_LONGREP = 8,
	STATE_LIT_SHORTREP = 9,
	STATE_NONLIT_MATCH = 10,
	STATE_NONLIT_REP = 11,
};

struct dictionary {
	uint8_t *buf;
	size_t start;
	size_t pos;
	size_t full;
	size_t limit;
	size_t end;
	uint32_t size;
	uint32_t size_max;
	uint32_t allocated;
	enum xz_mode mode;
};

struct rc_dec {
	uint32_t range;
	uint32_t code;
	uint32_t init_bytes_left;
	const uint8_t *in;
	size_t in_pos;
	size_t in_limit;
};

struct lzma_len_dec {
	uint16_t choice;
	uint16_t choice2;
	uint16_t low[128];
	uint16_t mid[128];
	uint16_t high[256];
};

struct lzma_dec {
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
	enum lzma_state state;
	uint32_t len;
	uint32_t lc;
	uint32_t literal_pos_mask;
	uint32_t pos_mask;
	uint16_t is_match[192];
	uint16_t is_rep[12];
	uint16_t is_rep0[12];
	uint16_t is_rep1[12];
	uint16_t is_rep2[12];
	uint16_t is_rep0_long[192];
	uint16_t dist_slot[256];
	uint16_t dist_special[114];
	uint16_t dist_align[16];
	struct lzma_len_dec match_len_dec;
	struct lzma_len_dec rep_len_dec;
	uint16_t literal[12288];
};

enum lzma2_seq {
	SEQ_CONTROL = 0,
	SEQ_UNCOMPRESSED_1 = 1,
	SEQ_UNCOMPRESSED_2 = 2,
	SEQ_COMPRESSED_0 = 3,
	SEQ_COMPRESSED_1 = 4,
	SEQ_PROPERTIES = 5,
	SEQ_LZMA_PREPARE = 6,
	SEQ_LZMA_RUN = 7,
	SEQ_COPY = 8,
};

struct lzma2_dec {
	enum lzma2_seq sequence;
	enum lzma2_seq next_sequence;
	uint32_t uncompressed;
	uint32_t compressed;
	bool need_dict_reset;
	bool need_props;
};

struct xz_dec_lzma2 {
	struct rc_dec rc;
	struct dictionary dict;
	struct lzma2_dec lzma2;
	struct lzma_dec lzma;
	struct {
		uint32_t size;
		uint8_t buf[63];
	} temp;
};

struct xz_dec_bcj {
	enum {
		BCJ_X86 = 4,
		BCJ_POWERPC = 5,
		BCJ_IA64 = 6,
		BCJ_ARM = 7,
		BCJ_ARMTHUMB = 8,
		BCJ_SPARC = 9,
	} type;
	enum xz_ret ret;
	bool single_call;
	uint32_t pos;
	uint32_t x86_prev_mask;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
	struct {
		size_t filtered;
		size_t size;
		uint8_t buf[16];
	} temp;
};

struct raid6_recov_calls {
	void (*data2)(int, size_t, int, int, void **);
	void (*datap)(int, size_t, int, void **);
	int (*valid)();
	const char *name;
	int priority;
};

typedef u64 unative_t;

struct raid6_sse_constants {
	u64 x1d[2];
};

struct raid6_avx2_constants {
	u64 x1d[4];
};

struct raid6_avx512_constants {
	u64 x1d[8];
};

struct ts_state {
	unsigned int offset;
	char cb[40];
};

struct ts_config;

struct ts_ops {
	const char *name;
	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
	unsigned int (*find)(struct ts_config *, struct ts_state *);
	void (*destroy)(struct ts_config *);
	void * (*get_pattern)(struct ts_config *);
	unsigned int (*get_pattern_len)(struct ts_config *);
	struct module *owner;
	struct list_head list;
};

struct ts_config {
	struct ts_ops *ops;
	int flags;
	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
	void (*finish)(struct ts_config *, struct ts_state *);
};

struct ts_linear_state {
	unsigned int len;
	const void *data;
};

typedef s32 pao_T_____7;

struct ei_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
	int etype;
	void *priv;
};

struct ddebug_table {
	struct list_head link;
	const char *mod_name;
	unsigned int num_ddebugs;
	struct _ddebug *ddebugs;
};

struct ddebug_query {
	const char *filename;
	const char *module;
	const char *function;
	const char *format;
	unsigned int first_lineno;
	unsigned int last_lineno;
};

struct ddebug_iter {
	struct ddebug_table *table;
	unsigned int idx;
};

struct flagsbuf {
	char buf[7];
};

struct nla_bitfield32 {
	__u32 value;
	__u32 selector;
};

enum nla_policy_validation {
	NLA_VALIDATE_NONE = 0,
	NLA_VALIDATE_RANGE = 1,
	NLA_VALIDATE_MIN = 2,
	NLA_VALIDATE_MAX = 3,
	NLA_VALIDATE_FUNCTION = 4,
};

struct cpu_rmap {
	struct kref refcount;
	u16 size;
	u16 used;
	void **obj;
	struct {
		u16 index;
		u16 dist;
	} near[0];
};

struct irq_glue {
	struct irq_affinity_notify notify;
	struct cpu_rmap *rmap;
	u16 index;
};

typedef mpi_limb_t *mpi_ptr_t;

typedef int mpi_size_t;

typedef mpi_limb_t UWtype;

typedef unsigned int UHWtype;

struct karatsuba_ctx {
	struct karatsuba_ctx *next;
	mpi_ptr_t tspace;
	mpi_size_t tspace_size;
	mpi_ptr_t tp;
	mpi_size_t tp_size;
};

typedef long int mpi_limb_signed_t;

enum {
	DIM_PARKING_ON_TOP = 0,
	DIM_PARKING_TIRED = 1,
	DIM_GOING_RIGHT = 2,
	DIM_GOING_LEFT = 3,
};

struct dim_cq_moder {
	u16 usec;
	u16 pkts;
	u16 comps;
	u8 cq_period_mode;
};

enum {
	DIM_CQ_PERIOD_MODE_START_FROM_EQE = 0,
	DIM_CQ_PERIOD_MODE_START_FROM_CQE = 1,
	DIM_CQ_PERIOD_NUM_MODES = 2,
};

enum {
	DIM_START_MEASURE = 0,
	DIM_MEASURE_IN_PROGRESS = 1,
	DIM_APPLY_NEW_PROFILE = 2,
};

enum {
	DIM_STATS_WORSE = 0,
	DIM_STATS_SAME = 1,
	DIM_STATS_BETTER = 2,
};

enum {
	DIM_STEPPED = 0,
	DIM_TOO_TIRED = 1,
	DIM_ON_EDGE = 2,
};

struct sg_pool {
	size_t size;
	char *name;
	struct kmem_cache *slab;
	mempool_t *pool;
};

enum {
	IRQ_POLL_F_SCHED = 0,
	IRQ_POLL_F_DISABLE = 1,
};

struct font_desc {
	int idx;
	const char *name;
	int width;
	int height;
	const void *data;
	int pref;
};

struct font_data {
	unsigned int extra[4];
	const unsigned char data[0];
};

struct msr {
	union {
		struct {
			u32 l;
			u32 h;
		};
		u64 q;
	};
};

struct msr_info {
	u32 msr_no;
	struct msr reg;
	struct msr *msrs;
	int err;
};

struct msr_regs_info {
	u32 *regs;
	int err;
};

struct msr_info_completion {
	struct msr_info msr;
	struct completion done;
};

struct trace_event_raw_msr_trace_class {
	struct trace_entry ent;
	unsigned int msr;
	u64 val;
	int failed;
	char __data[0];
};

struct trace_event_data_offsets_msr_trace_class {};

typedef void (*btf_trace_read_msr)(void *, unsigned int, u64, int);

typedef void (*btf_trace_write_msr)(void *, unsigned int, u64, int);

typedef void (*btf_trace_rdpmc)(void *, unsigned int, u64, int);

struct regulator;

struct phy_configure_opts_mipi_dphy {
	unsigned int clk_miss;
	unsigned int clk_post;
	unsigned int clk_pre;
	unsigned int clk_prepare;
	unsigned int clk_settle;
	unsigned int clk_term_en;
	unsigned int clk_trail;
	unsigned int clk_zero;
	unsigned int d_term_en;
	unsigned int eot;
	unsigned int hs_exit;
	unsigned int hs_prepare;
	unsigned int hs_settle;
	unsigned int hs_skip;
	unsigned int hs_trail;
	unsigned int hs_zero;
	unsigned int init;
	unsigned int lpx;
	unsigned int ta_get;
	unsigned int ta_go;
	unsigned int ta_sure;
	unsigned int wakeup;
	long unsigned int hs_clk_rate;
	long unsigned int lp_clk_rate;
	unsigned char lanes;
};

enum phy_mode {
	PHY_MODE_INVALID = 0,
	PHY_MODE_USB_HOST = 1,
	PHY_MODE_USB_HOST_LS = 2,
	PHY_MODE_USB_HOST_FS = 3,
	PHY_MODE_USB_HOST_HS = 4,
	PHY_MODE_USB_HOST_SS = 5,
	PHY_MODE_USB_DEVICE = 6,
	PHY_MODE_USB_DEVICE_LS = 7,
	PHY_MODE_USB_DEVICE_FS = 8,
	PHY_MODE_USB_DEVICE_HS = 9,
	PHY_MODE_USB_DEVICE_SS = 10,
	PHY_MODE_USB_OTG = 11,
	PHY_MODE_UFS_HS_A = 12,
	PHY_MODE_UFS_HS_B = 13,
	PHY_MODE_PCIE = 14,
	PHY_MODE_ETHERNET = 15,
	PHY_MODE_MIPI_DPHY = 16,
	PHY_MODE_SATA = 17,
};

union phy_configure_opts {
	struct phy_configure_opts_mipi_dphy mipi_dphy;
};

struct phy;

struct phy_ops {
	int (*init)(struct phy *);
	int (*exit)(struct phy *);
	int (*power_on)(struct phy *);
	int (*power_off)(struct phy *);
	int (*set_mode)(struct phy *, enum phy_mode, int);
	int (*configure)(struct phy *, union phy_configure_opts *);
	int (*validate)(struct phy *, enum phy_mode, int, union phy_configure_opts *);
	int (*reset)(struct phy *);
	int (*calibrate)(struct phy *);
	void (*release)(struct phy *);
	struct module *owner;
};

struct phy_attrs {
	u32 bus_width;
	enum phy_mode mode;
};

struct phy {
	struct device dev;
	int id;
	const struct phy_ops *ops;
	struct mutex mutex;
	int init_count;
	int power_count;
	struct phy_attrs attrs;
	struct regulator *pwr;
};

struct phy_provider {
	struct device *dev;
	struct device_node *children;
	struct module *owner;
	struct list_head list;
	struct phy * (*of_xlate)(struct device *, struct of_phandle_args *);
};

struct phy_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct phy *phy;
};

enum device_link_state {
	DL_STATE_NONE = 4294967295,
	DL_STATE_DORMANT = 0,
	DL_STATE_AVAILABLE = 1,
	DL_STATE_CONSUMER_PROBE = 2,
	DL_STATE_ACTIVE = 3,
	DL_STATE_SUPPLIER_UNBIND = 4,
};

struct device_link {
	struct device *supplier;
	struct list_head s_node;
	struct device *consumer;
	struct list_head c_node;
	enum device_link_state status;
	u32 flags;
	refcount_t rpm_active;
	struct kref kref;
	struct callback_head callback_head;
	bool supplier_preactivated;
};

struct pinctrl;

struct pinctrl_state;

struct dev_pin_info {
	struct pinctrl *p;
	struct pinctrl_state *default_state;
	struct pinctrl_state *init_state;
	struct pinctrl_state *sleep_state;
	struct pinctrl_state *idle_state;
};

struct pinctrl {
	struct list_head node;
	struct device *dev;
	struct list_head states;
	struct pinctrl_state *state;
	struct list_head dt_maps;
	struct kref users;
};

struct pinctrl_state {
	struct list_head node;
	const char *name;
	struct list_head settings;
};

struct pinctrl_pin_desc {
	unsigned int number;
	const char *name;
	void *drv_data;
};

struct gpio_chip;

struct pinctrl_gpio_range {
	struct list_head node;
	const char *name;
	unsigned int id;
	unsigned int base;
	unsigned int pin_base;
	const unsigned int *pins;
	unsigned int npins;
	struct gpio_chip *gc;
};

struct pinctrl_dev;

struct pinctrl_map;

struct pinctrl_ops {
	int (*get_groups_count)(struct pinctrl_dev *);
	const char * (*get_group_name)(struct pinctrl_dev *, unsigned int);
	int (*get_group_pins)(struct pinctrl_dev *, unsigned int, const unsigned int **, unsigned int *);
	void (*pin_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	int (*dt_node_to_map)(struct pinctrl_dev *, struct device_node *, struct pinctrl_map **, unsigned int *);
	void (*dt_free_map)(struct pinctrl_dev *, struct pinctrl_map *, unsigned int);
};

struct pinctrl_desc;

struct pinctrl_dev {
	struct list_head node;
	struct pinctrl_desc *desc;
	struct xarray pin_desc_tree;
	struct list_head gpio_ranges;
	struct device *dev;
	struct module *owner;
	void *driver_data;
	struct pinctrl *p;
	struct pinctrl_state *hog_default;
	struct pinctrl_state *hog_sleep;
	struct mutex mutex;
	struct dentry *device_root;
};

enum pinctrl_map_type {
	PIN_MAP_TYPE_INVALID = 0,
	PIN_MAP_TYPE_DUMMY_STATE = 1,
	PIN_MAP_TYPE_MUX_GROUP = 2,
	PIN_MAP_TYPE_CONFIGS_PIN = 3,
	PIN_MAP_TYPE_CONFIGS_GROUP = 4,
};

struct pinctrl_map_mux {
	const char *group;
	const char *function;
};

struct pinctrl_map_configs {
	const char *group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_map {
	const char *dev_name;
	const char *name;
	enum pinctrl_map_type type;
	const char *ctrl_dev_name;
	union {
		struct pinctrl_map_mux mux;
		struct pinctrl_map_configs configs;
	} data;
};

struct pinmux_ops;

struct pinconf_ops;

struct pinctrl_desc {
	const char *name;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct pinctrl_ops *pctlops;
	const struct pinmux_ops *pmxops;
	const struct pinconf_ops *confops;
	struct module *owner;
	bool link_consumers;
};

struct pinconf_ops {
	int (*pin_config_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*pin_config_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	int (*pin_config_group_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*pin_config_group_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	void (*pin_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_group_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, long unsigned int);
};

struct pinctrl_setting_mux {
	unsigned int group;
	unsigned int func;
};

struct pinctrl_setting_configs {
	unsigned int group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_setting {
	struct list_head node;
	enum pinctrl_map_type type;
	struct pinctrl_dev *pctldev;
	const char *dev_name;
	union {
		struct pinctrl_setting_mux mux;
		struct pinctrl_setting_configs configs;
	} data;
};

struct pin_desc {
	struct pinctrl_dev *pctldev;
	const char *name;
	bool dynamic_name;
	void *drv_data;
};

struct pinctrl_maps {
	struct list_head node;
	const struct pinctrl_map *maps;
	unsigned int num_maps;
};

struct pctldev;

struct pci_sriov {
	int pos;
	int nres;
	u32 cap;
	u16 ctrl;
	u16 total_VFs;
	u16 initial_VFs;
	u16 num_VFs;
	u16 offset;
	u16 stride;
	u16 vf_device;
	u32 pgsz;
	u8 link;
	u8 max_VF_buses;
	u16 driver_max_VFs;
	struct pci_dev *dev;
	struct pci_dev *self;
	u32 class;
	u8 hdr_type;
	u16 subsystem_vendor;
	u16 subsystem_device;
	resource_size_t barsz[6];
	bool drivers_autoprobe;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct pci_bus_resource {
	struct list_head list;
	struct resource *res;
	unsigned int flags;
};

typedef u64 pci_bus_addr_t;

struct pci_bus_region {
	pci_bus_addr_t start;
	pci_bus_addr_t end;
};

enum pci_fixup_pass {
	pci_fixup_early = 0,
	pci_fixup_header = 1,
	pci_fixup_final = 2,
	pci_fixup_enable = 3,
	pci_fixup_resume = 4,
	pci_fixup_suspend = 5,
	pci_fixup_resume_early = 6,
	pci_fixup_suspend_late = 7,
};

struct hotplug_slot_ops;

struct hotplug_slot {
	const struct hotplug_slot_ops *ops;
	struct list_head slot_list;
	struct pci_slot *pci_slot;
	struct module *owner;
	const char *mod_name;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

enum pci_dev_flags {
	PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
	PCI_DEV_FLAGS_NO_D3 = 2,
	PCI_DEV_FLAGS_ASSIGNED = 4,
	PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
	PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32,
	PCI_DEV_FLAGS_NO_BUS_RESET = 64,
	PCI_DEV_FLAGS_NO_PM_RESET = 128,
	PCI_DEV_FLAGS_VPD_REF_F0 = 256,
	PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = 512,
	PCI_DEV_FLAGS_NO_FLR_RESET = 1024,
	PCI_DEV_FLAGS_NO_RELAXED_ORDERING = 2048,
};

enum pci_bus_flags {
	PCI_BUS_FLAGS_NO_MSI = 1,
	PCI_BUS_FLAGS_NO_MMRBC = 2,
	PCI_BUS_FLAGS_NO_AERSID = 4,
	PCI_BUS_FLAGS_NO_EXTCFG = 8,
};

enum pci_bus_speed {
	PCI_SPEED_33MHz = 0,
	PCI_SPEED_66MHz = 1,
	PCI_SPEED_66MHz_PCIX = 2,
	PCI_SPEED_100MHz_PCIX = 3,
	PCI_SPEED_133MHz_PCIX = 4,
	PCI_SPEED_66MHz_PCIX_ECC = 5,
	PCI_SPEED_100MHz_PCIX_ECC = 6,
	PCI_SPEED_133MHz_PCIX_ECC = 7,
	PCI_SPEED_66MHz_PCIX_266 = 9,
	PCI_SPEED_100MHz_PCIX_266 = 10,
	PCI_SPEED_133MHz_PCIX_266 = 11,
	AGP_UNKNOWN = 12,
	AGP_1X = 13,
	AGP_2X = 14,
	AGP_4X = 15,
	AGP_8X = 16,
	PCI_SPEED_66MHz_PCIX_533 = 17,
	PCI_SPEED_100MHz_PCIX_533 = 18,
	PCI_SPEED_133MHz_PCIX_533 = 19,
	PCIE_SPEED_2_5GT = 20,
	PCIE_SPEED_5_0GT = 21,
	PCIE_SPEED_8_0GT = 22,
	PCIE_SPEED_16_0GT = 23,
	PCIE_SPEED_32_0GT = 24,
	PCI_SPEED_UNKNOWN = 255,
};

struct pci_host_bridge {
	struct device dev;
	struct pci_bus *bus;
	struct pci_ops *ops;
	void *sysdata;
	int busnr;
	struct list_head windows;
	struct list_head dma_ranges;
	u8 (*swizzle_irq)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void (*release_fn)(struct pci_host_bridge *);
	void *release_data;
	struct msi_controller *msi;
	unsigned int ignore_reset_delay: 1;
	unsigned int no_ext_tags: 1;
	unsigned int native_aer: 1;
	unsigned int native_pcie_hotplug: 1;
	unsigned int native_shpc_hotplug: 1;
	unsigned int native_pme: 1;
	unsigned int native_ltr: 1;
	unsigned int preserve_config: 1;
	resource_size_t (*align_resource)(struct pci_dev *, const struct resource *, resource_size_t, resource_size_t, resource_size_t);
	long: 64;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

enum {
	PCI_REASSIGN_ALL_RSRC = 1,
	PCI_REASSIGN_ALL_BUS = 2,
	PCI_PROBE_ONLY = 4,
	PCI_CAN_SKIP_ISA_ALIGN = 8,
	PCI_ENABLE_PROC_DOMAINS = 16,
	PCI_COMPAT_DOMAIN_0 = 32,
	PCI_SCAN_ALL_PCIE_DEVS = 64,
};

enum pcie_bus_config_types {
	PCIE_BUS_TUNE_OFF = 0,
	PCIE_BUS_DEFAULT = 1,
	PCIE_BUS_SAFE = 2,
	PCIE_BUS_PERFORMANCE = 3,
	PCIE_BUS_PEER2PEER = 4,
};

struct hotplug_slot_ops {
	int (*enable_slot)(struct hotplug_slot *);
	int (*disable_slot)(struct hotplug_slot *);
	int (*set_attention_status)(struct hotplug_slot *, u8);
	int (*hardware_test)(struct hotplug_slot *, u32);
	int (*get_power_status)(struct hotplug_slot *, u8 *);
	int (*get_attention_status)(struct hotplug_slot *, u8 *);
	int (*get_latch_status)(struct hotplug_slot *, u8 *);
	int (*get_adapter_status)(struct hotplug_slot *, u8 *);
	int (*reset_slot)(struct hotplug_slot *, int);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
};

enum pci_bar_type {
	pci_bar_unknown = 0,
	pci_bar_io = 1,
	pci_bar_mem32 = 2,
	pci_bar_mem64 = 3,
};

struct pci_domain_busn_res {
	struct list_head list;
	struct resource res;
	int domain_nr;
};

struct bus_attribute {
	struct attribute attr;
	ssize_t (*show)(struct bus_type *, char *);
	ssize_t (*store)(struct bus_type *, const char *, size_t);
};

enum pcie_reset_state {
	pcie_deassert_reset = 1,
	pcie_warm_reset = 2,
	pcie_hot_reset = 3,
};

enum pcie_link_width {
	PCIE_LNK_WIDTH_RESRV = 0,
	PCIE_LNK_X1 = 1,
	PCIE_LNK_X2 = 2,
	PCIE_LNK_X4 = 4,
	PCIE_LNK_X8 = 8,
	PCIE_LNK_X12 = 12,
	PCIE_LNK_X16 = 16,
	PCIE_LNK_X32 = 32,
	PCIE_LNK_WIDTH_UNKNOWN = 255,
};

struct pci_cap_saved_data {
	u16 cap_nr;
	bool cap_extended;
	unsigned int size;
	u32 data[0];
};

struct pci_cap_saved_state {
	struct hlist_node next;
	struct pci_cap_saved_data cap;
};

typedef int (*arch_set_vga_state_t)(struct pci_dev *, bool, unsigned int, u32);

struct pci_platform_pm_ops {
	bool (*bridge_d3)(struct pci_dev *);
	bool (*is_manageable)(struct pci_dev *);
	int (*set_state)(struct pci_dev *, pci_power_t);
	pci_power_t (*get_state)(struct pci_dev *);
	void (*refresh_state)(struct pci_dev *);
	pci_power_t (*choose_state)(struct pci_dev *);
	int (*set_wakeup)(struct pci_dev *, bool);
	bool (*need_resume)(struct pci_dev *);
};

struct pci_pme_device {
	struct list_head list;
	struct pci_dev *dev;
};

struct pci_saved_state {
	u32 config_space[16];
	struct pci_cap_saved_data cap[0];
};

struct pci_devres {
	unsigned int enabled: 1;
	unsigned int pinned: 1;
	unsigned int orig_intx: 1;
	unsigned int restore_intx: 1;
	unsigned int mwi: 1;
	u32 region_mask;
};

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *, char *);
	ssize_t (*store)(struct device_driver *, const char *, size_t);
};

enum pci_ers_result {
	PCI_ERS_RESULT_NONE = 1,
	PCI_ERS_RESULT_CAN_RECOVER = 2,
	PCI_ERS_RESULT_NEED_RESET = 3,
	PCI_ERS_RESULT_DISCONNECT = 4,
	PCI_ERS_RESULT_RECOVERED = 5,
	PCI_ERS_RESULT_NO_AER_DRIVER = 6,
};

enum dev_dma_attr {
	DEV_DMA_NOT_SUPPORTED = 0,
	DEV_DMA_NON_COHERENT = 1,
	DEV_DMA_COHERENT = 2,
};

struct pcie_device {
	int irq;
	struct pci_dev *port;
	u32 service;
	void *priv_data;
	struct device device;
};

struct pcie_port_service_driver {
	const char *name;
	int (*probe)(struct pcie_device *);
	void (*remove)(struct pcie_device *);
	int (*suspend)(struct pcie_device *);
	int (*resume_noirq)(struct pcie_device *);
	int (*resume)(struct pcie_device *);
	int (*runtime_suspend)(struct pcie_device *);
	int (*runtime_resume)(struct pcie_device *);
	void (*error_resume)(struct pci_dev *);
	pci_ers_result_t (*reset_link)(struct pci_dev *);
	int port_type;
	u32 service;
	struct device_driver driver;
};

struct pci_dynid {
	struct list_head node;
	struct pci_device_id id;
};

struct drv_dev_and_id {
	struct pci_driver *drv;
	struct pci_dev *dev;
	const struct pci_device_id *id;
};

enum pci_mmap_state {
	pci_mmap_io = 0,
	pci_mmap_mem = 1,
};

enum pci_mmap_api {
	PCI_MMAP_SYSFS = 0,
	PCI_MMAP_PROCFS = 1,
};

enum pci_lost_interrupt_reason {
	PCI_LOST_IRQ_NO_INFORMATION = 0,
	PCI_LOST_IRQ_DISABLE_MSI = 1,
	PCI_LOST_IRQ_DISABLE_MSIX = 2,
	PCI_LOST_IRQ_DISABLE_ACPI = 3,
};

struct pci_vpd_ops;

struct pci_vpd {
	const struct pci_vpd_ops *ops;
	struct bin_attribute *attr;
	struct mutex lock;
	unsigned int len;
	u16 flag;
	u8 cap;
	unsigned int busy: 1;
	unsigned int valid: 1;
};

struct pci_vpd_ops {
	ssize_t (*read)(struct pci_dev *, loff_t, size_t, void *);
	ssize_t (*write)(struct pci_dev *, loff_t, size_t, const void *);
	int (*set_size)(struct pci_dev *, size_t);
};

struct pci_dev_resource {
	struct list_head list;
	struct resource *res;
	struct pci_dev *dev;
	resource_size_t start;
	resource_size_t end;
	resource_size_t add_size;
	resource_size_t min_align;
	long unsigned int flags;
};

enum release_type {
	leaf_only = 0,
	whole_subtree = 1,
};

enum enable_type {
	undefined = 4294967295,
	user_disabled = 0,
	auto_disabled = 1,
	user_enabled = 2,
	auto_enabled = 3,
};

struct pci_filp_private {
	enum pci_mmap_state mmap_state;
	int write_combine;
};

struct pci_slot_attribute {
	struct attribute attr;
	ssize_t (*show)(struct pci_slot *, char *);
	ssize_t (*store)(struct pci_slot *, const char *, size_t);
};

struct acpi_bus_type {
	struct list_head list;
	const char *name;
	bool (*match)(struct device *);
	struct acpi_device * (*find_companion)(struct device *);
	void (*setup)(struct device *);
	void (*cleanup)(struct device *);
};

struct acpi_pci_root {
	struct acpi_device *device;
	struct pci_bus *bus;
	u16 segment;
	struct resource secondary;
	u32 osc_support_set;
	u32 osc_control_set;
	phys_addr_t mcfg_addr;
};

enum pm_qos_flags_status {
	PM_QOS_FLAGS_UNDEFINED = 4294967295,
	PM_QOS_FLAGS_NONE = 0,
	PM_QOS_FLAGS_SOME = 1,
	PM_QOS_FLAGS_ALL = 2,
};

struct hpx_type0 {
	u32 revision;
	u8 cache_line_size;
	u8 latency_timer;
	u8 enable_serr;
	u8 enable_perr;
};

struct hpx_type1 {
	u32 revision;
	u8 max_mem_read;
	u8 avg_max_split;
	u16 tot_max_split;
};

struct hpx_type2 {
	u32 revision;
	u32 unc_err_mask_and;
	u32 unc_err_mask_or;
	u32 unc_err_sever_and;
	u32 unc_err_sever_or;
	u32 cor_err_mask_and;
	u32 cor_err_mask_or;
	u32 adv_err_cap_and;
	u32 adv_err_cap_or;
	u16 pci_exp_devctl_and;
	u16 pci_exp_devctl_or;
	u16 pci_exp_lnkctl_and;
	u16 pci_exp_lnkctl_or;
	u32 sec_unc_err_sever_and;
	u32 sec_unc_err_sever_or;
	u32 sec_unc_err_mask_and;
	u32 sec_unc_err_mask_or;
};

struct hpx_type3 {
	u16 device_type;
	u16 function_type;
	u16 config_space_location;
	u16 pci_exp_cap_id;
	u16 pci_exp_cap_ver;
	u16 pci_exp_vendor_id;
	u16 dvsec_id;
	u16 dvsec_rev;
	u16 match_offset;
	u32 match_mask_and;
	u32 match_value;
	u16 reg_offset;
	u32 reg_mask_and;
	u32 reg_mask_or;
};

enum hpx_type3_dev_type {
	HPX_TYPE_ENDPOINT = 1,
	HPX_TYPE_LEG_END = 2,
	HPX_TYPE_RC_END = 4,
	HPX_TYPE_RC_EC = 8,
	HPX_TYPE_ROOT_PORT = 16,
	HPX_TYPE_UPSTREAM = 32,
	HPX_TYPE_DOWNSTREAM = 64,
	HPX_TYPE_PCI_BRIDGE = 128,
	HPX_TYPE_PCIE_BRIDGE = 256,
};

enum hpx_type3_fn_type {
	HPX_FN_NORMAL = 1,
	HPX_FN_SRIOV_PHYS = 2,
	HPX_FN_SRIOV_VIRT = 4,
};

enum hpx_type3_cfg_loc {
	HPX_CFG_PCICFG = 0,
	HPX_CFG_PCIE_CAP = 1,
	HPX_CFG_PCIE_CAP_EXT = 2,
	HPX_CFG_VEND_CAP = 3,
	HPX_CFG_DVSEC = 4,
	HPX_CFG_MAX = 5,
};

enum pci_irq_reroute_variant {
	INTEL_IRQ_REROUTE_VARIANT = 1,
	MAX_IRQ_REROUTE_VARIANTS = 3,
};

struct pci_fixup {
	u16 vendor;
	u16 device;
	u32 class;
	unsigned int class_shift;
	int hook_offset;
};

enum {
	NVME_REG_CAP = 0,
	NVME_REG_VS = 8,
	NVME_REG_INTMS = 12,
	NVME_REG_INTMC = 16,
	NVME_REG_CC = 20,
	NVME_REG_CSTS = 28,
	NVME_REG_NSSR = 32,
	NVME_REG_AQA = 36,
	NVME_REG_ASQ = 40,
	NVME_REG_ACQ = 48,
	NVME_REG_CMBLOC = 56,
	NVME_REG_CMBSZ = 60,
	NVME_REG_DBS = 4096,
};

enum {
	NVME_CC_ENABLE = 1,
	NVME_CC_CSS_NVM = 0,
	NVME_CC_EN_SHIFT = 0,
	NVME_CC_CSS_SHIFT = 4,
	NVME_CC_MPS_SHIFT = 7,
	NVME_CC_AMS_SHIFT = 11,
	NVME_CC_SHN_SHIFT = 14,
	NVME_CC_IOSQES_SHIFT = 16,
	NVME_CC_IOCQES_SHIFT = 20,
	NVME_CC_AMS_RR = 0,
	NVME_CC_AMS_WRRU = 2048,
	NVME_CC_AMS_VS = 14336,
	NVME_CC_SHN_NONE = 0,
	NVME_CC_SHN_NORMAL = 16384,
	NVME_CC_SHN_ABRUPT = 32768,
	NVME_CC_SHN_MASK = 49152,
	NVME_CC_IOSQES = 393216,
	NVME_CC_IOCQES = 4194304,
	NVME_CSTS_RDY = 1,
	NVME_CSTS_CFS = 2,
	NVME_CSTS_NSSRO = 16,
	NVME_CSTS_PP = 32,
	NVME_CSTS_SHST_NORMAL = 0,
	NVME_CSTS_SHST_OCCUR = 4,
	NVME_CSTS_SHST_CMPLT = 8,
	NVME_CSTS_SHST_MASK = 12,
};

enum {
	NVME_AEN_BIT_NS_ATTR = 8,
	NVME_AEN_BIT_FW_ACT = 9,
	NVME_AEN_BIT_ANA_CHANGE = 11,
	NVME_AEN_BIT_DISC_CHANGE = 31,
};

enum {
	SWITCHTEC_GAS_MRPC_OFFSET = 0,
	SWITCHTEC_GAS_TOP_CFG_OFFSET = 4096,
	SWITCHTEC_GAS_SW_EVENT_OFFSET = 6144,
	SWITCHTEC_GAS_SYS_INFO_OFFSET = 8192,
	SWITCHTEC_GAS_FLASH_INFO_OFFSET = 8704,
	SWITCHTEC_GAS_PART_CFG_OFFSET = 16384,
	SWITCHTEC_GAS_NTB_OFFSET = 65536,
	SWITCHTEC_GAS_PFF_CSR_OFFSET = 1261568,
};

enum {
	SWITCHTEC_NTB_REG_INFO_OFFSET = 0,
	SWITCHTEC_NTB_REG_CTRL_OFFSET = 16384,
	SWITCHTEC_NTB_REG_DBMSG_OFFSET = 409600,
};

struct nt_partition_info {
	u32 xlink_enabled;
	u32 target_part_low;
	u32 target_part_high;
	u32 reserved;
};

struct ntb_info_regs {
	u8 partition_count;
	u8 partition_id;
	u16 reserved1;
	u64 ep_map;
	u16 requester_id;
	u16 reserved2;
	u32 reserved3[4];
	struct nt_partition_info ntp_info[48];
} __attribute__((packed));

struct ntb_ctrl_regs {
	u32 partition_status;
	u32 partition_op;
	u32 partition_ctrl;
	u32 bar_setup;
	u32 bar_error;
	u16 lut_table_entries;
	u16 lut_table_offset;
	u32 lut_error;
	u16 req_id_table_size;
	u16 req_id_table_offset;
	u32 req_id_error;
	u32 reserved1[7];
	struct {
		u32 ctl;
		u32 win_size;
		u64 xlate_addr;
	} bar_entry[6];
	struct {
		u32 win_size;
		u32 reserved[3];
	} bar_ext_entry[6];
	u32 reserved2[192];
	u32 req_id_table[512];
	u32 reserved3[256];
	u64 lut_entry[512];
};

struct pci_dev_reset_methods {
	u16 vendor;
	u16 device;
	int (*reset)(struct pci_dev *, int);
};

struct pci_dev_acs_enabled {
	u16 vendor;
	u16 device;
	int (*acs_enabled)(struct pci_dev *, u16);
};

struct pci_dev_acs_ops {
	u16 vendor;
	u16 device;
	int (*enable_acs)(struct pci_dev *);
	int (*disable_acs_redir)(struct pci_dev *);
};

struct portdrv_service_data {
	struct pcie_port_service_driver *drv;
	struct device *dev;
	u32 service;
};

typedef int (*pcie_pm_callback_t)(struct pcie_device *);

struct aspm_latency {
	u32 l0s;
	u32 l1;
};

struct pcie_link_state {
	struct pci_dev *pdev;
	struct pci_dev *downstream;
	struct pcie_link_state *root;
	struct pcie_link_state *parent;
	struct list_head sibling;
	u32 aspm_support: 7;
	u32 aspm_enabled: 7;
	u32 aspm_capable: 7;
	u32 aspm_default: 7;
	char: 4;
	u32 aspm_disable: 7;
	u32 clkpm_capable: 1;
	u32 clkpm_enabled: 1;
	u32 clkpm_default: 1;
	u32 clkpm_disable: 1;
	struct aspm_latency latency_up;
	struct aspm_latency latency_dw;
	struct aspm_latency acceptable[8];
	struct {
		u32 up_cap_ptr;
		u32 dw_cap_ptr;
		u32 ctl1;
		u32 ctl2;
	} l1ss;
};

struct aspm_register_info {
	u32 support: 2;
	u32 enabled: 2;
	u32 latency_encoding_l0s;
	u32 latency_encoding_l1;
	u32 l1ss_cap_ptr;
	u32 l1ss_cap;
	u32 l1ss_ctl1;
	u32 l1ss_ctl2;
};

struct aer_stats {
	u64 dev_cor_errs[16];
	u64 dev_fatal_errs[27];
	u64 dev_nonfatal_errs[27];
	u64 dev_total_cor_errs;
	u64 dev_total_fatal_errs;
	u64 dev_total_nonfatal_errs;
	u64 rootport_total_cor_errs;
	u64 rootport_total_fatal_errs;
	u64 rootport_total_nonfatal_errs;
};

enum acpi_hest_types {
	ACPI_HEST_TYPE_IA32_CHECK = 0,
	ACPI_HEST_TYPE_IA32_CORRECTED_CHECK = 1,
	ACPI_HEST_TYPE_IA32_NMI = 2,
	ACPI_HEST_TYPE_NOT_USED3 = 3,
	ACPI_HEST_TYPE_NOT_USED4 = 4,
	ACPI_HEST_TYPE_NOT_USED5 = 5,
	ACPI_HEST_TYPE_AER_ROOT_PORT = 6,
	ACPI_HEST_TYPE_AER_ENDPOINT = 7,
	ACPI_HEST_TYPE_AER_BRIDGE = 8,
	ACPI_HEST_TYPE_GENERIC_ERROR = 9,
	ACPI_HEST_TYPE_GENERIC_ERROR_V2 = 10,
	ACPI_HEST_TYPE_IA32_DEFERRED_CHECK = 11,
	ACPI_HEST_TYPE_RESERVED = 12,
};

struct acpi_hest_aer_common {
	u16 reserved1;
	u8 flags;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	u32 bus;
	u16 device;
	u16 function;
	u16 device_control;
	u16 reserved2;
	u32 uncorrectable_mask;
	u32 uncorrectable_severity;
	u32 correctable_mask;
	u32 advanced_capabilities;
};

typedef int (*apei_hest_func_t)(struct acpi_hest_header *, void *);

struct aer_header_log_regs {
	unsigned int dw0;
	unsigned int dw1;
	unsigned int dw2;
	unsigned int dw3;
};

struct aer_capability_regs {
	u32 header;
	u32 uncor_status;
	u32 uncor_mask;
	u32 uncor_severity;
	u32 cor_status;
	u32 cor_mask;
	u32 cap_control;
	struct aer_header_log_regs header_log;
	u32 root_command;
	u32 root_status;
	u16 cor_err_source;
	u16 uncor_err_source;
};

struct aer_err_info {
	struct pci_dev *dev[5];
	int error_dev_num;
	unsigned int id: 16;
	unsigned int severity: 2;
	unsigned int __pad1: 5;
	unsigned int multi_error_valid: 1;
	unsigned int first_error: 5;
	unsigned int __pad2: 2;
	unsigned int tlp_header_valid: 1;
	unsigned int status;
	unsigned int mask;
	struct aer_header_log_regs tlp;
};

struct aer_err_source {
	unsigned int status;
	unsigned int id;
};

struct aer_rpc {
	struct pci_dev *rpd;
	struct {
		union {
			struct __kfifo kfifo;
			struct aer_err_source *type;
			const struct aer_err_source *const_type;
			char (*rectype)[0];
			struct aer_err_source *ptr;
			const struct aer_err_source *ptr_const;
		};
		struct aer_err_source buf[128];
	} aer_fifo;
};

struct aer_hest_parse_info {
	struct pci_dev *pci_dev;
	int firmware_first;
};

struct aer_recover_entry {
	u8 bus;
	u8 devfn;
	u16 domain;
	int severity;
	struct aer_capability_regs *regs;
};

struct pcie_pme_service_data {
	spinlock_t lock;
	struct pcie_device *srv;
	struct work_struct work;
	bool noirq;
};

typedef acpi_status (*acpi_walk_callback)(acpi_handle, u32, void *, void **);

struct controller {
	struct pcie_device *pcie;
	u32 slot_cap;
	u16 slot_ctrl;
	struct mutex ctrl_lock;
	long unsigned int cmd_started;
	unsigned int cmd_busy: 1;
	wait_queue_head_t queue;
	atomic_t pending_events;
	unsigned int notification_enabled: 1;
	unsigned int power_fault_detected;
	struct task_struct *poll_thread;
	u8 state;
	struct mutex state_lock;
	struct delayed_work button_work;
	struct hotplug_slot hotplug_slot;
	struct rw_semaphore reset_lock;
	unsigned int ist_running;
	int request_result;
	wait_queue_head_t requester;
};

struct acpiphp_slot;

struct slot {
	struct hotplug_slot hotplug_slot;
	struct acpiphp_slot *acpi_slot;
	unsigned int sun;
};

struct acpiphp_slot {
	struct list_head node;
	struct pci_bus *bus;
	struct list_head funcs;
	struct slot *slot;
	u8 device;
	u32 flags;
};

struct acpiphp_attention_info {
	int (*set_attn)(struct hotplug_slot *, u8);
	int (*get_attn)(struct hotplug_slot *, u8 *);
	struct module *owner;
};

struct acpiphp_context;

struct acpiphp_bridge {
	struct list_head list;
	struct list_head slots;
	struct kref ref;
	struct acpiphp_context *context;
	int nr_slots;
	struct pci_bus *pci_bus;
	struct pci_dev *pci_dev;
	bool is_going_away;
};

struct acpiphp_func {
	struct acpiphp_bridge *parent;
	struct acpiphp_slot *slot;
	struct list_head sibling;
	u8 function;
	u32 flags;
};

struct acpiphp_context {
	struct acpi_hotplug_context hp;
	struct acpiphp_func func;
	struct acpiphp_bridge *bridge;
	unsigned int refcount;
};

struct acpiphp_root_context {
	struct acpi_hotplug_context hp;
	struct acpiphp_bridge *root_bridge;
};

struct msix_entry {
	u32 vector;
	u16 entry;
};

enum dmi_device_type {
	DMI_DEV_TYPE_ANY = 0,
	DMI_DEV_TYPE_OTHER = 1,
	DMI_DEV_TYPE_UNKNOWN = 2,
	DMI_DEV_TYPE_VIDEO = 3,
	DMI_DEV_TYPE_SCSI = 4,
	DMI_DEV_TYPE_ETHERNET = 5,
	DMI_DEV_TYPE_TOKENRING = 6,
	DMI_DEV_TYPE_SOUND = 7,
	DMI_DEV_TYPE_PATA = 8,
	DMI_DEV_TYPE_SATA = 9,
	DMI_DEV_TYPE_SAS = 10,
	DMI_DEV_TYPE_IPMI = 4294967295,
	DMI_DEV_TYPE_OEM_STRING = 4294967294,
	DMI_DEV_TYPE_DEV_ONBOARD = 4294967293,
	DMI_DEV_TYPE_DEV_SLOT = 4294967292,
};

struct dmi_device {
	struct list_head list;
	int type;
	const char *name;
	void *device_data;
};

struct dmi_dev_onboard {
	struct dmi_device dev;
	int instance;
	int segment;
	int bus;
	int devfn;
};

enum smbios_attr_enum {
	SMBIOS_ATTR_NONE = 0,
	SMBIOS_ATTR_LABEL_SHOW = 1,
	SMBIOS_ATTR_INSTANCE_SHOW = 2,
};

enum acpi_attr_enum {
	ACPI_ATTR_LABEL_SHOW = 0,
	ACPI_ATTR_INDEX_SHOW = 1,
};

struct dma_domain {
	struct list_head node;
	const struct dma_map_ops *dma_ops;
	int domain_nr;
};

enum vmd_features {
	VMD_FEAT_HAS_MEMBAR_SHADOW = 1,
	VMD_FEAT_HAS_BUS_RESTRICTIONS = 2,
};

struct vmd_irq_list;

struct vmd_irq {
	struct list_head node;
	struct vmd_irq_list *irq;
	bool enabled;
	unsigned int virq;
};

struct vmd_irq_list {
	struct list_head irq_list;
	struct srcu_struct srcu;
	unsigned int count;
};

struct vmd_dev {
	struct pci_dev *dev;
	spinlock_t cfg_lock;
	char *cfgbar;
	int msix_count;
	struct vmd_irq_list *irqs;
	struct pci_sysdata sysdata;
	struct resource resources[3];
	struct irq_domain *irq_domain;
	struct pci_bus *bus;
	u8 busn_start;
	struct dma_map_ops dma_ops;
	struct dma_domain dma_domain;
};

enum hdmi_infoframe_type {
	HDMI_INFOFRAME_TYPE_VENDOR = 129,
	HDMI_INFOFRAME_TYPE_AVI = 130,
	HDMI_INFOFRAME_TYPE_SPD = 131,
	HDMI_INFOFRAME_TYPE_AUDIO = 132,
	HDMI_INFOFRAME_TYPE_DRM = 135,
};

struct hdmi_any_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
};

enum hdmi_colorspace {
	HDMI_COLORSPACE_RGB = 0,
	HDMI_COLORSPACE_YUV422 = 1,
	HDMI_COLORSPACE_YUV444 = 2,
	HDMI_COLORSPACE_YUV420 = 3,
	HDMI_COLORSPACE_RESERVED4 = 4,
	HDMI_COLORSPACE_RESERVED5 = 5,
	HDMI_COLORSPACE_RESERVED6 = 6,
	HDMI_COLORSPACE_IDO_DEFINED = 7,
};

enum hdmi_scan_mode {
	HDMI_SCAN_MODE_NONE = 0,
	HDMI_SCAN_MODE_OVERSCAN = 1,
	HDMI_SCAN_MODE_UNDERSCAN = 2,
	HDMI_SCAN_MODE_RESERVED = 3,
};

enum hdmi_colorimetry {
	HDMI_COLORIMETRY_NONE = 0,
	HDMI_COLORIMETRY_ITU_601 = 1,
	HDMI_COLORIMETRY_ITU_709 = 2,
	HDMI_COLORIMETRY_EXTENDED = 3,
};

enum hdmi_picture_aspect {
	HDMI_PICTURE_ASPECT_NONE = 0,
	HDMI_PICTURE_ASPECT_4_3 = 1,
	HDMI_PICTURE_ASPECT_16_9 = 2,
	HDMI_PICTURE_ASPECT_64_27 = 3,
	HDMI_PICTURE_ASPECT_256_135 = 4,
	HDMI_PICTURE_ASPECT_RESERVED = 5,
};

enum hdmi_active_aspect {
	HDMI_ACTIVE_ASPECT_16_9_TOP = 2,
	HDMI_ACTIVE_ASPECT_14_9_TOP = 3,
	HDMI_ACTIVE_ASPECT_16_9_CENTER = 4,
	HDMI_ACTIVE_ASPECT_PICTURE = 8,
	HDMI_ACTIVE_ASPECT_4_3 = 9,
	HDMI_ACTIVE_ASPECT_16_9 = 10,
	HDMI_ACTIVE_ASPECT_14_9 = 11,
	HDMI_ACTIVE_ASPECT_4_3_SP_14_9 = 13,
	HDMI_ACTIVE_ASPECT_16_9_SP_14_9 = 14,
	HDMI_ACTIVE_ASPECT_16_9_SP_4_3 = 15,
};

enum hdmi_extended_colorimetry {
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_601 = 0,
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_709 = 1,
	HDMI_EXTENDED_COLORIMETRY_S_YCC_601 = 2,
	HDMI_EXTENDED_COLORIMETRY_OPYCC_601 = 3,
	HDMI_EXTENDED_COLORIMETRY_OPRGB = 4,
	HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM = 5,
	HDMI_EXTENDED_COLORIMETRY_BT2020 = 6,
	HDMI_EXTENDED_COLORIMETRY_RESERVED = 7,
};

enum hdmi_quantization_range {
	HDMI_QUANTIZATION_RANGE_DEFAULT = 0,
	HDMI_QUANTIZATION_RANGE_LIMITED = 1,
	HDMI_QUANTIZATION_RANGE_FULL = 2,
	HDMI_QUANTIZATION_RANGE_RESERVED = 3,
};

enum hdmi_nups {
	HDMI_NUPS_UNKNOWN = 0,
	HDMI_NUPS_HORIZONTAL = 1,
	HDMI_NUPS_VERTICAL = 2,
	HDMI_NUPS_BOTH = 3,
};

enum hdmi_ycc_quantization_range {
	HDMI_YCC_QUANTIZATION_RANGE_LIMITED = 0,
	HDMI_YCC_QUANTIZATION_RANGE_FULL = 1,
};

enum hdmi_content_type {
	HDMI_CONTENT_TYPE_GRAPHICS = 0,
	HDMI_CONTENT_TYPE_PHOTO = 1,
	HDMI_CONTENT_TYPE_CINEMA = 2,
	HDMI_CONTENT_TYPE_GAME = 3,
};

enum hdmi_metadata_type {
	HDMI_STATIC_METADATA_TYPE1 = 1,
};

enum hdmi_eotf {
	HDMI_EOTF_TRADITIONAL_GAMMA_SDR = 0,
	HDMI_EOTF_TRADITIONAL_GAMMA_HDR = 1,
	HDMI_EOTF_SMPTE_ST2084 = 2,
	HDMI_EOTF_BT_2100_HLG = 3,
};

struct hdmi_avi_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_colorspace colorspace;
	enum hdmi_scan_mode scan_mode;
	enum hdmi_colorimetry colorimetry;
	enum hdmi_picture_aspect picture_aspect;
	enum hdmi_active_aspect active_aspect;
	bool itc;
	enum hdmi_extended_colorimetry extended_colorimetry;
	enum hdmi_quantization_range quantization_range;
	enum hdmi_nups nups;
	unsigned char video_code;
	enum hdmi_ycc_quantization_range ycc_quantization_range;
	enum hdmi_content_type content_type;
	unsigned char pixel_repeat;
	short unsigned int top_bar;
	short unsigned int bottom_bar;
	short unsigned int left_bar;
	short unsigned int right_bar;
};

struct hdmi_drm_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_eotf eotf;
	enum hdmi_metadata_type metadata_type;
	struct {
		u16 x;
		u16 y;
	} display_primaries[3];
	struct {
		u16 x;
		u16 y;
	} white_point;
	u16 max_display_mastering_luminance;
	u16 min_display_mastering_luminance;
	u16 max_cll;
	u16 max_fall;
};

enum hdmi_spd_sdi {
	HDMI_SPD_SDI_UNKNOWN = 0,
	HDMI_SPD_SDI_DSTB = 1,
	HDMI_SPD_SDI_DVDP = 2,
	HDMI_SPD_SDI_DVHS = 3,
	HDMI_SPD_SDI_HDDVR = 4,
	HDMI_SPD_SDI_DVC = 5,
	HDMI_SPD_SDI_DSC = 6,
	HDMI_SPD_SDI_VCD = 7,
	HDMI_SPD_SDI_GAME = 8,
	HDMI_SPD_SDI_PC = 9,
	HDMI_SPD_SDI_BD = 10,
	HDMI_SPD_SDI_SACD = 11,
	HDMI_SPD_SDI_HDDVD = 12,
	HDMI_SPD_SDI_PMP = 13,
};

struct hdmi_spd_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	char vendor[8];
	char product[16];
	enum hdmi_spd_sdi sdi;
};

enum hdmi_audio_coding_type {
	HDMI_AUDIO_CODING_TYPE_STREAM = 0,
	HDMI_AUDIO_CODING_TYPE_PCM = 1,
	HDMI_AUDIO_CODING_TYPE_AC3 = 2,
	HDMI_AUDIO_CODING_TYPE_MPEG1 = 3,
	HDMI_AUDIO_CODING_TYPE_MP3 = 4,
	HDMI_AUDIO_CODING_TYPE_MPEG2 = 5,
	HDMI_AUDIO_CODING_TYPE_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_DTS = 7,
	HDMI_AUDIO_CODING_TYPE_ATRAC = 8,
	HDMI_AUDIO_CODING_TYPE_DSD = 9,
	HDMI_AUDIO_CODING_TYPE_EAC3 = 10,
	HDMI_AUDIO_CODING_TYPE_DTS_HD = 11,
	HDMI_AUDIO_CODING_TYPE_MLP = 12,
	HDMI_AUDIO_CODING_TYPE_DST = 13,
	HDMI_AUDIO_CODING_TYPE_WMA_PRO = 14,
	HDMI_AUDIO_CODING_TYPE_CXT = 15,
};

enum hdmi_audio_sample_size {
	HDMI_AUDIO_SAMPLE_SIZE_STREAM = 0,
	HDMI_AUDIO_SAMPLE_SIZE_16 = 1,
	HDMI_AUDIO_SAMPLE_SIZE_20 = 2,
	HDMI_AUDIO_SAMPLE_SIZE_24 = 3,
};

enum hdmi_audio_sample_frequency {
	HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM = 0,
	HDMI_AUDIO_SAMPLE_FREQUENCY_32000 = 1,
	HDMI_AUDIO_SAMPLE_FREQUENCY_44100 = 2,
	HDMI_AUDIO_SAMPLE_FREQUENCY_48000 = 3,
	HDMI_AUDIO_SAMPLE_FREQUENCY_88200 = 4,
	HDMI_AUDIO_SAMPLE_FREQUENCY_96000 = 5,
	HDMI_AUDIO_SAMPLE_FREQUENCY_176400 = 6,
	HDMI_AUDIO_SAMPLE_FREQUENCY_192000 = 7,
};

enum hdmi_audio_coding_type_ext {
	HDMI_AUDIO_CODING_TYPE_EXT_CT = 0,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC = 1,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2 = 2,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND = 3,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC = 4,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2 = 5,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_EXT_DRA = 7,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND = 8,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND = 10,
};

struct hdmi_audio_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned char channels;
	enum hdmi_audio_coding_type coding_type;
	enum hdmi_audio_sample_size sample_size;
	enum hdmi_audio_sample_frequency sample_frequency;
	enum hdmi_audio_coding_type_ext coding_type_ext;
	unsigned char channel_allocation;
	unsigned char level_shift_value;
	bool downmix_inhibit;
};

enum hdmi_3d_structure {
	HDMI_3D_STRUCTURE_INVALID = 4294967295,
	HDMI_3D_STRUCTURE_FRAME_PACKING = 0,
	HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE = 1,
	HDMI_3D_STRUCTURE_LINE_ALTERNATIVE = 2,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL = 3,
	HDMI_3D_STRUCTURE_L_DEPTH = 4,
	HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH = 5,
	HDMI_3D_STRUCTURE_TOP_AND_BOTTOM = 6,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF = 8,
};

struct hdmi_vendor_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned int oui;
	u8 vic;
	enum hdmi_3d_structure s3d_struct;
	unsigned int s3d_ext_data;
};

union hdmi_vendor_any_infoframe {
	struct {
		enum hdmi_infoframe_type type;
		unsigned char version;
		unsigned char length;
		unsigned int oui;
	} any;
	struct hdmi_vendor_infoframe hdmi;
};

union hdmi_infoframe {
	struct hdmi_any_infoframe any;
	struct hdmi_avi_infoframe avi;
	struct hdmi_spd_infoframe spd;
	union hdmi_vendor_any_infoframe vendor;
	struct hdmi_audio_infoframe audio;
	struct hdmi_drm_infoframe drm;
};

struct console_font {
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_mode {
	char mode;
	char waitv;
	short int relsig;
	short int acqsig;
	short int frsig;
};

struct uni_pagedir;

struct uni_screen;

struct vc_data {
	struct tty_port port;
	short unsigned int vc_num;
	unsigned int vc_cols;
	unsigned int vc_rows;
	unsigned int vc_size_row;
	unsigned int vc_scan_lines;
	long unsigned int vc_origin;
	long unsigned int vc_scr_end;
	long unsigned int vc_visible_origin;
	unsigned int vc_top;
	unsigned int vc_bottom;
	const struct consw *vc_sw;
	short unsigned int *vc_screenbuf;
	unsigned int vc_screenbuf_size;
	unsigned char vc_mode;
	unsigned char vc_attr;
	unsigned char vc_def_color;
	unsigned char vc_color;
	unsigned char vc_s_color;
	unsigned char vc_ulcolor;
	unsigned char vc_itcolor;
	unsigned char vc_halfcolor;
	unsigned int vc_cursor_type;
	short unsigned int vc_complement_mask;
	short unsigned int vc_s_complement_mask;
	unsigned int vc_x;
	unsigned int vc_y;
	unsigned int vc_saved_x;
	unsigned int vc_saved_y;
	long unsigned int vc_pos;
	short unsigned int vc_hi_font_mask;
	struct console_font vc_font;
	short unsigned int vc_video_erase_char;
	unsigned int vc_state;
	unsigned int vc_npar;
	unsigned int vc_par[16];
	struct vt_mode vt_mode;
	struct pid *vt_pid;
	int vt_newvt;
	wait_queue_head_t paste_wait;
	unsigned int vc_charset: 1;
	unsigned int vc_s_charset: 1;
	unsigned int vc_disp_ctrl: 1;
	unsigned int vc_toggle_meta: 1;
	unsigned int vc_decscnm: 1;
	unsigned int vc_decom: 1;
	unsigned int vc_decawm: 1;
	unsigned int vc_deccm: 1;
	unsigned int vc_decim: 1;
	unsigned int vc_intensity: 2;
	unsigned int vc_italic: 1;
	unsigned int vc_underline: 1;
	unsigned int vc_blink: 1;
	unsigned int vc_reverse: 1;
	unsigned int vc_s_intensity: 2;
	unsigned int vc_s_italic: 1;
	unsigned int vc_s_underline: 1;
	unsigned int vc_s_blink: 1;
	unsigned int vc_s_reverse: 1;
	unsigned int vc_priv: 3;
	unsigned int vc_need_wrap: 1;
	unsigned int vc_can_do_color: 1;
	unsigned int vc_report_mouse: 2;
	unsigned char vc_utf: 1;
	unsigned char vc_utf_count;
	int vc_utf_char;
	unsigned int vc_tab_stop[8];
	unsigned char vc_palette[48];
	short unsigned int *vc_translate;
	unsigned char vc_G0_charset;
	unsigned char vc_G1_charset;
	unsigned char vc_saved_G0;
	unsigned char vc_saved_G1;
	unsigned int vc_resize_user;
	unsigned int vc_bell_pitch;
	unsigned int vc_bell_duration;
	short unsigned int vc_cur_blink_ms;
	struct vc_data **vc_display_fg;
	struct uni_pagedir *vc_uni_pagedir;
	struct uni_pagedir **vc_uni_pagedir_loc;
	struct uni_screen *vc_uni_screen;
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;
};

struct vgastate {
	void *vgabase;
	long unsigned int membase;
	__u32 memsize;
	__u32 flags;
	__u32 depth;
	__u32 num_attr;
	__u32 num_crtc;
	__u32 num_gfx;
	__u32 num_seq;
	void *vidstate;
};

struct fb_fix_screeninfo {
	char id[16];
	long unsigned int smem_start;
	__u32 smem_len;
	__u32 type;
	__u32 type_aux;
	__u32 visual;
	__u16 xpanstep;
	__u16 ypanstep;
	__u16 ywrapstep;
	__u32 line_length;
	long unsigned int mmio_start;
	__u32 mmio_len;
	__u32 accel;
	__u16 capabilities;
	__u16 reserved[2];
};

struct fb_bitfield {
	__u32 offset;
	__u32 length;
	__u32 msb_right;
};

struct fb_var_screeninfo {
	__u32 xres;
	__u32 yres;
	__u32 xres_virtual;
	__u32 yres_virtual;
	__u32 xoffset;
	__u32 yoffset;
	__u32 bits_per_pixel;
	__u32 grayscale;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	__u32 nonstd;
	__u32 activate;
	__u32 height;
	__u32 width;
	__u32 accel_flags;
	__u32 pixclock;
	__u32 left_margin;
	__u32 right_margin;
	__u32 upper_margin;
	__u32 lower_margin;
	__u32 hsync_len;
	__u32 vsync_len;
	__u32 sync;
	__u32 vmode;
	__u32 rotate;
	__u32 colorspace;
	__u32 reserved[4];
};

struct fb_cmap {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

enum {
	FB_BLANK_UNBLANK = 0,
	FB_BLANK_NORMAL = 1,
	FB_BLANK_VSYNC_SUSPEND = 2,
	FB_BLANK_HSYNC_SUSPEND = 3,
	FB_BLANK_POWERDOWN = 4,
};

struct fb_copyarea {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 sx;
	__u32 sy;
};

struct fb_fillrect {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 color;
	__u32 rop;
};

struct fb_image {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 fg_color;
	__u32 bg_color;
	__u8 depth;
	const char *data;
	struct fb_cmap cmap;
};

struct fbcurpos {
	__u16 x;
	__u16 y;
};

struct fb_cursor {
	__u16 set;
	__u16 enable;
	__u16 rop;
	const char *mask;
	struct fbcurpos hot;
	struct fb_image image;
};

struct fb_chroma {
	__u32 redx;
	__u32 greenx;
	__u32 bluex;
	__u32 whitex;
	__u32 redy;
	__u32 greeny;
	__u32 bluey;
	__u32 whitey;
};

struct fb_videomode;

struct fb_monspecs {
	struct fb_chroma chroma;
	struct fb_videomode *modedb;
	__u8 manufacturer[4];
	__u8 monitor[14];
	__u8 serial_no[14];
	__u8 ascii[14];
	__u32 modedb_len;
	__u32 model;
	__u32 serial;
	__u32 year;
	__u32 week;
	__u32 hfmin;
	__u32 hfmax;
	__u32 dclkmin;
	__u32 dclkmax;
	__u16 input;
	__u16 dpms;
	__u16 signal;
	__u16 vfmin;
	__u16 vfmax;
	__u16 gamma;
	__u16 gtf: 1;
	__u16 misc;
	__u8 version;
	__u8 revision;
	__u8 max_x;
	__u8 max_y;
};

struct fb_info;

struct fb_pixmap {
	u8 *addr;
	u32 size;
	u32 offset;
	u32 buf_align;
	u32 scan_align;
	u32 access_align;
	u32 flags;
	u32 blit_x;
	u32 blit_y;
	void (*writeio)(struct fb_info *, void *, void *, unsigned int);
	void (*readio)(struct fb_info *, void *, void *, unsigned int);
};

struct fb_deferred_io;

struct fb_ops;

struct apertures_struct;

struct fb_info {
	atomic_t count;
	int node;
	int flags;
	int fbcon_rotate_hint;
	struct mutex lock;
	struct mutex mm_lock;
	struct fb_var_screeninfo var;
	struct fb_fix_screeninfo fix;
	struct fb_monspecs monspecs;
	struct work_struct queue;
	struct fb_pixmap pixmap;
	struct fb_pixmap sprite;
	struct fb_cmap cmap;
	struct list_head modelist;
	struct fb_videomode *mode;
	struct delayed_work deferred_work;
	struct fb_deferred_io *fbdefio;
	struct fb_ops *fbops;
	struct device *device;
	struct device *dev;
	int class_flag;
	union {
		char *screen_base;
		char *screen_buffer;
	};
	long unsigned int screen_size;
	void *pseudo_palette;
	u32 state;
	void *fbcon_par;
	void *par;
	struct apertures_struct *apertures;
	bool skip_vt_switch;
};

struct fb_videomode {
	const char *name;
	u32 refresh;
	u32 xres;
	u32 yres;
	u32 pixclock;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 sync;
	u32 vmode;
	u32 flag;
};

struct fb_cmap_user {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_event {
	struct fb_info *info;
	void *data;
};

struct fb_blit_caps {
	u32 x;
	u32 y;
	u32 len;
	u32 flags;
};

struct fb_deferred_io {
	long unsigned int delay;
	struct mutex lock;
	struct list_head pagelist;
	void (*first_io)(struct fb_info *);
	void (*deferred_io)(struct fb_info *, struct list_head *);
};

struct fb_ops {
	struct module *owner;
	int (*fb_open)(struct fb_info *, int);
	int (*fb_release)(struct fb_info *, int);
	ssize_t (*fb_read)(struct fb_info *, char *, size_t, loff_t *);
	ssize_t (*fb_write)(struct fb_info *, const char *, size_t, loff_t *);
	int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *);
	int (*fb_set_par)(struct fb_info *);
	int (*fb_setcolreg)(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, struct fb_info *);
	int (*fb_setcmap)(struct fb_cmap *, struct fb_info *);
	int (*fb_blank)(int, struct fb_info *);
	int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *);
	void (*fb_fillrect)(struct fb_info *, const struct fb_fillrect *);
	void (*fb_copyarea)(struct fb_info *, const struct fb_copyarea *);
	void (*fb_imageblit)(struct fb_info *, const struct fb_image *);
	int (*fb_cursor)(struct fb_info *, struct fb_cursor *);
	int (*fb_sync)(struct fb_info *);
	int (*fb_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_compat_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_mmap)(struct fb_info *, struct vm_area_struct *);
	void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *);
	void (*fb_destroy)(struct fb_info *);
	int (*fb_debug_enter)(struct fb_info *);
	int (*fb_debug_leave)(struct fb_info *);
};

struct aperture {
	resource_size_t base;
	resource_size_t size;
};

struct apertures_struct {
	unsigned int count;
	struct aperture ranges[0];
};

struct fb_modelist {
	struct list_head list;
	struct fb_videomode mode;
};

struct fb_fix_screeninfo32 {
	char id[16];
	compat_caddr_t smem_start;
	u32 smem_len;
	u32 type;
	u32 type_aux;
	u32 visual;
	u16 xpanstep;
	u16 ypanstep;
	u16 ywrapstep;
	u32 line_length;
	compat_caddr_t mmio_start;
	u32 mmio_len;
	u32 accel;
	u16 reserved[3];
};

struct fb_cmap32 {
	u32 start;
	u32 len;
	compat_caddr_t red;
	compat_caddr_t green;
	compat_caddr_t blue;
	compat_caddr_t transp;
};

struct fb_cvt_data {
	u32 xres;
	u32 yres;
	u32 refresh;
	u32 f_refresh;
	u32 pixclock;
	u32 hperiod;
	u32 hblank;
	u32 hfreq;
	u32 htotal;
	u32 vtotal;
	u32 vsync;
	u32 hsync;
	u32 h_front_porch;
	u32 h_back_porch;
	u32 v_front_porch;
	u32 v_back_porch;
	u32 h_margin;
	u32 v_margin;
	u32 interlace;
	u32 aspect_ratio;
	u32 active_pixels;
	u32 flags;
	u32 status;
};

typedef unsigned char u_char;

typedef short unsigned int u_short;

struct fb_con2fbmap {
	__u32 console;
	__u32 framebuffer;
};

struct fbcon_display {
	const u_char *fontdata;
	int userfont;
	u_short scrollmode;
	u_short inverse;
	short int yscroll;
	int vrows;
	int cursor_shape;
	int con_rotate;
	u32 xres_virtual;
	u32 yres_virtual;
	u32 height;
	u32 width;
	u32 bits_per_pixel;
	u32 grayscale;
	u32 nonstd;
	u32 accel_flags;
	u32 rotate;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	const struct fb_videomode *mode;
};

struct fbcon_ops {
	void (*bmove)(struct vc_data *, struct fb_info *, int, int, int, int, int, int);
	void (*clear)(struct vc_data *, struct fb_info *, int, int, int, int);
	void (*putcs)(struct vc_data *, struct fb_info *, const short unsigned int *, int, int, int, int, int);
	void (*clear_margins)(struct vc_data *, struct fb_info *, int, int);
	void (*cursor)(struct vc_data *, struct fb_info *, int, int, int);
	int (*update_start)(struct fb_info *);
	int (*rotate_font)(struct fb_info *, struct vc_data *);
	struct fb_var_screeninfo var;
	struct timer_list cursor_timer;
	struct fb_cursor cursor_state;
	struct fbcon_display *p;
	struct fb_info *info;
	int currcon;
	int cur_blink_jiffies;
	int cursor_flash;
	int cursor_reset;
	int blank_state;
	int graphics;
	int save_graphics;
	int flags;
	int rotate;
	int cur_rotate;
	char *cursor_data;
	u8 *fontbuffer;
	u8 *fontdata;
	u8 *cursor_src;
	u32 cursor_size;
	u32 fd_size;
};

enum {
	FBCON_LOGO_CANSHOW = 4294967295,
	FBCON_LOGO_DRAW = 4294967294,
	FBCON_LOGO_DONTSHOW = 4294967293,
};

enum drm_panel_orientation {
	DRM_MODE_PANEL_ORIENTATION_UNKNOWN = 4294967295,
	DRM_MODE_PANEL_ORIENTATION_NORMAL = 0,
	DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP = 1,
	DRM_MODE_PANEL_ORIENTATION_LEFT_UP = 2,
	DRM_MODE_PANEL_ORIENTATION_RIGHT_UP = 3,
};

struct thermal_cooling_device_ops;

struct thermal_cooling_device {
	int id;
	char type[20];
	struct device device;
	struct device_node *np;
	void *devdata;
	void *stats;
	const struct thermal_cooling_device_ops *ops;
	bool updated;
	struct mutex lock;
	struct list_head thermal_instances;
	struct list_head node;
};

struct idle_cpu {
	struct cpuidle_state *state_table;
	long unsigned int auto_demotion_disable_flags;
	bool byt_auto_demotion_disable_flag;
	bool disable_promotion_to_c1e;
	bool use_acpi;
};

enum thermal_device_mode {
	THERMAL_DEVICE_DISABLED = 0,
	THERMAL_DEVICE_ENABLED = 1,
};

enum thermal_trip_type {
	THERMAL_TRIP_ACTIVE = 0,
	THERMAL_TRIP_PASSIVE = 1,
	THERMAL_TRIP_HOT = 2,
	THERMAL_TRIP_CRITICAL = 3,
};

enum thermal_trend {
	THERMAL_TREND_STABLE = 0,
	THERMAL_TREND_RAISING = 1,
	THERMAL_TREND_DROPPING = 2,
	THERMAL_TREND_RAISE_FULL = 3,
	THERMAL_TREND_DROP_FULL = 4,
};

enum thermal_notify_event {
	THERMAL_EVENT_UNSPECIFIED = 0,
	THERMAL_EVENT_TEMP_SAMPLE = 1,
	THERMAL_TRIP_VIOLATED = 2,
	THERMAL_TRIP_CHANGED = 3,
	THERMAL_DEVICE_DOWN = 4,
	THERMAL_DEVICE_UP = 5,
	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
	THERMAL_TABLE_CHANGED = 7,
};

struct thermal_zone_device;

struct thermal_zone_device_ops {
	int (*bind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*unbind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*get_temp)(struct thermal_zone_device *, int *);
	int (*set_trips)(struct thermal_zone_device *, int, int);
	int (*get_mode)(struct thermal_zone_device *, enum thermal_device_mode *);
	int (*set_mode)(struct thermal_zone_device *, enum thermal_device_mode);
	int (*get_trip_type)(struct thermal_zone_device *, int, enum thermal_trip_type *);
	int (*get_trip_temp)(struct thermal_zone_device *, int, int *);
	int (*set_trip_temp)(struct thermal_zone_device *, int, int);
	int (*get_trip_hyst)(struct thermal_zone_device *, int, int *);
	int (*set_trip_hyst)(struct thermal_zone_device *, int, int);
	int (*get_crit_temp)(struct thermal_zone_device *, int *);
	int (*set_emul_temp)(struct thermal_zone_device *, int);
	int (*get_trend)(struct thermal_zone_device *, int, enum thermal_trend *);
	int (*notify)(struct thermal_zone_device *, int, enum thermal_trip_type);
};

struct thermal_attr;

struct thermal_zone_params;

struct thermal_governor;

struct thermal_zone_device {
	int id;
	char type[20];
	struct device device;
	struct attribute_group trips_attribute_group;
	struct thermal_attr *trip_temp_attrs;
	struct thermal_attr *trip_type_attrs;
	struct thermal_attr *trip_hyst_attrs;
	void *devdata;
	int trips;
	long unsigned int trips_disabled;
	int passive_delay;
	int polling_delay;
	int temperature;
	int last_temperature;
	int emul_temperature;
	int passive;
	int prev_low_trip;
	int prev_high_trip;
	unsigned int forced_passive;
	atomic_t need_update;
	struct thermal_zone_device_ops *ops;
	struct thermal_zone_params *tzp;
	struct thermal_governor *governor;
	void *governor_data;
	struct list_head thermal_instances;
	struct ida ida;
	struct mutex lock;
	struct list_head node;
	struct delayed_work poll_queue;
	enum thermal_notify_event notify_event;
};

struct thermal_cooling_device_ops {
	int (*get_max_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*get_cur_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*set_cur_state)(struct thermal_cooling_device *, long unsigned int);
	int (*get_requested_power)(struct thermal_cooling_device *, struct thermal_zone_device *, u32 *);
	int (*state2power)(struct thermal_cooling_device *, struct thermal_zone_device *, long unsigned int, u32 *);
	int (*power2state)(struct thermal_cooling_device *, struct thermal_zone_device *, u32, long unsigned int *);
};

struct thermal_attr {
	struct device_attribute attr;
	char name[20];
};

struct thermal_bind_params;

struct thermal_zone_params {
	char governor_name[20];
	bool no_hwmon;
	int num_tbps;
	struct thermal_bind_params *tbp;
	u32 sustainable_power;
	s32 k_po;
	s32 k_pu;
	s32 k_i;
	s32 k_d;
	s32 integral_cutoff;
	int slope;
	int offset;
};

struct thermal_governor {
	char name[20];
	int (*bind_to_tz)(struct thermal_zone_device *);
	void (*unbind_from_tz)(struct thermal_zone_device *);
	int (*throttle)(struct thermal_zone_device *, int);
	struct list_head governor_list;
};

struct thermal_bind_params {
	struct thermal_cooling_device *cdev;
	int weight;
	int trip_mask;
	long unsigned int *binding_limits;
	int (*match)(struct thermal_zone_device *, struct thermal_cooling_device *);
};

struct acpi_lpi_state {
	u32 min_residency;
	u32 wake_latency;
	u32 flags;
	u32 arch_flags;
	u32 res_cnt_freq;
	u32 enable_parent_state;
	u64 address;
	u8 index;
	u8 entry_method;
	char desc[32];
};

struct acpi_processor_power {
	int count;
	union {
		struct acpi_processor_cx states[8];
		struct acpi_lpi_state lpi_states[8];
	};
	int timer_broadcast_on_state;
};

struct acpi_psd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_pct_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_processor_px {
	u64 core_frequency;
	u64 power;
	u64 transition_latency;
	u64 bus_master_latency;
	u64 control;
	u64 status;
};

struct acpi_processor_performance {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	short: 16;
	unsigned int state_count;
	int: 32;
	struct acpi_processor_px *states;
	struct acpi_psd_package domain_info;
	cpumask_var_t shared_cpu_map;
	unsigned int shared_type;
	int: 32;
} __attribute__((packed));

struct acpi_tsd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_processor_tx_tss {
	u64 freqpercentage;
	u64 power;
	u64 transition_latency;
	u64 control;
	u64 status;
};

struct acpi_processor_tx {
	u16 power;
	u16 performance;
};

struct acpi_processor;

struct acpi_processor_throttling {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	short: 16;
	unsigned int state_count;
	int: 32;
	struct acpi_processor_tx_tss *states_tss;
	struct acpi_tsd_package domain_info;
	cpumask_var_t shared_cpu_map;
	int (*acpi_processor_get_throttling)(struct acpi_processor *);
	int (*acpi_processor_set_throttling)(struct acpi_processor *, int, bool);
	u32 address;
	u8 duty_offset;
	u8 duty_width;
	u8 tsd_valid_flag;
	char: 8;
	unsigned int shared_type;
	struct acpi_processor_tx states[16];
	int: 32;
} __attribute__((packed));

struct acpi_processor_lx {
	int px;
	int tx;
};

struct acpi_processor_limit {
	struct acpi_processor_lx state;
	struct acpi_processor_lx thermal;
	struct acpi_processor_lx user;
};

struct acpi_processor {
	acpi_handle handle;
	u32 acpi_id;
	phys_cpuid_t phys_id;
	u32 id;
	u32 pblk;
	int performance_platform_limit;
	int throttling_platform_limit;
	struct acpi_processor_flags flags;
	struct acpi_processor_power power;
	struct acpi_processor_performance *performance;
	struct acpi_processor_throttling throttling;
	struct acpi_processor_limit limit;
	struct thermal_cooling_device *cdev;
	struct device *dev;
	struct freq_qos_request perflib_req;
	struct freq_qos_request thermal_req;
};

enum ipmi_addr_src {
	SI_INVALID = 0,
	SI_HOTMOD = 1,
	SI_HARDCODED = 2,
	SI_SPMI = 3,
	SI_ACPI = 4,
	SI_SMBIOS = 5,
	SI_PCI = 6,
	SI_DEVICETREE = 7,
	SI_PLATFORM = 8,
	SI_LAST = 9,
};

struct dmi_header {
	u8 type;
	u8 length;
	u16 handle;
};

enum si_type {
	SI_TYPE_INVALID = 0,
	SI_KCS = 1,
	SI_SMIC = 2,
	SI_BT = 3,
};

enum ipmi_addr_space {
	IPMI_IO_ADDR_SPACE = 0,
	IPMI_MEM_ADDR_SPACE = 1,
};

enum ipmi_plat_interface_type {
	IPMI_PLAT_IF_SI = 0,
	IPMI_PLAT_IF_SSIF = 1,
};

struct ipmi_plat_data {
	enum ipmi_plat_interface_type iftype;
	unsigned int type;
	unsigned int space;
	long unsigned int addr;
	unsigned int regspacing;
	unsigned int regsize;
	unsigned int regshift;
	unsigned int irq;
	unsigned int slave_addr;
	enum ipmi_addr_src addr_source;
};

struct ipmi_dmi_info {
	enum si_type si_type;
	unsigned int space;
	long unsigned int addr;
	u8 slave_addr;
	struct ipmi_dmi_info *next;
};

typedef u16 acpi_owner_id;

union acpi_name_union {
	u32 integer;
	char ascii[4];
};

struct acpi_table_desc {
	acpi_physical_address address;
	struct acpi_table_header *pointer;
	u32 length;
	union acpi_name_union signature;
	acpi_owner_id owner_id;
	u8 flags;
	u16 validation_count;
};

struct acpi_madt_io_sapic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 global_irq_base;
	u64 address;
};

struct acpi_madt_interrupt_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u8 type;
	u8 id;
	u8 eid;
	u8 io_sapic_vector;
	u32 global_irq;
	u32 flags;
};

struct acpi_madt_generic_interrupt {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 cpu_interface_number;
	u32 uid;
	u32 flags;
	u32 parking_version;
	u32 performance_interrupt;
	u64 parked_address;
	u64 base_address;
	u64 gicv_base_address;
	u64 gich_base_address;
	u32 vgic_interrupt;
	u64 gicr_base_address;
	u64 arm_mpidr;
	u8 efficiency_class;
	u8 reserved2[1];
	u16 spe_interrupt;
} __attribute__((packed));

struct acpi_madt_generic_distributor {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 gic_id;
	u64 base_address;
	u32 global_irq_base;
	u8 version;
	u8 reserved2[3];
};

enum acpi_subtable_type {
	ACPI_SUBTABLE_COMMON = 0,
	ACPI_SUBTABLE_HMAT = 1,
};

struct acpi_subtable_entry {
	union acpi_subtable_headers *hdr;
	enum acpi_subtable_type type;
};

enum acpi_predicate {
	all_versions = 0,
	less_than_or_equal = 1,
	equal = 2,
	greater_than_or_equal = 3,
};

struct acpi_platform_list {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
	char *table;
	enum acpi_predicate pred;
	char *reason;
	u32 data;
};

typedef u32 (*acpi_interface_handler)(acpi_string, u32);

struct acpi_osi_entry {
	char string[64];
	bool enable;
};

struct acpi_osi_config {
	u8 default_disabling;
	unsigned int linux_enable: 1;
	unsigned int linux_dmi: 1;
	unsigned int linux_cmdline: 1;
	unsigned int darwin_enable: 1;
	unsigned int darwin_dmi: 1;
	unsigned int darwin_cmdline: 1;
};

struct acpi_predefined_names {
	const char *name;
	u8 type;
	char *val;
};

typedef u32 (*acpi_osd_handler)(void *);

typedef void (*acpi_osd_exec_callback)(void *);

typedef u32 (*acpi_gpe_handler)(acpi_handle, u32, void *);

typedef void (*acpi_notify_handler)(acpi_handle, u32, void *);

typedef void (*acpi_object_handler)(acpi_handle, void *);

typedef acpi_status (*acpi_adr_space_handler)(u32, acpi_physical_address, u32, u64 *, void *, void *);

typedef acpi_status (*acpi_adr_space_setup)(acpi_handle, u32, void *, void **);

struct acpi_pci_id {
	u16 segment;
	u16 bus;
	u16 device;
	u16 function;
};

struct acpi_mem_space_context {
	u32 length;
	acpi_physical_address address;
	acpi_physical_address mapped_physical_address;
	u8 *mapped_logical_address;
	acpi_size mapped_length;
};

typedef enum {
	OSL_GLOBAL_LOCK_HANDLER = 0,
	OSL_NOTIFY_HANDLER = 1,
	OSL_GPE_HANDLER = 2,
	OSL_DEBUGGER_MAIN_THREAD = 3,
	OSL_DEBUGGER_EXEC_THREAD = 4,
	OSL_EC_POLL_HANDLER = 5,
	OSL_EC_BURST_HANDLER = 6,
} acpi_execute_type;

union acpi_operand_object;

struct acpi_namespace_node {
	union acpi_operand_object *object;
	u8 descriptor_type;
	u8 type;
	u16 flags;
	union acpi_name_union name;
	struct acpi_namespace_node *parent;
	struct acpi_namespace_node *child;
	struct acpi_namespace_node *peer;
	acpi_owner_id owner_id;
};

struct acpi_object_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
};

struct acpi_object_integer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 fill[3];
	u64 value;
};

struct acpi_object_string {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	char *pointer;
	u32 length;
};

struct acpi_object_buffer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 *pointer;
	u32 length;
	u32 aml_length;
	u8 *aml_start;
	struct acpi_namespace_node *node;
};

struct acpi_object_package {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	union acpi_operand_object **elements;
	u8 *aml_start;
	u32 aml_length;
	u32 count;
};

struct acpi_object_event {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	void *os_semaphore;
};

struct acpi_walk_state;

typedef acpi_status (*acpi_internal_method)(struct acpi_walk_state *);

struct acpi_object_method {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 info_flags;
	u8 param_count;
	u8 sync_level;
	union acpi_operand_object *mutex;
	union acpi_operand_object *node;
	u8 *aml_start;
	union {
		acpi_internal_method implementation;
		union acpi_operand_object *handler;
	} dispatch;
	u32 aml_length;
	acpi_owner_id owner_id;
	u8 thread_count;
};

struct acpi_thread_state;

struct acpi_object_mutex {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 sync_level;
	u16 acquisition_depth;
	void *os_mutex;
	u64 thread_id;
	struct acpi_thread_state *owner_thread;
	union acpi_operand_object *prev;
	union acpi_operand_object *next;
	struct acpi_namespace_node *node;
	u8 original_sync_level;
};

struct acpi_object_region {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler;
	union acpi_operand_object *next;
	acpi_physical_address address;
	u32 length;
};

struct acpi_object_notify_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_gpe_block_info;

struct acpi_object_device {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	struct acpi_gpe_block_info *gpe_block;
};

struct acpi_object_power_resource {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	u32 system_level;
	u32 resource_order;
};

struct acpi_object_processor {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 proc_id;
	u8 length;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	acpi_io_address address;
};

struct acpi_object_thermal_zone {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_object_field_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
};

struct acpi_object_region_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u16 resource_length;
	union acpi_operand_object *region_obj;
	u8 *resource_buffer;
	u16 pin_number_index;
	u8 *internal_pcc_buffer;
};

struct acpi_object_buffer_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *buffer_obj;
};

struct acpi_object_bank_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
	union acpi_operand_object *bank_obj;
};

struct acpi_object_index_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *index_obj;
	union acpi_operand_object *data_obj;
};

struct acpi_object_notify_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	u32 handler_type;
	acpi_notify_handler handler;
	void *context;
	union acpi_operand_object *next[2];
};

struct acpi_object_addr_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	u8 handler_flags;
	acpi_adr_space_handler handler;
	struct acpi_namespace_node *node;
	void *context;
	void *context_mutex;
	acpi_adr_space_setup setup;
	union acpi_operand_object *region_list;
	union acpi_operand_object *next;
};

struct acpi_object_reference {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 class;
	u8 target_type;
	u8 resolved;
	void *object;
	struct acpi_namespace_node *node;
	union acpi_operand_object **where;
	u8 *index_pointer;
	u8 *aml;
	u32 value;
};

struct acpi_object_extra {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *method_REG;
	struct acpi_namespace_node *scope_node;
	void *region_context;
	u8 *aml_start;
	u32 aml_length;
};

struct acpi_object_data {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	acpi_object_handler handler;
	void *pointer;
};

struct acpi_object_cache_list {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *next;
};

union acpi_operand_object {
	struct acpi_object_common common;
	struct acpi_object_integer integer;
	struct acpi_object_string string;
	struct acpi_object_buffer buffer;
	struct acpi_object_package package;
	struct acpi_object_event event;
	struct acpi_object_method method;
	struct acpi_object_mutex mutex;
	struct acpi_object_region region;
	struct acpi_object_notify_common common_notify;
	struct acpi_object_device device;
	struct acpi_object_power_resource power_resource;
	struct acpi_object_processor processor;
	struct acpi_object_thermal_zone thermal_zone;
	struct acpi_object_field_common common_field;
	struct acpi_object_region_field field;
	struct acpi_object_buffer_field buffer_field;
	struct acpi_object_bank_field bank_field;
	struct acpi_object_index_field index_field;
	struct acpi_object_notify_handler notify;
	struct acpi_object_addr_handler address_space;
	struct acpi_object_reference reference;
	struct acpi_object_extra extra;
	struct acpi_object_data data;
	struct acpi_object_cache_list cache;
	struct acpi_namespace_node node;
};

union acpi_parse_object;

union acpi_generic_state;

struct acpi_parse_state {
	u8 *aml_start;
	u8 *aml;
	u8 *aml_end;
	u8 *pkg_start;
	u8 *pkg_end;
	union acpi_parse_object *start_op;
	struct acpi_namespace_node *start_node;
	union acpi_generic_state *scope;
	union acpi_parse_object *start_scope;
	u32 aml_size;
};

typedef acpi_status (*acpi_parse_downwards)(struct acpi_walk_state *, union acpi_parse_object **);

typedef acpi_status (*acpi_parse_upwards)(struct acpi_walk_state *);

struct acpi_opcode_info;

struct acpi_walk_state {
	struct acpi_walk_state *next;
	u8 descriptor_type;
	u8 walk_type;
	u16 opcode;
	u8 next_op_info;
	u8 num_operands;
	u8 operand_index;
	acpi_owner_id owner_id;
	u8 last_predicate;
	u8 current_result;
	u8 return_used;
	u8 scope_depth;
	u8 pass_number;
	u8 namespace_override;
	u8 result_size;
	u8 result_count;
	u8 *aml;
	u32 arg_types;
	u32 method_breakpoint;
	u32 user_breakpoint;
	u32 parse_flags;
	struct acpi_parse_state parser_state;
	u32 prev_arg_types;
	u32 arg_count;
	u16 method_nesting_depth;
	u8 method_is_nested;
	struct acpi_namespace_node arguments[7];
	struct acpi_namespace_node local_variables[8];
	union acpi_operand_object *operands[9];
	union acpi_operand_object **params;
	u8 *aml_last_while;
	union acpi_operand_object **caller_return_desc;
	union acpi_generic_state *control_state;
	struct acpi_namespace_node *deferred_node;
	union acpi_operand_object *implicit_return_obj;
	struct acpi_namespace_node *method_call_node;
	union acpi_parse_object *method_call_op;
	union acpi_operand_object *method_desc;
	struct acpi_namespace_node *method_node;
	char *method_pathname;
	union acpi_parse_object *op;
	const struct acpi_opcode_info *op_info;
	union acpi_parse_object *origin;
	union acpi_operand_object *result_obj;
	union acpi_generic_state *results;
	union acpi_operand_object *return_desc;
	union acpi_generic_state *scope_info;
	union acpi_parse_object *prev_op;
	union acpi_parse_object *next_op;
	struct acpi_thread_state *thread;
	acpi_parse_downwards descending_callback;
	acpi_parse_upwards ascending_callback;
};

struct acpi_gpe_handler_info {
	acpi_gpe_handler address;
	void *context;
	struct acpi_namespace_node *method_node;
	u8 original_flags;
	u8 originally_enabled;
};

struct acpi_gpe_notify_info {
	struct acpi_namespace_node *device_node;
	struct acpi_gpe_notify_info *next;
};

union acpi_gpe_dispatch_info {
	struct acpi_namespace_node *method_node;
	struct acpi_gpe_handler_info *handler;
	struct acpi_gpe_notify_info *notify_list;
};

struct acpi_gpe_register_info;

struct acpi_gpe_event_info {
	union acpi_gpe_dispatch_info dispatch;
	struct acpi_gpe_register_info *register_info;
	u8 flags;
	u8 gpe_number;
	u8 runtime_count;
	u8 disable_for_dispatch;
};

struct acpi_gpe_register_info {
	struct acpi_generic_address status_address;
	struct acpi_generic_address enable_address;
	u16 base_gpe_number;
	u8 enable_for_wake;
	u8 enable_for_run;
	u8 mask_for_run;
	u8 enable_mask;
} __attribute__((packed));

struct acpi_gpe_xrupt_info;

struct acpi_gpe_block_info {
	struct acpi_namespace_node *node;
	struct acpi_gpe_block_info *previous;
	struct acpi_gpe_block_info *next;
	struct acpi_gpe_xrupt_info *xrupt_block;
	struct acpi_gpe_register_info *register_info;
	struct acpi_gpe_event_info *event_info;
	u64 address;
	u32 register_count;
	u16 gpe_count;
	u16 block_base_number;
	u8 space_id;
	u8 initialized;
};

struct acpi_gpe_xrupt_info {
	struct acpi_gpe_xrupt_info *previous;
	struct acpi_gpe_xrupt_info *next;
	struct acpi_gpe_block_info *gpe_block_list_head;
	u32 interrupt_number;
};

struct acpi_common_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
};

struct acpi_update_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *object;
};

struct acpi_pkg_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 index;
	union acpi_operand_object *source_object;
	union acpi_operand_object *dest_object;
	struct acpi_walk_state *walk_state;
	void *this_target_obj;
	u32 num_packages;
};

struct acpi_control_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u16 opcode;
	union acpi_parse_object *predicate_op;
	u8 *aml_predicate_start;
	u8 *package_end;
	u64 loop_timeout;
};

union acpi_parse_value {
	u64 integer;
	u32 size;
	char *string;
	u8 *buffer;
	char *name;
	union acpi_parse_object *arg;
};

struct acpi_parse_obj_common {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
};

struct acpi_parse_obj_named {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	char *path;
	u8 *data;
	u32 length;
	u32 name;
};

struct acpi_parse_obj_asl {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	union acpi_parse_object *child;
	union acpi_parse_object *parent_method;
	char *filename;
	u8 file_changed;
	char *parent_filename;
	char *external_name;
	char *namepath;
	char name_seg[4];
	u32 extra_value;
	u32 column;
	u32 line_number;
	u32 logical_line_number;
	u32 logical_byte_offset;
	u32 end_line;
	u32 end_logical_line;
	u32 acpi_btype;
	u32 aml_length;
	u32 aml_subtree_length;
	u32 final_aml_length;
	u32 final_aml_offset;
	u32 compile_flags;
	u16 parse_opcode;
	u8 aml_opcode_length;
	u8 aml_pkg_len_bytes;
	u8 extra;
	char parse_op_name[20];
};

union acpi_parse_object {
	struct acpi_parse_obj_common common;
	struct acpi_parse_obj_named named;
	struct acpi_parse_obj_asl asl;
};

struct acpi_scope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	struct acpi_namespace_node *node;
};

struct acpi_pscope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 arg_count;
	union acpi_parse_object *op;
	u8 *arg_end;
	u8 *pkg_end;
	u32 arg_list;
};

struct acpi_thread_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 current_sync_level;
	struct acpi_walk_state *walk_state_list;
	union acpi_operand_object *acquired_mutex_list;
	u64 thread_id;
};

struct acpi_result_values {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *obj_desc[8];
};

struct acpi_global_notify_handler {
	acpi_notify_handler handler;
	void *context;
};

struct acpi_notify_info {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 handler_list_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler_list_head;
	struct acpi_global_notify_handler *global;
};

union acpi_generic_state {
	struct acpi_common_state common;
	struct acpi_control_state control;
	struct acpi_update_state update;
	struct acpi_scope_state scope;
	struct acpi_pscope_state parse_scope;
	struct acpi_pkg_state pkg;
	struct acpi_thread_state thread;
	struct acpi_result_values results;
	struct acpi_notify_info notify;
};

struct acpi_opcode_info {
	u32 parse_args;
	u32 runtime_args;
	u16 flags;
	u8 object_type;
	u8 class;
	u8 type;
};

struct acpi_os_dpc {
	acpi_osd_exec_callback function;
	void *context;
	struct work_struct work;
};

struct acpi_ioremap {
	struct list_head list;
	void *virt;
	acpi_physical_address phys;
	acpi_size size;
	long unsigned int refcount;
};

struct acpi_hp_work {
	struct work_struct work;
	struct acpi_device *adev;
	u32 src;
};

struct acpi_pld_info {
	u8 revision;
	u8 ignore_color;
	u8 red;
	u8 green;
	u8 blue;
	u16 width;
	u16 height;
	u8 user_visible;
	u8 dock;
	u8 lid;
	u8 panel;
	u8 vertical_position;
	u8 horizontal_position;
	u8 shape;
	u8 group_orientation;
	u8 group_token;
	u8 group_position;
	u8 bay;
	u8 ejectable;
	u8 ospm_eject_required;
	u8 cabinet_number;
	u8 card_cage_number;
	u8 reference;
	u8 rotation;
	u8 order;
	u8 reserved;
	u16 vertical_offset;
	u16 horizontal_offset;
};

struct acpi_handle_list {
	u32 count;
	acpi_handle handles[10];
};

struct acpi_device_bus_id {
	const char *bus_id;
	struct ida instance_ida;
	struct list_head node;
};

struct acpi_dev_match_info {
	struct acpi_device_id hid[2];
	const char *uid;
	s64 hrv;
};

struct nvs_region {
	__u64 phys_start;
	__u64 size;
	struct list_head node;
};

struct nvs_page {
	long unsigned int phys_start;
	unsigned int size;
	void *kaddr;
	void *data;
	bool unmap;
	struct list_head node;
};

struct acpi_wakeup_handler {
	struct list_head list_node;
	bool (*wakeup)(void *);
	void *context;
};

typedef u32 acpi_event_status;

struct lpi_device_info {
	char *name;
	int enabled;
	union acpi_object *package;
};

struct lpi_device_constraint {
	int uid;
	int min_dstate;
	int function_states;
};

struct lpi_constraints {
	acpi_handle handle;
	int min_dstate;
};

struct acpi_hardware_id {
	struct list_head list;
	const char *id;
};

struct acpi_data_node {
	const char *name;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct fwnode_handle *parent;
	struct acpi_device_data data;
	struct list_head sibling;
	struct kobject kobj;
	struct completion kobj_done;
};

struct acpi_data_node_attr {
	struct attribute attr;
	ssize_t (*show)(struct acpi_data_node *, char *);
	ssize_t (*store)(struct acpi_data_node *, const char *, size_t);
};

struct acpi_device_physical_node {
	unsigned int node_id;
	struct list_head node;
	struct device *dev;
	bool put_online: 1;
};

typedef u32 (*acpi_event_handler)(void *);

typedef acpi_status (*acpi_table_handler)(u32, void *, void *);

enum acpi_bus_device_type {
	ACPI_BUS_TYPE_DEVICE = 0,
	ACPI_BUS_TYPE_POWER = 1,
	ACPI_BUS_TYPE_PROCESSOR = 2,
	ACPI_BUS_TYPE_THERMAL = 3,
	ACPI_BUS_TYPE_POWER_BUTTON = 4,
	ACPI_BUS_TYPE_SLEEP_BUTTON = 5,
	ACPI_BUS_TYPE_ECDT_EC = 6,
	ACPI_BUS_DEVICE_TYPE_COUNT = 7,
};

struct acpi_osc_context {
	char *uuid_str;
	int rev;
	struct acpi_buffer cap;
	struct acpi_buffer ret;
};

struct acpi_pnp_device_id {
	u32 length;
	char *string;
};

struct acpi_pnp_device_id_list {
	u32 count;
	u32 list_size;
	struct acpi_pnp_device_id ids[1];
};

struct acpi_device_info {
	u32 info_size;
	u32 name;
	acpi_object_type type;
	u8 param_count;
	u16 valid;
	u8 flags;
	u8 highest_dstates[4];
	u8 lowest_dstates[5];
	u64 address;
	struct acpi_pnp_device_id hardware_id;
	struct acpi_pnp_device_id unique_id;
	struct acpi_pnp_device_id class_code;
	struct acpi_pnp_device_id_list compatible_id_list;
};

struct acpi_table_spcr {
	struct acpi_table_header header;
	u8 interface_type;
	u8 reserved[3];
	struct acpi_generic_address serial_port;
	u8 interrupt_type;
	u8 pc_interrupt;
	u32 interrupt;
	u8 baud_rate;
	u8 parity;
	u8 stop_bits;
	u8 flow_control;
	u8 terminal_type;
	u8 reserved1;
	u16 pci_device_id;
	u16 pci_vendor_id;
	u8 pci_bus;
	u8 pci_device;
	u8 pci_function;
	u32 pci_flags;
	u8 pci_segment;
	u32 reserved2;
} __attribute__((packed));

struct acpi_table_stao {
	struct acpi_table_header header;
	u8 ignore_uart;
} __attribute__((packed));

struct acpi_resource_irq {
	u8 descriptor_length;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	u8 interrupts[1];
};

struct acpi_resource_dma {
	u8 type;
	u8 bus_master;
	u8 transfer;
	u8 channel_count;
	u8 channels[1];
};

struct acpi_resource_start_dependent {
	u8 descriptor_length;
	u8 compatibility_priority;
	u8 performance_robustness;
};

struct acpi_resource_io {
	u8 io_decode;
	u8 alignment;
	u8 address_length;
	u16 minimum;
	u16 maximum;
} __attribute__((packed));

struct acpi_resource_fixed_io {
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_dma {
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct acpi_resource_vendor {
	u16 byte_length;
	u8 byte_data[1];
} __attribute__((packed));

struct acpi_resource_vendor_typed {
	u16 byte_length;
	u8 uuid_subtype;
	u8 uuid[16];
	u8 byte_data[1];
};

struct acpi_resource_end_tag {
	u8 checksum;
};

struct acpi_resource_memory24 {
	u8 write_protect;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct acpi_resource_memory32 {
	u8 write_protect;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_memory32 {
	u8 write_protect;
	u32 address;
	u32 address_length;
} __attribute__((packed));

struct acpi_memory_attribute {
	u8 write_protect;
	u8 caching;
	u8 range_type;
	u8 translation;
};

struct acpi_io_attribute {
	u8 range_type;
	u8 translation;
	u8 translation_type;
	u8 reserved1;
};

union acpi_resource_attribute {
	struct acpi_memory_attribute mem;
	struct acpi_io_attribute io;
	u8 type_specific;
};

struct acpi_resource_label {
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_resource_source {
	u8 index;
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_address16_attribute {
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
};

struct acpi_address32_attribute {
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
};

struct acpi_address64_attribute {
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
};

struct acpi_resource_address {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
};

struct acpi_resource_address16 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address16_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address32 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address32_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address64_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_extended_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	u8 revision_ID;
	struct acpi_address64_attribute address;
	u64 type_specific;
} __attribute__((packed));

struct acpi_resource_extended_irq {
	u8 producer_consumer;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	struct acpi_resource_source resource_source;
	u32 interrupts[1];
} __attribute__((packed));

struct acpi_resource_generic_register {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_resource_gpio {
	u8 revision_id;
	u8 connection_type;
	u8 producer_consumer;
	u8 pin_config;
	u8 shareable;
	u8 wake_capable;
	u8 io_restriction;
	u8 triggering;
	u8 polarity;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_common_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_i2c_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 access_mode;
	u16 slave_address;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_spi_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 wire_mode;
	u8 device_polarity;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_uart_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 endian;
	u8 data_bits;
	u8 stop_bits;
	u8 flow_control;
	u8 parity;
	u8 lines_enabled;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u32 default_baud_rate;
} __attribute__((packed));

struct acpi_resource_pin_function {
	u8 revision_id;
	u8 pin_config;
	u8 shareable;
	u16 function_number;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group {
	u8 revision_id;
	u8 producer_consumer;
	u16 pin_table_length;
	u16 vendor_length;
	u16 *pin_table;
	struct acpi_resource_label resource_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_function {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u16 function_number;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

union acpi_resource_data {
	struct acpi_resource_irq irq;
	struct acpi_resource_dma dma;
	struct acpi_resource_start_dependent start_dpf;
	struct acpi_resource_io io;
	struct acpi_resource_fixed_io fixed_io;
	struct acpi_resource_fixed_dma fixed_dma;
	struct acpi_resource_vendor vendor;
	struct acpi_resource_vendor_typed vendor_typed;
	struct acpi_resource_end_tag end_tag;
	struct acpi_resource_memory24 memory24;
	struct acpi_resource_memory32 memory32;
	struct acpi_resource_fixed_memory32 fixed_memory32;
	struct acpi_resource_address16 address16;
	struct acpi_resource_address32 address32;
	struct acpi_resource_address64 address64;
	struct acpi_resource_extended_address64 ext_address64;
	struct acpi_resource_extended_irq extended_irq;
	struct acpi_resource_generic_register generic_reg;
	struct acpi_resource_gpio gpio;
	struct acpi_resource_i2c_serialbus i2c_serial_bus;
	struct acpi_resource_spi_serialbus spi_serial_bus;
	struct acpi_resource_uart_serialbus uart_serial_bus;
	struct acpi_resource_common_serialbus common_serial_bus;
	struct acpi_resource_pin_function pin_function;
	struct acpi_resource_pin_config pin_config;
	struct acpi_resource_pin_group pin_group;
	struct acpi_resource_pin_group_function pin_group_function;
	struct acpi_resource_pin_group_config pin_group_config;
	struct acpi_resource_address address;
};

struct acpi_resource {
	u32 type;
	u32 length;
	union acpi_resource_data data;
} __attribute__((packed));

typedef acpi_status (*acpi_walk_resource_callback)(struct acpi_resource *, void *);

enum acpi_reconfig_event {
	ACPI_RECONFIG_DEVICE_ADD = 0,
	ACPI_RECONFIG_DEVICE_REMOVE = 1,
};

struct acpi_probe_entry;

typedef bool (*acpi_probe_entry_validate_subtbl)(struct acpi_subtable_header *, struct acpi_probe_entry *);

struct acpi_probe_entry {
	__u8 id[5];
	__u8 type;
	acpi_probe_entry_validate_subtbl subtable_valid;
	union {
		acpi_tbl_table_handler probe_table;
		acpi_tbl_entry_handler probe_subtbl;
	};
	kernel_ulong_t driver_data;
};

struct acpi_dep_data {
	struct list_head node;
	acpi_handle master;
	acpi_handle slave;
};

struct acpi_table_events_work {
	struct work_struct work;
	void *table;
	u32 event;
};

struct platform_device;

struct resource_win {
	struct resource res;
	resource_size_t offset;
};

struct res_proc_context {
	struct list_head *list;
	int (*preproc)(struct acpi_resource *, void *);
	void *preproc_data;
	int count;
	int error;
};

struct acpi_processor_errata {
	u8 smp;
	struct {
		u8 throttle: 1;
		u8 fdma: 1;
		u8 reserved: 6;
		u32 bmisx;
	} piix4;
};

struct acpi_table_ecdt {
	struct acpi_table_header header;
	struct acpi_generic_address control;
	struct acpi_generic_address data;
	u32 uid;
	u8 gpe;
	u8 id[1];
} __attribute__((packed));

struct transaction;

struct acpi_ec {
	acpi_handle handle;
	u32 gpe;
	long unsigned int command_addr;
	long unsigned int data_addr;
	bool global_lock;
	long unsigned int flags;
	long unsigned int reference_count;
	struct mutex mutex;
	wait_queue_head_t wait;
	struct list_head list;
	struct transaction *curr;
	spinlock_t lock;
	struct work_struct work;
	long unsigned int timestamp;
	long unsigned int nr_pending_queries;
	bool busy_polling;
	unsigned int polling_guard;
};

struct transaction {
	const u8 *wdata;
	u8 *rdata;
	short unsigned int irq_count;
	u8 command;
	u8 wi;
	u8 ri;
	u8 wlen;
	u8 rlen;
	u8 flags;
};

typedef int (*acpi_ec_query_func)(void *);

enum ec_command {
	ACPI_EC_COMMAND_READ = 128,
	ACPI_EC_COMMAND_WRITE = 129,
	ACPI_EC_BURST_ENABLE = 130,
	ACPI_EC_BURST_DISABLE = 131,
	ACPI_EC_COMMAND_QUERY = 132,
};

enum {
	EC_FLAGS_QUERY_ENABLED = 0,
	EC_FLAGS_QUERY_PENDING = 1,
	EC_FLAGS_QUERY_GUARDING = 2,
	EC_FLAGS_GPE_HANDLER_INSTALLED = 3,
	EC_FLAGS_EC_HANDLER_INSTALLED = 4,
	EC_FLAGS_EVT_HANDLER_INSTALLED = 5,
	EC_FLAGS_STARTED = 6,
	EC_FLAGS_STOPPED = 7,
	EC_FLAGS_GPE_MASKED = 8,
};

struct acpi_ec_query_handler {
	struct list_head node;
	acpi_ec_query_func func;
	acpi_handle handle;
	void *data;
	u8 query_bit;
	struct kref kref;
};

struct acpi_ec_query {
	struct transaction transaction;
	struct work_struct work;
	struct acpi_ec_query_handler *handler;
};

struct acpi_pci_root_ops;

struct acpi_pci_root_info {
	struct acpi_pci_root *root;
	struct acpi_device *bridge;
	struct acpi_pci_root_ops *ops;
	struct list_head resources;
	char name[16];
};

struct acpi_pci_root_ops {
	struct pci_ops *pci_ops;
	int (*init_info)(struct acpi_pci_root_info *);
	void (*release_info)(struct acpi_pci_root_info *);
	int (*prepare_resources)(struct acpi_pci_root_info *);
};

struct pci_osc_bit_struct {
	u32 bit;
	char *desc;
};

struct acpi_handle_node {
	struct list_head node;
	acpi_handle handle;
};

struct acpi_pci_link_irq {
	u32 active;
	u8 triggering;
	u8 polarity;
	u8 resource_type;
	u8 possible_count;
	u32 possible[16];
	u8 initialized: 1;
	u8 reserved: 7;
};

struct acpi_pci_link {
	struct list_head list;
	struct acpi_device *device;
	struct acpi_pci_link_irq irq;
	int refcnt;
};

struct acpi_pci_routing_table {
	u32 length;
	u32 pin;
	u64 address;
	u32 source_index;
	char source[4];
};

struct acpi_prt_entry {
	struct acpi_pci_id id;
	u8 pin;
	acpi_handle link;
	u32 index;
};

struct prt_quirk {
	const struct dmi_system_id *system;
	unsigned int segment;
	unsigned int bus;
	unsigned int device;
	unsigned char pin;
	const char *source;
	const char *actual_source;
};

struct st_clk_data {
	void *base;
};

struct apd_private_data;

struct apd_device_desc {
	unsigned int flags;
	unsigned int fixed_clk_rate;
	struct property_entry *properties;
	int (*setup)(struct apd_private_data *);
};

struct apd_private_data {
	struct clk *clk;
	struct acpi_device *adev;
	const struct apd_device_desc *dev_desc;
};

struct acpi_power_dependent_device {
	struct device *dev;
	struct list_head node;
};

struct acpi_power_resource {
	struct acpi_device device;
	struct list_head list_node;
	char *name;
	u32 system_level;
	u32 order;
	unsigned int ref_count;
	bool wakeup_enabled;
	struct mutex resource_lock;
	struct list_head dependents;
};

struct acpi_power_resource_entry {
	struct list_head node;
	struct acpi_power_resource *resource;
};

struct acpi_bus_event {
	struct list_head node;
	acpi_device_class device_class;
	acpi_bus_id bus_id;
	u32 type;
	u32 data;
};

struct acpi_genl_event {
	acpi_device_class device_class;
	char bus_id[15];
	u32 type;
	u32 data;
};

enum {
	ACPI_GENL_ATTR_UNSPEC = 0,
	ACPI_GENL_ATTR_EVENT = 1,
	__ACPI_GENL_ATTR_MAX = 2,
};

enum {
	ACPI_GENL_CMD_UNSPEC = 0,
	ACPI_GENL_CMD_EVENT = 1,
	__ACPI_GENL_CMD_MAX = 2,
};

struct acpi_ged_device {
	struct device *dev;
	struct list_head event_list;
};

struct acpi_ged_event {
	struct list_head node;
	struct device *dev;
	unsigned int gsi;
	unsigned int irq;
	acpi_handle handle;
};

typedef void (*acpi_gbl_event_handler)(u32, acpi_handle, u32, void *);

struct acpi_table_bert {
	struct acpi_table_header header;
	u32 region_length;
	u64 address;
};

struct acpi_table_attr {
	struct bin_attribute attr;
	char name[4];
	int instance;
	char filename[8];
	struct list_head node;
};

struct acpi_data_attr {
	struct bin_attribute attr;
	u64 addr;
};

struct acpi_data_obj {
	char *name;
	int (*fn)(void *, struct acpi_data_attr *);
};

struct event_counter {
	u32 count;
	u32 flags;
};

struct acpi_device_properties {
	const guid_t *guid;
	const union acpi_object *properties;
	struct list_head list;
};

struct always_present_id {
	struct acpi_device_id hid[2];
	struct x86_cpu_id cpu_ids[2];
	struct dmi_system_id dmi_ids[2];
	const char *uid;
};

struct acpi_table_slit {
	struct acpi_table_header header;
	u64 locality_count;
	u8 entry[1];
} __attribute__((packed));

struct acpi_table_srat {
	struct acpi_table_header header;
	u32 table_revision;
	u64 reserved;
};

enum acpi_srat_type {
	ACPI_SRAT_TYPE_CPU_AFFINITY = 0,
	ACPI_SRAT_TYPE_MEMORY_AFFINITY = 1,
	ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY = 2,
	ACPI_SRAT_TYPE_GICC_AFFINITY = 3,
	ACPI_SRAT_TYPE_GIC_ITS_AFFINITY = 4,
	ACPI_SRAT_TYPE_GENERIC_AFFINITY = 5,
	ACPI_SRAT_TYPE_RESERVED = 6,
};

struct acpi_srat_mem_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u16 reserved;
	u64 base_address;
	u64 length;
	u32 reserved1;
	u32 flags;
	u64 reserved2;
} __attribute__((packed));

struct acpi_srat_gicc_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u32 acpi_processor_uid;
	u32 flags;
	u32 clock_domain;
} __attribute__((packed));

struct acpi_lpat {
	int temp;
	int raw;
};

struct acpi_lpat_conversion_table {
	struct acpi_lpat *lpat;
	int lpat_count;
};

struct acpi_table_lpit {
	struct acpi_table_header header;
};

struct acpi_lpit_header {
	u32 type;
	u32 length;
	u16 unique_id;
	u16 reserved;
	u32 flags;
};

struct acpi_lpit_native {
	struct acpi_lpit_header header;
	struct acpi_generic_address entry_trigger;
	u32 residency;
	u32 latency;
	struct acpi_generic_address residency_counter;
	u64 counter_frequency;
} __attribute__((packed));

struct lpit_residency_info {
	struct acpi_generic_address gaddr;
	u64 frequency;
	void *iomem_addr;
};

struct acpi_name_info {
	char name[4];
	u16 argument_list;
	u8 expected_btypes;
} __attribute__((packed));

struct acpi_package_info {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 object_type2;
	u8 count2;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info2 {
	u8 type;
	u8 count;
	u8 object_type[4];
	u8 reserved;
};

struct acpi_package_info3 {
	u8 type;
	u8 count;
	u8 object_type[2];
	u8 tail_object_type;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info4 {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 sub_object_types;
	u8 pkg_count;
	u16 reserved;
} __attribute__((packed));

union acpi_predefined_info {
	struct acpi_name_info info;
	struct acpi_package_info ret_info;
	struct acpi_package_info2 ret_info2;
	struct acpi_package_info3 ret_info3;
	struct acpi_package_info4 ret_info4;
};

struct acpi_evaluate_info {
	struct acpi_namespace_node *prefix_node;
	const char *relative_pathname;
	union acpi_operand_object **parameters;
	struct acpi_namespace_node *node;
	union acpi_operand_object *obj_desc;
	char *full_pathname;
	const union acpi_predefined_info *predefined;
	union acpi_operand_object *return_object;
	union acpi_operand_object *parent_package;
	u32 return_flags;
	u32 return_btype;
	u16 param_count;
	u16 node_flags;
	u8 pass_number;
	u8 return_object_type;
	u8 flags;
};

enum {
	ACPI_REFCLASS_LOCAL = 0,
	ACPI_REFCLASS_ARG = 1,
	ACPI_REFCLASS_REFOF = 2,
	ACPI_REFCLASS_INDEX = 3,
	ACPI_REFCLASS_TABLE = 4,
	ACPI_REFCLASS_NAME = 5,
	ACPI_REFCLASS_DEBUG = 6,
	ACPI_REFCLASS_MAX = 6,
};

struct acpi_common_descriptor {
	void *common_pointer;
	u8 descriptor_type;
};

union acpi_descriptor {
	struct acpi_common_descriptor common;
	union acpi_operand_object object;
	struct acpi_namespace_node node;
	union acpi_parse_object op;
};

typedef enum {
	ACPI_IMODE_LOAD_PASS1 = 1,
	ACPI_IMODE_LOAD_PASS2 = 2,
	ACPI_IMODE_EXECUTE = 3,
} acpi_interpreter_mode;

struct acpi_create_field_info {
	struct acpi_namespace_node *region_node;
	struct acpi_namespace_node *field_node;
	struct acpi_namespace_node *register_node;
	struct acpi_namespace_node *data_register_node;
	struct acpi_namespace_node *connection_node;
	u8 *resource_buffer;
	u32 bank_value;
	u32 field_bit_position;
	u32 field_bit_length;
	u16 resource_length;
	u16 pin_number_index;
	u8 field_flags;
	u8 attribute;
	u8 field_type;
	u8 access_length;
};

struct acpi_init_walk_info {
	u32 table_index;
	u32 object_count;
	u32 method_count;
	u32 serial_method_count;
	u32 non_serial_method_count;
	u32 serialized_method_count;
	u32 device_count;
	u32 op_region_count;
	u32 field_count;
	u32 buffer_count;
	u32 package_count;
	u32 op_region_init;
	u32 field_init;
	u32 buffer_init;
	u32 package_init;
	acpi_owner_id owner_id;
};

typedef u32 acpi_name;

typedef acpi_status (*acpi_exception_handler)(acpi_status, acpi_name, u16, u32, void *);

enum {
	AML_FIELD_ACCESS_ANY = 0,
	AML_FIELD_ACCESS_BYTE = 1,
	AML_FIELD_ACCESS_WORD = 2,
	AML_FIELD_ACCESS_DWORD = 3,
	AML_FIELD_ACCESS_QWORD = 4,
	AML_FIELD_ACCESS_BUFFER = 5,
};

typedef acpi_status (*acpi_execute_op)(struct acpi_walk_state *);

struct acpi_fixed_event_handler {
	acpi_event_handler handler;
	void *context;
};

struct acpi_fixed_event_info {
	u8 status_register_id;
	u8 enable_register_id;
	u16 status_bit_mask;
	u16 enable_bit_mask;
};

typedef u32 acpi_mutex_handle;

struct acpi_gpe_walk_info {
	struct acpi_namespace_node *gpe_device;
	struct acpi_gpe_block_info *gpe_block;
	u16 count;
	acpi_owner_id owner_id;
	u8 execute_by_owner_id;
};

struct acpi_gpe_device_info {
	u32 index;
	u32 next_block_base_index;
	acpi_status status;
	struct acpi_namespace_node *gpe_device;
};

typedef acpi_status (*acpi_gpe_callback)(struct acpi_gpe_xrupt_info *, struct acpi_gpe_block_info *, void *);

struct acpi_table_facs {
	char signature[4];
	u32 length;
	u32 hardware_signature;
	u32 firmware_waking_vector;
	u32 global_lock;
	u32 flags;
	u64 xfirmware_waking_vector;
	u8 version;
	u8 reserved[3];
	u32 ospm_flags;
	u8 reserved1[24];
};

struct acpi_connection_info {
	u8 *connection;
	u16 length;
	u8 access_length;
};

struct acpi_reg_walk_info {
	u32 function;
	u32 reg_run_count;
	acpi_adr_space_type space_id;
};

typedef u32 (*acpi_sci_handler)(void *);

struct acpi_sci_handler_info {
	struct acpi_sci_handler_info *next;
	acpi_sci_handler address;
	void *context;
};

enum {
	AML_FIELD_UPDATE_PRESERVE = 0,
	AML_FIELD_UPDATE_WRITE_AS_ONES = 32,
	AML_FIELD_UPDATE_WRITE_AS_ZEROS = 64,
};

struct acpi_signal_fatal_info {
	u32 type;
	u32 code;
	u32 argument;
};

enum {
	MATCH_MTR = 0,
	MATCH_MEQ = 1,
	MATCH_MLE = 2,
	MATCH_MLT = 3,
	MATCH_MGE = 4,
	MATCH_MGT = 5,
};

enum {
	AML_FIELD_ATTRIB_QUICK = 2,
	AML_FIELD_ATTRIB_SEND_RECEIVE = 4,
	AML_FIELD_ATTRIB_BYTE = 6,
	AML_FIELD_ATTRIB_WORD = 8,
	AML_FIELD_ATTRIB_BLOCK = 10,
	AML_FIELD_ATTRIB_BYTES = 11,
	AML_FIELD_ATTRIB_PROCESS_CALL = 12,
	AML_FIELD_ATTRIB_BLOCK_PROCESS_CALL = 13,
	AML_FIELD_ATTRIB_RAW_BYTES = 14,
	AML_FIELD_ATTRIB_RAW_PROCESS_BYTES = 15,
};

typedef enum {
	ACPI_TRACE_AML_METHOD = 0,
	ACPI_TRACE_AML_OPCODE = 1,
	ACPI_TRACE_AML_REGION = 2,
} acpi_trace_event_type;

struct acpi_gpe_block_status_context {
	struct acpi_gpe_register_info *gpe_skip_register_info;
	u8 gpe_skip_mask;
	u8 retval;
};

struct acpi_bit_register_info {
	u8 parent_register;
	u8 bit_position;
	u16 access_bit_mask;
};

struct acpi_port_info {
	char *name;
	u16 start;
	u16 end;
	u8 osi_dependency;
};

struct acpi_pci_device {
	acpi_handle device;
	struct acpi_pci_device *next;
};

typedef acpi_status (*acpi_init_handler)(acpi_handle, u32);

struct acpi_device_walk_info {
	struct acpi_table_desc *table_desc;
	struct acpi_evaluate_info *evaluate_info;
	u32 device_count;
	u32 num_STA;
	u32 num_INI;
};

typedef acpi_status (*acpi_pkg_callback)(u8, union acpi_operand_object *, union acpi_generic_state *, void *);

struct acpi_table_list {
	struct acpi_table_desc *tables;
	u32 current_table_count;
	u32 max_table_count;
	u8 flags;
};

enum acpi_return_package_types {
	ACPI_PTYPE1_FIXED = 1,
	ACPI_PTYPE1_VAR = 2,
	ACPI_PTYPE1_OPTION = 3,
	ACPI_PTYPE2 = 4,
	ACPI_PTYPE2_COUNT = 5,
	ACPI_PTYPE2_PKG_COUNT = 6,
	ACPI_PTYPE2_FIXED = 7,
	ACPI_PTYPE2_MIN = 8,
	ACPI_PTYPE2_REV_FIXED = 9,
	ACPI_PTYPE2_FIX_VAR = 10,
	ACPI_PTYPE2_VAR_VAR = 11,
	ACPI_PTYPE2_UUID_PAIR = 12,
	ACPI_PTYPE_CUSTOM = 13,
};

typedef acpi_status (*acpi_object_converter)(struct acpi_namespace_node *, union acpi_operand_object *, union acpi_operand_object **);

struct acpi_simple_repair_info {
	char name[4];
	u32 unexpected_btypes;
	u32 package_index;
	acpi_object_converter object_converter;
};

typedef acpi_status (*acpi_repair_function)(struct acpi_evaluate_info *, union acpi_operand_object **);

struct acpi_repair_info {
	char name[4];
	acpi_repair_function repair_function;
};

struct acpi_namestring_info {
	const char *external_name;
	const char *next_external_char;
	char *internal_name;
	u32 length;
	u32 num_segments;
	u32 num_carats;
	u8 fully_qualified;
};

struct acpi_rw_lock {
	void *writer_mutex;
	void *reader_mutex;
	u32 num_readers;
};

struct acpi_get_devices_info {
	acpi_walk_callback user_function;
	void *context;
	const char *hid;
};

struct aml_resource_small_header {
	u8 descriptor_type;
};

struct aml_resource_irq {
	u8 descriptor_type;
	u16 irq_mask;
	u8 flags;
} __attribute__((packed));

struct aml_resource_dma {
	u8 descriptor_type;
	u8 dma_channel_mask;
	u8 flags;
};

struct aml_resource_start_dependent {
	u8 descriptor_type;
	u8 flags;
};

struct aml_resource_end_dependent {
	u8 descriptor_type;
};

struct aml_resource_io {
	u8 descriptor_type;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u8 alignment;
	u8 address_length;
};

struct aml_resource_fixed_io {
	u8 descriptor_type;
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct aml_resource_vendor_small {
	u8 descriptor_type;
};

struct aml_resource_end_tag {
	u8 descriptor_type;
	u8 checksum;
};

struct aml_resource_fixed_dma {
	u8 descriptor_type;
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct aml_resource_large_header {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_memory24 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_vendor_large {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_fixed_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 address;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
} __attribute__((packed));

struct aml_resource_extended_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u8 revision_ID;
	u8 reserved;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
	u64 type_specific;
} __attribute__((packed));

struct aml_resource_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
} __attribute__((packed));

struct aml_resource_address32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address16 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_extended_irq {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u8 interrupt_count;
	u32 interrupts[1];
} __attribute__((packed));

struct aml_resource_generic_register {
	u8 descriptor_type;
	u16 resource_length;
	u8 address_space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct aml_resource_gpio {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 connection_type;
	u16 flags;
	u16 int_flags;
	u8 pin_config;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_common_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
} __attribute__((packed));

struct aml_resource_i2c_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u16 slave_address;
} __attribute__((packed));

struct aml_resource_spi_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
} __attribute__((packed));

struct aml_resource_uart_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 default_baud_rate;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u8 parity;
	u8 lines_enabled;
} __attribute__((packed));

struct aml_resource_pin_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config;
	u16 function_number;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 pin_table_offset;
	u16 label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 function_number;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

union aml_resource {
	u8 descriptor_type;
	struct aml_resource_small_header small_header;
	struct aml_resource_large_header large_header;
	struct aml_resource_irq irq;
	struct aml_resource_dma dma;
	struct aml_resource_start_dependent start_dpf;
	struct aml_resource_end_dependent end_dpf;
	struct aml_resource_io io;
	struct aml_resource_fixed_io fixed_io;
	struct aml_resource_fixed_dma fixed_dma;
	struct aml_resource_vendor_small vendor_small;
	struct aml_resource_end_tag end_tag;
	struct aml_resource_memory24 memory24;
	struct aml_resource_generic_register generic_reg;
	struct aml_resource_vendor_large vendor_large;
	struct aml_resource_memory32 memory32;
	struct aml_resource_fixed_memory32 fixed_memory32;
	struct aml_resource_address16 address16;
	struct aml_resource_address32 address32;
	struct aml_resource_address64 address64;
	struct aml_resource_extended_address64 ext_address64;
	struct aml_resource_extended_irq extended_irq;
	struct aml_resource_gpio gpio;
	struct aml_resource_i2c_serialbus i2c_serial_bus;
	struct aml_resource_spi_serialbus spi_serial_bus;
	struct aml_resource_uart_serialbus uart_serial_bus;
	struct aml_resource_common_serialbus common_serial_bus;
	struct aml_resource_pin_function pin_function;
	struct aml_resource_pin_config pin_config;
	struct aml_resource_pin_group pin_group;
	struct aml_resource_pin_group_function pin_group_function;
	struct aml_resource_pin_group_config pin_group_config;
	struct aml_resource_address address;
	u32 dword_item;
	u16 word_item;
	u8 byte_item;
};

struct acpi_rsconvert_info {
	u8 opcode;
	u8 resource_offset;
	u8 aml_offset;
	u8 value;
};

enum {
	ACPI_RSC_INITGET = 0,
	ACPI_RSC_INITSET = 1,
	ACPI_RSC_FLAGINIT = 2,
	ACPI_RSC_1BITFLAG = 3,
	ACPI_RSC_2BITFLAG = 4,
	ACPI_RSC_3BITFLAG = 5,
	ACPI_RSC_ADDRESS = 6,
	ACPI_RSC_BITMASK = 7,
	ACPI_RSC_BITMASK16 = 8,
	ACPI_RSC_COUNT = 9,
	ACPI_RSC_COUNT16 = 10,
	ACPI_RSC_COUNT_GPIO_PIN = 11,
	ACPI_RSC_COUNT_GPIO_RES = 12,
	ACPI_RSC_COUNT_GPIO_VEN = 13,
	ACPI_RSC_COUNT_SERIAL_RES = 14,
	ACPI_RSC_COUNT_SERIAL_VEN = 15,
	ACPI_RSC_DATA8 = 16,
	ACPI_RSC_EXIT_EQ = 17,
	ACPI_RSC_EXIT_LE = 18,
	ACPI_RSC_EXIT_NE = 19,
	ACPI_RSC_LENGTH = 20,
	ACPI_RSC_MOVE_GPIO_PIN = 21,
	ACPI_RSC_MOVE_GPIO_RES = 22,
	ACPI_RSC_MOVE_SERIAL_RES = 23,
	ACPI_RSC_MOVE_SERIAL_VEN = 24,
	ACPI_RSC_MOVE8 = 25,
	ACPI_RSC_MOVE16 = 26,
	ACPI_RSC_MOVE32 = 27,
	ACPI_RSC_MOVE64 = 28,
	ACPI_RSC_SET8 = 29,
	ACPI_RSC_SOURCE = 30,
	ACPI_RSC_SOURCEX = 31,
};

typedef u16 acpi_rs_length;

typedef acpi_status (*acpi_walk_aml_callback)(u8 *, u32, u32, u8, void **);

typedef u32 acpi_rsdesc_size;

struct acpi_vendor_uuid {
	u8 subtype;
	u8 data[16];
};

struct acpi_vendor_walk_info {
	struct acpi_vendor_uuid *uuid;
	struct acpi_buffer *buffer;
	acpi_status status;
};

struct acpi_fadt_info {
	const char *name;
	u16 address64;
	u16 address32;
	u16 length;
	u8 default_length;
	u8 flags;
};

struct acpi_fadt_pm_info {
	struct acpi_generic_address *target;
	u16 source;
	u8 register_num;
};

struct acpi_table_rsdp {
	char signature[8];
	u8 checksum;
	char oem_id[6];
	u8 revision;
	u32 rsdt_physical_address;
	u32 length;
	u64 xsdt_physical_address;
	u8 extended_checksum;
	u8 reserved[3];
} __attribute__((packed));

struct acpi_address_range {
	struct acpi_address_range *next;
	struct acpi_namespace_node *region_node;
	acpi_physical_address start_address;
	acpi_physical_address end_address;
};

struct acpi_pkg_info {
	u8 *free_space;
	acpi_size length;
	u32 object_space;
	u32 num_packages;
};

struct acpi_exception_info {
	char *name;
};

struct acpi_mutex_info {
	void *mutex;
	u32 use_count;
	u64 thread_id;
};

struct acpi_comment_node {
	char *comment;
	struct acpi_comment_node *next;
};

struct acpi_interface_info {
	char *name;
	struct acpi_interface_info *next;
	u8 flags;
	u8 value;
};

struct input_id {
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
};

struct input_absinfo {
	__s32 value;
	__s32 minimum;
	__s32 maximum;
	__s32 fuzz;
	__s32 flat;
	__s32 resolution;
};

struct input_keymap_entry {
	__u8 flags;
	__u8 len;
	__u16 index;
	__u32 keycode;
	__u8 scancode[32];
};

struct ff_replay {
	__u16 length;
	__u16 delay;
};

struct ff_trigger {
	__u16 button;
	__u16 interval;
};

struct ff_envelope {
	__u16 attack_length;
	__u16 attack_level;
	__u16 fade_length;
	__u16 fade_level;
};

struct ff_constant_effect {
	__s16 level;
	struct ff_envelope envelope;
};

struct ff_ramp_effect {
	__s16 start_level;
	__s16 end_level;
	struct ff_envelope envelope;
};

struct ff_condition_effect {
	__u16 right_saturation;
	__u16 left_saturation;
	__s16 right_coeff;
	__s16 left_coeff;
	__u16 deadband;
	__s16 center;
};

struct ff_periodic_effect {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	__s16 *custom_data;
};

struct ff_rumble_effect {
	__u16 strong_magnitude;
	__u16 weak_magnitude;
};

struct ff_effect {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_device_id {
	kernel_ulong_t flags;
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
	kernel_ulong_t evbit[1];
	kernel_ulong_t keybit[12];
	kernel_ulong_t relbit[1];
	kernel_ulong_t absbit[1];
	kernel_ulong_t mscbit[1];
	kernel_ulong_t ledbit[1];
	kernel_ulong_t sndbit[1];
	kernel_ulong_t ffbit[2];
	kernel_ulong_t swbit[1];
	kernel_ulong_t propbit[1];
	kernel_ulong_t driver_info;
};

struct input_value {
	__u16 type;
	__u16 code;
	__s32 value;
};

struct ff_device;

struct input_dev_poller;

struct input_mt;

struct input_handle;

struct input_dev {
	const char *name;
	const char *phys;
	const char *uniq;
	struct input_id id;
	long unsigned int propbit[1];
	long unsigned int evbit[1];
	long unsigned int keybit[12];
	long unsigned int relbit[1];
	long unsigned int absbit[1];
	long unsigned int mscbit[1];
	long unsigned int ledbit[1];
	long unsigned int sndbit[1];
	long unsigned int ffbit[2];
	long unsigned int swbit[1];
	unsigned int hint_events_per_packet;
	unsigned int keycodemax;
	unsigned int keycodesize;
	void *keycode;
	int (*setkeycode)(struct input_dev *, const struct input_keymap_entry *, unsigned int *);
	int (*getkeycode)(struct input_dev *, struct input_keymap_entry *);
	struct ff_device *ff;
	struct input_dev_poller *poller;
	unsigned int repeat_key;
	struct timer_list timer;
	int rep[2];
	struct input_mt *mt;
	struct input_absinfo *absinfo;
	long unsigned int key[12];
	long unsigned int led[1];
	long unsigned int snd[1];
	long unsigned int sw[1];
	int (*open)(struct input_dev *);
	void (*close)(struct input_dev *);
	int (*flush)(struct input_dev *, struct file *);
	int (*event)(struct input_dev *, unsigned int, unsigned int, int);
	struct input_handle *grab;
	spinlock_t event_lock;
	struct mutex mutex;
	unsigned int users;
	bool going_away;
	struct device dev;
	struct list_head h_list;
	struct list_head node;
	unsigned int num_vals;
	unsigned int max_vals;
	struct input_value *vals;
	bool devres_managed;
	ktime_t timestamp[3];
};

struct ff_device {
	int (*upload)(struct input_dev *, struct ff_effect *, struct ff_effect *);
	int (*erase)(struct input_dev *, int);
	int (*playback)(struct input_dev *, int, int);
	void (*set_gain)(struct input_dev *, u16);
	void (*set_autocenter)(struct input_dev *, u16);
	void (*destroy)(struct ff_device *);
	void *private;
	long unsigned int ffbit[2];
	struct mutex mutex;
	int max_effects;
	struct ff_effect *effects;
	struct file *effect_owners[0];
};

struct input_handler;

struct input_handle {
	void *private;
	int open;
	const char *name;
	struct input_dev *dev;
	struct input_handler *handler;
	struct list_head d_node;
	struct list_head h_node;
};

struct input_handler {
	void *private;
	void (*event)(struct input_handle *, unsigned int, unsigned int, int);
	void (*events)(struct input_handle *, const struct input_value *, unsigned int);
	bool (*filter)(struct input_handle *, unsigned int, unsigned int, int);
	bool (*match)(struct input_handler *, struct input_dev *);
	int (*connect)(struct input_handler *, struct input_dev *, const struct input_device_id *);
	void (*disconnect)(struct input_handle *);
	void (*start)(struct input_handle *);
	bool legacy_minors;
	int minor;
	const char *name;
	const struct input_device_id *id_table;
	struct list_head h_list;
	struct list_head node;
};

struct acpi_button {
	unsigned int type;
	struct input_dev *input;
	char phys[32];
	long unsigned int pushed;
	int last_state;
	ktime_t last_time;
	bool suspended;
	bool lid_state_initialized;
};

struct acpi_pci_slot {
	struct pci_slot *pci_slot;
	struct list_head list;
};

struct acpi_lpi_states_array {
	unsigned int size;
	unsigned int composite_states_size;
	struct acpi_lpi_state *entries;
	struct acpi_lpi_state *composite_states[8];
};

struct throttling_tstate {
	unsigned int cpu;
	int target_state;
};

struct acpi_processor_throttling_arg {
	struct acpi_processor *pr;
	int target_state;
	bool force;
};

struct container_dev {
	struct device dev;
	int (*offline)(struct container_dev *);
};

struct acpi_thermal_state {
	u8 critical: 1;
	u8 hot: 1;
	u8 passive: 1;
	u8 active: 1;
	u8 reserved: 4;
	int active_index;
};

struct acpi_thermal_state_flags {
	u8 valid: 1;
	u8 enabled: 1;
	u8 reserved: 6;
};

struct acpi_thermal_critical {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
};

struct acpi_thermal_hot {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
};

struct acpi_thermal_passive {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
	long unsigned int tc1;
	long unsigned int tc2;
	long unsigned int tsp;
	struct acpi_handle_list devices;
};

struct acpi_thermal_active {
	struct acpi_thermal_state_flags flags;
	long unsigned int temperature;
	struct acpi_handle_list devices;
};

struct acpi_thermal_trips {
	struct acpi_thermal_critical critical;
	struct acpi_thermal_hot hot;
	struct acpi_thermal_passive passive;
	struct acpi_thermal_active active[10];
};

struct acpi_thermal_flags {
	u8 cooling_mode: 1;
	u8 devices: 1;
	u8 reserved: 6;
};

struct acpi_thermal {
	struct acpi_device *device;
	acpi_bus_id name;
	long unsigned int temperature;
	long unsigned int last_temperature;
	long unsigned int polling_frequency;
	volatile u8 zombie;
	struct acpi_thermal_flags flags;
	struct acpi_thermal_state state;
	struct acpi_thermal_trips trips;
	struct acpi_handle_list devices;
	struct thermal_zone_device *thermal_zone;
	int tz_enabled;
	int kelvin_offset;
	struct work_struct thermal_check_work;
	struct mutex thermal_check_lock;
	refcount_t thermal_check_count;
};

enum {
	NDD_ALIASING = 0,
	NDD_UNARMED = 1,
	NDD_LOCKED = 2,
	NDD_SECURITY_OVERWRITE = 3,
	NDD_WORK_PENDING = 4,
	NDD_NOBLK = 5,
	ND_IOCTL_MAX_BUFLEN = 4194304,
	ND_CMD_MAX_ELEM = 5,
	ND_CMD_MAX_ENVELOPE = 256,
	ND_MAX_MAPPINGS = 32,
	ND_REGION_PAGEMAP = 0,
	ND_REGION_PERSIST_CACHE = 1,
	ND_REGION_PERSIST_MEMCTRL = 2,
	ND_REGION_ASYNC = 3,
	DPA_RESOURCE_ADJUSTED = 1,
};

struct nvdimm_bus_descriptor;

struct nvdimm;

typedef int (*ndctl_fn)(struct nvdimm_bus_descriptor *, struct nvdimm *, unsigned int, void *, unsigned int, int *);

struct nvdimm_bus_descriptor {
	const struct attribute_group **attr_groups;
	long unsigned int bus_dsm_mask;
	long unsigned int cmd_mask;
	struct module *module;
	char *provider_name;
	struct device_node *of_node;
	ndctl_fn ndctl;
	int (*flush_probe)(struct nvdimm_bus_descriptor *);
	int (*clear_to_send)(struct nvdimm_bus_descriptor *, struct nvdimm *, unsigned int, void *);
};

struct nd_cmd_desc {
	int in_num;
	int out_num;
	u32 in_sizes[5];
	int out_sizes[5];
};

struct nd_interleave_set {
	u64 cookie1;
	u64 cookie2;
	u64 altcookie;
	guid_t type_guid;
};

struct nd_mapping_desc {
	struct nvdimm *nvdimm;
	u64 start;
	u64 size;
	int position;
};

struct nd_region;

struct nd_region_desc {
	struct resource *res;
	struct nd_mapping_desc *mapping;
	u16 num_mappings;
	const struct attribute_group **attr_groups;
	struct nd_interleave_set *nd_set;
	void *provider_data;
	int num_lanes;
	int numa_node;
	int target_node;
	long unsigned int flags;
	struct device_node *of_node;
	int (*flush)(struct nd_region *, struct bio *);
};

struct nvdimm_bus;

struct nd_blk_region;

struct nd_blk_region_desc {
	int (*enable)(struct nvdimm_bus *, struct device *);
	int (*do_io)(struct nd_blk_region *, resource_size_t, void *, u64, int);
	struct nd_region_desc ndr_desc;
};

struct nvdimm_key_data {
	u8 data[32];
};

enum nvdimm_passphrase_type {
	NVDIMM_USER = 0,
	NVDIMM_MASTER = 1,
};

struct nvdimm_security_ops {
	long unsigned int (*get_flags)(struct nvdimm *, enum nvdimm_passphrase_type);
	int (*freeze)(struct nvdimm *);
	int (*change_key)(struct nvdimm *, const struct nvdimm_key_data *, const struct nvdimm_key_data *, enum nvdimm_passphrase_type);
	int (*unlock)(struct nvdimm *, const struct nvdimm_key_data *);
	int (*disable)(struct nvdimm *, const struct nvdimm_key_data *);
	int (*erase)(struct nvdimm *, const struct nvdimm_key_data *, enum nvdimm_passphrase_type);
	int (*overwrite)(struct nvdimm *, const struct nvdimm_key_data *);
	int (*query_overwrite)(struct nvdimm *);
};

struct nd_cmd_dimm_flags {
	__u32 status;
	__u32 flags;
};

struct nd_cmd_get_config_data_hdr {
	__u32 in_offset;
	__u32 in_length;
	__u32 status;
	__u8 out_buf[0];
};

struct nd_cmd_set_config_hdr {
	__u32 in_offset;
	__u32 in_length;
	__u8 in_buf[0];
};

struct nd_cmd_ars_cap {
	__u64 address;
	__u64 length;
	__u32 status;
	__u32 max_ars_out;
	__u32 clear_err_unit;
	__u16 flags;
	__u16 reserved;
};

struct nd_cmd_ars_start {
	__u64 address;
	__u64 length;
	__u16 type;
	__u8 flags;
	__u8 reserved[5];
	__u32 status;
	__u32 scrub_time;
};

struct nd_ars_record {
	__u32 handle;
	__u32 reserved;
	__u64 err_address;
	__u64 length;
};

struct nd_cmd_ars_status {
	__u32 status;
	__u32 out_length;
	__u64 address;
	__u64 length;
	__u64 restart_address;
	__u64 restart_length;
	__u16 type;
	__u16 flags;
	__u32 num_records;
	struct nd_ars_record records[0];
};

struct nd_cmd_clear_error {
	__u64 address;
	__u64 length;
	__u32 status;
	__u8 reserved[4];
	__u64 cleared;
};

enum {
	ND_CMD_IMPLEMENTED = 0,
	ND_CMD_ARS_CAP = 1,
	ND_CMD_ARS_START = 2,
	ND_CMD_ARS_STATUS = 3,
	ND_CMD_CLEAR_ERROR = 4,
	ND_CMD_SMART = 1,
	ND_CMD_SMART_THRESHOLD = 2,
	ND_CMD_DIMM_FLAGS = 3,
	ND_CMD_GET_CONFIG_SIZE = 4,
	ND_CMD_GET_CONFIG_DATA = 5,
	ND_CMD_SET_CONFIG_DATA = 6,
	ND_CMD_VENDOR_EFFECT_LOG_SIZE = 7,
	ND_CMD_VENDOR_EFFECT_LOG = 8,
	ND_CMD_VENDOR = 9,
	ND_CMD_CALL = 10,
};

enum {
	ND_ARS_VOLATILE = 1,
	ND_ARS_PERSISTENT = 2,
	ND_ARS_RETURN_PREV_DATA = 2,
	ND_CONFIG_LOCKED = 1,
};

struct nd_cmd_pkg {
	__u64 nd_family;
	__u64 nd_command;
	__u32 nd_size_in;
	__u32 nd_size_out;
	__u32 nd_reserved2[9];
	__u32 nd_fw_size;
	unsigned char nd_payload[0];
};

struct acpi_nfit_header {
	u16 type;
	u16 length;
};

enum acpi_nfit_type {
	ACPI_NFIT_TYPE_SYSTEM_ADDRESS = 0,
	ACPI_NFIT_TYPE_MEMORY_MAP = 1,
	ACPI_NFIT_TYPE_INTERLEAVE = 2,
	ACPI_NFIT_TYPE_SMBIOS = 3,
	ACPI_NFIT_TYPE_CONTROL_REGION = 4,
	ACPI_NFIT_TYPE_DATA_REGION = 5,
	ACPI_NFIT_TYPE_FLUSH_ADDRESS = 6,
	ACPI_NFIT_TYPE_CAPABILITIES = 7,
	ACPI_NFIT_TYPE_RESERVED = 8,
};

struct acpi_nfit_system_address {
	struct acpi_nfit_header header;
	u16 range_index;
	u16 flags;
	u32 reserved;
	u32 proximity_domain;
	u8 range_guid[16];
	u64 address;
	u64 length;
	u64 memory_mapping;
};

struct acpi_nfit_memory_map {
	struct acpi_nfit_header header;
	u32 device_handle;
	u16 physical_id;
	u16 region_id;
	u16 range_index;
	u16 region_index;
	u64 region_size;
	u64 region_offset;
	u64 address;
	u16 interleave_index;
	u16 interleave_ways;
	u16 flags;
	u16 reserved;
};

struct acpi_nfit_interleave {
	struct acpi_nfit_header header;
	u16 interleave_index;
	u16 reserved;
	u32 line_count;
	u32 line_size;
	u32 line_offset[1];
};

struct acpi_nfit_control_region {
	struct acpi_nfit_header header;
	u16 region_index;
	u16 vendor_id;
	u16 device_id;
	u16 revision_id;
	u16 subsystem_vendor_id;
	u16 subsystem_device_id;
	u16 subsystem_revision_id;
	u8 valid_fields;
	u8 manufacturing_location;
	u16 manufacturing_date;
	u8 reserved[2];
	u32 serial_number;
	u16 code;
	u16 windows;
	u64 window_size;
	u64 command_offset;
	u64 command_size;
	u64 status_offset;
	u64 status_size;
	u16 flags;
	u8 reserved1[6];
};

struct acpi_nfit_data_region {
	struct acpi_nfit_header header;
	u16 region_index;
	u16 windows;
	u64 offset;
	u64 size;
	u64 capacity;
	u64 start_address;
};

struct acpi_nfit_flush_address {
	struct acpi_nfit_header header;
	u32 device_handle;
	u16 hint_count;
	u8 reserved[6];
	u64 hint_address[1];
};

struct acpi_nfit_capabilities {
	struct acpi_nfit_header header;
	u8 highest_capability;
	u8 reserved[3];
	u32 capabilities;
	u32 reserved2;
};

enum nvdimm_event {
	NVDIMM_REVALIDATE_POISON = 0,
};

struct nd_intel_smart {
	u32 status;
	union {
		struct {
			u32 flags;
			u8 reserved0[4];
			u8 health;
			u8 spares;
			u8 life_used;
			u8 alarm_flags;
			u16 media_temperature;
			u16 ctrl_temperature;
			u32 shutdown_count;
			u8 ait_status;
			u16 pmic_temperature;
			u8 reserved1[8];
			u8 shutdown_state;
			u32 vendor_size;
			u8 vendor_data[92];
		} __attribute__((packed));
		u8 data[128];
	};
};

enum nvdimm_family_cmds {
	NVDIMM_INTEL_LATCH_SHUTDOWN = 10,
	NVDIMM_INTEL_GET_MODES = 11,
	NVDIMM_INTEL_GET_FWINFO = 12,
	NVDIMM_INTEL_START_FWUPDATE = 13,
	NVDIMM_INTEL_SEND_FWUPDATE = 14,
	NVDIMM_INTEL_FINISH_FWUPDATE = 15,
	NVDIMM_INTEL_QUERY_FWUPDATE = 16,
	NVDIMM_INTEL_SET_THRESHOLD = 17,
	NVDIMM_INTEL_INJECT_ERROR = 18,
	NVDIMM_INTEL_GET_SECURITY_STATE = 19,
	NVDIMM_INTEL_SET_PASSPHRASE = 20,
	NVDIMM_INTEL_DISABLE_PASSPHRASE = 21,
	NVDIMM_INTEL_UNLOCK_UNIT = 22,
	NVDIMM_INTEL_FREEZE_LOCK = 23,
	NVDIMM_INTEL_SECURE_ERASE = 24,
	NVDIMM_INTEL_OVERWRITE = 25,
	NVDIMM_INTEL_QUERY_OVERWRITE = 26,
	NVDIMM_INTEL_SET_MASTER_PASSPHRASE = 27,
	NVDIMM_INTEL_MASTER_SECURE_ERASE = 28,
};

enum nfit_uuids {
	NFIT_DEV_DIMM = 0,
	NFIT_DEV_DIMM_N_HPE1 = 1,
	NFIT_DEV_DIMM_N_HPE2 = 2,
	NFIT_DEV_DIMM_N_MSFT = 3,
	NFIT_DEV_DIMM_N_HYPERV = 4,
	NFIT_SPA_VOLATILE = 5,
	NFIT_SPA_PM = 6,
	NFIT_SPA_DCR = 7,
	NFIT_SPA_BDW = 8,
	NFIT_SPA_VDISK = 9,
	NFIT_SPA_VCD = 10,
	NFIT_SPA_PDISK = 11,
	NFIT_SPA_PCD = 12,
	NFIT_DEV_BUS = 13,
	NFIT_UUID_MAX = 14,
};

enum {
	NFIT_BLK_READ_FLUSH = 1,
	NFIT_BLK_DCR_LATCH = 2,
	NFIT_ARS_STATUS_DONE = 0,
	NFIT_ARS_STATUS_BUSY = 65536,
	NFIT_ARS_STATUS_NONE = 131072,
	NFIT_ARS_STATUS_INTR = 196608,
	NFIT_ARS_START_BUSY = 6,
	NFIT_ARS_CAP_NONE = 1,
	NFIT_ARS_F_OVERFLOW = 1,
	NFIT_ARS_TIMEOUT = 90,
};

enum nfit_root_notifiers {
	NFIT_NOTIFY_UPDATE = 128,
	NFIT_NOTIFY_UC_MEMORY_ERROR = 129,
};

enum nfit_dimm_notifiers {
	NFIT_NOTIFY_DIMM_HEALTH = 129,
};

enum nfit_ars_state {
	ARS_REQ_SHORT = 0,
	ARS_REQ_LONG = 1,
	ARS_FAILED = 2,
};

struct nfit_spa {
	struct list_head list;
	struct nd_region *nd_region;
	long unsigned int ars_state;
	u32 clear_err_unit;
	u32 max_ars;
	struct acpi_nfit_system_address spa[0];
};

struct nfit_dcr {
	struct list_head list;
	struct acpi_nfit_control_region dcr[0];
};

struct nfit_bdw {
	struct list_head list;
	struct acpi_nfit_data_region bdw[0];
};

struct nfit_idt {
	struct list_head list;
	struct acpi_nfit_interleave idt[0];
};

struct nfit_flush {
	struct list_head list;
	struct acpi_nfit_flush_address flush[0];
};

struct nfit_memdev {
	struct list_head list;
	struct acpi_nfit_memory_map memdev[0];
};

enum nfit_mem_flags {
	NFIT_MEM_LSR = 0,
	NFIT_MEM_LSW = 1,
	NFIT_MEM_DIRTY = 2,
	NFIT_MEM_DIRTY_COUNT = 3,
};

struct acpi_nfit_desc;

struct nfit_mem {
	struct nvdimm *nvdimm;
	struct acpi_nfit_memory_map *memdev_dcr;
	struct acpi_nfit_memory_map *memdev_pmem;
	struct acpi_nfit_memory_map *memdev_bdw;
	struct acpi_nfit_control_region *dcr;
	struct acpi_nfit_data_region *bdw;
	struct acpi_nfit_system_address *spa_dcr;
	struct acpi_nfit_system_address *spa_bdw;
	struct acpi_nfit_interleave *idt_dcr;
	struct acpi_nfit_interleave *idt_bdw;
	struct kernfs_node *flags_attr;
	struct nfit_flush *nfit_flush;
	struct list_head list;
	struct acpi_device *adev;
	struct acpi_nfit_desc *acpi_desc;
	char id[23];
	struct resource *flush_wpq;
	long unsigned int dsm_mask;
	long unsigned int flags;
	u32 dirty_shutdown;
	int family;
};

struct acpi_nfit_desc {
	struct nvdimm_bus_descriptor nd_desc;
	struct acpi_table_header acpi_header;
	struct mutex init_mutex;
	struct list_head memdevs;
	struct list_head flushes;
	struct list_head dimms;
	struct list_head spas;
	struct list_head dcrs;
	struct list_head bdws;
	struct list_head idts;
	struct nvdimm_bus *nvdimm_bus;
	struct device *dev;
	struct nd_cmd_ars_status *ars_status;
	struct nfit_spa *scrub_spa;
	struct delayed_work dwork;
	struct list_head list;
	struct kernfs_node *scrub_count_state;
	unsigned int max_ars;
	unsigned int scrub_count;
	unsigned int scrub_mode;
	long unsigned int scrub_flags;
	long unsigned int dimm_cmd_force_en;
	long unsigned int bus_cmd_force_en;
	long unsigned int bus_nfit_cmd_force_en;
	unsigned int platform_cap;
	unsigned int scrub_tmo;
	int (*blk_do_io)(struct nd_blk_region *, resource_size_t, void *, u64, int);
};

enum scrub_flags {
	ARS_BUSY = 0,
	ARS_CANCEL = 1,
	ARS_VALID = 2,
	ARS_POLL = 3,
};

enum scrub_mode {
	HW_ERROR_SCRUB_OFF = 0,
	HW_ERROR_SCRUB_ON = 1,
};

enum nd_blk_mmio_selector {
	BDW = 0,
	DCR = 1,
};

struct nd_blk_addr {
	union {
		void *base;
		void *aperture;
	};
};

struct nfit_blk_mmio {
	struct nd_blk_addr addr;
	u64 size;
	u64 base_offset;
	u32 line_size;
	u32 num_lines;
	u32 table_size;
	struct acpi_nfit_interleave *idt;
	struct acpi_nfit_system_address *spa;
};

struct nfit_blk {
	struct nfit_blk_mmio mmio[2];
	struct nd_region *nd_region;
	u64 bdw_offset;
	u64 stat_offset;
	u64 cmd_offset;
	u32 dimm_flags;
};

struct nfit_table_prev {
	struct list_head spas;
	struct list_head memdevs;
	struct list_head dcrs;
	struct list_head bdws;
	struct list_head idts;
	struct list_head flushes;
};

enum nfit_aux_cmds {
	NFIT_CMD_TRANSLATE_SPA = 5,
	NFIT_CMD_ARS_INJECT_SET = 7,
	NFIT_CMD_ARS_INJECT_CLEAR = 8,
	NFIT_CMD_ARS_INJECT_GET = 9,
};

struct nfit_set_info_map {
	u64 region_offset;
	u32 serial_number;
	u32 pad;
};

struct nfit_set_info {
	struct nfit_set_info_map mapping[0];
};

struct nfit_set_info_map2 {
	u64 region_offset;
	u32 serial_number;
	u16 vendor_id;
	u16 manufacturing_date;
	u8 manufacturing_location;
	u8 reserved[31];
};

struct nfit_set_info2 {
	struct nfit_set_info_map2 mapping[0];
};

enum {
	BCW_OFFSET_MASK = 4294967295,
	BCW_LEN_SHIFT = 48,
	BCW_LEN_MASK = 255,
	BCW_CMD_SHIFT = 56,
};

enum nvdimm_security_bits {
	NVDIMM_SECURITY_DISABLED = 0,
	NVDIMM_SECURITY_UNLOCKED = 1,
	NVDIMM_SECURITY_LOCKED = 2,
	NVDIMM_SECURITY_FROZEN = 3,
	NVDIMM_SECURITY_OVERWRITE = 4,
};

struct nd_intel_get_security_state {
	u32 status;
	u8 extended_state;
	u8 reserved[3];
	u8 state;
	u8 reserved1[3];
};

struct nd_intel_set_passphrase {
	u8 old_pass[32];
	u8 new_pass[32];
	u32 status;
};

struct nd_intel_unlock_unit {
	u8 passphrase[32];
	u32 status;
};

struct nd_intel_disable_passphrase {
	u8 passphrase[32];
	u32 status;
};

struct nd_intel_freeze_lock {
	u32 status;
};

struct nd_intel_secure_erase {
	u8 passphrase[32];
	u32 status;
};

struct nd_intel_overwrite {
	u8 passphrase[32];
	u32 status;
};

struct nd_intel_query_overwrite {
	u32 status;
};

enum acpi_hmat_type {
	ACPI_HMAT_TYPE_PROXIMITY = 0,
	ACPI_HMAT_TYPE_LOCALITY = 1,
	ACPI_HMAT_TYPE_CACHE = 2,
	ACPI_HMAT_TYPE_RESERVED = 3,
};

struct acpi_hmat_proximity_domain {
	struct acpi_hmat_structure header;
	u16 flags;
	u16 reserved1;
	u32 processor_PD;
	u32 memory_PD;
	u32 reserved2;
	u64 reserved3;
	u64 reserved4;
};

struct acpi_hmat_locality {
	struct acpi_hmat_structure header;
	u8 flags;
	u8 data_type;
	u16 reserved1;
	u32 number_of_initiator_Pds;
	u32 number_of_target_Pds;
	u32 reserved2;
	u64 entry_base_unit;
};

struct acpi_hmat_cache {
	struct acpi_hmat_structure header;
	u32 memory_PD;
	u32 reserved1;
	u64 cache_size;
	u32 cache_attributes;
	u16 reserved2;
	u16 number_of_SMBIOShandles;
};

struct node_hmem_attrs {
	unsigned int read_bandwidth;
	unsigned int write_bandwidth;
	unsigned int read_latency;
	unsigned int write_latency;
};

enum cache_indexing {
	NODE_CACHE_DIRECT_MAP = 0,
	NODE_CACHE_INDEXED = 1,
	NODE_CACHE_OTHER = 2,
};

enum cache_write_policy {
	NODE_CACHE_WRITE_BACK = 0,
	NODE_CACHE_WRITE_THROUGH = 1,
	NODE_CACHE_WRITE_OTHER = 2,
};

struct node_cache_attrs {
	enum cache_indexing indexing;
	enum cache_write_policy write_policy;
	u64 size;
	u16 line_size;
	u8 level;
};

enum locality_types {
	WRITE_LATENCY = 0,
	READ_LATENCY = 1,
	WRITE_BANDWIDTH = 2,
	READ_BANDWIDTH = 3,
};

struct memory_locality {
	struct list_head node;
	struct acpi_hmat_locality *hmat_loc;
};

struct target_cache {
	struct list_head node;
	struct node_cache_attrs cache_attrs;
};

struct memory_target {
	struct list_head node;
	unsigned int memory_pxm;
	unsigned int processor_pxm;
	struct node_hmem_attrs hmem_attrs;
	struct list_head caches;
	struct node_cache_attrs cache_attrs;
	bool registered;
};

struct memory_initiator {
	struct list_head node;
	unsigned int processor_pxm;
};

struct acpi_memory_info {
	struct list_head list;
	u64 start_addr;
	u64 length;
	short unsigned int caching;
	short unsigned int write_protect;
	unsigned int enabled: 1;
};

struct acpi_memory_device {
	struct acpi_device *device;
	unsigned int state;
	struct list_head res_list;
};

struct acpi_pci_ioapic {
	acpi_handle root_handle;
	acpi_handle handle;
	u32 gsi_base;
	struct resource res;
	struct pci_dev *pdev;
	struct list_head list;
};

struct acpi_table_bgrt {
	struct acpi_table_header header;
	u16 version;
	u8 status;
	u8 image_type;
	u64 image_address;
	u32 image_offset_x;
	u32 image_offset_y;
};

struct acpi_pcct_hw_reduced {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pcct_shared_memory {
	u32 signature;
	u16 command;
	u16 status;
};

struct mbox_chan;

struct mbox_chan_ops {
	int (*send_data)(struct mbox_chan *, void *);
	int (*flush)(struct mbox_chan *, long unsigned int);
	int (*startup)(struct mbox_chan *);
	void (*shutdown)(struct mbox_chan *);
	bool (*last_tx_done)(struct mbox_chan *);
	bool (*peek_data)(struct mbox_chan *);
};

struct mbox_controller;

struct mbox_client;

struct mbox_chan {
	struct mbox_controller *mbox;
	unsigned int txdone_method;
	struct mbox_client *cl;
	struct completion tx_complete;
	void *active_req;
	unsigned int msg_count;
	unsigned int msg_free;
	void *msg_data[20];
	spinlock_t lock;
	void *con_priv;
};

struct mbox_controller {
	struct device *dev;
	const struct mbox_chan_ops *ops;
	struct mbox_chan *chans;
	int num_chans;
	bool txdone_irq;
	bool txdone_poll;
	unsigned int txpoll_period;
	struct mbox_chan * (*of_xlate)(struct mbox_controller *, const struct of_phandle_args *);
	struct hrtimer poll_hrt;
	struct list_head node;
};

struct mbox_client {
	struct device *dev;
	bool tx_block;
	long unsigned int tx_tout;
	bool knows_txdone;
	void (*rx_callback)(struct mbox_client *, void *);
	void (*tx_prepare)(struct mbox_client *, void *);
	void (*tx_done)(struct mbox_client *, void *, int);
};

struct cpc_register_resource {
	acpi_object_type type;
	u64 *sys_mem_vaddr;
	union {
		struct cpc_reg reg;
		u64 int_value;
	} cpc_entry;
};

struct cpc_desc {
	int num_entries;
	int version;
	int cpu_id;
	int write_cmd_status;
	int write_cmd_id;
	struct cpc_register_resource cpc_regs[21];
	struct acpi_psd_package domain_info;
	struct kobject kobj;
};

enum cppc_regs {
	HIGHEST_PERF = 0,
	NOMINAL_PERF = 1,
	LOW_NON_LINEAR_PERF = 2,
	LOWEST_PERF = 3,
	GUARANTEED_PERF = 4,
	DESIRED_PERF = 5,
	MIN_PERF = 6,
	MAX_PERF = 7,
	PERF_REDUC_TOLERANCE = 8,
	TIME_WINDOW = 9,
	CTR_WRAP_TIME = 10,
	REFERENCE_CTR = 11,
	DELIVERED_CTR = 12,
	PERF_LIMITED = 13,
	ENABLE = 14,
	AUTO_SEL_ENABLE = 15,
	AUTO_ACT_WINDOW = 16,
	ENERGY_PERF = 17,
	REFERENCE_PERF = 18,
	LOWEST_FREQ = 19,
	NOMINAL_FREQ = 20,
};

struct cppc_perf_caps {
	u32 guaranteed_perf;
	u32 highest_perf;
	u32 nominal_perf;
	u32 lowest_perf;
	u32 lowest_nonlinear_perf;
	u32 lowest_freq;
	u32 nominal_freq;
};

struct cppc_perf_ctrls {
	u32 max_perf;
	u32 min_perf;
	u32 desired_perf;
};

struct cppc_perf_fb_ctrs {
	u64 reference;
	u64 delivered;
	u64 reference_perf;
	u64 wraparound_time;
};

struct cppc_cpudata {
	int cpu;
	struct cppc_perf_caps perf_caps;
	struct cppc_perf_ctrls perf_ctrls;
	struct cppc_perf_fb_ctrs perf_fb_ctrs;
	struct cpufreq_policy *cur_policy;
	unsigned int shared_type;
	cpumask_var_t shared_cpu_map;
};

struct cppc_pcc_data {
	struct mbox_chan *pcc_channel;
	void *pcc_comm_addr;
	bool pcc_channel_acquired;
	unsigned int deadline_us;
	unsigned int pcc_mpar;
	unsigned int pcc_mrtt;
	unsigned int pcc_nominal;
	bool pending_pcc_write_cmd;
	bool platform_owns_pcc;
	unsigned int pcc_write_cnt;
	struct rw_semaphore pcc_lock;
	wait_queue_head_t pcc_write_wait_q;
	ktime_t last_cmd_cmpl_time;
	ktime_t last_mpar_reset;
	int mpar_count;
	int refcount;
};

struct acpi_whea_header {
	u8 action;
	u8 instruction;
	u8 flags;
	u8 reserved;
	struct acpi_generic_address register_region;
	u64 value;
	u64 mask;
} __attribute__((packed));

struct apei_exec_context;

typedef int (*apei_exec_ins_func_t)(struct apei_exec_context *, struct acpi_whea_header *);

struct apei_exec_ins_type;

struct apei_exec_context {
	u32 ip;
	u64 value;
	u64 var1;
	u64 var2;
	u64 src_base;
	u64 dst_base;
	struct apei_exec_ins_type *ins_table;
	u32 instructions;
	struct acpi_whea_header *action_table;
	u32 entries;
};

struct apei_exec_ins_type {
	u32 flags;
	apei_exec_ins_func_t run;
};

struct apei_resources {
	struct list_head iomem;
	struct list_head ioport;
};

typedef int (*apei_exec_entry_func_t)(struct apei_exec_context *, struct acpi_whea_header *, void *);

struct apei_res {
	struct list_head list;
	long unsigned int start;
	long unsigned int end;
};

struct acpi_table_hest {
	struct acpi_table_header header;
	u32 error_source_count;
};

struct acpi_hest_ia_machine_check {
	struct acpi_hest_header header;
	u16 reserved1;
	u8 flags;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	u64 global_capability_data;
	u64 global_control_data;
	u8 num_hardware_banks;
	u8 reserved3[7];
};

struct acpi_hest_generic {
	struct acpi_hest_header header;
	u16 related_source_id;
	u8 reserved;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	u32 max_raw_data_length;
	struct acpi_generic_address error_status_address;
	struct acpi_hest_notify notify;
	u32 error_block_length;
} __attribute__((packed));

struct acpi_hest_ia_deferred_check {
	struct acpi_hest_header header;
	u16 reserved1;
	u8 flags;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	struct acpi_hest_notify notify;
	u8 num_hardware_banks;
	u8 reserved2[3];
};

enum hest_status {
	HEST_ENABLED = 0,
	HEST_DISABLED = 1,
	HEST_NOT_FOUND = 2,
};

struct ghes_arr {
	struct platform_device **ghes_devs;
	unsigned int count;
};

struct acpi_table_erst {
	struct acpi_table_header header;
	u32 header_length;
	u32 reserved;
	u32 entries;
};

enum acpi_erst_actions {
	ACPI_ERST_BEGIN_WRITE = 0,
	ACPI_ERST_BEGIN_READ = 1,
	ACPI_ERST_BEGIN_CLEAR = 2,
	ACPI_ERST_END = 3,
	ACPI_ERST_SET_RECORD_OFFSET = 4,
	ACPI_ERST_EXECUTE_OPERATION = 5,
	ACPI_ERST_CHECK_BUSY_STATUS = 6,
	ACPI_ERST_GET_COMMAND_STATUS = 7,
	ACPI_ERST_GET_RECORD_ID = 8,
	ACPI_ERST_SET_RECORD_ID = 9,
	ACPI_ERST_GET_RECORD_COUNT = 10,
	ACPI_ERST_BEGIN_DUMMY_WRIITE = 11,
	ACPI_ERST_NOT_USED = 12,
	ACPI_ERST_GET_ERROR_RANGE = 13,
	ACPI_ERST_GET_ERROR_LENGTH = 14,
	ACPI_ERST_GET_ERROR_ATTRIBUTES = 15,
	ACPI_ERST_EXECUTE_TIMINGS = 16,
	ACPI_ERST_ACTION_RESERVED = 17,
};

enum acpi_erst_instructions {
	ACPI_ERST_READ_REGISTER = 0,
	ACPI_ERST_READ_REGISTER_VALUE = 1,
	ACPI_ERST_WRITE_REGISTER = 2,
	ACPI_ERST_WRITE_REGISTER_VALUE = 3,
	ACPI_ERST_NOOP = 4,
	ACPI_ERST_LOAD_VAR1 = 5,
	ACPI_ERST_LOAD_VAR2 = 6,
	ACPI_ERST_STORE_VAR1 = 7,
	ACPI_ERST_ADD = 8,
	ACPI_ERST_SUBTRACT = 9,
	ACPI_ERST_ADD_VALUE = 10,
	ACPI_ERST_SUBTRACT_VALUE = 11,
	ACPI_ERST_STALL = 12,
	ACPI_ERST_STALL_WHILE_TRUE = 13,
	ACPI_ERST_SKIP_NEXT_IF_TRUE = 14,
	ACPI_ERST_GOTO = 15,
	ACPI_ERST_SET_SRC_ADDRESS_BASE = 16,
	ACPI_ERST_SET_DST_ADDRESS_BASE = 17,
	ACPI_ERST_MOVE_DATA = 18,
	ACPI_ERST_INSTRUCTION_RESERVED = 19,
};

struct erst_erange {
	u64 base;
	u64 size;
	void *vaddr;
	u32 attr;
};

struct erst_record_id_cache {
	struct mutex lock;
	u64 *entries;
	int len;
	int size;
	int refcount;
};

struct cper_pstore_record {
	struct cper_record_header hdr;
	struct cper_section_descriptor sec_hdr;
	char data[0];
};

struct acpi_bert_region {
	u32 block_status;
	u32 raw_data_offset;
	u32 raw_data_length;
	u32 data_length;
	u32 error_severity;
};

struct acpi_hest_generic_status {
	u32 block_status;
	u32 raw_data_offset;
	u32 raw_data_length;
	u32 data_length;
	u32 error_severity;
};

enum acpi_hest_notify_types {
	ACPI_HEST_NOTIFY_POLLED = 0,
	ACPI_HEST_NOTIFY_EXTERNAL = 1,
	ACPI_HEST_NOTIFY_LOCAL = 2,
	ACPI_HEST_NOTIFY_SCI = 3,
	ACPI_HEST_NOTIFY_NMI = 4,
	ACPI_HEST_NOTIFY_CMCI = 5,
	ACPI_HEST_NOTIFY_MCE = 6,
	ACPI_HEST_NOTIFY_GPIO = 7,
	ACPI_HEST_NOTIFY_SEA = 8,
	ACPI_HEST_NOTIFY_SEI = 9,
	ACPI_HEST_NOTIFY_GSIV = 10,
	ACPI_HEST_NOTIFY_SOFTWARE_DELEGATED = 11,
	ACPI_HEST_NOTIFY_RESERVED = 12,
};

struct acpi_hest_generic_v2 {
	struct acpi_hest_header header;
	u16 related_source_id;
	u8 reserved;
	u8 enabled;
	u32 records_to_preallocate;
	u32 max_sections_per_record;
	u32 max_raw_data_length;
	struct acpi_generic_address error_status_address;
	struct acpi_hest_notify notify;
	u32 error_block_length;
	struct acpi_generic_address read_ack_register;
	u64 read_ack_preserve;
	u64 read_ack_write;
} __attribute__((packed));

struct acpi_hest_generic_data {
	u8 section_type[16];
	u32 error_severity;
	u16 revision;
	u8 validation_bits;
	u8 flags;
	u32 error_data_length;
	u8 fru_id[16];
	u8 fru_text[20];
};

struct acpi_hest_generic_data_v300 {
	u8 section_type[16];
	u32 error_severity;
	u16 revision;
	u8 validation_bits;
	u8 flags;
	u32 error_data_length;
	u8 fru_id[16];
	u8 fru_text[20];
	u64 time_stamp;
};

struct cper_sec_proc_arm {
	u32 validation_bits;
	u16 err_info_num;
	u16 context_info_num;
	u32 section_length;
	u8 affinity_level;
	u8 reserved[3];
	u64 mpidr;
	u64 midr;
	u32 running_state;
	u32 psci_state;
};

struct cper_sec_pcie {
	u64 validation_bits;
	u32 port_type;
	struct {
		u8 minor;
		u8 major;
		u8 reserved[2];
	} version;
	u16 command;
	u16 status;
	u32 reserved;
	struct {
		u16 vendor_id;
		u16 device_id;
		u8 class_code[3];
		u8 function;
		u8 device;
		u16 segment;
		u8 bus;
		u8 secondary_bus;
		u16 slot;
		u8 reserved;
	} __attribute__((packed)) device_id;
	struct {
		u32 lower;
		u32 upper;
	} serial_number;
	struct {
		u16 secondary_status;
		u16 control;
	} bridge;
	u8 capability[60];
	u8 aer_info[96];
};

struct ghes {
	union {
		struct acpi_hest_generic *generic;
		struct acpi_hest_generic_v2 *generic_v2;
	};
	struct acpi_hest_generic_status *estatus;
	long unsigned int flags;
	union {
		struct list_head list;
		struct timer_list timer;
		unsigned int irq;
	};
};

struct ghes_estatus_node {
	struct llist_node llnode;
	struct acpi_hest_generic *generic;
	struct ghes *ghes;
	int task_work_cpu;
	struct callback_head task_work;
};

struct ghes_estatus_cache {
	u32 estatus_len;
	atomic_t count;
	struct acpi_hest_generic *generic;
	long long unsigned int time_in;
	struct callback_head rcu;
};

struct pnp_resource {
	struct list_head list;
	struct resource res;
};

struct pnp_port {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

typedef struct {
	long unsigned int bits[4];
} pnp_irq_mask_t;

struct pnp_irq {
	pnp_irq_mask_t map;
	unsigned char flags;
};

struct pnp_dma {
	unsigned char map;
	unsigned char flags;
};

struct pnp_mem {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

struct pnp_option {
	struct list_head list;
	unsigned int flags;
	long unsigned int type;
	union {
		struct pnp_port port;
		struct pnp_irq irq;
		struct pnp_dma dma;
		struct pnp_mem mem;
	} u;
};

struct pnp_info_buffer {
	char *buffer;
	char *curr;
	long unsigned int size;
	long unsigned int len;
	int stop;
	int error;
};

typedef struct pnp_info_buffer pnp_info_buffer_t;

struct pnp_fixup {
	char id[7];
	void (*quirk_function)(struct pnp_dev *);
};

struct acpipnp_parse_option_s {
	struct pnp_dev *dev;
	unsigned int option_flags;
};

struct clk_bulk_data {
	const char *id;
	struct clk *clk;
};

struct clk_bulk_devres {
	struct clk_bulk_data *clks;
	int num_clks;
};

struct clk_hw;

struct clk_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct clk *clk;
	struct clk_hw *clk_hw;
};

struct clk_core;

struct clk_init_data;

struct clk_hw {
	struct clk_core *core;
	struct clk *clk;
	const struct clk_init_data *init;
};

struct clk_rate_request {
	long unsigned int rate;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int best_parent_rate;
	struct clk_hw *best_parent_hw;
};

struct clk_duty {
	unsigned int num;
	unsigned int den;
};

struct clk_ops {
	int (*prepare)(struct clk_hw *);
	void (*unprepare)(struct clk_hw *);
	int (*is_prepared)(struct clk_hw *);
	void (*unprepare_unused)(struct clk_hw *);
	int (*enable)(struct clk_hw *);
	void (*disable)(struct clk_hw *);
	int (*is_enabled)(struct clk_hw *);
	void (*disable_unused)(struct clk_hw *);
	int (*save_context)(struct clk_hw *);
	void (*restore_context)(struct clk_hw *);
	long unsigned int (*recalc_rate)(struct clk_hw *, long unsigned int);
	long int (*round_rate)(struct clk_hw *, long unsigned int, long unsigned int *);
	int (*determine_rate)(struct clk_hw *, struct clk_rate_request *);
	int (*set_parent)(struct clk_hw *, u8);
	u8 (*get_parent)(struct clk_hw *);
	int (*set_rate)(struct clk_hw *, long unsigned int, long unsigned int);
	int (*set_rate_and_parent)(struct clk_hw *, long unsigned int, long unsigned int, u8);
	long unsigned int (*recalc_accuracy)(struct clk_hw *, long unsigned int);
	int (*get_phase)(struct clk_hw *);
	int (*set_phase)(struct clk_hw *, int);
	int (*get_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*set_duty_cycle)(struct clk_hw *, struct clk_duty *);
	void (*init)(struct clk_hw *);
	void (*debug_init)(struct clk_hw *, struct dentry *);
};

struct clk_parent_data {
	const struct clk_hw *hw;
	const char *fw_name;
	const char *name;
	int index;
};

struct clk_init_data {
	const char *name;
	const struct clk_ops *ops;
	const char * const *parent_names;
	const struct clk_parent_data *parent_data;
	const struct clk_hw **parent_hws;
	u8 num_parents;
	long unsigned int flags;
};

struct clk_lookup_alloc {
	struct clk_lookup cl;
	char dev_id[20];
	char con_id[16];
};

struct clk_notifier {
	struct clk *clk;
	struct srcu_notifier_head notifier_head;
	struct list_head node;
};

struct clk {
	struct clk_core *core;
	struct device *dev;
	const char *dev_id;
	const char *con_id;
	long unsigned int min_rate;
	long unsigned int max_rate;
	unsigned int exclusive_count;
	struct hlist_node clks_node;
};

struct clk_notifier_data {
	struct clk *clk;
	long unsigned int old_rate;
	long unsigned int new_rate;
};

struct clk_parent_map;

struct clk_core {
	const char *name;
	const struct clk_ops *ops;
	struct clk_hw *hw;
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct clk_core *parent;
	struct clk_parent_map *parents;
	u8 num_parents;
	u8 new_parent_index;
	long unsigned int rate;
	long unsigned int req_rate;
	long unsigned int new_rate;
	struct clk_core *new_parent;
	struct clk_core *new_child;
	long unsigned int flags;
	bool orphan;
	bool rpm_enabled;
	unsigned int enable_count;
	unsigned int prepare_count;
	unsigned int protect_count;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int accuracy;
	int phase;
	struct clk_duty duty;
	struct hlist_head children;
	struct hlist_node child_node;
	struct hlist_head clks;
	unsigned int notifier_count;
	struct dentry *dentry;
	struct hlist_node debug_node;
	struct kref ref;
};

struct clk_parent_map {
	const struct clk_hw *hw;
	struct clk_core *core;
	const char *fw_name;
	const char *name;
	int index;
};

struct trace_event_raw_clk {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_clk_rate {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int rate;
	char __data[0];
};

struct trace_event_raw_clk_parent {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_pname;
	char __data[0];
};

struct trace_event_raw_clk_phase {
	struct trace_entry ent;
	u32 __data_loc_name;
	int phase;
	char __data[0];
};

struct trace_event_raw_clk_duty_cycle {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int num;
	unsigned int den;
	char __data[0];
};

struct trace_event_data_offsets_clk {
	u32 name;
};

struct trace_event_data_offsets_clk_rate {
	u32 name;
};

struct trace_event_data_offsets_clk_parent {
	u32 name;
	u32 pname;
};

struct trace_event_data_offsets_clk_phase {
	u32 name;
};

struct trace_event_data_offsets_clk_duty_cycle {
	u32 name;
};

typedef void (*btf_trace_clk_enable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_enable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_set_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_complete)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_parent)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_parent_complete)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_phase)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_phase_complete)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_duty_cycle)(void *, struct clk_core *, struct clk_duty *);

typedef void (*btf_trace_clk_set_duty_cycle_complete)(void *, struct clk_core *, struct clk_duty *);

struct clk_div_table {
	unsigned int val;
	unsigned int div;
};

struct clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

struct clk_fixed_factor {
	struct clk_hw hw;
	unsigned int mult;
	unsigned int div;
};

struct clk_fixed_rate {
	struct clk_hw hw;
	long unsigned int fixed_rate;
	long unsigned int fixed_accuracy;
};

struct clk_gate {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

struct clk_multiplier {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	spinlock_t *lock;
};

struct clk_mux {
	struct clk_hw hw;
	void *reg;
	u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct clk_composite {
	struct clk_hw hw;
	struct clk_ops ops;
	struct clk_hw *mux_hw;
	struct clk_hw *rate_hw;
	struct clk_hw *gate_hw;
	const struct clk_ops *mux_ops;
	const struct clk_ops *rate_ops;
	const struct clk_ops *gate_ops;
};

struct clk_fractional_divider {
	struct clk_hw hw;
	void *reg;
	u8 mshift;
	u8 mwidth;
	u32 mmask;
	u8 nshift;
	u8 nwidth;
	u32 nmask;
	u8 flags;
	void (*approximation)(struct clk_hw *, long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
	spinlock_t *lock;
};

struct gpio_desc;

struct clk_gpio {
	struct clk_hw hw;
	struct gpio_desc *gpiod;
};

enum gpiod_flags {
	GPIOD_ASIS = 0,
	GPIOD_IN = 1,
	GPIOD_OUT_LOW = 3,
	GPIOD_OUT_HIGH = 7,
	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
};

struct pmc_clk {
	const char *name;
	long unsigned int freq;
	const char *parent_name;
};

struct pmc_clk_data {
	void *base;
	const struct pmc_clk *clks;
	bool critical;
};

struct clk_plt_fixed {
	struct clk_hw *clk;
	struct clk_lookup *lookup;
};

struct clk_plt {
	struct clk_hw hw;
	void *reg;
	struct clk_lookup *lookup;
	spinlock_t lock;
};

struct clk_plt_data {
	struct clk_plt_fixed **parents;
	u8 nparents;
	struct clk_plt *clks[6];
	struct clk_lookup *mclk_lookup;
	struct clk_lookup *ether_clk_lookup;
};

struct dma_slave_caps {
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 max_burst;
	bool cmd_pause;
	bool cmd_resume;
	bool cmd_terminate;
	enum dma_residue_granularity residue_granularity;
	bool descriptor_reuse;
};

struct dma_chan_tbl_ent {
	struct dma_chan___2 *chan;
};

struct dmaengine_unmap_pool {
	struct kmem_cache *cache;
	const char *name;
	mempool_t *pool;
	size_t size;
};

struct dmaengine_desc_callback {
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
};

struct virt_dma_desc {
	struct dma_async_tx_descriptor tx;
	struct dmaengine_result tx_result;
	struct list_head node;
};

struct virt_dma_chan {
	struct dma_chan___2 chan;
	struct tasklet_struct task;
	void (*desc_free)(struct virt_dma_desc *);
	spinlock_t lock;
	struct list_head desc_allocated;
	struct list_head desc_submitted;
	struct list_head desc_issued;
	struct list_head desc_completed;
	struct virt_dma_desc *cyclic;
	struct virt_dma_desc *vd_terminated;
};

struct acpi_table_csrt {
	struct acpi_table_header header;
};

struct acpi_csrt_group {
	u32 length;
	u32 vendor_id;
	u32 subvendor_id;
	u16 device_id;
	u16 subdevice_id;
	u16 revision;
	u16 reserved;
	u32 shared_info_length;
};

struct acpi_csrt_shared_info {
	u16 major_version;
	u16 minor_version;
	u32 mmio_base_low;
	u32 mmio_base_high;
	u32 gsi_interrupt;
	u8 interrupt_polarity;
	u8 interrupt_mode;
	u8 num_channels;
	u8 dma_address_width;
	u16 base_request_line;
	u16 num_handshake_signals;
	u32 max_block_size;
};

struct acpi_dma_spec {
	int chan_id;
	int slave_id;
	struct device *dev;
};

struct acpi_dma {
	struct list_head dma_controllers;
	struct device *dev;
	struct dma_chan___2 * (*acpi_dma_xlate)(struct acpi_dma_spec *, struct acpi_dma *);
	void *data;
	short unsigned int base_request_line;
	short unsigned int end_request_line;
};

struct acpi_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

struct acpi_dma_parser_data {
	struct acpi_dma_spec dma_spec;
	size_t index;
	size_t n;
};

struct dw_dma_slave {
	struct device *dma_dev;
	u8 src_id;
	u8 dst_id;
	u8 m_master;
	u8 p_master;
	u8 channels;
	bool hs_polarity;
};

struct dw_dma_platform_data {
	unsigned int nr_channels;
	unsigned char chan_allocation_order;
	unsigned char chan_priority;
	unsigned int block_size;
	unsigned char nr_masters;
	unsigned char data_width[4];
	unsigned char multi_block[8];
	unsigned char protctl;
};

struct dw_dma;

struct dw_dma_chip {
	struct device *dev;
	int id;
	int irq;
	void *regs;
	struct clk *clk;
	struct dw_dma *dw;
	const struct dw_dma_platform_data *pdata;
};

struct dma_pool;

struct dw_dma_chan;

struct dw_dma {
	struct dma_device dma;
	char name[20];
	void *regs;
	struct dma_pool *desc_pool;
	struct tasklet_struct tasklet;
	struct dw_dma_chan *chan;
	u8 all_chan_mask;
	u8 in_use;
	void (*initialize_chan)(struct dw_dma_chan *);
	void (*suspend_chan)(struct dw_dma_chan *, bool);
	void (*resume_chan)(struct dw_dma_chan *, bool);
	u32 (*prepare_ctllo)(struct dw_dma_chan *);
	void (*encode_maxburst)(struct dw_dma_chan *, u32 *);
	u32 (*bytes2block)(struct dw_dma_chan *, size_t, unsigned int, size_t *);
	size_t (*block2bytes)(struct dw_dma_chan *, u32, u32);
	void (*set_device_name)(struct dw_dma *, int);
	void (*disable)(struct dw_dma *);
	void (*enable)(struct dw_dma *);
	struct dw_dma_platform_data *pdata;
};

enum dw_dma_fc {
	DW_DMA_FC_D_M2M = 0,
	DW_DMA_FC_D_M2P = 1,
	DW_DMA_FC_D_P2M = 2,
	DW_DMA_FC_D_P2P = 3,
	DW_DMA_FC_P_P2M = 4,
	DW_DMA_FC_SP_P2P = 5,
	DW_DMA_FC_P_M2P = 6,
	DW_DMA_FC_DP_P2P = 7,
};

struct dw_dma_chan_regs {
	u32 SAR;
	u32 __pad_SAR;
	u32 DAR;
	u32 __pad_DAR;
	u32 LLP;
	u32 __pad_LLP;
	u32 CTL_LO;
	u32 CTL_HI;
	u32 SSTAT;
	u32 __pad_SSTAT;
	u32 DSTAT;
	u32 __pad_DSTAT;
	u32 SSTATAR;
	u32 __pad_SSTATAR;
	u32 DSTATAR;
	u32 __pad_DSTATAR;
	u32 CFG_LO;
	u32 CFG_HI;
	u32 SGR;
	u32 __pad_SGR;
	u32 DSR;
	u32 __pad_DSR;
};

struct dw_dma_irq_regs {
	u32 XFER;
	u32 __pad_XFER;
	u32 BLOCK;
	u32 __pad_BLOCK;
	u32 SRC_TRAN;
	u32 __pad_SRC_TRAN;
	u32 DST_TRAN;
	u32 __pad_DST_TRAN;
	u32 ERROR;
	u32 __pad_ERROR;
};

struct dw_dma_regs {
	struct dw_dma_chan_regs CHAN[8];
	struct dw_dma_irq_regs RAW;
	struct dw_dma_irq_regs STATUS;
	struct dw_dma_irq_regs MASK;
	struct dw_dma_irq_regs CLEAR;
	u32 STATUS_INT;
	u32 __pad_STATUS_INT;
	u32 REQ_SRC;
	u32 __pad_REQ_SRC;
	u32 REQ_DST;
	u32 __pad_REQ_DST;
	u32 SGL_REQ_SRC;
	u32 __pad_SGL_REQ_SRC;
	u32 SGL_REQ_DST;
	u32 __pad_SGL_REQ_DST;
	u32 LAST_SRC;
	u32 __pad_LAST_SRC;
	u32 LAST_DST;
	u32 __pad_LAST_DST;
	u32 CFG;
	u32 __pad_CFG;
	u32 CH_EN;
	u32 __pad_CH_EN;
	u32 ID;
	u32 __pad_ID;
	u32 TEST;
	u32 __pad_TEST;
	u32 CLASS_PRIORITY0;
	u32 __pad_CLASS_PRIORITY0;
	u32 CLASS_PRIORITY1;
	u32 __pad_CLASS_PRIORITY1;
	u32 __reserved;
	u32 DWC_PARAMS[8];
	u32 MULTI_BLK_TYPE;
	u32 MAX_BLK_SIZE;
	u32 DW_PARAMS;
	u32 COMP_TYPE;
	u32 COMP_VERSION;
	u32 FIFO_PARTITION0;
	u32 __pad_FIFO_PARTITION0;
	u32 FIFO_PARTITION1;
	u32 __pad_FIFO_PARTITION1;
	u32 SAI_ERR;
	u32 __pad_SAI_ERR;
	u32 GLOBAL_CFG;
	u32 __pad_GLOBAL_CFG;
};

enum dw_dmac_flags {
	DW_DMA_IS_CYCLIC = 0,
	DW_DMA_IS_SOFT_LLP = 1,
	DW_DMA_IS_PAUSED = 2,
	DW_DMA_IS_INITIALIZED = 3,
};

struct dw_dma_chan {
	struct dma_chan___2 chan;
	void *ch_regs;
	u8 mask;
	u8 priority;
	enum dma_transfer_direction direction;
	struct list_head *tx_node_active;
	spinlock_t lock;
	long unsigned int flags;
	struct list_head active_list;
	struct list_head queue;
	unsigned int descs_allocated;
	unsigned int block_size;
	bool nollp;
	struct dw_dma_slave dws;
	struct dma_slave_config dma_sconfig;
};

struct dw_lli {
	__le32 sar;
	__le32 dar;
	__le32 llp;
	__le32 ctllo;
	__le32 ctlhi;
	__le32 sstat;
	__le32 dstat;
};

struct dw_desc {
	struct dw_lli lli;
	struct list_head desc_node;
	struct list_head tx_list;
	struct dma_async_tx_descriptor txd;
	size_t len;
	size_t total_len;
	u32 residue;
};

struct dw_dma_chip_pdata {
	const struct dw_dma_platform_data *pdata;
	int (*probe)(struct dw_dma_chip *);
	int (*remove)(struct dw_dma_chip *);
	struct dw_dma_chip *chip;
};

enum dw_dma_msize {
	DW_DMA_MSIZE_1 = 0,
	DW_DMA_MSIZE_4 = 1,
	DW_DMA_MSIZE_8 = 2,
	DW_DMA_MSIZE_16 = 3,
	DW_DMA_MSIZE_32 = 4,
	DW_DMA_MSIZE_64 = 5,
	DW_DMA_MSIZE_128 = 6,
	DW_DMA_MSIZE_256 = 7,
};

enum idma32_msize {
	IDMA32_MSIZE_1 = 0,
	IDMA32_MSIZE_2 = 1,
	IDMA32_MSIZE_4 = 2,
	IDMA32_MSIZE_8 = 3,
	IDMA32_MSIZE_16 = 4,
	IDMA32_MSIZE_32 = 5,
};

struct hsu_dma;

struct hsu_dma_chip {
	struct device *dev;
	int irq;
	void *regs;
	unsigned int length;
	unsigned int offset;
	struct hsu_dma *hsu;
};

struct hsu_dma_chan;

struct hsu_dma {
	struct dma_device dma;
	struct hsu_dma_chan *chan;
	short unsigned int nr_channels;
};

struct hsu_dma_sg {
	dma_addr_t addr;
	unsigned int len;
};

struct hsu_dma_desc {
	struct virt_dma_desc vdesc;
	enum dma_transfer_direction direction;
	struct hsu_dma_sg *sg;
	unsigned int nents;
	size_t length;
	unsigned int active;
	enum dma_status status;
};

struct hsu_dma_chan {
	struct virt_dma_chan vchan;
	void *reg;
	enum dma_transfer_direction direction;
	struct dma_slave_config config;
	struct hsu_dma_desc *desc;
};

struct idma64_lli {
	u64 sar;
	u64 dar;
	u64 llp;
	u32 ctllo;
	u32 ctlhi;
	u32 sstat;
	u32 dstat;
};

struct idma64_hw_desc {
	struct idma64_lli *lli;
	dma_addr_t llp;
	dma_addr_t phys;
	unsigned int len;
};

struct idma64_desc {
	struct virt_dma_desc vdesc;
	enum dma_transfer_direction direction;
	struct idma64_hw_desc *hw;
	unsigned int ndesc;
	size_t length;
	enum dma_status status;
};

struct idma64_chan {
	struct virt_dma_chan vchan;
	void *regs;
	enum dma_transfer_direction direction;
	unsigned int mask;
	struct dma_slave_config config;
	void *pool;
	struct idma64_desc *desc;
};

struct idma64 {
	struct dma_device dma;
	void *regs;
	short unsigned int all_chan_mask;
	struct idma64_chan *chan;
};

struct idma64_chip {
	struct device *dev;
	struct device *sysdev;
	int irq;
	void *regs;
	struct idma64 *idma64;
};

struct dca_ops;

struct dca_provider {
	struct list_head node;
	const struct dca_ops *ops;
	struct device *cd;
	int id;
};

struct dca_ops {
	int (*add_requester)(struct dca_provider *, struct device *);
	int (*remove_requester)(struct dca_provider *, struct device *);
	u8 (*get_tag)(struct dca_provider *, struct device *, int);
	int (*dev_managed)(struct dca_provider *, struct device *);
};

struct ioat_dma_descriptor {
	uint32_t size;
	union {
		uint32_t ctl;
		struct {
			unsigned int int_en: 1;
			unsigned int src_snoop_dis: 1;
			unsigned int dest_snoop_dis: 1;
			unsigned int compl_write: 1;
			unsigned int fence: 1;
			unsigned int null: 1;
			unsigned int src_brk: 1;
			unsigned int dest_brk: 1;
			unsigned int bundle: 1;
			unsigned int dest_dca: 1;
			unsigned int hint: 1;
			unsigned int rsvd2: 13;
			unsigned int op: 8;
		} ctl_f;
	};
	uint64_t src_addr;
	uint64_t dst_addr;
	uint64_t next;
	uint64_t rsv1;
	uint64_t rsv2;
	union {
		uint64_t user1;
		uint64_t tx_cnt;
	};
	uint64_t user2;
};

struct ioat_xor_descriptor {
	uint32_t size;
	union {
		uint32_t ctl;
		struct {
			unsigned int int_en: 1;
			unsigned int src_snoop_dis: 1;
			unsigned int dest_snoop_dis: 1;
			unsigned int compl_write: 1;
			unsigned int fence: 1;
			unsigned int src_cnt: 3;
			unsigned int bundle: 1;
			unsigned int dest_dca: 1;
			unsigned int hint: 1;
			unsigned int rsvd: 13;
			unsigned int op: 8;
		} ctl_f;
	};
	uint64_t src_addr;
	uint64_t dst_addr;
	uint64_t next;
	uint64_t src_addr2;
	uint64_t src_addr3;
	uint64_t src_addr4;
	uint64_t src_addr5;
};

struct ioat_xor_ext_descriptor {
	uint64_t src_addr6;
	uint64_t src_addr7;
	uint64_t src_addr8;
	uint64_t next;
	uint64_t rsvd[4];
};

struct ioat_pq_descriptor {
	union {
		uint32_t size;
		uint32_t dwbes;
		struct {
			unsigned int rsvd: 25;
			unsigned int p_val_err: 1;
			unsigned int q_val_err: 1;
			unsigned int rsvd1: 4;
			unsigned int wbes: 1;
		} dwbes_f;
	};
	union {
		uint32_t ctl;
		struct {
			unsigned int int_en: 1;
			unsigned int src_snoop_dis: 1;
			unsigned int dest_snoop_dis: 1;
			unsigned int compl_write: 1;
			unsigned int fence: 1;
			unsigned int src_cnt: 3;
			unsigned int bundle: 1;
			unsigned int dest_dca: 1;
			unsigned int hint: 1;
			unsigned int p_disable: 1;
			unsigned int q_disable: 1;
			unsigned int rsvd2: 2;
			unsigned int wb_en: 1;
			unsigned int prl_en: 1;
			unsigned int rsvd3: 7;
			unsigned int op: 8;
		} ctl_f;
	};
	uint64_t src_addr;
	uint64_t p_addr;
	uint64_t next;
	uint64_t src_addr2;
	union {
		uint64_t src_addr3;
		uint64_t sed_addr;
	};
	uint8_t coef[8];
	uint64_t q_addr;
};

struct ioat_pq_ext_descriptor {
	uint64_t src_addr4;
	uint64_t src_addr5;
	uint64_t src_addr6;
	uint64_t next;
	uint64_t src_addr7;
	uint64_t src_addr8;
	uint64_t rsvd[2];
};

struct ioat_pq_update_descriptor {
	uint32_t size;
	union {
		uint32_t ctl;
		struct {
			unsigned int int_en: 1;
			unsigned int src_snoop_dis: 1;
			unsigned int dest_snoop_dis: 1;
			unsigned int compl_write: 1;
			unsigned int fence: 1;
			unsigned int src_cnt: 3;
			unsigned int bundle: 1;
			unsigned int dest_dca: 1;
			unsigned int hint: 1;
			unsigned int p_disable: 1;
			unsigned int q_disable: 1;
			unsigned int rsvd: 3;
			unsigned int coef: 8;
			unsigned int op: 8;
		} ctl_f;
	};
	uint64_t src_addr;
	uint64_t p_addr;
	uint64_t next;
	uint64_t src_addr2;
	uint64_t p_src;
	uint64_t q_src;
	uint64_t q_addr;
};

struct ioat_raw_descriptor {
	uint64_t field[8];
};

struct ioat_sed_raw_descriptor {
	uint64_t a[8];
	uint64_t b[8];
	uint64_t c[8];
};

enum ioat_irq_mode {
	IOAT_NOIRQ = 0,
	IOAT_MSIX = 1,
	IOAT_MSI = 2,
	IOAT_INTX = 3,
};

struct ioatdma_chan;

struct ioatdma_device {
	struct pci_dev *pdev;
	void *reg_base;
	struct dma_pool *completion_pool;
	struct dma_pool *sed_hw_pool[5];
	struct dma_device dma_dev;
	u8 version;
	struct msix_entry msix_entries[4];
	struct ioatdma_chan *idx[4];
	struct dca_provider *dca;
	enum ioat_irq_mode irq_mode;
	u32 cap;
	u64 msixtba0;
	u64 msixdata0;
	u32 msixpba;
};

struct ioat_descs {
	void *virt;
	dma_addr_t hw;
};

struct ioat_ring_ent;

struct ioatdma_chan {
	struct dma_chan___2 dma_chan;
	void *reg_base;
	dma_addr_t last_completion;
	spinlock_t cleanup_lock;
	long unsigned int state;
	struct timer_list timer;
	struct ioatdma_device *ioat_dma;
	dma_addr_t completion_dma;
	u64 *completion;
	struct tasklet_struct cleanup_task;
	struct kobject kobj;
	size_t xfercap_log;
	u16 head;
	u16 issued;
	u16 tail;
	u16 dmacount;
	u16 alloc_order;
	u16 produce;
	struct ioat_ring_ent **ring;
	spinlock_t prep_lock;
	struct ioat_descs descs[2];
	int desc_chunks;
	int intr_coalesce;
	int prev_intr_coalesce;
};

struct ioat_sed_ent;

struct ioat_ring_ent {
	union {
		struct ioat_dma_descriptor *hw;
		struct ioat_xor_descriptor *xor;
		struct ioat_xor_ext_descriptor *xor_ex;
		struct ioat_pq_descriptor *pq;
		struct ioat_pq_ext_descriptor *pq_ex;
		struct ioat_pq_update_descriptor *pqu;
		struct ioat_raw_descriptor *raw;
	};
	size_t len;
	struct dma_async_tx_descriptor txd;
	enum sum_check_flags *result;
	struct ioat_sed_ent *sed;
};

struct ioat_sed_ent {
	struct ioat_sed_raw_descriptor *hw;
	dma_addr_t dma;
	struct ioat_ring_ent *parent;
	unsigned int hw_pool;
};

struct ioat_pq16a_descriptor {
	uint8_t coef[8];
	uint64_t src_addr3;
	uint64_t src_addr4;
	uint64_t src_addr5;
	uint64_t src_addr6;
	uint64_t src_addr7;
	uint64_t src_addr8;
	uint64_t src_addr9;
};

struct ioat_dca_slot {
	struct pci_dev *pdev;
	u16 rid;
};

struct ioat_dca_priv {
	void *iobase;
	void *dca_base;
	int max_requesters;
	int requester_count;
	u8 tag_map[8];
	struct ioat_dca_slot req_slots[0];
};

struct ioat_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct dma_chan___2 *, char *);
	ssize_t (*store)(struct dma_chan___2 *, const char *, size_t);
};

struct virtio_driver {
	struct device_driver driver;
	const struct virtio_device_id *id_table;
	const unsigned int *feature_table;
	unsigned int feature_table_size;
	const unsigned int *feature_table_legacy;
	unsigned int feature_table_size_legacy;
	int (*validate)(struct virtio_device *);
	int (*probe)(struct virtio_device *);
	void (*scan)(struct virtio_device *);
	void (*remove)(struct virtio_device *);
	void (*config_changed)(struct virtio_device *);
	int (*freeze)(struct virtio_device *);
	int (*restore)(struct virtio_device *);
};

struct vring_packed_desc_event {
	__le16 off_wrap;
	__le16 flags;
};

struct vring_packed_desc {
	__le64 addr;
	__le32 len;
	__le16 id;
	__le16 flags;
};

struct vring_desc_state_split {
	void *data;
	struct vring_desc *indir_desc;
};

struct vring_desc_state_packed {
	void *data;
	struct vring_packed_desc *indir_desc;
	u16 num;
	u16 next;
	u16 last;
};

struct vring_desc_extra_packed {
	dma_addr_t addr;
	u32 len;
	u16 flags;
};

struct vring_virtqueue {
	struct virtqueue vq;
	bool packed_ring;
	bool use_dma_api;
	bool weak_barriers;
	bool broken;
	bool indirect;
	bool event;
	unsigned int free_head;
	unsigned int num_added;
	u16 last_used_idx;
	union {
		struct {
			struct vring vring;
			u16 avail_flags_shadow;
			u16 avail_idx_shadow;
			struct vring_desc_state_split *desc_state;
			dma_addr_t queue_dma_addr;
			size_t queue_size_in_bytes;
		} split;
		struct {
			struct {
				unsigned int num;
				struct vring_packed_desc *desc;
				struct vring_packed_desc_event *driver;
				struct vring_packed_desc_event *device;
			} vring;
			bool avail_wrap_counter;
			bool used_wrap_counter;
			u16 avail_used_flags;
			u16 next_avail_idx;
			u16 event_flags_shadow;
			struct vring_desc_state_packed *desc_state;
			struct vring_desc_extra_packed *desc_extra;
			dma_addr_t ring_dma_addr;
			dma_addr_t driver_event_dma_addr;
			dma_addr_t device_event_dma_addr;
			size_t ring_size_in_bytes;
			size_t event_size_in_bytes;
		} packed;
	};
	bool (*notify)(struct virtqueue *);
	bool we_own_ring;
};

struct virtio_mmio_device {
	struct virtio_device vdev;
	struct platform_device *pdev;
	void *base;
	long unsigned int version;
	spinlock_t lock;
	struct list_head virtqueues;
};

struct virtio_mmio_vq_info {
	struct virtqueue *vq;
	struct list_head node;
};

struct virtio_pci_common_cfg {
	__le32 device_feature_select;
	__le32 device_feature;
	__le32 guest_feature_select;
	__le32 guest_feature;
	__le16 msix_config;
	__le16 num_queues;
	__u8 device_status;
	__u8 config_generation;
	__le16 queue_select;
	__le16 queue_size;
	__le16 queue_msix_vector;
	__le16 queue_enable;
	__le16 queue_notify_off;
	__le32 queue_desc_lo;
	__le32 queue_desc_hi;
	__le32 queue_avail_lo;
	__le32 queue_avail_hi;
	__le32 queue_used_lo;
	__le32 queue_used_hi;
};

struct virtio_pci_vq_info {
	struct virtqueue *vq;
	struct list_head node;
	unsigned int msix_vector;
};

struct virtio_pci_device {
	struct virtio_device vdev;
	struct pci_dev *pci_dev;
	u8 *isr;
	struct virtio_pci_common_cfg *common;
	void *device;
	void *notify_base;
	size_t notify_len;
	size_t device_len;
	int notify_map_cap;
	u32 notify_offset_multiplier;
	int modern_bars;
	void *ioaddr;
	spinlock_t lock;
	struct list_head virtqueues;
	struct virtio_pci_vq_info **vqs;
	int msix_enabled;
	int intx_enabled;
	cpumask_var_t *msix_affinity_masks;
	char (*msix_names)[256];
	unsigned int msix_vectors;
	unsigned int msix_used_vectors;
	bool per_vq_vectors;
	struct virtqueue * (*setup_vq)(struct virtio_pci_device *, struct virtio_pci_vq_info *, unsigned int, void (*)(struct virtqueue *), const char *, bool, u16);
	void (*del_vq)(struct virtio_pci_vq_info *);
	u16 (*config_vector)(struct virtio_pci_device *, u16);
};

enum {
	VP_MSIX_CONFIG_VECTOR = 0,
	VP_MSIX_VQ_VECTOR = 1,
};

struct serial_struct32 {
	compat_int_t type;
	compat_int_t line;
	compat_uint_t port;
	compat_int_t irq;
	compat_int_t flags;
	compat_int_t xmit_fifo_size;
	compat_int_t custom_divisor;
	compat_int_t baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char[1];
	compat_int_t hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	compat_uint_t iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	compat_int_t reserved[1];
};

struct n_tty_data {
	size_t read_head;
	size_t commit_head;
	size_t canon_head;
	size_t echo_head;
	size_t echo_commit;
	size_t echo_mark;
	long unsigned int char_map[4];
	long unsigned int overrun_time;
	int num_overrun;
	bool no_room;
	unsigned char lnext: 1;
	unsigned char erasing: 1;
	unsigned char raw: 1;
	unsigned char real_raw: 1;
	unsigned char icanon: 1;
	unsigned char push: 1;
	char read_buf[4096];
	long unsigned int read_flags[64];
	unsigned char echo_buf[4096];
	size_t read_tail;
	size_t line_start;
	unsigned int column;
	unsigned int canon_column;
	size_t echo_tail;
	struct mutex atomic_read_lock;
	struct mutex output_lock;
};

enum {
	ERASE = 0,
	WERASE = 1,
	KILL = 2,
};

struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
};

struct termios2 {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct termio {
	short unsigned int c_iflag;
	short unsigned int c_oflag;
	short unsigned int c_cflag;
	short unsigned int c_lflag;
	unsigned char c_line;
	unsigned char c_cc[8];
};

struct ldsem_waiter {
	struct list_head list;
	struct task_struct *task;
};

struct pts_fs_info;

struct tty_audit_buf {
	struct mutex mutex;
	dev_t dev;
	unsigned int icanon: 1;
	size_t valid;
	unsigned char *data;
};

enum input_clock_type {
	INPUT_CLK_REAL = 0,
	INPUT_CLK_MONO = 1,
	INPUT_CLK_BOOT = 2,
	INPUT_CLK_MAX = 3,
};

struct sysrq_state {
	struct input_handle handle;
	struct work_struct reinject_work;
	long unsigned int key_down[12];
	unsigned int alt;
	unsigned int alt_use;
	bool active;
	bool need_reinject;
	bool reinjecting;
	bool reset_canceled;
	bool reset_requested;
	long unsigned int reset_keybit[12];
	int reset_seq_len;
	int reset_seq_cnt;
	int reset_seq_version;
	struct timer_list keyreset_timer;
};

struct consolefontdesc {
	short unsigned int charcount;
	short unsigned int charheight;
	char *chardata;
};

struct unipair {
	short unsigned int unicode;
	short unsigned int fontpos;
};

struct unimapdesc {
	short unsigned int entry_ct;
	struct unipair *entries;
};

struct kbentry {
	unsigned char kb_table;
	unsigned char kb_index;
	short unsigned int kb_value;
};

struct kbsentry {
	unsigned char kb_func;
	unsigned char kb_string[512];
};

struct kbkeycode {
	unsigned int scancode;
	unsigned int keycode;
};

struct kbd_repeat {
	int delay;
	int period;
};

struct console_font_op {
	unsigned int op;
	unsigned int flags;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_stat {
	short unsigned int v_active;
	short unsigned int v_signal;
	short unsigned int v_state;
};

struct vt_sizes {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_scrollsize;
};

struct vt_consize {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_vlin;
	short unsigned int v_clin;
	short unsigned int v_vcol;
	short unsigned int v_ccol;
};

struct vt_event {
	unsigned int event;
	unsigned int oldev;
	unsigned int newev;
	unsigned int pad[4];
};

struct vt_setactivate {
	unsigned int console;
	struct vt_mode mode;
};

struct vt_spawn_console {
	spinlock_t lock;
	struct pid *pid;
	int sig;
};

struct vt_event_wait {
	struct list_head list;
	struct vt_event event;
	int done;
};

struct compat_consolefontdesc {
	short unsigned int charcount;
	short unsigned int charheight;
	compat_caddr_t chardata;
};

struct compat_console_font_op {
	compat_uint_t op;
	compat_uint_t flags;
	compat_uint_t width;
	compat_uint_t height;
	compat_uint_t charcount;
	compat_caddr_t data;
};

struct compat_unimapdesc {
	short unsigned int entry_ct;
	compat_caddr_t entries;
};

struct vt_notifier_param {
	struct vc_data *vc;
	unsigned int c;
};

struct vcs_poll_data {
	struct notifier_block notifier;
	unsigned int cons_num;
	int event;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
};

struct tiocl_selection {
	short unsigned int xs;
	short unsigned int ys;
	short unsigned int xe;
	short unsigned int ye;
	short unsigned int sel_mode;
};

struct keyboard_notifier_param {
	struct vc_data *vc;
	int down;
	int shift;
	int ledstate;
	unsigned int value;
};

struct kbd_struct {
	unsigned char lockstate;
	unsigned char slockstate;
	unsigned char ledmode: 1;
	unsigned char ledflagstate: 4;
	char: 3;
	unsigned char default_ledflagstate: 4;
	unsigned char kbdmode: 3;
	char: 1;
	unsigned char modeflags: 5;
};

struct kbdiacr {
	unsigned char diacr;
	unsigned char base;
	unsigned char result;
};

struct kbdiacrs {
	unsigned int kb_cnt;
	struct kbdiacr kbdiacr[256];
};

struct kbdiacruc {
	unsigned int diacr;
	unsigned int base;
	unsigned int result;
};

struct kbdiacrsuc {
	unsigned int kb_cnt;
	struct kbdiacruc kbdiacruc[256];
};

typedef void k_handler_fn(struct vc_data *, unsigned char, char);

typedef void fn_handler_fn(struct vc_data *);

struct getset_keycode_data {
	struct input_keymap_entry ke;
	int error;
};

struct uni_pagedir {
	u16 **uni_pgdir[32];
	long unsigned int refcount;
	long unsigned int sum;
	unsigned char *inverse_translations[4];
	u16 *inverse_trans_unicode;
};

typedef uint32_t char32_t;

struct uni_screen {
	char32_t *lines[0];
};

struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};

enum {
	blank_off = 0,
	blank_normal_wait = 1,
	blank_vesa_wait = 2,
};

enum {
	EPecma = 0,
	EPdec = 1,
	EPeq = 2,
	EPgt = 3,
	EPlt = 4,
};

struct rgb {
	u8 r;
	u8 g;
	u8 b;
};

enum {
	ESnormal = 0,
	ESesc = 1,
	ESsquare = 2,
	ESgetpars = 3,
	ESfunckey = 4,
	EShash = 5,
	ESsetG0 = 6,
	ESsetG1 = 7,
	ESpercent = 8,
	EScsiignore = 9,
	ESnonstd = 10,
	ESpalette = 11,
	ESosc = 12,
};

struct interval {
	uint32_t first;
	uint32_t last;
};

struct hv_ops;

struct hvc_struct {
	struct tty_port port;
	spinlock_t lock;
	int index;
	int do_wakeup;
	char *outbuf;
	int outbuf_size;
	int n_outbuf;
	uint32_t vtermno;
	const struct hv_ops *ops;
	int irq_requested;
	int data;
	struct winsize ws;
	struct work_struct tty_resize;
	struct list_head next;
	long unsigned int flags;
};

struct hv_ops {
	int (*get_chars)(uint32_t, char *, int);
	int (*put_chars)(uint32_t, const char *, int);
	int (*flush)(uint32_t, bool);
	int (*notifier_add)(struct hvc_struct *, int);
	void (*notifier_del)(struct hvc_struct *, int);
	void (*notifier_hangup)(struct hvc_struct *, int);
	int (*tiocmget)(struct hvc_struct *);
	int (*tiocmset)(struct hvc_struct *, unsigned int, unsigned int);
	void (*dtr_rts)(struct hvc_struct *, int);
};

struct serial_rs485 {
	__u32 flags;
	__u32 delay_rts_before_send;
	__u32 delay_rts_after_send;
	__u32 padding[5];
};

struct serial_iso7816 {
	__u32 flags;
	__u32 tg;
	__u32 sc_fi;
	__u32 sc_di;
	__u32 clk;
	__u32 reserved[5];
};

struct circ_buf {
	char *buf;
	int head;
	int tail;
};

struct uart_port;

struct uart_ops {
	unsigned int (*tx_empty)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*stop_tx)(struct uart_port *);
	void (*start_tx)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	void (*send_xchar)(struct uart_port *, char);
	void (*stop_rx)(struct uart_port *);
	void (*enable_ms)(struct uart_port *);
	void (*break_ctl)(struct uart_port *, int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*flush_buffer)(struct uart_port *);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	const char * (*type)(struct uart_port *);
	void (*release_port)(struct uart_port *);
	int (*request_port)(struct uart_port *);
	void (*config_port)(struct uart_port *, int);
	int (*verify_port)(struct uart_port *, struct serial_struct *);
	int (*ioctl)(struct uart_port *, unsigned int, long unsigned int);
};

struct uart_icount {
	__u32 cts;
	__u32 dsr;
	__u32 rng;
	__u32 dcd;
	__u32 rx;
	__u32 tx;
	__u32 frame;
	__u32 overrun;
	__u32 parity;
	__u32 brk;
	__u32 buf_overrun;
};

typedef unsigned int upf_t;

typedef unsigned int upstat_t;

struct uart_state;

struct uart_port {
	spinlock_t lock;
	long unsigned int iobase;
	unsigned char *membase;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
	int (*rs485_config)(struct uart_port *, struct serial_rs485 *);
	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	unsigned int fifosize;
	unsigned char x_char;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char quirks;
	unsigned int read_status_mask;
	unsigned int ignore_status_mask;
	struct uart_state *state;
	struct uart_icount icount;
	struct console *cons;
	long unsigned int sysrq;
	unsigned int sysrq_ch;
	upf_t flags;
	upstat_t status;
	int hw_stopped;
	unsigned int mctrl;
	unsigned int timeout;
	unsigned int type;
	const struct uart_ops *ops;
	unsigned int custom_divisor;
	unsigned int line;
	unsigned int minor;
	resource_size_t mapbase;
	resource_size_t mapsize;
	struct device *dev;
	unsigned char hub6;
	unsigned char suspended;
	unsigned char unused[2];
	const char *name;
	struct attribute_group *attr_group;
	const struct attribute_group **tty_groups;
	struct serial_rs485 rs485;
	struct serial_iso7816 iso7816;
	void *private_data;
};

enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3,
	UART_PM_STATE_UNDEFINED = 4,
};

struct uart_state {
	struct tty_port port;
	enum uart_pm_state pm_state;
	struct circ_buf xmit;
	atomic_t refcount;
	wait_queue_head_t remove_wait;
	struct uart_port *uart_port;
};

struct uart_driver {
	struct module *owner;
	const char *driver_name;
	const char *dev_name;
	int major;
	int minor;
	int nr;
	struct console *cons;
	struct uart_state *state;
	struct tty_driver *tty_driver;
};

struct uart_match {
	struct uart_port *port;
	struct uart_driver *driver;
};

struct earlycon_device {
	struct console *con;
	struct uart_port port;
	char options[16];
	unsigned int baud;
};

struct earlycon_id {
	char name[15];
	char name_term;
	char compatible[128];
	int (*setup)(struct earlycon_device *, const char *);
};

enum hwparam_type {
	hwparam_ioport = 0,
	hwparam_iomem = 1,
	hwparam_ioport_or_iomem = 2,
	hwparam_irq = 3,
	hwparam_dma = 4,
	hwparam_dma_addr = 5,
	hwparam_other = 6,
};

struct plat_serial8250_port {
	long unsigned int iobase;
	void *membase;
	resource_size_t mapbase;
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	void *private_data;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char hub6;
	upf_t flags;
	unsigned int type;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
};

enum {
	PLAT8250_DEV_LEGACY = 4294967295,
	PLAT8250_DEV_PLATFORM = 0,
	PLAT8250_DEV_PLATFORM1 = 1,
	PLAT8250_DEV_PLATFORM2 = 2,
	PLAT8250_DEV_FOURPORT = 3,
	PLAT8250_DEV_ACCENT = 4,
	PLAT8250_DEV_BOCA = 5,
	PLAT8250_DEV_EXAR_ST16C554 = 6,
	PLAT8250_DEV_HUB6 = 7,
	PLAT8250_DEV_AU1X00 = 8,
	PLAT8250_DEV_SM501 = 9,
};

struct uart_8250_port;

struct uart_8250_ops {
	int (*setup_irq)(struct uart_8250_port *);
	void (*release_irq)(struct uart_8250_port *);
};

struct mctrl_gpios;

struct uart_8250_dma;

struct uart_8250_em485;

struct uart_8250_port {
	struct uart_port port;
	struct timer_list timer;
	struct list_head list;
	u32 capabilities;
	short unsigned int bugs;
	bool fifo_bug;
	unsigned int tx_loadsz;
	unsigned char acr;
	unsigned char fcr;
	unsigned char ier;
	unsigned char lcr;
	unsigned char mcr;
	unsigned char mcr_mask;
	unsigned char mcr_force;
	unsigned char cur_iotype;
	unsigned int rpm_tx_active;
	unsigned char canary;
	unsigned char probe;
	struct mctrl_gpios *gpios;
	unsigned char lsr_saved_flags;
	unsigned char msr_saved_flags;
	struct uart_8250_dma *dma;
	const struct uart_8250_ops *ops;
	int (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, int);
	struct uart_8250_em485 *em485;
	struct delayed_work overrun_backoff;
	u32 overrun_backoff_time_ms;
};

struct uart_8250_em485 {
	struct hrtimer start_tx_timer;
	struct hrtimer stop_tx_timer;
	struct hrtimer *active_timer;
	struct uart_8250_port *port;
};

struct uart_8250_dma {
	int (*tx_dma)(struct uart_8250_port *);
	int (*rx_dma)(struct uart_8250_port *);
	dma_filter_fn fn;
	void *rx_param;
	void *tx_param;
	struct dma_slave_config rxconf;
	struct dma_slave_config txconf;
	struct dma_chan___2 *rxchan;
	struct dma_chan___2 *txchan;
	phys_addr_t rx_dma_addr;
	phys_addr_t tx_dma_addr;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	void *rx_buf;
	size_t rx_size;
	size_t tx_size;
	unsigned char tx_running;
	unsigned char tx_err;
	unsigned char rx_running;
};

struct old_serial_port {
	unsigned int uart;
	unsigned int baud_base;
	unsigned int port;
	unsigned int irq;
	upf_t flags;
	unsigned char io_type;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
};

struct irq_info {
	struct hlist_node node;
	int irq;
	spinlock_t lock;
	struct list_head *head;
};

struct serial8250_config {
	const char *name;
	short unsigned int fifo_size;
	short unsigned int tx_loadsz;
	unsigned char fcr;
	unsigned char rxtrig_bytes[4];
	unsigned int flags;
};

struct dw8250_port_data {
	int line;
	struct uart_8250_dma dma;
	u8 dlf_size;
};

struct pciserial_board {
	unsigned int flags;
	unsigned int num_ports;
	unsigned int base_baud;
	unsigned int uart_offset;
	unsigned int reg_shift;
	unsigned int first_offset;
};

struct serial_private;

struct pci_serial_quirk {
	u32 vendor;
	u32 device;
	u32 subvendor;
	u32 subdevice;
	int (*probe)(struct pci_dev *);
	int (*init)(struct pci_dev *);
	int (*setup)(struct serial_private *, const struct pciserial_board *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct serial_private {
	struct pci_dev *dev;
	unsigned int nr;
	struct pci_serial_quirk *quirk;
	const struct pciserial_board *board;
	int line[0];
};

struct f815xxa_data {
	spinlock_t lock;
	int idx;
};

struct timedia_struct {
	int num;
	const short unsigned int *ids;
};

struct quatech_feature {
	u16 devid;
	bool amcc;
};

enum pci_board_num_t {
	pbn_default = 0,
	pbn_b0_1_115200 = 1,
	pbn_b0_2_115200 = 2,
	pbn_b0_4_115200 = 3,
	pbn_b0_5_115200 = 4,
	pbn_b0_8_115200 = 5,
	pbn_b0_1_921600 = 6,
	pbn_b0_2_921600 = 7,
	pbn_b0_4_921600 = 8,
	pbn_b0_2_1130000 = 9,
	pbn_b0_4_1152000 = 10,
	pbn_b0_4_1250000 = 11,
	pbn_b0_2_1843200 = 12,
	pbn_b0_4_1843200 = 13,
	pbn_b0_1_4000000 = 14,
	pbn_b0_bt_1_115200 = 15,
	pbn_b0_bt_2_115200 = 16,
	pbn_b0_bt_4_115200 = 17,
	pbn_b0_bt_8_115200 = 18,
	pbn_b0_bt_1_460800 = 19,
	pbn_b0_bt_2_460800 = 20,
	pbn_b0_bt_4_460800 = 21,
	pbn_b0_bt_1_921600 = 22,
	pbn_b0_bt_2_921600 = 23,
	pbn_b0_bt_4_921600 = 24,
	pbn_b0_bt_8_921600 = 25,
	pbn_b1_1_115200 = 26,
	pbn_b1_2_115200 = 27,
	pbn_b1_4_115200 = 28,
	pbn_b1_8_115200 = 29,
	pbn_b1_16_115200 = 30,
	pbn_b1_1_921600 = 31,
	pbn_b1_2_921600 = 32,
	pbn_b1_4_921600 = 33,
	pbn_b1_8_921600 = 34,
	pbn_b1_2_1250000 = 35,
	pbn_b1_bt_1_115200 = 36,
	pbn_b1_bt_2_115200 = 37,
	pbn_b1_bt_4_115200 = 38,
	pbn_b1_bt_2_921600 = 39,
	pbn_b1_1_1382400 = 40,
	pbn_b1_2_1382400 = 41,
	pbn_b1_4_1382400 = 42,
	pbn_b1_8_1382400 = 43,
	pbn_b2_1_115200 = 44,
	pbn_b2_2_115200 = 45,
	pbn_b2_4_115200 = 46,
	pbn_b2_8_115200 = 47,
	pbn_b2_1_460800 = 48,
	pbn_b2_4_460800 = 49,
	pbn_b2_8_460800 = 50,
	pbn_b2_16_460800 = 51,
	pbn_b2_1_921600 = 52,
	pbn_b2_4_921600 = 53,
	pbn_b2_8_921600 = 54,
	pbn_b2_8_1152000 = 55,
	pbn_b2_bt_1_115200 = 56,
	pbn_b2_bt_2_115200 = 57,
	pbn_b2_bt_4_115200 = 58,
	pbn_b2_bt_2_921600 = 59,
	pbn_b2_bt_4_921600 = 60,
	pbn_b3_2_115200 = 61,
	pbn_b3_4_115200 = 62,
	pbn_b3_8_115200 = 63,
	pbn_b4_bt_2_921600 = 64,
	pbn_b4_bt_4_921600 = 65,
	pbn_b4_bt_8_921600 = 66,
	pbn_panacom = 67,
	pbn_panacom2 = 68,
	pbn_panacom4 = 69,
	pbn_plx_romulus = 70,
	pbn_endrun_2_4000000 = 71,
	pbn_oxsemi = 72,
	pbn_oxsemi_1_4000000 = 73,
	pbn_oxsemi_2_4000000 = 74,
	pbn_oxsemi_4_4000000 = 75,
	pbn_oxsemi_8_4000000 = 76,
	pbn_intel_i960 = 77,
	pbn_sgi_ioc3 = 78,
	pbn_computone_4 = 79,
	pbn_computone_6 = 80,
	pbn_computone_8 = 81,
	pbn_sbsxrsio = 82,
	pbn_pasemi_1682M = 83,
	pbn_ni8430_2 = 84,
	pbn_ni8430_4 = 85,
	pbn_ni8430_8 = 86,
	pbn_ni8430_16 = 87,
	pbn_ADDIDATA_PCIe_1_3906250 = 88,
	pbn_ADDIDATA_PCIe_2_3906250 = 89,
	pbn_ADDIDATA_PCIe_4_3906250 = 90,
	pbn_ADDIDATA_PCIe_8_3906250 = 91,
	pbn_ce4100_1_115200 = 92,
	pbn_omegapci = 93,
	pbn_NETMOS9900_2s_115200 = 94,
	pbn_brcm_trumanage = 95,
	pbn_fintek_4 = 96,
	pbn_fintek_8 = 97,
	pbn_fintek_12 = 98,
	pbn_fintek_F81504A = 99,
	pbn_fintek_F81508A = 100,
	pbn_fintek_F81512A = 101,
	pbn_wch382_2 = 102,
	pbn_wch384_4 = 103,
	pbn_pericom_PI7C9X7951 = 104,
	pbn_pericom_PI7C9X7952 = 105,
	pbn_pericom_PI7C9X7954 = 106,
	pbn_pericom_PI7C9X7958 = 107,
	pbn_sunix_pci_1s = 108,
	pbn_sunix_pci_2s = 109,
	pbn_sunix_pci_4s = 110,
	pbn_sunix_pci_8s = 111,
	pbn_sunix_pci_16s = 112,
	pbn_moxa8250_2p = 113,
	pbn_moxa8250_4p = 114,
	pbn_moxa8250_8p = 115,
};

struct acpi_gpio_params {
	unsigned int crs_entry_index;
	unsigned int line_index;
	bool active_low;
};

struct exar8250_platform {
	int (*rs485_config)(struct uart_port *, struct serial_rs485 *);
	int (*register_gpio)(struct pci_dev *, struct uart_8250_port *);
};

struct exar8250;

struct exar8250_board {
	unsigned int num_ports;
	unsigned int reg_shift;
	int (*setup)(struct exar8250 *, struct pci_dev *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct exar8250 {
	unsigned int nr;
	struct exar8250_board *board;
	void *virt;
	int line[0];
};

struct lpss8250;

struct lpss8250_board {
	long unsigned int freq;
	unsigned int base_baud;
	int (*setup)(struct lpss8250 *, struct uart_port *);
	void (*exit)(struct lpss8250 *);
};

struct lpss8250 {
	struct dw8250_port_data data;
	struct lpss8250_board *board;
	struct dw_dma_chip dma_chip;
	struct dw_dma_slave dma_param;
	u8 dma_maxburst;
};

struct hsu_dma_slave {
	struct device *dma_dev;
	int chan_id;
};

struct mid8250;

struct mid8250_board {
	unsigned int flags;
	long unsigned int freq;
	unsigned int base_baud;
	int (*setup)(struct mid8250 *, struct uart_port *);
	void (*exit)(struct mid8250 *);
};

struct mid8250 {
	int line;
	int dma_index;
	struct pci_dev *dma_dev;
	struct uart_8250_dma dma;
	struct mid8250_board *board;
	struct hsu_dma_chip dma_chip;
};

struct memdev {
	const char *name;
	umode_t mode;
	const struct file_operations *fops;
	fmode_t fmode;
};

struct timer_rand_state {
	cycles_t last_time;
	long int last_delta;
	long int last_delta2;
};

struct trace_event_raw_add_device_randomness {
	struct trace_entry ent;
	int bytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random__mix_pool_bytes {
	struct trace_entry ent;
	const char *pool_name;
	int bytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_credit_entropy_bits {
	struct trace_entry ent;
	const char *pool_name;
	int bits;
	int entropy_count;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_push_to_pool {
	struct trace_entry ent;
	const char *pool_name;
	int pool_bits;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_debit_entropy {
	struct trace_entry ent;
	const char *pool_name;
	int debit_bits;
	char __data[0];
};

struct trace_event_raw_add_input_randomness {
	struct trace_entry ent;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_add_disk_randomness {
	struct trace_entry ent;
	dev_t dev;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_xfer_secondary_pool {
	struct trace_entry ent;
	const char *pool_name;
	int xfer_bits;
	int request_bits;
	int pool_entropy;
	int input_entropy;
	char __data[0];
};

struct trace_event_raw_random__get_random_bytes {
	struct trace_entry ent;
	int nbytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random__extract_entropy {
	struct trace_entry ent;
	const char *pool_name;
	int nbytes;
	int entropy_count;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random_read {
	struct trace_entry ent;
	int got_bits;
	int need_bits;
	int pool_left;
	int input_left;
	char __data[0];
};

struct trace_event_raw_urandom_read {
	struct trace_entry ent;
	int got_bits;
	int pool_left;
	int input_left;
	char __data[0];
};

struct trace_event_data_offsets_add_device_randomness {};

struct trace_event_data_offsets_random__mix_pool_bytes {};

struct trace_event_data_offsets_credit_entropy_bits {};

struct trace_event_data_offsets_push_to_pool {};

struct trace_event_data_offsets_debit_entropy {};

struct trace_event_data_offsets_add_input_randomness {};

struct trace_event_data_offsets_add_disk_randomness {};

struct trace_event_data_offsets_xfer_secondary_pool {};

struct trace_event_data_offsets_random__get_random_bytes {};

struct trace_event_data_offsets_random__extract_entropy {};

struct trace_event_data_offsets_random_read {};

struct trace_event_data_offsets_urandom_read {};

typedef void (*btf_trace_add_device_randomness)(void *, int, long unsigned int);

typedef void (*btf_trace_mix_pool_bytes)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_mix_pool_bytes_nolock)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_credit_entropy_bits)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_push_to_pool)(void *, const char *, int, int);

typedef void (*btf_trace_debit_entropy)(void *, const char *, int);

typedef void (*btf_trace_add_input_randomness)(void *, int);

typedef void (*btf_trace_add_disk_randomness)(void *, dev_t, int);

typedef void (*btf_trace_xfer_secondary_pool)(void *, const char *, int, int, int, int);

typedef void (*btf_trace_get_random_bytes)(void *, int, long unsigned int);

typedef void (*btf_trace_get_random_bytes_arch)(void *, int, long unsigned int);

typedef void (*btf_trace_extract_entropy)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_extract_entropy_user)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_random_read)(void *, int, int, int, int);

typedef void (*btf_trace_urandom_read)(void *, int, int, int);

struct poolinfo {
	int poolbitshift;
	int poolwords;
	int poolbytes;
	int poolfracbits;
	int tap1;
	int tap2;
	int tap3;
	int tap4;
	int tap5;
};

struct crng_state {
	__u32 state[16];
	long unsigned int init_time;
	spinlock_t lock;
};

struct entropy_store {
	const struct poolinfo *poolinfo;
	__u32 *pool;
	const char *name;
	struct entropy_store *pull;
	struct work_struct push_work;
	long unsigned int last_pulled;
	spinlock_t lock;
	short unsigned int add_ptr;
	short unsigned int input_rotate;
	int entropy_count;
	unsigned int initialized: 1;
	unsigned int last_data_init: 1;
	__u8 last_data[10];
};

struct fast_pool {
	__u32 pool[4];
	long unsigned int last;
	short unsigned int reg_idx;
	unsigned char count;
};

struct batched_entropy {
	union {
		u64 entropy_u64[8];
		u32 entropy_u32[16];
	};
	unsigned int position;
	spinlock_t batch_lock;
};

struct raw_config_request {
	int raw_minor;
	__u64 block_major;
	__u64 block_minor;
};

struct raw_device_data {
	struct block_device *binding;
	int inuse;
};

struct raw32_config_request {
	compat_int_t raw_minor;
	compat_u64 block_major;
	compat_u64 block_minor;
} __attribute__((packed));

struct hpet_info {
	long unsigned int hi_ireqfreq;
	long unsigned int hi_flags;
	short unsigned int hi_hpet;
	short unsigned int hi_timer;
};

struct hpet_timer {
	u64 hpet_config;
	union {
		u64 _hpet_hc64;
		u32 _hpet_hc32;
		long unsigned int _hpet_compare;
	} _u1;
	u64 hpet_fsb[2];
};

struct hpet {
	u64 hpet_cap;
	u64 res0;
	u64 hpet_config;
	u64 res1;
	u64 hpet_isr;
	u64 res2[25];
	union {
		u64 _hpet_mc64;
		u32 _hpet_mc32;
		long unsigned int _hpet_mc;
	} _u0;
	u64 res3;
	struct hpet_timer hpet_timers[1];
};

struct hpets;

struct hpet_dev {
	struct hpets *hd_hpets;
	struct hpet *hd_hpet;
	struct hpet_timer *hd_timer;
	long unsigned int hd_ireqfreq;
	long unsigned int hd_irqdata;
	wait_queue_head_t hd_waitqueue;
	struct fasync_struct *hd_async_queue;
	unsigned int hd_flags;
	unsigned int hd_irq;
	unsigned int hd_hdwirq;
	char hd_name[7];
};

struct hpets {
	struct hpets *hp_next;
	struct hpet *hp_hpet;
	long unsigned int hp_hpet_phys;
	struct clocksource *hp_clocksource;
	long long unsigned int hp_tick_freq;
	long unsigned int hp_delta;
	unsigned int hp_ntimer;
	unsigned int hp_which;
	struct hpet_dev hp_dev[1];
};

struct compat_hpet_info {
	compat_ulong_t hi_ireqfreq;
	compat_ulong_t hi_flags;
	short unsigned int hi_hpet;
	short unsigned int hi_timer;
};

struct nvram_ops {
	ssize_t (*get_size)();
	unsigned char (*read_byte)(int);
	void (*write_byte)(unsigned char, int);
	ssize_t (*read)(char *, size_t, loff_t *);
	ssize_t (*write)(char *, size_t, loff_t *);
	long int (*initialize)();
	long int (*set_checksum)();
};

struct hwrng {
	const char *name;
	int (*init)(struct hwrng *);
	void (*cleanup)(struct hwrng *);
	int (*data_present)(struct hwrng *, int);
	int (*data_read)(struct hwrng *, u32 *);
	int (*read)(struct hwrng *, void *, size_t, bool);
	long unsigned int priv;
	short unsigned int quality;
	struct list_head list;
	struct kref ref;
	struct completion cleanup_done;
};

struct agp_bridge_data;

struct agp_memory {
	struct agp_memory *next;
	struct agp_memory *prev;
	struct agp_bridge_data *bridge;
	struct page **pages;
	size_t page_count;
	int key;
	int num_scratch_pages;
	off_t pg_start;
	u32 type;
	u32 physical;
	bool is_bound;
	bool is_flushed;
	struct list_head mapped_list;
	struct scatterlist *sg_list;
	int num_sg;
};

struct agp_bridge_driver;

struct agp_bridge_data {
	const struct agp_version *version;
	const struct agp_bridge_driver *driver;
	const struct vm_operations_struct *vm_ops;
	void *previous_size;
	void *current_size;
	void *dev_private_data;
	struct pci_dev *dev;
	u32 *gatt_table;
	u32 *gatt_table_real;
	long unsigned int scratch_page;
	struct page *scratch_page_page;
	dma_addr_t scratch_page_dma;
	long unsigned int gart_bus_addr;
	long unsigned int gatt_bus_addr;
	u32 mode;
	enum chipset_type type;
	long unsigned int *key_list;
	atomic_t current_memory_agp;
	atomic_t agp_in_use;
	int max_memory_agp;
	int aperture_size_idx;
	int capndx;
	int flags;
	char major_version;
	char minor_version;
	struct list_head list;
	u32 apbase_config;
	struct list_head mapped_list;
	spinlock_t mapped_lock;
};

enum aper_size_type {
	U8_APER_SIZE = 0,
	U16_APER_SIZE = 1,
	U32_APER_SIZE = 2,
	LVL2_APER_SIZE = 3,
	FIXED_APER_SIZE = 4,
};

struct gatt_mask {
	long unsigned int mask;
	u32 type;
};

struct agp_bridge_driver {
	struct module *owner;
	const void *aperture_sizes;
	int num_aperture_sizes;
	enum aper_size_type size_type;
	bool cant_use_aperture;
	bool needs_scratch_page;
	const struct gatt_mask *masks;
	int (*fetch_size)();
	int (*configure)();
	void (*agp_enable)(struct agp_bridge_data *, u32);
	void (*cleanup)();
	void (*tlb_flush)(struct agp_memory *);
	long unsigned int (*mask_memory)(struct agp_bridge_data *, dma_addr_t, int);
	void (*cache_flush)();
	int (*create_gatt_table)(struct agp_bridge_data *);
	int (*free_gatt_table)(struct agp_bridge_data *);
	int (*insert_memory)(struct agp_memory *, off_t, int);
	int (*remove_memory)(struct agp_memory *, off_t, int);
	struct agp_memory * (*alloc_by_type)(size_t, int);
	void (*free_by_type)(struct agp_memory *);
	struct page * (*agp_alloc_page)(struct agp_bridge_data *);
	int (*agp_alloc_pages)(struct agp_bridge_data *, struct agp_memory *, size_t);
	void (*agp_destroy_page)(struct page *, int);
	void (*agp_destroy_pages)(struct agp_memory *);
	int (*agp_type_to_mask_type)(struct agp_bridge_data *, int);
};

struct agp_info {
	struct agp_version version;
	u32 bridge_id;
	u32 agp_mode;
	long unsigned int aper_base;
	size_t aper_size;
	size_t pg_total;
	size_t pg_system;
	size_t pg_used;
};

struct agp_setup {
	u32 agp_mode;
};

struct agp_segment {
	off_t pg_start;
	size_t pg_count;
	int prot;
};

struct agp_segment_priv {
	off_t pg_start;
	size_t pg_count;
	pgprot_t prot;
};

struct agp_region {
	pid_t pid;
	size_t seg_count;
	struct agp_segment *seg_list;
};

struct agp_allocate {
	int key;
	size_t pg_count;
	u32 type;
	u32 physical;
};

struct agp_bind {
	int key;
	off_t pg_start;
};

struct agp_unbind {
	int key;
	u32 priority;
};

struct agp_client {
	struct agp_client *next;
	struct agp_client *prev;
	pid_t pid;
	int num_segments;
	struct agp_segment_priv **segments;
};

struct agp_controller {
	struct agp_controller *next;
	struct agp_controller *prev;
	pid_t pid;
	int num_clients;
	struct agp_memory *pool;
	struct agp_client *clients;
};

struct agp_file_private {
	struct agp_file_private *next;
	struct agp_file_private *prev;
	pid_t my_pid;
	long unsigned int access_flags;
};

struct agp_front_data {
	struct mutex agp_mutex;
	struct agp_controller *current_controller;
	struct agp_controller *controllers;
	struct agp_file_private *file_priv_list;
	bool used_by_controller;
	bool backend_acquired;
};

struct aper_size_info_8 {
	int size;
	int num_entries;
	int page_order;
	u8 size_value;
};

struct aper_size_info_16 {
	int size;
	int num_entries;
	int page_order;
	u16 size_value;
};

struct aper_size_info_32 {
	int size;
	int num_entries;
	int page_order;
	u32 size_value;
};

struct aper_size_info_lvl2 {
	int size;
	int num_entries;
	u32 size_value;
};

struct aper_size_info_fixed {
	int size;
	int num_entries;
	int page_order;
};

struct agp_3_5_dev {
	struct list_head list;
	u8 capndx;
	u32 maxbw;
	struct pci_dev *dev;
};

struct isoch_data {
	u32 maxbw;
	u32 n;
	u32 y;
	u32 l;
	u32 rq;
	struct agp_3_5_dev *dev;
};

struct agp_info32 {
	struct agp_version version;
	u32 bridge_id;
	u32 agp_mode;
	compat_long_t aper_base;
	compat_size_t aper_size;
	compat_size_t pg_total;
	compat_size_t pg_system;
	compat_size_t pg_used;
};

struct agp_segment32 {
	compat_off_t pg_start;
	compat_size_t pg_count;
	compat_int_t prot;
};

struct agp_region32 {
	compat_pid_t pid;
	compat_size_t seg_count;
	struct agp_segment32 *seg_list;
};

struct agp_allocate32 {
	compat_int_t key;
	compat_size_t pg_count;
	u32 type;
	u32 physical;
};

struct agp_bind32 {
	compat_int_t key;
	compat_off_t pg_start;
};

struct agp_unbind32 {
	compat_int_t key;
	u32 priority;
};

struct intel_agp_driver_description {
	unsigned int chip_id;
	char *name;
	const struct agp_bridge_driver *driver;
};

struct intel_gtt_driver {
	unsigned int gen: 8;
	unsigned int is_g33: 1;
	unsigned int is_pineview: 1;
	unsigned int is_ironlake: 1;
	unsigned int has_pgtbl_enable: 1;
	unsigned int dma_mask_size: 8;
	int (*setup)();
	void (*cleanup)();
	void (*write_entry)(dma_addr_t, unsigned int, unsigned int);
	bool (*check_flags)(unsigned int);
	void (*chipset_flush)();
};

struct _intel_private {
	const struct intel_gtt_driver *driver;
	struct pci_dev *pcidev;
	struct pci_dev *bridge_dev;
	u8 *registers;
	phys_addr_t gtt_phys_addr;
	u32 PGETBL_save;
	u32 *gtt;
	bool clear_fake_agp;
	int num_dcache_entries;
	void *i9xx_flush_page;
	char *i81x_gtt_table;
	struct resource ifp_resource;
	int resource_valid;
	struct page *scratch_page;
	phys_addr_t scratch_page_dma;
	int refcount;
	unsigned int needs_dmar: 1;
	phys_addr_t gma_bus_addr;
	resource_size_t stolen_size;
	unsigned int gtt_total_entries;
	unsigned int gtt_mappable_entries;
};

struct intel_gtt_driver_description {
	unsigned int gmch_chip_id;
	char *name;
	const struct intel_gtt_driver *gtt_driver;
};

struct tpm_bank_info {
	u16 alg_id;
	u16 digest_size;
	u16 crypto_id;
};

struct tpm_chip;

struct tpm_class_ops {
	unsigned int flags;
	const u8 req_complete_mask;
	const u8 req_complete_val;
	bool (*req_canceled)(struct tpm_chip *, u8);
	int (*recv)(struct tpm_chip *, u8 *, size_t);
	int (*send)(struct tpm_chip *, u8 *, size_t);
	void (*cancel)(struct tpm_chip *);
	u8 (*status)(struct tpm_chip *);
	void (*update_timeouts)(struct tpm_chip *, long unsigned int *);
	int (*go_idle)(struct tpm_chip *);
	int (*cmd_ready)(struct tpm_chip *);
	int (*request_locality)(struct tpm_chip *, int);
	int (*relinquish_locality)(struct tpm_chip *, int);
	void (*clk_enable)(struct tpm_chip *, bool);
};

struct tpm_bios_log {
	void *bios_event_log;
	void *bios_event_log_end;
};

struct tpm_chip_seqops {
	struct tpm_chip *chip;
	const struct seq_operations *seqops;
};

struct tpm_space {
	u32 context_tbl[3];
	u8 *context_buf;
	u32 session_tbl[3];
	u8 *session_buf;
	u32 buf_size;
};

struct tpm_chip {
	struct device dev;
	struct device devs;
	struct cdev cdev;
	struct cdev cdevs;
	struct rw_semaphore ops_sem;
	const struct tpm_class_ops *ops;
	struct tpm_bios_log log;
	struct tpm_chip_seqops bin_log_seqops;
	struct tpm_chip_seqops ascii_log_seqops;
	unsigned int flags;
	int dev_num;
	long unsigned int is_open;
	char hwrng_name[64];
	struct hwrng hwrng;
	struct mutex tpm_mutex;
	long unsigned int timeout_a;
	long unsigned int timeout_b;
	long unsigned int timeout_c;
	long unsigned int timeout_d;
	bool timeout_adjusted;
	long unsigned int duration[4];
	bool duration_adjusted;
	struct dentry *bios_dir[3];
	const struct attribute_group *groups[3];
	unsigned int groups_cnt;
	u32 nr_allocated_banks;
	struct tpm_bank_info *allocated_banks;
	acpi_handle acpi_dev_handle;
	char ppi_version[4];
	struct tpm_space work_space;
	u32 last_cc;
	u32 nr_commands;
	u32 *cc_attrs_tbl;
	int locality;
};

enum tpm2_startup_types {
	TPM2_SU_CLEAR = 0,
	TPM2_SU_STATE = 1,
};

enum tpm_chip_flags {
	TPM_CHIP_FLAG_TPM2 = 2,
	TPM_CHIP_FLAG_IRQ = 4,
	TPM_CHIP_FLAG_VIRTUAL = 8,
	TPM_CHIP_FLAG_HAVE_TIMEOUTS = 16,
	TPM_CHIP_FLAG_ALWAYS_POWERED = 32,
};

enum tpm2_structures {
	TPM2_ST_NO_SESSIONS = 32769,
	TPM2_ST_SESSIONS = 32770,
};

enum tpm2_return_codes {
	TPM2_RC_SUCCESS = 0,
	TPM2_RC_HASH = 131,
	TPM2_RC_HANDLE = 139,
	TPM2_RC_INITIALIZE = 256,
	TPM2_RC_FAILURE = 257,
	TPM2_RC_DISABLED = 288,
	TPM2_RC_COMMAND_CODE = 323,
	TPM2_RC_TESTING = 2314,
	TPM2_RC_REFERENCE_H0 = 2320,
	TPM2_RC_RETRY = 2338,
};

struct tpm_header {
	__be16 tag;
	__be32 length;
	union {
		__be32 ordinal;
		__be32 return_code;
	};
} __attribute__((packed));

struct file_priv {
	struct tpm_chip *chip;
	struct tpm_space *space;
	struct mutex buffer_mutex;
	struct timer_list user_read_timer;
	struct work_struct timeout_work;
	struct work_struct async_work;
	wait_queue_head_t async_wait;
	ssize_t response_length;
	bool response_read;
	bool command_enqueued;
	u8 data_buffer[4096];
};

struct tpm_digest {
	u16 alg_id;
	u8 digest[64];
};

enum TPM_OPS_FLAGS {
	TPM_OPS_AUTO_STARTUP = 1,
};

enum tpm_timeout {
	TPM_TIMEOUT = 5,
	TPM_TIMEOUT_RETRY = 100,
	TPM_TIMEOUT_RANGE_US = 300,
	TPM_TIMEOUT_POLL = 1,
	TPM_TIMEOUT_USECS_MIN = 100,
	TPM_TIMEOUT_USECS_MAX = 500,
};

enum tpm2_timeouts {
	TPM2_TIMEOUT_A = 750,
	TPM2_TIMEOUT_B = 2000,
	TPM2_TIMEOUT_C = 200,
	TPM2_TIMEOUT_D = 30,
	TPM2_DURATION_SHORT = 20,
	TPM2_DURATION_MEDIUM = 750,
	TPM2_DURATION_LONG = 2000,
	TPM2_DURATION_LONG_LONG = 300000,
	TPM2_DURATION_DEFAULT = 120000,
};

enum tpm2_command_codes {
	TPM2_CC_FIRST = 287,
	TPM2_CC_HIERARCHY_CONTROL = 289,
	TPM2_CC_HIERARCHY_CHANGE_AUTH = 297,
	TPM2_CC_CREATE_PRIMARY = 305,
	TPM2_CC_SEQUENCE_COMPLETE = 318,
	TPM2_CC_SELF_TEST = 323,
	TPM2_CC_STARTUP = 324,
	TPM2_CC_SHUTDOWN = 325,
	TPM2_CC_NV_READ = 334,
	TPM2_CC_CREATE = 339,
	TPM2_CC_LOAD = 343,
	TPM2_CC_SEQUENCE_UPDATE = 348,
	TPM2_CC_UNSEAL = 350,
	TPM2_CC_CONTEXT_LOAD = 353,
	TPM2_CC_CONTEXT_SAVE = 354,
	TPM2_CC_FLUSH_CONTEXT = 357,
	TPM2_CC_VERIFY_SIGNATURE = 375,
	TPM2_CC_GET_CAPABILITY = 378,
	TPM2_CC_GET_RANDOM = 379,
	TPM2_CC_PCR_READ = 382,
	TPM2_CC_PCR_EXTEND = 386,
	TPM2_CC_EVENT_SEQUENCE_COMPLETE = 389,
	TPM2_CC_HASH_SEQUENCE_START = 390,
	TPM2_CC_CREATE_LOADED = 401,
	TPM2_CC_LAST = 403,
};

struct tpm_buf {
	struct page *data_page;
	unsigned int flags;
	u8 *data;
};

struct trusted_key_payload;

struct trusted_key_options;

enum tpm_algorithms {
	TPM_ALG_ERROR = 0,
	TPM_ALG_SHA1 = 4,
	TPM_ALG_KEYEDHASH = 8,
	TPM_ALG_SHA256 = 11,
	TPM_ALG_SHA384 = 12,
	TPM_ALG_SHA512 = 13,
	TPM_ALG_NULL = 16,
	TPM_ALG_SM3_256 = 18,
};

struct stclear_flags_t {
	__be16 tag;
	u8 deactivated;
	u8 disableForceClear;
	u8 physicalPresence;
	u8 physicalPresenceLock;
	u8 bGlobalLock;
} __attribute__((packed));

struct tpm_version_t {
	u8 Major;
	u8 Minor;
	u8 revMajor;
	u8 revMinor;
};

struct tpm_version_1_2_t {
	__be16 tag;
	u8 Major;
	u8 Minor;
	u8 revMajor;
	u8 revMinor;
};

struct timeout_t {
	__be32 a;
	__be32 b;
	__be32 c;
	__be32 d;
};

struct duration_t {
	__be32 tpm_short;
	__be32 tpm_medium;
	__be32 tpm_long;
};

struct permanent_flags_t {
	__be16 tag;
	u8 disable;
	u8 ownership;
	u8 deactivated;
	u8 readPubek;
	u8 disableOwnerClear;
	u8 allowMaintenance;
	u8 physicalPresenceLifetimeLock;
	u8 physicalPresenceHWEnable;
	u8 physicalPresenceCMDEnable;
	u8 CEKPUsed;
	u8 TPMpost;
	u8 TPMpostLock;
	u8 FIPS;
	u8 operator;
	u8 enableRevokeEK;
	u8 nvLocked;
	u8 readSRKPub;
	u8 tpmEstablished;
	u8 maintenanceDone;
	u8 disableFullDALogicInfo;
};

typedef union {
	struct permanent_flags_t perm_flags;
	struct stclear_flags_t stclear_flags;
	__u8 owned;
	__be32 num_pcrs;
	struct tpm_version_t tpm_version;
	struct tpm_version_1_2_t tpm_version_1_2;
	__be32 manufacturer_id;
	struct timeout_t timeout;
	struct duration_t duration;
} cap_t;

enum tpm_capabilities {
	TPM_CAP_FLAG = 4,
	TPM_CAP_PROP = 5,
	TPM_CAP_VERSION_1_1 = 6,
	TPM_CAP_VERSION_1_2 = 26,
};

enum tpm_sub_capabilities {
	TPM_CAP_PROP_PCR = 257,
	TPM_CAP_PROP_MANUFACTURER = 259,
	TPM_CAP_FLAG_PERM = 264,
	TPM_CAP_FLAG_VOL = 265,
	TPM_CAP_PROP_OWNER = 273,
	TPM_CAP_PROP_TIS_TIMEOUT = 277,
	TPM_CAP_PROP_TIS_DURATION = 288,
};

enum tpm_buf_flags {
	TPM_BUF_OVERFLOW = 1,
};

struct tpm1_get_random_out {
	__be32 rng_data_len;
	u8 rng_data[128];
};

enum tpm2_const {
	TPM2_PLATFORM_PCR = 24,
	TPM2_PCR_SELECT_MIN = 3,
};

enum tpm2_permanent_handles {
	TPM2_RS_PW = 1073741833,
};

enum tpm2_capabilities {
	TPM2_CAP_HANDLES = 1,
	TPM2_CAP_COMMANDS = 2,
	TPM2_CAP_PCRS = 5,
	TPM2_CAP_TPM_PROPERTIES = 6,
};

enum tpm2_properties {
	TPM_PT_TOTAL_COMMANDS = 297,
};

enum tpm2_cc_attrs {
	TPM2_CC_ATTR_CHANDLES = 25,
	TPM2_CC_ATTR_RHANDLE = 28,
};

struct trusted_key_payload {
	struct callback_head rcu;
	unsigned int key_len;
	unsigned int blob_len;
	unsigned char migratable;
	unsigned char key[129];
	unsigned char blob[512];
};

struct trusted_key_options {
	uint16_t keytype;
	uint32_t keyhandle;
	unsigned char keyauth[20];
	unsigned char blobauth[20];
	uint32_t pcrinfo_len;
	unsigned char pcrinfo[64];
	int pcrlock;
	uint32_t hash;
	uint32_t policydigest_len;
	unsigned char policydigest[64];
	uint32_t policyhandle;
};

enum tpm2_object_attributes {
	TPM2_OA_USER_WITH_AUTH = 64,
};

enum tpm2_session_attributes {
	TPM2_SA_CONTINUE_SESSION = 1,
};

struct tpm2_hash {
	unsigned int crypto_id;
	unsigned int tpm_id;
};

struct tpm2_pcr_read_out {
	__be32 update_cnt;
	__be32 pcr_selects_cnt;
	__be16 hash_alg;
	u8 pcr_select_size;
	u8 pcr_select[3];
	__be32 digests_cnt;
	__be16 digest_size;
	u8 digest[0];
} __attribute__((packed));

struct tpm2_null_auth_area {
	__be32 handle;
	__be16 nonce_size;
	u8 attributes;
	__be16 auth_size;
} __attribute__((packed));

struct tpm2_get_random_out {
	__be16 size;
	u8 buffer[128];
};

struct tpm2_get_cap_out {
	u8 more_data;
	__be32 subcap_id;
	__be32 property_cnt;
	__be32 property_id;
	__be32 value;
} __attribute__((packed));

struct tpm2_pcr_selection {
	__be16 hash_alg;
	u8 size_of_select;
	u8 pcr_select[3];
};

struct tpmrm_priv {
	struct file_priv priv;
	struct tpm_space space;
};

enum tpm2_handle_types {
	TPM2_HT_HMAC_SESSION = 33554432,
	TPM2_HT_POLICY_SESSION = 50331648,
	TPM2_HT_TRANSIENT = 2147483648,
};

struct tpm2_context {
	__be64 sequence;
	__be32 saved_handle;
	__be32 hierarchy;
	__be16 blob_size;
} __attribute__((packed));

struct tpm2_cap_handles {
	u8 more_data;
	__be32 capability;
	__be32 count;
	__be32 handles[0];
} __attribute__((packed));

struct tpm_readpubek_out {
	u8 algorithm[4];
	u8 encscheme[2];
	u8 sigscheme[2];
	__be32 paramsize;
	u8 parameters[12];
	__be32 keysize;
	u8 modulus[256];
	u8 checksum[20];
};

struct tcpa_event {
	u32 pcr_index;
	u32 event_type;
	u8 pcr_value[20];
	u32 event_size;
	u8 event_data[0];
};

enum tcpa_event_types {
	PREBOOT = 0,
	POST_CODE = 1,
	UNUSED = 2,
	NO_ACTION = 3,
	SEPARATOR = 4,
	ACTION = 5,
	EVENT_TAG = 6,
	SCRTM_CONTENTS = 7,
	SCRTM_VERSION = 8,
	CPU_MICROCODE = 9,
	PLATFORM_CONFIG_FLAGS = 10,
	TABLE_OF_DEVICES = 11,
	COMPACT_HASH = 12,
	IPL = 13,
	IPL_PARTITION_DATA = 14,
	NONHOST_CODE = 15,
	NONHOST_CONFIG = 16,
	NONHOST_INFO = 17,
};

struct tcpa_pc_event {
	u32 event_id;
	u32 event_size;
	u8 event_data[0];
};

enum tcpa_pc_event_ids {
	SMBIOS = 1,
	BIS_CERT = 2,
	POST_BIOS_ROM = 3,
	ESCD = 4,
	CMOS = 5,
	NVRAM = 6,
	OPTION_ROM_EXEC = 7,
	OPTION_ROM_CONFIG = 8,
	OPTION_ROM_MICROCODE = 10,
	S_CRTM_VERSION = 11,
	S_CRTM_CONTENTS = 12,
	POST_CONTENTS = 13,
	HOST_TABLE_OF_DEVICES = 14,
};

struct tcg_efi_specid_event_algs {
	u16 alg_id;
	u16 digest_size;
};

struct tcg_efi_specid_event_head {
	u8 signature[16];
	u32 platform_class;
	u8 spec_version_minor;
	u8 spec_version_major;
	u8 spec_errata;
	u8 uintnsize;
	u32 num_algs;
	struct tcg_efi_specid_event_algs digest_sizes[0];
};

struct tcg_pcr_event {
	u32 pcr_idx;
	u32 event_type;
	u8 digest[20];
	u32 event_size;
	u8 event[0];
};

struct tcg_event_field {
	u32 event_size;
	u8 event[0];
};

struct tcg_pcr_event2_head {
	u32 pcr_idx;
	u32 event_type;
	u32 count;
	struct tpm_digest digests[0];
};

enum bios_platform_class {
	BIOS_CLIENT = 0,
	BIOS_SERVER = 1,
};

struct client_hdr {
	u32 log_max_len;
	u64 log_start_addr;
} __attribute__((packed));

struct server_hdr {
	u16 reserved;
	u64 log_max_len;
	u64 log_start_addr;
} __attribute__((packed));

struct acpi_tcpa {
	struct acpi_table_header hdr;
	u16 platform_class;
	union {
		struct client_hdr client;
		struct server_hdr server;
	};
} __attribute__((packed));

struct linux_efi_tpm_eventlog {
	u32 size;
	u32 final_events_preboot_size;
	u8 version;
	u8 log[0];
};

struct efi_tcg2_final_events_table {
	u64 version;
	u64 nr_events;
	u8 events[0];
};

enum tis_access {
	TPM_ACCESS_VALID = 128,
	TPM_ACCESS_ACTIVE_LOCALITY = 32,
	TPM_ACCESS_REQUEST_PENDING = 4,
	TPM_ACCESS_REQUEST_USE = 2,
};

enum tis_status {
	TPM_STS_VALID = 128,
	TPM_STS_COMMAND_READY = 64,
	TPM_STS_GO = 32,
	TPM_STS_DATA_AVAIL = 16,
	TPM_STS_DATA_EXPECT = 8,
};

enum tis_int_flags {
	TPM_GLOBAL_INT_ENABLE = 2147483648,
	TPM_INTF_BURST_COUNT_STATIC = 256,
	TPM_INTF_CMD_READY_INT = 128,
	TPM_INTF_INT_EDGE_FALLING = 64,
	TPM_INTF_INT_EDGE_RISING = 32,
	TPM_INTF_INT_LEVEL_LOW = 16,
	TPM_INTF_INT_LEVEL_HIGH = 8,
	TPM_INTF_LOCALITY_CHANGE_INT = 4,
	TPM_INTF_STS_VALID_INT = 2,
	TPM_INTF_DATA_AVAIL_INT = 1,
};

enum tis_defaults {
	TIS_MEM_LEN = 20480,
	TIS_SHORT_TIMEOUT = 750,
	TIS_LONG_TIMEOUT = 2000,
};

enum tpm_tis_flags {
	TPM_TIS_ITPM_WORKAROUND = 1,
};

struct tpm_tis_phy_ops;

struct tpm_tis_data {
	u16 manufacturer_id;
	int locality;
	int irq;
	bool irq_tested;
	unsigned int flags;
	void *ilb_base_addr;
	u16 clkrun_enabled;
	wait_queue_head_t int_queue;
	wait_queue_head_t read_queue;
	const struct tpm_tis_phy_ops *phy_ops;
	short unsigned int rng_quality;
};

struct tpm_tis_phy_ops {
	int (*read_bytes)(struct tpm_tis_data *, u32, u16, u8 *);
	int (*write_bytes)(struct tpm_tis_data *, u32, u16, const u8 *);
	int (*read16)(struct tpm_tis_data *, u32, u16 *);
	int (*read32)(struct tpm_tis_data *, u32, u32 *);
	int (*write32)(struct tpm_tis_data *, u32, u32);
};

struct tis_vendor_timeout_override {
	u32 did_vid;
	long unsigned int timeout_us[4];
};

struct acpi_table_tpm2 {
	struct acpi_table_header header;
	u16 platform_class;
	u16 reserved;
	u64 control_address;
	u32 start_method;
} __attribute__((packed));

struct tpm_info {
	struct resource res;
	int irq;
};

struct tpm_tis_tcg_phy {
	struct tpm_tis_data priv;
	void *iobase;
};

struct iommu_group {
	struct kobject kobj;
	struct kobject *devices_kobj;
	struct list_head devices;
	struct mutex mutex;
	struct blocking_notifier_head notifier;
	void *iommu_data;
	void (*iommu_data_release)(void *);
	char *name;
	int id;
	struct iommu_domain *default_domain;
	struct iommu_domain *domain;
};

enum iommu_fault_type {
	IOMMU_FAULT_DMA_UNRECOV = 1,
	IOMMU_FAULT_PAGE_REQ = 2,
};

struct iommu_device {
	struct list_head list;
	const struct iommu_ops *ops;
	struct fwnode_handle *fwnode;
	struct device *dev;
};

struct fsl_mc_obj_desc {
	char type[16];
	int id;
	u16 vendor;
	u16 ver_major;
	u16 ver_minor;
	u8 irq_count;
	u8 region_count;
	u32 state;
	char label[16];
	u16 flags;
};

struct fsl_mc_io;

struct fsl_mc_device_irq;

struct fsl_mc_resource;

struct fsl_mc_device {
	struct device dev;
	u64 dma_mask;
	u16 flags;
	u16 icid;
	u16 mc_handle;
	struct fsl_mc_io *mc_io;
	struct fsl_mc_obj_desc obj_desc;
	struct resource *regions;
	struct fsl_mc_device_irq **irqs;
	struct fsl_mc_resource *resource;
	struct device_link *consumer_link;
};

enum fsl_mc_pool_type {
	FSL_MC_POOL_DPMCP = 0,
	FSL_MC_POOL_DPBP = 1,
	FSL_MC_POOL_DPCON = 2,
	FSL_MC_POOL_IRQ = 3,
	FSL_MC_NUM_POOL_TYPES = 4,
};

struct fsl_mc_resource_pool;

struct fsl_mc_resource {
	enum fsl_mc_pool_type type;
	s32 id;
	void *data;
	struct fsl_mc_resource_pool *parent_pool;
	struct list_head node;
};

struct fsl_mc_device_irq {
	struct msi_desc *msi_desc;
	struct fsl_mc_device *mc_dev;
	u8 dev_irq_index;
	struct fsl_mc_resource resource;
};

struct fsl_mc_io {
	struct device *dev;
	u16 flags;
	u32 portal_size;
	phys_addr_t portal_phys_addr;
	void *portal_virt_addr;
	struct fsl_mc_device *dpmcp_dev;
	union {
		struct mutex mutex;
		spinlock_t spinlock;
	};
};

struct group_device {
	struct list_head list;
	struct device *dev;
	char *name;
};

struct iommu_group_attribute {
	struct attribute attr;
	ssize_t (*show)(struct iommu_group *, char *);
	ssize_t (*store)(struct iommu_group *, const char *, size_t);
};

struct group_for_pci_data {
	struct pci_dev *pdev;
	struct iommu_group *group;
};

struct trace_event_raw_iommu_group_event {
	struct trace_entry ent;
	int gid;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_iommu_device_event {
	struct trace_entry ent;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_map {
	struct trace_entry ent;
	u64 iova;
	u64 paddr;
	size_t size;
	char __data[0];
};

struct trace_event_raw_unmap {
	struct trace_entry ent;
	u64 iova;
	size_t size;
	size_t unmapped_size;
	char __data[0];
};

struct trace_event_raw_iommu_error {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u64 iova;
	int flags;
	char __data[0];
};

struct trace_event_data_offsets_iommu_group_event {
	u32 device;
};

struct trace_event_data_offsets_iommu_device_event {
	u32 device;
};

struct trace_event_data_offsets_map {};

struct trace_event_data_offsets_unmap {};

struct trace_event_data_offsets_iommu_error {
	u32 device;
	u32 driver;
};

typedef void (*btf_trace_add_device_to_group)(void *, int, struct device *);

typedef void (*btf_trace_remove_device_from_group)(void *, int, struct device *);

typedef void (*btf_trace_attach_device_to_domain)(void *, struct device *);

typedef void (*btf_trace_detach_device_from_domain)(void *, struct device *);

typedef void (*btf_trace_map)(void *, long unsigned int, phys_addr_t, size_t);

typedef void (*btf_trace_unmap)(void *, long unsigned int, size_t, size_t);

typedef void (*btf_trace_io_page_fault)(void *, struct device *, long unsigned int, int);

struct iova {
	struct rb_node node;
	long unsigned int pfn_hi;
	long unsigned int pfn_lo;
};

struct iova_magazine;

struct iova_cpu_rcache;

struct iova_rcache {
	spinlock_t lock;
	long unsigned int depot_size;
	struct iova_magazine *depot[32];
	struct iova_cpu_rcache *cpu_rcaches;
};

struct iova_magazine {
	long unsigned int size;
	long unsigned int pfns[128];
};

struct iova_cpu_rcache {
	spinlock_t lock;
	struct iova_magazine *loaded;
	struct iova_magazine *prev;
};

struct iova_domain;

typedef void (*iova_flush_cb)(struct iova_domain *);

typedef void (*iova_entry_dtor)(long unsigned int);

struct iova_fq;

struct iova_domain {
	spinlock_t iova_rbtree_lock;
	struct rb_root rbroot;
	struct rb_node *cached_node;
	struct rb_node *cached32_node;
	long unsigned int granule;
	long unsigned int start_pfn;
	long unsigned int dma_32bit_pfn;
	long unsigned int max32_alloc_size;
	struct iova_fq *fq;
	atomic64_t fq_flush_start_cnt;
	atomic64_t fq_flush_finish_cnt;
	struct iova anchor;
	struct iova_rcache rcaches[6];
	iova_flush_cb flush_cb;
	iova_entry_dtor entry_dtor;
	struct timer_list fq_timer;
	atomic_t fq_timer_on;
};

struct iova_fq_entry {
	long unsigned int iova_pfn;
	long unsigned int pages;
	long unsigned int data;
	u64 counter;
};

struct iova_fq {
	struct iova_fq_entry entries[256];
	unsigned int head;
	unsigned int tail;
	spinlock_t lock;
};

struct vcpu_data;

struct amd_iommu_pi_data {
	u32 ga_tag;
	u32 prev_ga_tag;
	u64 base;
	bool is_guest_mode;
	struct vcpu_data *vcpu_data;
	void *ir_data;
};

struct vcpu_data {
	u64 pi_desc_addr;
	u32 vector;
};

struct amd_iommu_device_info {
	int max_pasids;
	u32 flags;
};

struct irq_remap_table {
	raw_spinlock_t lock;
	unsigned int min_index;
	u32 *table;
};

struct amd_iommu_fault {
	u64 address;
	u32 pasid;
	u16 device_id;
	u16 tag;
	u16 flags;
};

struct protection_domain {
	struct list_head list;
	struct list_head dev_list;
	struct iommu_domain domain;
	spinlock_t lock;
	struct mutex api_lock;
	u16 id;
	int mode;
	u64 *pt_root;
	int glx;
	u64 *gcr3_tbl;
	long unsigned int flags;
	unsigned int dev_cnt;
	unsigned int dev_iommu[32];
};

struct amd_irte_ops;

struct amd_iommu {
	struct list_head list;
	int index;
	raw_spinlock_t lock;
	struct pci_dev *dev;
	struct pci_dev *root_pdev;
	u64 mmio_phys;
	u64 mmio_phys_end;
	u8 *mmio_base;
	u32 cap;
	u8 acpi_flags;
	u64 features;
	bool is_iommu_v2;
	u16 devid;
	u16 cap_ptr;
	u16 pci_seg;
	u64 exclusion_start;
	u64 exclusion_length;
	u8 *cmd_buf;
	u32 cmd_buf_head;
	u32 cmd_buf_tail;
	u8 *evt_buf;
	u8 *ppr_log;
	u8 *ga_log;
	u8 *ga_log_tail;
	bool int_enabled;
	bool need_sync;
	struct iommu_device iommu;
	u32 stored_addr_lo;
	u32 stored_addr_hi;
	u32 stored_l1[108];
	u32 stored_l2[131];
	u8 max_banks;
	u8 max_counters;
	struct irq_domain *ir_domain;
	struct irq_domain *msi_domain;
	struct amd_irte_ops *irte_ops;
	u32 flags;
	volatile u64 cmd_sem;
	struct irq_affinity_notify intcapxt_notify;
};

struct amd_irte_ops {
	void (*prepare)(void *, u32, u32, u8, u32, int);
	void (*activate)(void *, u16, u16);
	void (*deactivate)(void *, u16, u16);
	void (*set_affinity)(void *, u16, u16, u8, u32);
	void * (*get)(struct irq_remap_table *, int);
	void (*set_allocated)(struct irq_remap_table *, int);
	bool (*is_allocated)(struct irq_remap_table *, int);
	void (*clear_allocated)(struct irq_remap_table *, int);
};

struct acpihid_map_entry {
	struct list_head list;
	u8 uid[256];
	u8 hid[9];
	u16 devid;
	u16 root_devid;
	bool cmd_line;
	struct iommu_group *group;
};

struct devid_map {
	struct list_head list;
	u8 id;
	u16 devid;
	bool cmd_line;
};

struct iommu_dev_data {
	spinlock_t lock;
	struct list_head list;
	struct llist_node dev_data_list;
	struct protection_domain *domain;
	struct pci_dev *pdev;
	u16 devid;
	bool iommu_v2;
	bool passthrough;
	struct {
		bool enabled;
		int qdep;
	} ats;
	bool pri_tlp;
	u32 errata;
	bool use_vapic;
	bool defer_attach;
	struct ratelimit_state rs;
};

struct dev_table_entry {
	u64 data[4];
};

struct unity_map_entry {
	struct list_head list;
	u16 devid_start;
	u16 devid_end;
	u64 address_start;
	u64 address_end;
	int prot;
};

enum amd_iommu_intr_mode_type {
	AMD_IOMMU_GUEST_IR_LEGACY = 0,
	AMD_IOMMU_GUEST_IR_LEGACY_GA = 1,
	AMD_IOMMU_GUEST_IR_VAPIC = 2,
};

union irte {
	u32 val;
	struct {
		u32 valid: 1;
		u32 no_fault: 1;
		u32 int_type: 3;
		u32 rq_eoi: 1;
		u32 dm: 1;
		u32 rsvd_1: 1;
		u32 destination: 8;
		u32 vector: 8;
		u32 rsvd_2: 8;
	} fields;
};

union irte_ga_lo {
	u64 val;
	struct {
		u64 valid: 1;
		u64 no_fault: 1;
		u64 int_type: 3;
		u64 rq_eoi: 1;
		u64 dm: 1;
		u64 guest_mode: 1;
		u64 destination: 24;
		u64 ga_tag: 32;
	} fields_remap;
	struct {
		u64 valid: 1;
		u64 no_fault: 1;
		u64 ga_log_intr: 1;
		u64 rsvd1: 3;
		u64 is_run: 1;
		u64 guest_mode: 1;
		u64 destination: 24;
		u64 ga_tag: 32;
	} fields_vapic;
};

union irte_ga_hi {
	u64 val;
	struct {
		u64 vector: 8;
		u64 rsvd_1: 4;
		u64 ga_root_ptr: 40;
		u64 rsvd_2: 4;
		u64 destination: 8;
	} fields;
};

struct irte_ga {
	union irte_ga_lo lo;
	union irte_ga_hi hi;
};

struct irq_2_irte {
	u16 devid;
	u16 index;
};

struct amd_ir_data {
	u32 cached_ga_tag;
	struct irq_2_irte irq_2_irte;
	struct msi_msg msi_entry;
	void *entry;
	void *ref;
	struct irq_cfg *cfg;
	int ga_vector;
	int ga_root_ptr;
	int ga_tag;
};

struct irq_remap_ops {
	int capability;
	int (*prepare)();
	int (*enable)();
	void (*disable)();
	int (*reenable)(int);
	int (*enable_faulting)();
	struct irq_domain * (*get_ir_irq_domain)(struct irq_alloc_info *);
	struct irq_domain * (*get_irq_domain)(struct irq_alloc_info *);
};

struct iommu_cmd {
	u32 data[4];
};

struct dma_ops_domain {
	struct protection_domain domain;
	struct iova_domain iovad;
};

enum irq_remap_cap {
	IRQ_POSTING_CAP = 0,
};

struct ivhd_header {
	u8 type;
	u8 flags;
	u16 length;
	u16 devid;
	u16 cap_ptr;
	u64 mmio_phys;
	u16 pci_seg;
	u16 info;
	u32 efr_attr;
	u64 efr_reg;
	u64 res;
};

struct ivhd_entry {
	u8 type;
	u16 devid;
	u8 flags;
	u32 ext;
	u32 hidh;
	u64 cid;
	u8 uidf;
	u8 uidl;
	u8 uid;
} __attribute__((packed));

struct ivmd_header {
	u8 type;
	u8 flags;
	u16 length;
	u16 devid;
	u16 aux;
	u64 resv;
	u64 range_start;
	u64 range_length;
};

enum iommu_init_state {
	IOMMU_START_STATE = 0,
	IOMMU_IVRS_DETECTED = 1,
	IOMMU_ACPI_FINISHED = 2,
	IOMMU_ENABLED = 3,
	IOMMU_PCI_INIT = 4,
	IOMMU_INTERRUPTS_EN = 5,
	IOMMU_DMA_OPS = 6,
	IOMMU_INITIALIZED = 7,
	IOMMU_NOT_FOUND = 8,
	IOMMU_INIT_ERROR = 9,
	IOMMU_CMDLINE_DISABLED = 10,
};

struct ivrs_quirk_entry {
	u8 id;
	u16 devid;
};

enum {
	DELL_INSPIRON_7375 = 0,
	DELL_LATITUDE_5495 = 1,
	LENOVO_IDEAPAD_330S_15ARR = 2,
};

struct acpi_table_dmar {
	struct acpi_table_header header;
	u8 width;
	u8 flags;
	u8 reserved[10];
};

struct acpi_dmar_header {
	u16 type;
	u16 length;
};

enum acpi_dmar_type {
	ACPI_DMAR_TYPE_HARDWARE_UNIT = 0,
	ACPI_DMAR_TYPE_RESERVED_MEMORY = 1,
	ACPI_DMAR_TYPE_ROOT_ATS = 2,
	ACPI_DMAR_TYPE_HARDWARE_AFFINITY = 3,
	ACPI_DMAR_TYPE_NAMESPACE = 4,
	ACPI_DMAR_TYPE_RESERVED = 5,
};

struct acpi_dmar_device_scope {
	u8 entry_type;
	u8 length;
	u16 reserved;
	u8 enumeration_id;
	u8 bus;
};

enum acpi_dmar_scope_type {
	ACPI_DMAR_SCOPE_TYPE_NOT_USED = 0,
	ACPI_DMAR_SCOPE_TYPE_ENDPOINT = 1,
	ACPI_DMAR_SCOPE_TYPE_BRIDGE = 2,
	ACPI_DMAR_SCOPE_TYPE_IOAPIC = 3,
	ACPI_DMAR_SCOPE_TYPE_HPET = 4,
	ACPI_DMAR_SCOPE_TYPE_NAMESPACE = 5,
	ACPI_DMAR_SCOPE_TYPE_RESERVED = 6,
};

struct acpi_dmar_pci_path {
	u8 device;
	u8 function;
};

struct acpi_dmar_hardware_unit {
	struct acpi_dmar_header header;
	u8 flags;
	u8 reserved;
	u16 segment;
	u64 address;
};

struct acpi_dmar_reserved_memory {
	struct acpi_dmar_header header;
	u16 reserved;
	u16 segment;
	u64 base_address;
	u64 end_address;
};

struct acpi_dmar_atsr {
	struct acpi_dmar_header header;
	u8 flags;
	u8 reserved;
	u16 segment;
};

struct acpi_dmar_rhsa {
	struct acpi_dmar_header header;
	u32 reserved;
	u64 base_address;
	u32 proximity_domain;
} __attribute__((packed));

struct acpi_dmar_andd {
	struct acpi_dmar_header header;
	u8 reserved[3];
	u8 device_number;
	char device_name[1];
} __attribute__((packed));

struct dmar_dev_scope {
	struct device *dev;
	u8 bus;
	u8 devfn;
};

struct intel_iommu;

struct dmar_drhd_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	u64 reg_base_addr;
	struct dmar_dev_scope *devices;
	int devices_cnt;
	u16 segment;
	u8 ignored: 1;
	u8 include_all: 1;
	struct intel_iommu *iommu;
};

struct iommu_flush {
	void (*flush_context)(struct intel_iommu *, u16, u16, u8, u64);
	void (*flush_iotlb)(struct intel_iommu *, u16, u64, unsigned int, u64);
};

struct dmar_domain;

struct root_entry;

struct page_req_dsc;

struct q_inval;

struct ir_table;

struct intel_iommu {
	void *reg;
	u64 reg_phys;
	u64 reg_size;
	u64 cap;
	u64 ecap;
	u32 gcmd;
	raw_spinlock_t register_lock;
	int seq_id;
	int agaw;
	int msagaw;
	unsigned int irq;
	unsigned int pr_irq;
	u16 segment;
	unsigned char name[13];
	long unsigned int *domain_ids;
	struct dmar_domain ***domains;
	spinlock_t lock;
	struct root_entry *root_entry;
	struct iommu_flush flush;
	struct page_req_dsc *prq;
	unsigned char prq_name[16];
	struct q_inval *qi;
	u32 *iommu_state;
	struct ir_table *ir_table;
	struct irq_domain *ir_domain;
	struct irq_domain *ir_msi_domain;
	struct iommu_device iommu;
	int node;
	u32 flags;
	struct dmar_drhd_unit *drhd;
};

struct dmar_pci_path {
	u8 bus;
	u8 device;
	u8 function;
};

struct dmar_pci_notify_info {
	struct pci_dev *dev;
	long unsigned int event;
	int bus;
	u16 seg;
	u16 level;
	struct dmar_pci_path path[0];
};

struct irte___2 {
	union {
		struct {
			__u64 present: 1;
			__u64 fpd: 1;
			__u64 __res0: 6;
			__u64 avail: 4;
			__u64 __res1: 3;
			__u64 pst: 1;
			__u64 vector: 8;
			__u64 __res2: 40;
		};
		struct {
			__u64 r_present: 1;
			__u64 r_fpd: 1;
			__u64 dst_mode: 1;
			__u64 redir_hint: 1;
			__u64 trigger_mode: 1;
			__u64 dlvry_mode: 3;
			__u64 r_avail: 4;
			__u64 r_res0: 4;
			__u64 r_vector: 8;
			__u64 r_res1: 8;
			__u64 dest_id: 32;
		};
		struct {
			__u64 p_present: 1;
			__u64 p_fpd: 1;
			__u64 p_res0: 6;
			__u64 p_avail: 4;
			__u64 p_res1: 2;
			__u64 p_urgent: 1;
			__u64 p_pst: 1;
			__u64 p_vector: 8;
			__u64 p_res2: 14;
			__u64 pda_l: 26;
		};
		__u64 low;
	};
	union {
		struct {
			__u64 sid: 16;
			__u64 sq: 2;
			__u64 svt: 2;
			__u64 __res3: 44;
		};
		struct {
			__u64 p_sid: 16;
			__u64 p_sq: 2;
			__u64 p_svt: 2;
			__u64 p_res3: 12;
			__u64 pda_h: 32;
		};
		__u64 high;
	};
};

enum {
	QI_FREE = 0,
	QI_IN_USE = 1,
	QI_DONE = 2,
	QI_ABORT = 3,
};

struct qi_desc {
	u64 qw0;
	u64 qw1;
	u64 qw2;
	u64 qw3;
};

struct q_inval {
	raw_spinlock_t q_lock;
	void *desc;
	int *desc_status;
	int free_head;
	int free_tail;
	int free_cnt;
};

struct ir_table {
	struct irte___2 *base;
	long unsigned int *bitmap;
};

struct root_entry {
	u64 lo;
	u64 hi;
};

struct dma_pte;

struct dmar_domain {
	int nid;
	unsigned int iommu_refcnt[128];
	u16 iommu_did[128];
	unsigned int auxd_refcnt;
	bool has_iotlb_device;
	struct list_head devices;
	struct list_head auxd;
	struct iova_domain iovad;
	struct dma_pte *pgd;
	int gaw;
	int agaw;
	int flags;
	int iommu_coherency;
	int iommu_snooping;
	int iommu_count;
	int iommu_superpage;
	u64 max_addr;
	int default_pasid;
	struct iommu_domain domain;
};

struct dma_pte {
	u64 val;
};

typedef int (*dmar_res_handler_t)(struct acpi_dmar_header *, void *);

struct dmar_res_callback {
	dmar_res_handler_t cb[5];
	void *arg[5];
	bool ignore_unhandled;
	bool print_entry;
};

enum faulttype {
	DMA_REMAP = 0,
	INTR_REMAP = 1,
	UNKNOWN = 2,
};

enum {
	SR_DMAR_FECTL_REG = 0,
	SR_DMAR_FEDATA_REG = 1,
	SR_DMAR_FEADDR_REG = 2,
	SR_DMAR_FEUADDR_REG = 3,
	MAX_SR_DMAR_REGS = 4,
};

struct context_entry {
	u64 lo;
	u64 hi;
};

struct pasid_table;

struct device_domain_info {
	struct list_head link;
	struct list_head global;
	struct list_head table;
	struct list_head auxiliary_domains;
	u8 bus;
	u8 devfn;
	u16 pfsid;
	u8 pasid_supported: 3;
	u8 pasid_enabled: 1;
	u8 pri_supported: 1;
	u8 pri_enabled: 1;
	u8 ats_supported: 1;
	u8 ats_enabled: 1;
	u8 auxd_enabled: 1;
	u8 ats_qdep;
	struct device *dev;
	struct intel_iommu *iommu;
	struct dmar_domain *domain;
	struct pasid_table *pasid_table;
};

struct pasid_table {
	void *table;
	int order;
	int max_pasid;
	struct list_head dev;
};

struct dmar_rmrr_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	u64 base_address;
	u64 end_address;
	struct dmar_dev_scope *devices;
	int devices_cnt;
};

struct dmar_atsr_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	struct dmar_dev_scope *devices;
	int devices_cnt;
	u8 include_all: 1;
};

struct domain_context_mapping_data {
	struct dmar_domain *domain;
	struct intel_iommu *iommu;
	struct pasid_table *table;
};

struct pasid_dir_entry {
	u64 val;
};

struct pasid_entry {
	u64 val[8];
};

struct pasid_table_opaque {
	struct pasid_table **pasid_table;
	int segment;
	int bus;
	int devfn;
};

struct trace_event_raw_dma_map {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	dma_addr_t dev_addr;
	phys_addr_t phys_addr;
	size_t size;
	char __data[0];
};

struct trace_event_raw_dma_unmap {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	dma_addr_t dev_addr;
	size_t size;
	char __data[0];
};

struct trace_event_data_offsets_dma_map {
	u32 dev_name;
};

struct trace_event_data_offsets_dma_unmap {
	u32 dev_name;
};

typedef void (*btf_trace_map_single)(void *, struct device *, dma_addr_t, phys_addr_t, size_t);

typedef void (*btf_trace_map_sg)(void *, struct device *, dma_addr_t, phys_addr_t, size_t);

typedef void (*btf_trace_bounce_map_single)(void *, struct device *, dma_addr_t, phys_addr_t, size_t);

typedef void (*btf_trace_unmap_single)(void *, struct device *, dma_addr_t, size_t);

typedef void (*btf_trace_unmap_sg)(void *, struct device *, dma_addr_t, size_t);

typedef void (*btf_trace_bounce_unmap_single)(void *, struct device *, dma_addr_t, size_t);

struct page_req_dsc {
	union {
		struct {
			u64 type: 8;
			u64 pasid_present: 1;
			u64 priv_data_present: 1;
			u64 rsvd: 6;
			u64 rid: 16;
			u64 pasid: 20;
			u64 exe_req: 1;
			u64 pm_req: 1;
			u64 rsvd2: 10;
		};
		u64 qw_0;
	};
	union {
		struct {
			u64 rd_req: 1;
			u64 wr_req: 1;
			u64 lpig: 1;
			u64 prg_index: 9;
			u64 addr: 52;
		};
		u64 qw_1;
	};
	u64 priv_data[2];
};

struct svm_dev_ops;

struct intel_svm_dev {
	struct list_head list;
	struct callback_head rcu;
	struct device *dev;
	struct svm_dev_ops *ops;
	int users;
	u16 did;
	u16 dev_iotlb: 1;
	u16 sid;
	u16 qdep;
};

struct svm_dev_ops {
	void (*fault_cb)(struct device *, int, u64, void *, int, int);
};

struct intel_svm {
	struct mmu_notifier notifier;
	struct mm_struct *mm;
	struct intel_iommu *iommu;
	int flags;
	int pasid;
	struct list_head devs;
	struct list_head list;
};

enum irq_mode {
	IRQ_REMAPPING = 0,
	IRQ_POSTING = 1,
};

struct ioapic_scope {
	struct intel_iommu *iommu;
	unsigned int id;
	unsigned int bus;
	unsigned int devfn;
};

struct hpet_scope {
	struct intel_iommu *iommu;
	u8 id;
	unsigned int bus;
	unsigned int devfn;
};

struct irq_2_iommu {
	struct intel_iommu *iommu;
	u16 irte_index;
	u16 sub_handle;
	u8 irte_mask;
	enum irq_mode mode;
};

struct intel_ir_data {
	struct irq_2_iommu irq_2_iommu;
	struct irte___2 irte_entry;
	union {
		struct msi_msg msi_entry;
	};
};

struct set_msi_sid_data {
	struct pci_dev *pdev;
	u16 alias;
	int count;
	int busmatch_count;
};

struct mipi_dsi_msg {
	u8 channel;
	u8 type;
	u16 flags;
	size_t tx_len;
	const void *tx_buf;
	size_t rx_len;
	void *rx_buf;
};

struct mipi_dsi_packet {
	size_t size;
	u8 header[4];
	size_t payload_length;
	const u8 *payload;
};

struct mipi_dsi_host;

struct mipi_dsi_device;

struct mipi_dsi_host_ops {
	int (*attach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	int (*detach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	ssize_t (*transfer)(struct mipi_dsi_host *, const struct mipi_dsi_msg *);
};

struct mipi_dsi_host {
	struct device *dev;
	const struct mipi_dsi_host_ops *ops;
	struct list_head list;
};

enum mipi_dsi_pixel_format {
	MIPI_DSI_FMT_RGB888 = 0,
	MIPI_DSI_FMT_RGB666 = 1,
	MIPI_DSI_FMT_RGB666_PACKED = 2,
	MIPI_DSI_FMT_RGB565 = 3,
};

struct mipi_dsi_device {
	struct mipi_dsi_host *host;
	struct device dev;
	char name[20];
	unsigned int channel;
	unsigned int lanes;
	enum mipi_dsi_pixel_format format;
	long unsigned int mode_flags;
	long unsigned int hs_rate;
	long unsigned int lp_rate;
};

struct mipi_dsi_device_info {
	char type[20];
	u32 channel;
	struct device_node *node;
};

enum mipi_dsi_dcs_tear_mode {
	MIPI_DSI_DCS_TEAR_MODE_VBLANK = 0,
	MIPI_DSI_DCS_TEAR_MODE_VHBLANK = 1,
};

struct mipi_dsi_driver {
	struct device_driver driver;
	int (*probe)(struct mipi_dsi_device *);
	int (*remove)(struct mipi_dsi_device *);
	void (*shutdown)(struct mipi_dsi_device *);
};

enum {
	MIPI_DSI_V_SYNC_START = 1,
	MIPI_DSI_V_SYNC_END = 17,
	MIPI_DSI_H_SYNC_START = 33,
	MIPI_DSI_H_SYNC_END = 49,
	MIPI_DSI_COLOR_MODE_OFF = 2,
	MIPI_DSI_COLOR_MODE_ON = 18,
	MIPI_DSI_SHUTDOWN_PERIPHERAL = 34,
	MIPI_DSI_TURN_ON_PERIPHERAL = 50,
	MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM = 3,
	MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM = 19,
	MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM = 35,
	MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM = 4,
	MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM = 20,
	MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM = 36,
	MIPI_DSI_DCS_SHORT_WRITE = 5,
	MIPI_DSI_DCS_SHORT_WRITE_PARAM = 21,
	MIPI_DSI_DCS_READ = 6,
	MIPI_DSI_DCS_COMPRESSION_MODE = 7,
	MIPI_DSI_PPS_LONG_WRITE = 10,
	MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE = 55,
	MIPI_DSI_END_OF_TRANSMISSION = 8,
	MIPI_DSI_NULL_PACKET = 9,
	MIPI_DSI_BLANKING_PACKET = 25,
	MIPI_DSI_GENERIC_LONG_WRITE = 41,
	MIPI_DSI_DCS_LONG_WRITE = 57,
	MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20 = 12,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24 = 28,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16 = 44,
	MIPI_DSI_PACKED_PIXEL_STREAM_30 = 13,
	MIPI_DSI_PACKED_PIXEL_STREAM_36 = 29,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12 = 61,
	MIPI_DSI_PACKED_PIXEL_STREAM_16 = 14,
	MIPI_DSI_PACKED_PIXEL_STREAM_18 = 30,
	MIPI_DSI_PIXEL_STREAM_3BYTE_18 = 46,
	MIPI_DSI_PACKED_PIXEL_STREAM_24 = 62,
};

enum {
	MIPI_DCS_NOP = 0,
	MIPI_DCS_SOFT_RESET = 1,
	MIPI_DCS_GET_DISPLAY_ID = 4,
	MIPI_DCS_GET_RED_CHANNEL = 6,
	MIPI_DCS_GET_GREEN_CHANNEL = 7,
	MIPI_DCS_GET_BLUE_CHANNEL = 8,
	MIPI_DCS_GET_DISPLAY_STATUS = 9,
	MIPI_DCS_GET_POWER_MODE = 10,
	MIPI_DCS_GET_ADDRESS_MODE = 11,
	MIPI_DCS_GET_PIXEL_FORMAT = 12,
	MIPI_DCS_GET_DISPLAY_MODE = 13,
	MIPI_DCS_GET_SIGNAL_MODE = 14,
	MIPI_DCS_GET_DIAGNOSTIC_RESULT = 15,
	MIPI_DCS_ENTER_SLEEP_MODE = 16,
	MIPI_DCS_EXIT_SLEEP_MODE = 17,
	MIPI_DCS_ENTER_PARTIAL_MODE = 18,
	MIPI_DCS_ENTER_NORMAL_MODE = 19,
	MIPI_DCS_EXIT_INVERT_MODE = 32,
	MIPI_DCS_ENTER_INVERT_MODE = 33,
	MIPI_DCS_SET_GAMMA_CURVE = 38,
	MIPI_DCS_SET_DISPLAY_OFF = 40,
	MIPI_DCS_SET_DISPLAY_ON = 41,
	MIPI_DCS_SET_COLUMN_ADDRESS = 42,
	MIPI_DCS_SET_PAGE_ADDRESS = 43,
	MIPI_DCS_WRITE_MEMORY_START = 44,
	MIPI_DCS_WRITE_LUT = 45,
	MIPI_DCS_READ_MEMORY_START = 46,
	MIPI_DCS_SET_PARTIAL_AREA = 48,
	MIPI_DCS_SET_SCROLL_AREA = 51,
	MIPI_DCS_SET_TEAR_OFF = 52,
	MIPI_DCS_SET_TEAR_ON = 53,
	MIPI_DCS_SET_ADDRESS_MODE = 54,
	MIPI_DCS_SET_SCROLL_START = 55,
	MIPI_DCS_EXIT_IDLE_MODE = 56,
	MIPI_DCS_ENTER_IDLE_MODE = 57,
	MIPI_DCS_SET_PIXEL_FORMAT = 58,
	MIPI_DCS_WRITE_MEMORY_CONTINUE = 60,
	MIPI_DCS_READ_MEMORY_CONTINUE = 62,
	MIPI_DCS_SET_TEAR_SCANLINE = 68,
	MIPI_DCS_GET_SCANLINE = 69,
	MIPI_DCS_SET_DISPLAY_BRIGHTNESS = 81,
	MIPI_DCS_GET_DISPLAY_BRIGHTNESS = 82,
	MIPI_DCS_WRITE_CONTROL_DISPLAY = 83,
	MIPI_DCS_GET_CONTROL_DISPLAY = 84,
	MIPI_DCS_WRITE_POWER_SAVE = 85,
	MIPI_DCS_GET_POWER_SAVE = 86,
	MIPI_DCS_SET_CABC_MIN_BRIGHTNESS = 94,
	MIPI_DCS_GET_CABC_MIN_BRIGHTNESS = 95,
	MIPI_DCS_READ_DDB_START = 161,
	MIPI_DCS_READ_DDB_CONTINUE = 168,
};

struct drm_dmi_panel_orientation_data {
	int width;
	int height;
	const char * const *bios_dates;
	int orientation;
};

struct vga_device {
	struct list_head list;
	struct pci_dev *pdev;
	unsigned int decodes;
	unsigned int owns;
	unsigned int locks;
	unsigned int io_lock_cnt;
	unsigned int mem_lock_cnt;
	unsigned int io_norm_cnt;
	unsigned int mem_norm_cnt;
	bool bridge_has_one_vga;
	void *cookie;
	void (*irq_set_state)(void *, bool);
	unsigned int (*set_vga_decode)(void *, bool);
};

struct vga_arb_user_card {
	struct pci_dev *pdev;
	unsigned int mem_cnt;
	unsigned int io_cnt;
};

struct vga_arb_private {
	struct list_head list;
	struct pci_dev *target;
	struct vga_arb_user_card cards[64];
	spinlock_t lock;
};

struct cb_id {
	__u32 idx;
	__u32 val;
};

struct cn_msg {
	struct cb_id id;
	__u32 seq;
	__u32 ack;
	__u16 len;
	__u16 flags;
	__u8 data[0];
};

struct cn_queue_dev {
	atomic_t refcnt;
	unsigned char name[32];
	struct list_head queue_list;
	spinlock_t queue_lock;
	struct sock *nls;
};

struct cn_callback_id {
	unsigned char name[32];
	struct cb_id id;
};

struct cn_callback_entry {
	struct list_head callback_entry;
	refcount_t refcnt;
	struct cn_queue_dev *pdev;
	struct cn_callback_id id;
	void (*callback)(struct cn_msg *, struct netlink_skb_parms *);
	u32 seq;
	u32 group;
};

struct cn_dev {
	struct cb_id id;
	u32 seq;
	u32 groups;
	struct sock *nls;
	struct cn_queue_dev *cbdev;
};

enum proc_cn_mcast_op {
	PROC_CN_MCAST_LISTEN = 1,
	PROC_CN_MCAST_IGNORE = 2,
};

struct fork_proc_event {
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
	__kernel_pid_t child_pid;
	__kernel_pid_t child_tgid;
};

struct exec_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct id_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	union {
		__u32 ruid;
		__u32 rgid;
	} r;
	union {
		__u32 euid;
		__u32 egid;
	} e;
};

struct sid_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct ptrace_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t tracer_pid;
	__kernel_pid_t tracer_tgid;
};

struct comm_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	char comm[16];
};

struct coredump_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct exit_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__u32 exit_code;
	__u32 exit_signal;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct proc_event {
	enum what what;
	__u32 cpu;
	__u64 timestamp_ns;
	union {
		struct {
			__u32 err;
		} ack;
		struct fork_proc_event fork;
		struct exec_proc_event exec;
		struct id_proc_event id;
		struct sid_proc_event sid;
		struct ptrace_proc_event ptrace;
		struct comm_proc_event comm;
		struct coredump_proc_event coredump;
		struct exit_proc_event exit;
	} event_data;
};

struct component_ops {
	int (*bind)(struct device *, struct device *, void *);
	void (*unbind)(struct device *, struct device *, void *);
};

struct component_master_ops {
	int (*bind)(struct device *);
	void (*unbind)(struct device *);
};

struct component;

struct component_match_array {
	void *data;
	int (*compare)(struct device *, void *);
	int (*compare_typed)(struct device *, int, void *);
	void (*release)(struct device *, void *);
	struct component *component;
	bool duplicate;
};

struct master;

struct component {
	struct list_head node;
	struct master *master;
	bool bound;
	const struct component_ops *ops;
	int subcomponent;
	struct device *dev;
};

struct component_match {
	size_t alloc;
	size_t num;
	struct component_match_array *compare;
};

struct master {
	struct list_head node;
	bool bound;
	const struct component_master_ops *ops;
	struct device *dev;
	struct component_match *match;
	struct dentry *dentry;
};

struct wake_irq {
	struct device *dev;
	unsigned int status;
	int irq;
	const char *name;
};

enum dpm_order {
	DPM_ORDER_NONE = 0,
	DPM_ORDER_DEV_AFTER_PARENT = 1,
	DPM_ORDER_PARENT_BEFORE_DEV = 2,
	DPM_ORDER_DEV_LAST = 3,
};

struct subsys_private {
	struct kset subsys;
	struct kset *devices_kset;
	struct list_head interfaces;
	struct mutex mutex;
	struct kset *drivers_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe: 1;
	struct bus_type *bus;
	struct kset glue_dirs;
	struct class *class;
};

struct driver_private {
	struct kobject kobj;
	struct klist klist_devices;
	struct klist_node knode_bus;
	struct module_kobject *mkobj;
	struct device_driver *driver;
};

struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	struct klist_node knode_class;
	struct list_head deferred_probe;
	struct device_driver *async_driver;
	struct device *device;
	u8 dead: 1;
};

union device_attr_group_devres {
	const struct attribute_group *group;
	const struct attribute_group **groups;
};

struct class_dir {
	struct kobject kobj;
	struct class *class;
};

struct root_device {
	struct device dev;
	struct module *owner;
};

struct subsys_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

struct device_attach_data {
	struct device *dev;
	bool check_async;
	bool want_async;
	bool have_async;
};

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(struct class *, struct class_attribute *, char *);
	ssize_t (*store)(struct class *, struct class_attribute *, const char *, size_t);
};

struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

struct class_compat {
	struct kobject *kobj;
};

struct early_platform_driver {
	const char *class_str;
	struct platform_driver *pdrv;
	struct list_head list;
	int requested_id;
	char *buffer;
	int bufsize;
};

struct platform_object {
	struct platform_device pdev;
	char name[0];
};

struct cpu_attr {
	struct device_attribute attr;
	const struct cpumask * const map;
};

struct probe {
	struct probe *next;
	dev_t dev;
	long unsigned int range;
	struct module *owner;
	kobj_probe_t *get;
	int (*lock)(dev_t, void *);
	void *data;
};

struct kobj_map {
	struct probe *probes[255];
	struct mutex *lock;
};

struct devres_node {
	struct list_head entry;
	dr_release_t release;
};

struct devres {
	struct devres_node node;
	u8 data[0];
};

struct devres_group {
	struct devres_node node[2];
	void *id;
	int color;
};

struct action_devres {
	void *data;
	void (*action)(void *);
};

struct pages_devres {
	long unsigned int addr;
	unsigned int order;
};

struct attribute_container {
	struct list_head node;
	struct klist containers;
	struct class *class;
	const struct attribute_group *grp;
	struct device_attribute **attrs;
	int (*match)(struct attribute_container *, struct device *);
	long unsigned int flags;
};

struct internal_container {
	struct klist_node node;
	struct attribute_container *cont;
	struct device classdev;
};

struct transport_container;

struct transport_class {
	struct class class;
	int (*setup)(struct transport_container *, struct device *, struct device *);
	int (*configure)(struct transport_container *, struct device *, struct device *);
	int (*remove)(struct transport_container *, struct device *, struct device *);
};

struct transport_container {
	struct attribute_container ac;
	const struct attribute_group *statistics;
};

struct anon_transport_class {
	struct transport_class tclass;
	struct attribute_container container;
};

enum ethtool_link_mode_bit_indices {
	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
	ETHTOOL_LINK_MODE_TP_BIT = 7,
	ETHTOOL_LINK_MODE_AUI_BIT = 8,
	ETHTOOL_LINK_MODE_MII_BIT = 9,
	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
	ETHTOOL_LINK_MODE_BNC_BIT = 11,
	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
	ETHTOOL_LINK_MODE_Pause_BIT = 13,
	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
	__ETHTOOL_LINK_MODE_MASK_NBITS = 69,
};

struct reset_control;

struct mii_bus;

struct mdio_device {
	struct device dev;
	struct mii_bus *bus;
	char modalias[32];
	int (*bus_match)(struct device *, struct device_driver *);
	void (*device_free)(struct mdio_device *);
	void (*device_remove)(struct mdio_device *);
	int addr;
	int flags;
	struct gpio_desc *reset_gpio;
	struct reset_control *reset_ctrl;
	unsigned int reset_assert_delay;
	unsigned int reset_deassert_delay;
};

struct phy_c45_device_ids {
	u32 devices_in_package;
	u32 device_ids[8];
};

enum phy_state {
	PHY_DOWN = 0,
	PHY_READY = 1,
	PHY_HALTED = 2,
	PHY_UP = 3,
	PHY_RUNNING = 4,
	PHY_NOLINK = 5,
};

typedef enum {
	PHY_INTERFACE_MODE_NA = 0,
	PHY_INTERFACE_MODE_INTERNAL = 1,
	PHY_INTERFACE_MODE_MII = 2,
	PHY_INTERFACE_MODE_GMII = 3,
	PHY_INTERFACE_MODE_SGMII = 4,
	PHY_INTERFACE_MODE_TBI = 5,
	PHY_INTERFACE_MODE_REVMII = 6,
	PHY_INTERFACE_MODE_RMII = 7,
	PHY_INTERFACE_MODE_RGMII = 8,
	PHY_INTERFACE_MODE_RGMII_ID = 9,
	PHY_INTERFACE_MODE_RGMII_RXID = 10,
	PHY_INTERFACE_MODE_RGMII_TXID = 11,
	PHY_INTERFACE_MODE_RTBI = 12,
	PHY_INTERFACE_MODE_SMII = 13,
	PHY_INTERFACE_MODE_XGMII = 14,
	PHY_INTERFACE_MODE_MOCA = 15,
	PHY_INTERFACE_MODE_QSGMII = 16,
	PHY_INTERFACE_MODE_TRGMII = 17,
	PHY_INTERFACE_MODE_1000BASEX = 18,
	PHY_INTERFACE_MODE_2500BASEX = 19,
	PHY_INTERFACE_MODE_RXAUI = 20,
	PHY_INTERFACE_MODE_XAUI = 21,
	PHY_INTERFACE_MODE_10GKR = 22,
	PHY_INTERFACE_MODE_USXGMII = 23,
	PHY_INTERFACE_MODE_MAX = 24,
} phy_interface_t;

struct phylink;

struct phy_driver;

struct phy_device {
	struct mdio_device mdio;
	struct phy_driver *drv;
	u32 phy_id;
	struct phy_c45_device_ids c45_ids;
	unsigned int is_c45: 1;
	unsigned int is_internal: 1;
	unsigned int is_pseudo_fixed_link: 1;
	unsigned int is_gigabit_capable: 1;
	unsigned int has_fixups: 1;
	unsigned int suspended: 1;
	unsigned int suspended_by_mdio_bus: 1;
	unsigned int sysfs_links: 1;
	unsigned int loopback_enabled: 1;
	unsigned int autoneg: 1;
	unsigned int link: 1;
	unsigned int autoneg_complete: 1;
	unsigned int interrupts: 1;
	enum phy_state state;
	u32 dev_flags;
	phy_interface_t interface;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
	long unsigned int supported[2];
	long unsigned int advertising[2];
	long unsigned int lp_advertising[2];
	long unsigned int adv_old[2];
	u32 eee_broken_modes;
	int irq;
	void *priv;
	struct delayed_work state_queue;
	struct mutex lock;
	struct phylink *phylink;
	struct net_device *attached_dev;
	u8 mdix;
	u8 mdix_ctrl;
	void (*phy_link_change)(struct phy_device *, bool, bool);
	void (*adjust_link)(struct net_device *);
};

struct mii_bus {
	struct module *owner;
	const char *name;
	char id[61];
	void *priv;
	int (*read)(struct mii_bus *, int, int);
	int (*write)(struct mii_bus *, int, int, u16);
	int (*reset)(struct mii_bus *);
	struct mutex mdio_lock;
	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED = 2,
		MDIOBUS_UNREGISTERED = 3,
		MDIOBUS_RELEASED = 4,
	} state;
	struct device dev;
	struct mdio_device *mdio_map[32];
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
	int irq[32];
	int reset_delay_us;
	struct gpio_desc *reset_gpiod;
};

struct mdio_driver_common {
	struct device_driver driver;
	int flags;
};

struct phy_driver {
	struct mdio_driver_common mdiodrv;
	u32 phy_id;
	char *name;
	u32 phy_id_mask;
	const long unsigned int * const features;
	u32 flags;
	const void *driver_data;
	int (*soft_reset)(struct phy_device *);
	int (*config_init)(struct phy_device *);
	int (*probe)(struct phy_device *);
	int (*get_features)(struct phy_device *);
	int (*suspend)(struct phy_device *);
	int (*resume)(struct phy_device *);
	int (*config_aneg)(struct phy_device *);
	int (*aneg_done)(struct phy_device *);
	int (*read_status)(struct phy_device *);
	int (*ack_interrupt)(struct phy_device *);
	int (*config_intr)(struct phy_device *);
	int (*did_interrupt)(struct phy_device *);
	int (*handle_interrupt)(struct phy_device *);
	void (*remove)(struct phy_device *);
	int (*match_phy_device)(struct phy_device *);
	int (*ts_info)(struct phy_device *, struct ethtool_ts_info *);
	int (*hwtstamp)(struct phy_device *, struct ifreq *);
	bool (*rxtstamp)(struct phy_device *, struct sk_buff *, int);
	void (*txtstamp)(struct phy_device *, struct sk_buff *, int);
	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*link_change_notify)(struct phy_device *);
	int (*read_mmd)(struct phy_device *, int, u16);
	int (*write_mmd)(struct phy_device *, int, u16, u16);
	int (*read_page)(struct phy_device *);
	int (*write_page)(struct phy_device *, int);
	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
	int (*get_sset_count)(struct phy_device *);
	void (*get_strings)(struct phy_device *, u8 *);
	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
	int (*set_loopback)(struct phy_device *, bool);
};

struct device_connection {
	struct fwnode_handle *fwnode;
	const char *endpoint[2];
	const char *id;
	struct list_head list;
};

typedef void * (*devcon_match_fn_t)(struct device_connection *, int, void *);

struct software_node;

struct software_node_ref_args {
	const struct software_node *node;
	unsigned int nargs;
	u64 args[8];
};

struct software_node_reference;

struct software_node {
	const char *name;
	const struct software_node *parent;
	const struct property_entry *properties;
	const struct software_node_reference *references;
};

struct software_node_reference {
	const char *name;
	unsigned int nrefs;
	const struct software_node_ref_args *refs;
};

struct swnode {
	int id;
	struct kobject kobj;
	struct fwnode_handle fwnode;
	const struct software_node *node;
	struct ida child_ids;
	struct list_head entry;
	struct list_head children;
	struct swnode *parent;
	unsigned int allocated: 1;
};

struct req {
	struct req *next;
	struct completion done;
	int err;
	const char *name;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	struct device *dev;
};

typedef int (*pm_callback_t)(struct device *);

struct pm_clk_notifier_block {
	struct notifier_block nb;
	struct dev_pm_domain *pm_domain;
	char *con_ids[0];
};

enum pce_status {
	PCE_STATUS_NONE = 0,
	PCE_STATUS_ACQUIRED = 1,
	PCE_STATUS_ENABLED = 2,
	PCE_STATUS_ERROR = 3,
};

struct pm_clock_entry {
	struct list_head node;
	char *con_id;
	struct clk *clk;
	enum pce_status status;
};

struct firmware_fallback_config {
	unsigned int force_sysfs_fallback;
	unsigned int ignore_sysfs_fallback;
	int old_timeout;
	int loading_timeout;
};

enum fw_opt {
	FW_OPT_UEVENT = 1,
	FW_OPT_NOWAIT = 2,
	FW_OPT_USERHELPER = 4,
	FW_OPT_NO_WARN = 8,
	FW_OPT_NOCACHE = 16,
	FW_OPT_NOFALLBACK = 32,
};

enum fw_status {
	FW_STATUS_UNKNOWN = 0,
	FW_STATUS_LOADING = 1,
	FW_STATUS_DONE = 2,
	FW_STATUS_ABORTED = 3,
};

struct fw_state {
	struct completion completion;
	enum fw_status status;
};

struct firmware_cache;

struct fw_priv {
	struct kref ref;
	struct list_head list;
	struct firmware_cache *fwc;
	struct fw_state fw_st;
	void *data;
	size_t size;
	size_t allocated_size;
	bool is_paged_buf;
	struct page **pages;
	int nr_pages;
	int page_array_size;
	bool need_uevent;
	struct list_head pending_list;
	const char *fw_name;
};

struct firmware_cache {
	spinlock_t lock;
	struct list_head head;
	int state;
	spinlock_t name_lock;
	struct list_head fw_names;
	struct delayed_work work;
	struct notifier_block pm_notify;
};

struct fw_cache_entry {
	struct list_head list;
	const char *name;
};

struct fw_name_devm {
	long unsigned int magic;
	const char *name;
};

struct firmware_work {
	struct work_struct work;
	struct module *module;
	const char *name;
	struct device *device;
	void *context;
	void (*cont)(const struct firmware *, void *);
	enum fw_opt opt_flags;
};

struct fw_sysfs {
	bool nowait;
	struct device dev;
	struct fw_priv *fw_priv;
	struct firmware *fw;
};

struct node_access_nodes {
	struct device dev;
	struct list_head list_node;
	unsigned int access;
	struct node_hmem_attrs hmem_attrs;
};

struct node_cache_info {
	struct device dev;
	struct list_head node;
	struct node_cache_attrs cache_attrs;
};

struct node_attr {
	struct device_attribute attr;
	enum node_states state;
};

struct for_each_memory_block_cb_data {
	walk_memory_blocks_func_t func;
	void *arg;
};

typedef void (*irq_write_msi_msg_t)(struct msi_desc *, struct msi_msg *);

struct platform_msi_priv_data {
	struct device *dev;
	void *host_data;
	msi_alloc_info_t arg;
	irq_write_msi_msg_t write_msg;
	int devid;
};

typedef long unsigned int __kernel_old_dev_t;

enum {
	LO_FLAGS_READ_ONLY = 1,
	LO_FLAGS_AUTOCLEAR = 4,
	LO_FLAGS_PARTSCAN = 8,
	LO_FLAGS_DIRECT_IO = 16,
};

struct loop_info {
	int lo_number;
	__kernel_old_dev_t lo_device;
	long unsigned int lo_inode;
	__kernel_old_dev_t lo_rdevice;
	int lo_offset;
	int lo_encrypt_type;
	int lo_encrypt_key_size;
	int lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	long unsigned int lo_init[2];
	char reserved[4];
};

struct loop_info64 {
	__u64 lo_device;
	__u64 lo_inode;
	__u64 lo_rdevice;
	__u64 lo_offset;
	__u64 lo_sizelimit;
	__u32 lo_number;
	__u32 lo_encrypt_type;
	__u32 lo_encrypt_key_size;
	__u32 lo_flags;
	__u8 lo_file_name[64];
	__u8 lo_crypt_name[64];
	__u8 lo_encrypt_key[32];
	__u64 lo_init[2];
};

enum {
	Lo_unbound = 0,
	Lo_bound = 1,
	Lo_rundown = 2,
};

struct loop_func_table;

struct loop_device {
	int lo_number;
	atomic_t lo_refcnt;
	loff_t lo_offset;
	loff_t lo_sizelimit;
	int lo_flags;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	char lo_file_name[64];
	char lo_crypt_name[64];
	char lo_encrypt_key[32];
	int lo_encrypt_key_size;
	struct loop_func_table *lo_encryption;
	__u32 lo_init[2];
	kuid_t lo_key_owner;
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct file *lo_backing_file;
	struct block_device *lo_device;
	void *key_data;
	gfp_t old_gfp_mask;
	spinlock_t lo_lock;
	int lo_state;
	struct kthread_worker worker;
	struct task_struct *worker_task;
	bool use_dio;
	bool sysfs_inited;
	struct request_queue *lo_queue;
	struct blk_mq_tag_set tag_set;
	struct gendisk *lo_disk;
};

struct loop_func_table {
	int number;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	int (*init)(struct loop_device *, const struct loop_info64 *);
	int (*release)(struct loop_device *);
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct module *owner;
};

struct loop_cmd {
	struct kthread_work work;
	bool use_aio;
	atomic_t ref;
	long int ret;
	struct kiocb iocb;
	struct bio_vec *bvec;
	struct cgroup_subsys_state *css;
};

struct compat_loop_info {
	compat_int_t lo_number;
	compat_dev_t lo_device;
	compat_ulong_t lo_inode;
	compat_dev_t lo_rdevice;
	compat_int_t lo_offset;
	compat_int_t lo_encrypt_type;
	compat_int_t lo_encrypt_key_size;
	compat_int_t lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	compat_ulong_t lo_init[2];
	char reserved[4];
};

enum sock_shutdown_cmd {
	SHUT_RD = 0,
	SHUT_WR = 1,
	SHUT_RDWR = 2,
};

enum {
	NBD_CMD_READ = 0,
	NBD_CMD_WRITE = 1,
	NBD_CMD_DISC = 2,
	NBD_CMD_FLUSH = 3,
	NBD_CMD_TRIM = 4,
};

struct nbd_request {
	__be32 magic;
	__be32 type;
	char handle[8];
	__be64 from;
	__be32 len;
} __attribute__((packed));

struct nbd_reply {
	__be32 magic;
	__be32 error;
	char handle[8];
};

enum {
	NBD_ATTR_UNSPEC = 0,
	NBD_ATTR_INDEX = 1,
	NBD_ATTR_SIZE_BYTES = 2,
	NBD_ATTR_BLOCK_SIZE_BYTES = 3,
	NBD_ATTR_TIMEOUT = 4,
	NBD_ATTR_SERVER_FLAGS = 5,
	NBD_ATTR_CLIENT_FLAGS = 6,
	NBD_ATTR_SOCKETS = 7,
	NBD_ATTR_DEAD_CONN_TIMEOUT = 8,
	NBD_ATTR_DEVICE_LIST = 9,
	__NBD_ATTR_MAX = 10,
};

enum {
	NBD_DEVICE_ITEM_UNSPEC = 0,
	NBD_DEVICE_ITEM = 1,
	__NBD_DEVICE_ITEM_MAX = 2,
};

enum {
	NBD_DEVICE_UNSPEC = 0,
	NBD_DEVICE_INDEX = 1,
	NBD_DEVICE_CONNECTED = 2,
	__NBD_DEVICE_MAX = 3,
};

enum {
	NBD_SOCK_ITEM_UNSPEC = 0,
	NBD_SOCK_ITEM = 1,
	__NBD_SOCK_ITEM_MAX = 2,
};

enum {
	NBD_SOCK_UNSPEC = 0,
	NBD_SOCK_FD = 1,
	__NBD_SOCK_MAX = 2,
};

enum {
	NBD_CMD_UNSPEC = 0,
	NBD_CMD_CONNECT = 1,
	NBD_CMD_DISCONNECT = 2,
	NBD_CMD_RECONFIGURE = 3,
	NBD_CMD_LINK_DEAD = 4,
	NBD_CMD_STATUS = 5,
	__NBD_CMD_MAX = 6,
};

struct trace_event_raw_nbd_transport_event {
	struct trace_entry ent;
	struct request *req;
	u64 handle;
	char __data[0];
};

struct trace_event_raw_nbd_send_request {
	struct trace_entry ent;
	struct nbd_request *nbd_request;
	u64 dev_index;
	struct request *request;
	char __data[0];
};

struct trace_event_data_offsets_nbd_transport_event {};

struct trace_event_data_offsets_nbd_send_request {};

typedef void (*btf_trace_nbd_header_sent)(void *, struct request *, u64);

typedef void (*btf_trace_nbd_payload_sent)(void *, struct request *, u64);

typedef void (*btf_trace_nbd_header_received)(void *, struct request *, u64);

typedef void (*btf_trace_nbd_payload_received)(void *, struct request *, u64);

typedef void (*btf_trace_nbd_send_request)(void *, struct nbd_request *, int, struct request *);

struct nbd_sock {
	struct socket *sock;
	struct mutex tx_lock;
	struct request *pending;
	int sent;
	bool dead;
	int fallback_index;
	int cookie;
};

struct nbd_device;

struct recv_thread_args {
	struct work_struct work;
	struct nbd_device *nbd;
	int index;
};

struct nbd_config;

struct nbd_device {
	struct blk_mq_tag_set tag_set;
	int index;
	refcount_t config_refs;
	refcount_t refs;
	struct nbd_config *config;
	struct mutex config_lock;
	struct gendisk *disk;
	struct workqueue_struct *recv_workq;
	struct list_head list;
	struct task_struct *task_recv;
	struct task_struct *task_setup;
	struct completion *destroy_complete;
	long unsigned int flags;
};

struct link_dead_args {
	struct work_struct work;
	int index;
};

struct nbd_config {
	u32 flags;
	long unsigned int runtime_flags;
	u64 dead_conn_timeout;
	struct nbd_sock **socks;
	int num_connections;
	atomic_t live_connections;
	wait_queue_head_t conn_wait;
	atomic_t recv_threads;
	wait_queue_head_t recv_wq;
	loff_t blksize;
	loff_t bytesize;
	struct dentry *dbg_dir;
};

struct nbd_cmd {
	struct nbd_device *nbd;
	struct mutex lock;
	int index;
	int cookie;
	int retries;
	blk_status_t status;
	long unsigned int flags;
	u32 cmd_cookie;
};

struct virtio_blk_geometry {
	__u16 cylinders;
	__u8 heads;
	__u8 sectors;
};

struct virtio_blk_config {
	__u64 capacity;
	__u32 size_max;
	__u32 seg_max;
	struct virtio_blk_geometry geometry;
	__u32 blk_size;
	__u8 physical_block_exp;
	__u8 alignment_offset;
	__u16 min_io_size;
	__u32 opt_io_size;
	__u8 wce;
	__u8 unused;
	__u16 num_queues;
	__u32 max_discard_sectors;
	__u32 max_discard_seg;
	__u32 discard_sector_alignment;
	__u32 max_write_zeroes_sectors;
	__u32 max_write_zeroes_seg;
	__u8 write_zeroes_may_unmap;
	__u8 unused1[3];
} __attribute__((packed));

struct virtio_blk_outhdr {
	__virtio32 type;
	__virtio32 ioprio;
	__virtio64 sector;
};

struct virtio_blk_discard_write_zeroes {
	__le64 sector;
	__le32 num_sectors;
	__le32 flags;
};

struct virtio_scsi_inhdr {
	__virtio32 errors;
	__virtio32 data_len;
	__virtio32 sense_len;
	__virtio32 residual;
};

struct virtio_blk_vq {
	struct virtqueue *vq;
	spinlock_t lock;
	char name[16];
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct virtio_blk {
	struct mutex vdev_mutex;
	struct virtio_device *vdev;
	struct gendisk *disk;
	struct blk_mq_tag_set tag_set;
	struct work_struct config_work;
	refcount_t refs;
	unsigned int sg_elems;
	int index;
	int num_vqs;
	struct virtio_blk_vq *vqs;
};

struct virtblk_req {
	struct scsi_request sreq;
	u8 sense[96];
	struct virtio_scsi_inhdr in_hdr;
	struct virtio_blk_outhdr out_hdr;
	u8 status;
	struct scatterlist sg[0];
};

enum {
	CARM_MAX_PORTS = 8,
	CARM_SHM_SIZE = 524288,
	CARM_MINORS_PER_MAJOR = 32,
	CARM_MAX_WAIT_Q = 9,
	CARM_MAX_REQ = 64,
	CARM_MSG_LOW_WATER = 16,
	CARM_MAX_REQ_SG = 32,
	CARM_MAX_HOST_SG = 600,
	CARM_SG_LOW_WATER = 150,
	CARM_IHQP = 28,
	CARM_INT_STAT = 16,
	CARM_INT_MASK = 20,
	CARM_HMUC = 24,
	RBUF_ADDR_LO = 32,
	RBUF_ADDR_HI = 36,
	RBUF_BYTE_SZ = 40,
	CARM_RESP_IDX = 44,
	CARM_CMS0 = 48,
	CARM_LMUC = 72,
	CARM_HMPHA = 108,
	CARM_INITC = 181,
	INT_RESERVED = 4294967280,
	INT_WATCHDOG = 8,
	INT_Q_OVERFLOW = 4,
	INT_Q_AVAILABLE = 2,
	INT_RESPONSE = 1,
	INT_ACK_MASK = 12,
	INT_DEF_MASK = 4294967285,
	CARM_HAVE_RESP = 1,
	CARM_MSG_READ = 1,
	CARM_MSG_WRITE = 2,
	CARM_MSG_VERIFY = 3,
	CARM_MSG_GET_CAPACITY = 4,
	CARM_MSG_FLUSH = 5,
	CARM_MSG_IOCTL = 6,
	CARM_MSG_ARRAY = 8,
	CARM_MSG_MISC = 9,
	CARM_CME = 4,
	CARM_RME = 2,
	CARM_WZBC = 1,
	CARM_RMI = 1,
	CARM_Q_FULL = 8,
	CARM_MSG_SIZE = 288,
	CARM_Q_LEN = 48,
	CARM_IOC_SCAN_CHAN = 5,
	CARM_IOC_GET_TCQ = 13,
	CARM_IOC_SET_TCQ = 14,
	IOC_SCAN_CHAN_NODEV = 31,
	IOC_SCAN_CHAN_OFFSET = 64,
	CARM_ARRAY_INFO = 0,
	ARRAY_NO_EXIST = 2147483648,
	RMSG_SZ = 8,
	RMSG_Q_LEN = 48,
	RMSG_OK = 1,
	RBUF_LEN = 384,
	PDC_SHM_SIZE = 524288,
	MISC_GET_FW_VER = 2,
	MISC_ALLOC_MEM = 3,
	MISC_SET_TIME = 5,
	FW_VER_4PORT = 4,
	FW_VER_NON_RAID = 2,
	FW_VER_ZCR = 1,
	FL_NON_RAID = 2,
	FL_4PORT = 4,
	FL_FW_VER_MASK = 6,
	FL_DYN_MAJOR = 131072,
};

enum {
	CARM_SG_BOUNDARY = 65535,
};

enum scatter_gather_types {
	SGT_32BIT = 0,
	SGT_64BIT = 1,
};

enum host_states {
	HST_INVALID = 0,
	HST_ALLOC_BUF = 1,
	HST_ERROR = 2,
	HST_PORT_SCAN = 3,
	HST_DEV_SCAN_START = 4,
	HST_DEV_SCAN = 5,
	HST_DEV_ACTIVATE = 6,
	HST_PROBE_FINISHED = 7,
	HST_PROBE_START = 8,
	HST_SYNC_TIME = 9,
	HST_GET_FW_VER = 10,
};

struct carm_host;

struct carm_port {
	unsigned int port_no;
	struct gendisk *disk;
	struct carm_host *host;
	u64 capacity;
	char name[41];
	u16 dev_geom_head;
	u16 dev_geom_sect;
	u16 dev_geom_cyl;
};

struct carm_host {
	long unsigned int flags;
	void *mmio;
	void *shm;
	dma_addr_t shm_dma;
	int major;
	int id;
	char name[32];
	spinlock_t lock;
	struct pci_dev *pdev;
	unsigned int state;
	u32 fw_ver;
	struct blk_mq_tag_set tag_set;
	struct request_queue *oob_q;
	unsigned int n_oob;
	unsigned int hw_sg_used;
	unsigned int resp_idx;
	unsigned int wait_q_prod;
	unsigned int wait_q_cons;
	struct request_queue *wait_q[9];
	void *msg_base;
	dma_addr_t msg_dma;
	int cur_scan_dev;
	long unsigned int dev_active;
	long unsigned int dev_present;
	struct carm_port port[8];
	struct work_struct fsm_task;
	struct completion probe_comp;
};

struct carm_request {
	int n_elem;
	unsigned int msg_type;
	unsigned int msg_subtype;
	unsigned int msg_bucket;
	struct scatterlist sg[32];
};

struct carm_response {
	__le32 ret_handle;
	__le32 status;
};

struct carm_msg_sg {
	__le32 start;
	__le32 len;
};

struct carm_msg_rw {
	u8 type;
	u8 id;
	u8 sg_count;
	u8 sg_type;
	__le32 handle;
	__le32 lba;
	__le16 lba_count;
	__le16 lba_high;
	struct carm_msg_sg sg[32];
};

struct carm_msg_allocbuf {
	u8 type;
	u8 subtype;
	u8 n_sg;
	u8 sg_type;
	__le32 handle;
	__le32 addr;
	__le32 len;
	__le32 evt_pool;
	__le32 n_evt;
	__le32 rbuf_pool;
	__le32 n_rbuf;
	__le32 msg_pool;
	__le32 n_msg;
	struct carm_msg_sg sg[8];
};

struct carm_msg_ioctl {
	u8 type;
	u8 subtype;
	u8 array_id;
	u8 reserved1;
	__le32 handle;
	__le32 data_addr;
	u32 reserved2;
};

struct carm_msg_sync_time {
	u8 type;
	u8 subtype;
	u16 reserved1;
	__le32 handle;
	u32 reserved2;
	__le32 timestamp;
};

struct carm_msg_get_fw_ver {
	u8 type;
	u8 subtype;
	u16 reserved1;
	__le32 handle;
	__le32 data_addr;
	u32 reserved2;
};

struct carm_fw_ver {
	__le32 version;
	u8 features;
	u8 reserved1;
	u16 reserved2;
};

struct carm_array_info {
	__le32 size;
	__le16 size_hi;
	__le16 stripe_size;
	__le32 mode;
	__le16 stripe_blk_sz;
	__le16 reserved1;
	__le16 cyl;
	__le16 head;
	__le16 sect;
	u8 array_id;
	u8 reserved2;
	char name[40];
	__le32 array_status;
};

typedef unsigned int (*carm_sspc_t)(struct carm_host *, unsigned int, void *);

enum {
	ATA_MAX_DEVICES = 2,
	ATA_MAX_PRD = 256,
	ATA_SECT_SIZE = 512,
	ATA_MAX_SECTORS_128 = 128,
	ATA_MAX_SECTORS = 256,
	ATA_MAX_SECTORS_1024 = 1024,
	ATA_MAX_SECTORS_LBA48 = 65535,
	ATA_MAX_SECTORS_TAPE = 65535,
	ATA_MAX_TRIM_RNUM = 64,
	ATA_ID_WORDS = 256,
	ATA_ID_CONFIG = 0,
	ATA_ID_CYLS = 1,
	ATA_ID_HEADS = 3,
	ATA_ID_SECTORS = 6,
	ATA_ID_SERNO = 10,
	ATA_ID_BUF_SIZE = 21,
	ATA_ID_FW_REV = 23,
	ATA_ID_PROD = 27,
	ATA_ID_MAX_MULTSECT = 47,
	ATA_ID_DWORD_IO = 48,
	ATA_ID_TRUSTED = 48,
	ATA_ID_CAPABILITY = 49,
	ATA_ID_OLD_PIO_MODES = 51,
	ATA_ID_OLD_DMA_MODES = 52,
	ATA_ID_FIELD_VALID = 53,
	ATA_ID_CUR_CYLS = 54,
	ATA_ID_CUR_HEADS = 55,
	ATA_ID_CUR_SECTORS = 56,
	ATA_ID_MULTSECT = 59,
	ATA_ID_LBA_CAPACITY = 60,
	ATA_ID_SWDMA_MODES = 62,
	ATA_ID_MWDMA_MODES = 63,
	ATA_ID_PIO_MODES = 64,
	ATA_ID_EIDE_DMA_MIN = 65,
	ATA_ID_EIDE_DMA_TIME = 66,
	ATA_ID_EIDE_PIO = 67,
	ATA_ID_EIDE_PIO_IORDY = 68,
	ATA_ID_ADDITIONAL_SUPP = 69,
	ATA_ID_QUEUE_DEPTH = 75,
	ATA_ID_SATA_CAPABILITY = 76,
	ATA_ID_SATA_CAPABILITY_2 = 77,
	ATA_ID_FEATURE_SUPP = 78,
	ATA_ID_MAJOR_VER = 80,
	ATA_ID_COMMAND_SET_1 = 82,
	ATA_ID_COMMAND_SET_2 = 83,
	ATA_ID_CFSSE = 84,
	ATA_ID_CFS_ENABLE_1 = 85,
	ATA_ID_CFS_ENABLE_2 = 86,
	ATA_ID_CSF_DEFAULT = 87,
	ATA_ID_UDMA_MODES = 88,
	ATA_ID_HW_CONFIG = 93,
	ATA_ID_SPG = 98,
	ATA_ID_LBA_CAPACITY_2 = 100,
	ATA_ID_SECTOR_SIZE = 106,
	ATA_ID_WWN = 108,
	ATA_ID_LOGICAL_SECTOR_SIZE = 117,
	ATA_ID_COMMAND_SET_3 = 119,
	ATA_ID_COMMAND_SET_4 = 120,
	ATA_ID_LAST_LUN = 126,
	ATA_ID_DLF = 128,
	ATA_ID_CSFO = 129,
	ATA_ID_CFA_POWER = 160,
	ATA_ID_CFA_KEY_MGMT = 162,
	ATA_ID_CFA_MODES = 163,
	ATA_ID_DATA_SET_MGMT = 169,
	ATA_ID_SCT_CMD_XPORT = 206,
	ATA_ID_ROT_SPEED = 217,
	ATA_ID_PIO4 = 2,
	ATA_ID_SERNO_LEN = 20,
	ATA_ID_FW_REV_LEN = 8,
	ATA_ID_PROD_LEN = 40,
	ATA_ID_WWN_LEN = 8,
	ATA_PCI_CTL_OFS = 2,
	ATA_PIO0 = 1,
	ATA_PIO1 = 3,
	ATA_PIO2 = 7,
	ATA_PIO3 = 15,
	ATA_PIO4 = 31,
	ATA_PIO5 = 63,
	ATA_PIO6 = 127,
	ATA_PIO4_ONLY = 16,
	ATA_SWDMA0 = 1,
	ATA_SWDMA1 = 3,
	ATA_SWDMA2 = 7,
	ATA_SWDMA2_ONLY = 4,
	ATA_MWDMA0 = 1,
	ATA_MWDMA1 = 3,
	ATA_MWDMA2 = 7,
	ATA_MWDMA3 = 15,
	ATA_MWDMA4 = 31,
	ATA_MWDMA12_ONLY = 6,
	ATA_MWDMA2_ONLY = 4,
	ATA_UDMA0 = 1,
	ATA_UDMA1 = 3,
	ATA_UDMA2 = 7,
	ATA_UDMA3 = 15,
	ATA_UDMA4 = 31,
	ATA_UDMA5 = 63,
	ATA_UDMA6 = 127,
	ATA_UDMA7 = 255,
	ATA_UDMA24_ONLY = 20,
	ATA_UDMA_MASK_40C = 7,
	ATA_PRD_SZ = 8,
	ATA_PRD_TBL_SZ = 2048,
	ATA_PRD_EOT = 2147483648,
	ATA_DMA_TABLE_OFS = 4,
	ATA_DMA_STATUS = 2,
	ATA_DMA_CMD = 0,
	ATA_DMA_WR = 8,
	ATA_DMA_START = 1,
	ATA_DMA_INTR = 4,
	ATA_DMA_ERR = 2,
	ATA_DMA_ACTIVE = 1,
	ATA_HOB = 128,
	ATA_NIEN = 2,
	ATA_LBA = 64,
	ATA_DEV1 = 16,
	ATA_DEVICE_OBS = 160,
	ATA_DEVCTL_OBS = 8,
	ATA_BUSY = 128,
	ATA_DRDY = 64,
	ATA_DF = 32,
	ATA_DSC = 16,
	ATA_DRQ = 8,
	ATA_CORR = 4,
	ATA_SENSE = 2,
	ATA_ERR = 1,
	ATA_SRST = 4,
	ATA_ICRC = 128,
	ATA_BBK = 128,
	ATA_UNC = 64,
	ATA_MC = 32,
	ATA_IDNF = 16,
	ATA_MCR = 8,
	ATA_ABORTED = 4,
	ATA_TRK0NF = 2,
	ATA_AMNF = 1,
	ATAPI_LFS = 240,
	ATAPI_EOM = 2,
	ATAPI_ILI = 1,
	ATAPI_IO = 2,
	ATAPI_COD = 1,
	ATA_REG_DATA = 0,
	ATA_REG_ERR = 1,
	ATA_REG_NSECT = 2,
	ATA_REG_LBAL = 3,
	ATA_REG_LBAM = 4,
	ATA_REG_LBAH = 5,
	ATA_REG_DEVICE = 6,
	ATA_REG_STATUS = 7,
	ATA_REG_FEATURE = 1,
	ATA_REG_CMD = 7,
	ATA_REG_BYTEL = 4,
	ATA_REG_BYTEH = 5,
	ATA_REG_DEVSEL = 6,
	ATA_REG_IRQ = 2,
	ATA_CMD_DEV_RESET = 8,
	ATA_CMD_CHK_POWER = 229,
	ATA_CMD_STANDBY = 226,
	ATA_CMD_IDLE = 227,
	ATA_CMD_EDD = 144,
	ATA_CMD_DOWNLOAD_MICRO = 146,
	ATA_CMD_DOWNLOAD_MICRO_DMA = 147,
	ATA_CMD_NOP = 0,
	ATA_CMD_FLUSH = 231,
	ATA_CMD_FLUSH_EXT = 234,
	ATA_CMD_ID_ATA = 236,
	ATA_CMD_ID_ATAPI = 161,
	ATA_CMD_SERVICE = 162,
	ATA_CMD_READ = 200,
	ATA_CMD_READ_EXT = 37,
	ATA_CMD_READ_QUEUED = 38,
	ATA_CMD_READ_STREAM_EXT = 43,
	ATA_CMD_READ_STREAM_DMA_EXT = 42,
	ATA_CMD_WRITE = 202,
	ATA_CMD_WRITE_EXT = 53,
	ATA_CMD_WRITE_QUEUED = 54,
	ATA_CMD_WRITE_STREAM_EXT = 59,
	ATA_CMD_WRITE_STREAM_DMA_EXT = 58,
	ATA_CMD_WRITE_FUA_EXT = 61,
	ATA_CMD_WRITE_QUEUED_FUA_EXT = 62,
	ATA_CMD_FPDMA_READ = 96,
	ATA_CMD_FPDMA_WRITE = 97,
	ATA_CMD_NCQ_NON_DATA = 99,
	ATA_CMD_FPDMA_SEND = 100,
	ATA_CMD_FPDMA_RECV = 101,
	ATA_CMD_PIO_READ = 32,
	ATA_CMD_PIO_READ_EXT = 36,
	ATA_CMD_PIO_WRITE = 48,
	ATA_CMD_PIO_WRITE_EXT = 52,
	ATA_CMD_READ_MULTI = 196,
	ATA_CMD_READ_MULTI_EXT = 41,
	ATA_CMD_WRITE_MULTI = 197,
	ATA_CMD_WRITE_MULTI_EXT = 57,
	ATA_CMD_WRITE_MULTI_FUA_EXT = 206,
	ATA_CMD_SET_FEATURES = 239,
	ATA_CMD_SET_MULTI = 198,
	ATA_CMD_PACKET = 160,
	ATA_CMD_VERIFY = 64,
	ATA_CMD_VERIFY_EXT = 66,
	ATA_CMD_WRITE_UNCORR_EXT = 69,
	ATA_CMD_STANDBYNOW1 = 224,
	ATA_CMD_IDLEIMMEDIATE = 225,
	ATA_CMD_SLEEP = 230,
	ATA_CMD_INIT_DEV_PARAMS = 145,
	ATA_CMD_READ_NATIVE_MAX = 248,
	ATA_CMD_READ_NATIVE_MAX_EXT = 39,
	ATA_CMD_SET_MAX = 249,
	ATA_CMD_SET_MAX_EXT = 55,
	ATA_CMD_READ_LOG_EXT = 47,
	ATA_CMD_WRITE_LOG_EXT = 63,
	ATA_CMD_READ_LOG_DMA_EXT = 71,
	ATA_CMD_WRITE_LOG_DMA_EXT = 87,
	ATA_CMD_TRUSTED_NONDATA = 91,
	ATA_CMD_TRUSTED_RCV = 92,
	ATA_CMD_TRUSTED_RCV_DMA = 93,
	ATA_CMD_TRUSTED_SND = 94,
	ATA_CMD_TRUSTED_SND_DMA = 95,
	ATA_CMD_PMP_READ = 228,
	ATA_CMD_PMP_READ_DMA = 233,
	ATA_CMD_PMP_WRITE = 232,
	ATA_CMD_PMP_WRITE_DMA = 235,
	ATA_CMD_CONF_OVERLAY = 177,
	ATA_CMD_SEC_SET_PASS = 241,
	ATA_CMD_SEC_UNLOCK = 242,
	ATA_CMD_SEC_ERASE_PREP = 243,
	ATA_CMD_SEC_ERASE_UNIT = 244,
	ATA_CMD_SEC_FREEZE_LOCK = 245,
	ATA_CMD_SEC_DISABLE_PASS = 246,
	ATA_CMD_CONFIG_STREAM = 81,
	ATA_CMD_SMART = 176,
	ATA_CMD_MEDIA_LOCK = 222,
	ATA_CMD_MEDIA_UNLOCK = 223,
	ATA_CMD_DSM = 6,
	ATA_CMD_CHK_MED_CRD_TYP = 209,
	ATA_CMD_CFA_REQ_EXT_ERR = 3,
	ATA_CMD_CFA_WRITE_NE = 56,
	ATA_CMD_CFA_TRANS_SECT = 135,
	ATA_CMD_CFA_ERASE = 192,
	ATA_CMD_CFA_WRITE_MULT_NE = 205,
	ATA_CMD_REQ_SENSE_DATA = 11,
	ATA_CMD_SANITIZE_DEVICE = 180,
	ATA_CMD_ZAC_MGMT_IN = 74,
	ATA_CMD_ZAC_MGMT_OUT = 159,
	ATA_CMD_RESTORE = 16,
	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 1,
	ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN = 2,
	ATA_SUBCMD_FPDMA_SEND_DSM = 0,
	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 2,
	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE = 0,
	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 5,
	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT = 6,
	ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT = 7,
	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0,
	ATA_SUBCMD_ZAC_MGMT_OUT_CLOSE_ZONE = 1,
	ATA_SUBCMD_ZAC_MGMT_OUT_FINISH_ZONE = 2,
	ATA_SUBCMD_ZAC_MGMT_OUT_OPEN_ZONE = 3,
	ATA_SUBCMD_ZAC_MGMT_OUT_RESET_WRITE_POINTER = 4,
	ATA_LOG_DIRECTORY = 0,
	ATA_LOG_SATA_NCQ = 16,
	ATA_LOG_NCQ_NON_DATA = 18,
	ATA_LOG_NCQ_SEND_RECV = 19,
	ATA_LOG_IDENTIFY_DEVICE = 48,
	ATA_LOG_SECURITY = 6,
	ATA_LOG_SATA_SETTINGS = 8,
	ATA_LOG_ZONED_INFORMATION = 9,
	ATA_LOG_DEVSLP_OFFSET = 48,
	ATA_LOG_DEVSLP_SIZE = 8,
	ATA_LOG_DEVSLP_MDAT = 0,
	ATA_LOG_DEVSLP_MDAT_MASK = 31,
	ATA_LOG_DEVSLP_DETO = 1,
	ATA_LOG_DEVSLP_VALID = 7,
	ATA_LOG_DEVSLP_VALID_MASK = 128,
	ATA_LOG_NCQ_PRIO_OFFSET = 9,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_DSM = 1,
	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET = 4,
	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM = 1,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET = 8,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET = 12,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET = 16,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OUT_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED = 2,
	ATA_LOG_NCQ_SEND_RECV_SIZE = 20,
	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_NCQ = 1,
	ATA_LOG_NCQ_NON_DATA_ABORT_ALL = 2,
	ATA_LOG_NCQ_NON_DATA_ABORT_STREAMING = 4,
	ATA_LOG_NCQ_NON_DATA_ABORT_NON_STREAMING = 8,
	ATA_LOG_NCQ_NON_DATA_ABORT_SELECTED = 16,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET = 28,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT = 1,
	ATA_LOG_NCQ_NON_DATA_SIZE = 64,
	ATA_CMD_READ_LONG = 34,
	ATA_CMD_READ_LONG_ONCE = 35,
	ATA_CMD_WRITE_LONG = 50,
	ATA_CMD_WRITE_LONG_ONCE = 51,
	SETFEATURES_XFER = 3,
	XFER_UDMA_7 = 71,
	XFER_UDMA_6 = 70,
	XFER_UDMA_5 = 69,
	XFER_UDMA_4 = 68,
	XFER_UDMA_3 = 67,
	XFER_UDMA_2 = 66,
	XFER_UDMA_1 = 65,
	XFER_UDMA_0 = 64,
	XFER_MW_DMA_4 = 36,
	XFER_MW_DMA_3 = 35,
	XFER_MW_DMA_2 = 34,
	XFER_MW_DMA_1 = 33,
	XFER_MW_DMA_0 = 32,
	XFER_SW_DMA_2 = 18,
	XFER_SW_DMA_1 = 17,
	XFER_SW_DMA_0 = 16,
	XFER_PIO_6 = 14,
	XFER_PIO_5 = 13,
	XFER_PIO_4 = 12,
	XFER_PIO_3 = 11,
	XFER_PIO_2 = 10,
	XFER_PIO_1 = 9,
	XFER_PIO_0 = 8,
	XFER_PIO_SLOW = 0,
	SETFEATURES_WC_ON = 2,
	SETFEATURES_WC_OFF = 130,
	SETFEATURES_RA_ON = 170,
	SETFEATURES_RA_OFF = 85,
	SETFEATURES_AAM_ON = 66,
	SETFEATURES_AAM_OFF = 194,
	SETFEATURES_SPINUP = 7,
	SETFEATURES_SPINUP_TIMEOUT = 30000,
	SETFEATURES_SATA_ENABLE = 16,
	SETFEATURES_SATA_DISABLE = 144,
	SATA_FPDMA_OFFSET = 1,
	SATA_FPDMA_AA = 2,
	SATA_DIPM = 3,
	SATA_FPDMA_IN_ORDER = 4,
	SATA_AN = 5,
	SATA_SSP = 6,
	SATA_DEVSLP = 9,
	SETFEATURE_SENSE_DATA = 195,
	ATA_SET_MAX_ADDR = 0,
	ATA_SET_MAX_PASSWD = 1,
	ATA_SET_MAX_LOCK = 2,
	ATA_SET_MAX_UNLOCK = 3,
	ATA_SET_MAX_FREEZE_LOCK = 4,
	ATA_SET_MAX_PASSWD_DMA = 5,
	ATA_SET_MAX_UNLOCK_DMA = 6,
	ATA_DCO_RESTORE = 192,
	ATA_DCO_FREEZE_LOCK = 193,
	ATA_DCO_IDENTIFY = 194,
	ATA_DCO_SET = 195,
	ATA_SMART_ENABLE = 216,
	ATA_SMART_READ_VALUES = 208,
	ATA_SMART_READ_THRESHOLDS = 209,
	ATA_DSM_TRIM = 1,
	ATA_SMART_LBAM_PASS = 79,
	ATA_SMART_LBAH_PASS = 194,
	ATAPI_PKT_DMA = 1,
	ATAPI_DMADIR = 4,
	ATAPI_CDB_LEN = 16,
	SATA_PMP_MAX_PORTS = 15,
	SATA_PMP_CTRL_PORT = 15,
	SATA_PMP_GSCR_DWORDS = 128,
	SATA_PMP_GSCR_PROD_ID = 0,
	SATA_PMP_GSCR_REV = 1,
	SATA_PMP_GSCR_PORT_INFO = 2,
	SATA_PMP_GSCR_ERROR = 32,
	SATA_PMP_GSCR_ERROR_EN = 33,
	SATA_PMP_GSCR_FEAT = 64,
	SATA_PMP_GSCR_FEAT_EN = 96,
	SATA_PMP_PSCR_STATUS = 0,
	SATA_PMP_PSCR_ERROR = 1,
	SATA_PMP_PSCR_CONTROL = 2,
	SATA_PMP_FEAT_BIST = 1,
	SATA_PMP_FEAT_PMREQ = 2,
	SATA_PMP_FEAT_DYNSSC = 4,
	SATA_PMP_FEAT_NOTIFY = 8,
	ATA_CBL_NONE = 0,
	ATA_CBL_PATA40 = 1,
	ATA_CBL_PATA80 = 2,
	ATA_CBL_PATA40_SHORT = 3,
	ATA_CBL_PATA_UNK = 4,
	ATA_CBL_PATA_IGN = 5,
	ATA_CBL_SATA = 6,
	SCR_STATUS = 0,
	SCR_ERROR = 1,
	SCR_CONTROL = 2,
	SCR_ACTIVE = 3,
	SCR_NOTIFICATION = 4,
	SERR_DATA_RECOVERED = 1,
	SERR_COMM_RECOVERED = 2,
	SERR_DATA = 256,
	SERR_PERSISTENT = 512,
	SERR_PROTOCOL = 1024,
	SERR_INTERNAL = 2048,
	SERR_PHYRDY_CHG = 65536,
	SERR_PHY_INT_ERR = 131072,
	SERR_COMM_WAKE = 262144,
	SERR_10B_8B_ERR = 524288,
	SERR_DISPARITY = 1048576,
	SERR_CRC = 2097152,
	SERR_HANDSHAKE = 4194304,
	SERR_LINK_SEQ_ERR = 8388608,
	SERR_TRANS_ST_ERROR = 16777216,
	SERR_UNRECOG_FIS = 33554432,
	SERR_DEV_XCHG = 67108864,
};

union ide_reg_valid_s {
	unsigned int all: 16;
	struct {
		unsigned int data: 1;
		unsigned int error_feature: 1;
		unsigned int sector: 1;
		unsigned int nsector: 1;
		unsigned int lcyl: 1;
		unsigned int hcyl: 1;
		unsigned int select: 1;
		unsigned int status_command: 1;
		unsigned int data_hob: 1;
		unsigned int error_feature_hob: 1;
		unsigned int sector_hob: 1;
		unsigned int nsector_hob: 1;
		unsigned int lcyl_hob: 1;
		unsigned int hcyl_hob: 1;
		unsigned int select_hob: 1;
		unsigned int control_hob: 1;
	} b;
};

typedef union ide_reg_valid_s ide_reg_valid_t;

struct ide_task_request_s {
	__u8 io_ports[8];
	__u8 hob_ports[8];
	ide_reg_valid_t out_flags;
	ide_reg_valid_t in_flags;
	int data_phase;
	int req_cmd;
	long unsigned int out_size;
	long unsigned int in_size;
};

typedef struct ide_task_request_s ide_task_request_t;

enum {
	LIBATA_MAX_PRD = 128,
	LIBATA_DUMB_MAX_PRD = 64,
	ATA_DEF_QUEUE = 1,
	ATA_MAX_QUEUE = 32,
	ATA_TAG_INTERNAL = 32,
	ATA_SHORT_PAUSE = 16,
	ATAPI_MAX_DRAIN = 16384,
	ATA_ALL_DEVICES = 3,
	ATA_SHT_EMULATED = 1,
	ATA_SHT_THIS_ID = 4294967295,
	ATA_TFLAG_LBA48 = 1,
	ATA_TFLAG_ISADDR = 2,
	ATA_TFLAG_DEVICE = 4,
	ATA_TFLAG_WRITE = 8,
	ATA_TFLAG_LBA = 16,
	ATA_TFLAG_FUA = 32,
	ATA_TFLAG_POLLING = 64,
	ATA_DFLAG_LBA = 1,
	ATA_DFLAG_LBA48 = 2,
	ATA_DFLAG_CDB_INTR = 4,
	ATA_DFLAG_NCQ = 8,
	ATA_DFLAG_FLUSH_EXT = 16,
	ATA_DFLAG_ACPI_PENDING = 32,
	ATA_DFLAG_ACPI_FAILED = 64,
	ATA_DFLAG_AN = 128,
	ATA_DFLAG_TRUSTED = 256,
	ATA_DFLAG_DMADIR = 1024,
	ATA_DFLAG_CFG_MASK = 4095,
	ATA_DFLAG_PIO = 4096,
	ATA_DFLAG_NCQ_OFF = 8192,
	ATA_DFLAG_SLEEPING = 32768,
	ATA_DFLAG_DUBIOUS_XFER = 65536,
	ATA_DFLAG_NO_UNLOAD = 131072,
	ATA_DFLAG_UNLOCK_HPA = 262144,
	ATA_DFLAG_NCQ_SEND_RECV = 524288,
	ATA_DFLAG_NCQ_PRIO = 1048576,
	ATA_DFLAG_NCQ_PRIO_ENABLE = 2097152,
	ATA_DFLAG_INIT_MASK = 16777215,
	ATA_DFLAG_DETACH = 16777216,
	ATA_DFLAG_DETACHED = 33554432,
	ATA_DFLAG_DA = 67108864,
	ATA_DFLAG_DEVSLP = 134217728,
	ATA_DFLAG_ACPI_DISABLED = 268435456,
	ATA_DFLAG_D_SENSE = 536870912,
	ATA_DFLAG_ZAC = 1073741824,
	ATA_DEV_UNKNOWN = 0,
	ATA_DEV_ATA = 1,
	ATA_DEV_ATA_UNSUP = 2,
	ATA_DEV_ATAPI = 3,
	ATA_DEV_ATAPI_UNSUP = 4,
	ATA_DEV_PMP = 5,
	ATA_DEV_PMP_UNSUP = 6,
	ATA_DEV_SEMB = 7,
	ATA_DEV_SEMB_UNSUP = 8,
	ATA_DEV_ZAC = 9,
	ATA_DEV_ZAC_UNSUP = 10,
	ATA_DEV_NONE = 11,
	ATA_LFLAG_NO_HRST = 2,
	ATA_LFLAG_NO_SRST = 4,
	ATA_LFLAG_ASSUME_ATA = 8,
	ATA_LFLAG_ASSUME_SEMB = 16,
	ATA_LFLAG_ASSUME_CLASS = 24,
	ATA_LFLAG_NO_RETRY = 32,
	ATA_LFLAG_DISABLED = 64,
	ATA_LFLAG_SW_ACTIVITY = 128,
	ATA_LFLAG_NO_LPM = 256,
	ATA_LFLAG_RST_ONCE = 512,
	ATA_LFLAG_CHANGED = 1024,
	ATA_LFLAG_NO_DB_DELAY = 2048,
	ATA_FLAG_SLAVE_POSS = 1,
	ATA_FLAG_SATA = 2,
	ATA_FLAG_NO_LPM = 4,
	ATA_FLAG_NO_LOG_PAGE = 32,
	ATA_FLAG_NO_ATAPI = 64,
	ATA_FLAG_PIO_DMA = 128,
	ATA_FLAG_PIO_LBA48 = 256,
	ATA_FLAG_PIO_POLLING = 512,
	ATA_FLAG_NCQ = 1024,
	ATA_FLAG_NO_POWEROFF_SPINDOWN = 2048,
	ATA_FLAG_NO_HIBERNATE_SPINDOWN = 4096,
	ATA_FLAG_DEBUGMSG = 8192,
	ATA_FLAG_FPDMA_AA = 16384,
	ATA_FLAG_IGN_SIMPLEX = 32768,
	ATA_FLAG_NO_IORDY = 65536,
	ATA_FLAG_ACPI_SATA = 131072,
	ATA_FLAG_AN = 262144,
	ATA_FLAG_PMP = 524288,
	ATA_FLAG_FPDMA_AUX = 1048576,
	ATA_FLAG_EM = 2097152,
	ATA_FLAG_SW_ACTIVITY = 4194304,
	ATA_FLAG_NO_DIPM = 8388608,
	ATA_FLAG_SAS_HOST = 16777216,
	ATA_PFLAG_EH_PENDING = 1,
	ATA_PFLAG_EH_IN_PROGRESS = 2,
	ATA_PFLAG_FROZEN = 4,
	ATA_PFLAG_RECOVERED = 8,
	ATA_PFLAG_LOADING = 16,
	ATA_PFLAG_SCSI_HOTPLUG = 64,
	ATA_PFLAG_INITIALIZING = 128,
	ATA_PFLAG_RESETTING = 256,
	ATA_PFLAG_UNLOADING = 512,
	ATA_PFLAG_UNLOADED = 1024,
	ATA_PFLAG_SUSPENDED = 131072,
	ATA_PFLAG_PM_PENDING = 262144,
	ATA_PFLAG_INIT_GTM_VALID = 524288,
	ATA_PFLAG_PIO32 = 1048576,
	ATA_PFLAG_PIO32CHANGE = 2097152,
	ATA_PFLAG_EXTERNAL = 4194304,
	ATA_QCFLAG_ACTIVE = 1,
	ATA_QCFLAG_DMAMAP = 2,
	ATA_QCFLAG_IO = 8,
	ATA_QCFLAG_RESULT_TF = 16,
	ATA_QCFLAG_CLEAR_EXCL = 32,
	ATA_QCFLAG_QUIET = 64,
	ATA_QCFLAG_RETRY = 128,
	ATA_QCFLAG_FAILED = 65536,
	ATA_QCFLAG_SENSE_VALID = 131072,
	ATA_QCFLAG_EH_SCHEDULED = 262144,
	ATA_HOST_SIMPLEX = 1,
	ATA_HOST_STARTED = 2,
	ATA_HOST_PARALLEL_SCAN = 4,
	ATA_HOST_IGNORE_ATA = 8,
	ATA_TMOUT_BOOT = 30000,
	ATA_TMOUT_BOOT_QUICK = 7000,
	ATA_TMOUT_INTERNAL_QUICK = 5000,
	ATA_TMOUT_MAX_PARK = 30000,
	ATA_TMOUT_FF_WAIT_LONG = 2000,
	ATA_TMOUT_FF_WAIT = 800,
	ATA_WAIT_AFTER_RESET = 150,
	ATA_TMOUT_PMP_SRST_WAIT = 5000,
	ATA_TMOUT_SPURIOUS_PHY = 10000,
	BUS_UNKNOWN = 0,
	BUS_DMA = 1,
	BUS_IDLE = 2,
	BUS_NOINTR = 3,
	BUS_NODATA = 4,
	BUS_TIMER = 5,
	BUS_PIO = 6,
	BUS_EDD = 7,
	BUS_IDENTIFY = 8,
	BUS_PACKET = 9,
	PORT_UNKNOWN = 0,
	PORT_ENABLED = 1,
	PORT_DISABLED = 2,
	ATA_NR_PIO_MODES = 7,
	ATA_NR_MWDMA_MODES = 5,
	ATA_NR_UDMA_MODES = 8,
	ATA_SHIFT_PIO = 0,
	ATA_SHIFT_MWDMA = 7,
	ATA_SHIFT_UDMA = 12,
	ATA_SHIFT_PRIO = 6,
	ATA_PRIO_HIGH = 2,
	ATA_DMA_PAD_SZ = 4,
	ATA_ERING_SIZE = 32,
	ATA_DEFER_LINK = 1,
	ATA_DEFER_PORT = 2,
	ATA_EH_DESC_LEN = 80,
	ATA_EH_REVALIDATE = 1,
	ATA_EH_SOFTRESET = 2,
	ATA_EH_HARDRESET = 4,
	ATA_EH_RESET = 6,
	ATA_EH_ENABLE_LINK = 8,
	ATA_EH_PARK = 32,
	ATA_EH_PERDEV_MASK = 33,
	ATA_EH_ALL_ACTIONS = 15,
	ATA_EHI_HOTPLUGGED = 1,
	ATA_EHI_NO_AUTOPSY = 4,
	ATA_EHI_QUIET = 8,
	ATA_EHI_NO_RECOVERY = 16,
	ATA_EHI_DID_SOFTRESET = 65536,
	ATA_EHI_DID_HARDRESET = 131072,
	ATA_EHI_PRINTINFO = 262144,
	ATA_EHI_SETMODE = 524288,
	ATA_EHI_POST_SETMODE = 1048576,
	ATA_EHI_DID_RESET = 196608,
	ATA_EHI_TO_SLAVE_MASK = 12,
	ATA_EH_MAX_TRIES = 5,
	ATA_LINK_RESUME_TRIES = 5,
	ATA_PROBE_MAX_TRIES = 3,
	ATA_EH_DEV_TRIES = 3,
	ATA_EH_PMP_TRIES = 5,
	ATA_EH_PMP_LINK_TRIES = 3,
	SATA_PMP_RW_TIMEOUT = 3000,
	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 6,
	ATA_HORKAGE_DIAGNOSTIC = 1,
	ATA_HORKAGE_NODMA = 2,
	ATA_HORKAGE_NONCQ = 4,
	ATA_HORKAGE_MAX_SEC_128 = 8,
	ATA_HORKAGE_BROKEN_HPA = 16,
	ATA_HORKAGE_DISABLE = 32,
	ATA_HORKAGE_HPA_SIZE = 64,
	ATA_HORKAGE_IVB = 256,
	ATA_HORKAGE_STUCK_ERR = 512,
	ATA_HORKAGE_BRIDGE_OK = 1024,
	ATA_HORKAGE_ATAPI_MOD16_DMA = 2048,
	ATA_HORKAGE_FIRMWARE_WARN = 4096,
	ATA_HORKAGE_1_5_GBPS = 8192,
	ATA_HORKAGE_NOSETXFER = 16384,
	ATA_HORKAGE_BROKEN_FPDMA_AA = 32768,
	ATA_HORKAGE_DUMP_ID = 65536,
	ATA_HORKAGE_MAX_SEC_LBA48 = 131072,
	ATA_HORKAGE_ATAPI_DMADIR = 262144,
	ATA_HORKAGE_NO_NCQ_TRIM = 524288,
	ATA_HORKAGE_NOLPM = 1048576,
	ATA_HORKAGE_WD_BROKEN_LPM = 2097152,
	ATA_HORKAGE_ZERO_AFTER_TRIM = 4194304,
	ATA_HORKAGE_NO_DMA_LOG = 8388608,
	ATA_HORKAGE_NOTRIM = 16777216,
	ATA_HORKAGE_MAX_SEC_1024 = 33554432,
	ATA_HORKAGE_MAX_TRIM_128M = 67108864,
	ATA_DMA_MASK_ATA = 1,
	ATA_DMA_MASK_ATAPI = 2,
	ATA_DMA_MASK_CFA = 4,
	ATAPI_READ = 0,
	ATAPI_WRITE = 1,
	ATAPI_READ_CD = 2,
	ATAPI_PASS_THRU = 3,
	ATAPI_MISC = 4,
	ATA_TIMING_SETUP = 1,
	ATA_TIMING_ACT8B = 2,
	ATA_TIMING_REC8B = 4,
	ATA_TIMING_CYC8B = 8,
	ATA_TIMING_8BIT = 14,
	ATA_TIMING_ACTIVE = 16,
	ATA_TIMING_RECOVER = 32,
	ATA_TIMING_DMACK_HOLD = 64,
	ATA_TIMING_CYCLE = 128,
	ATA_TIMING_UDMA = 256,
	ATA_TIMING_ALL = 511,
	ATA_ACPI_FILTER_SETXFER = 1,
	ATA_ACPI_FILTER_LOCK = 2,
	ATA_ACPI_FILTER_DIPM = 4,
	ATA_ACPI_FILTER_FPDMA_OFFSET = 8,
	ATA_ACPI_FILTER_FPDMA_AA = 16,
	ATA_ACPI_FILTER_DEFAULT = 7,
};

enum {
	AHCI_MAX_PORTS = 32,
	AHCI_MAX_CLKS = 5,
	AHCI_MAX_SG = 168,
	AHCI_DMA_BOUNDARY = 4294967295,
	AHCI_MAX_CMDS = 32,
	AHCI_CMD_SZ = 32,
	AHCI_CMD_SLOT_SZ = 1024,
	AHCI_RX_FIS_SZ = 256,
	AHCI_CMD_TBL_CDB = 64,
	AHCI_CMD_TBL_HDR_SZ = 128,
	AHCI_CMD_TBL_SZ = 2816,
	AHCI_CMD_TBL_AR_SZ = 90112,
	AHCI_PORT_PRIV_DMA_SZ = 91392,
	AHCI_PORT_PRIV_FBS_DMA_SZ = 95232,
	AHCI_IRQ_ON_SG = 2147483648,
	AHCI_CMD_ATAPI = 32,
	AHCI_CMD_WRITE = 64,
	AHCI_CMD_PREFETCH = 128,
	AHCI_CMD_RESET = 256,
	AHCI_CMD_CLR_BUSY = 1024,
	RX_FIS_PIO_SETUP = 32,
	RX_FIS_D2H_REG = 64,
	RX_FIS_SDB = 88,
	RX_FIS_UNK = 96,
	HOST_CAP = 0,
	HOST_CTL = 4,
	HOST_IRQ_STAT = 8,
	HOST_PORTS_IMPL = 12,
	HOST_VERSION = 16,
	HOST_EM_LOC = 28,
	HOST_EM_CTL = 32,
	HOST_CAP2 = 36,
	HOST_RESET = 1,
	HOST_IRQ_EN = 2,
	HOST_MRSM = 4,
	HOST_AHCI_EN = 2147483648,
	HOST_CAP_SXS = 32,
	HOST_CAP_EMS = 64,
	HOST_CAP_CCC = 128,
	HOST_CAP_PART = 8192,
	HOST_CAP_SSC = 16384,
	HOST_CAP_PIO_MULTI = 32768,
	HOST_CAP_FBS = 65536,
	HOST_CAP_PMP = 131072,
	HOST_CAP_ONLY = 262144,
	HOST_CAP_CLO = 16777216,
	HOST_CAP_LED = 33554432,
	HOST_CAP_ALPM = 67108864,
	HOST_CAP_SSS = 134217728,
	HOST_CAP_MPS = 268435456,
	HOST_CAP_SNTF = 536870912,
	HOST_CAP_NCQ = 1073741824,
	HOST_CAP_64 = 2147483648,
	HOST_CAP2_BOH = 1,
	HOST_CAP2_NVMHCI = 2,
	HOST_CAP2_APST = 4,
	HOST_CAP2_SDS = 8,
	HOST_CAP2_SADM = 16,
	HOST_CAP2_DESO = 32,
	PORT_LST_ADDR = 0,
	PORT_LST_ADDR_HI = 4,
	PORT_FIS_ADDR = 8,
	PORT_FIS_ADDR_HI = 12,
	PORT_IRQ_STAT = 16,
	PORT_IRQ_MASK = 20,
	PORT_CMD = 24,
	PORT_TFDATA = 32,
	PORT_SIG = 36,
	PORT_CMD_ISSUE = 56,
	PORT_SCR_STAT = 40,
	PORT_SCR_CTL = 44,
	PORT_SCR_ERR = 48,
	PORT_SCR_ACT = 52,
	PORT_SCR_NTF = 60,
	PORT_FBS = 64,
	PORT_DEVSLP = 68,
	PORT_IRQ_COLD_PRES = 2147483648,
	PORT_IRQ_TF_ERR = 1073741824,
	PORT_IRQ_HBUS_ERR = 536870912,
	PORT_IRQ_HBUS_DATA_ERR = 268435456,
	PORT_IRQ_IF_ERR = 134217728,
	PORT_IRQ_IF_NONFATAL = 67108864,
	PORT_IRQ_OVERFLOW = 16777216,
	PORT_IRQ_BAD_PMP = 8388608,
	PORT_IRQ_PHYRDY = 4194304,
	PORT_IRQ_DEV_ILCK = 128,
	PORT_IRQ_CONNECT = 64,
	PORT_IRQ_SG_DONE = 32,
	PORT_IRQ_UNK_FIS = 16,
	PORT_IRQ_SDB_FIS = 8,
	PORT_IRQ_DMAS_FIS = 4,
	PORT_IRQ_PIOS_FIS = 2,
	PORT_IRQ_D2H_REG_FIS = 1,
	PORT_IRQ_FREEZE = 683671632,
	PORT_IRQ_ERROR = 2025848912,
	DEF_PORT_IRQ = 2025848959,
	PORT_CMD_ASP = 134217728,
	PORT_CMD_ALPE = 67108864,
	PORT_CMD_ATAPI = 16777216,
	PORT_CMD_FBSCP = 4194304,
	PORT_CMD_ESP = 2097152,
	PORT_CMD_HPCP = 262144,
	PORT_CMD_PMP = 131072,
	PORT_CMD_LIST_ON = 32768,
	PORT_CMD_FIS_ON = 16384,
	PORT_CMD_FIS_RX = 16,
	PORT_CMD_CLO = 8,
	PORT_CMD_POWER_ON = 4,
	PORT_CMD_SPIN_UP = 2,
	PORT_CMD_START = 1,
	PORT_CMD_ICC_MASK = 4026531840,
	PORT_CMD_ICC_ACTIVE = 268435456,
	PORT_CMD_ICC_PARTIAL = 536870912,
	PORT_CMD_ICC_SLUMBER = 1610612736,
	PORT_FBS_DWE_OFFSET = 16,
	PORT_FBS_ADO_OFFSET = 12,
	PORT_FBS_DEV_OFFSET = 8,
	PORT_FBS_DEV_MASK = 3840,
	PORT_FBS_SDE = 4,
	PORT_FBS_DEC = 2,
	PORT_FBS_EN = 1,
	PORT_DEVSLP_DM_OFFSET = 25,
	PORT_DEVSLP_DM_MASK = 503316480,
	PORT_DEVSLP_DITO_OFFSET = 15,
	PORT_DEVSLP_MDAT_OFFSET = 10,
	PORT_DEVSLP_DETO_OFFSET = 2,
	PORT_DEVSLP_DSP = 2,
	PORT_DEVSLP_ADSE = 1,
	AHCI_HFLAG_NO_NCQ = 1,
	AHCI_HFLAG_IGN_IRQ_IF_ERR = 2,
	AHCI_HFLAG_IGN_SERR_INTERNAL = 4,
	AHCI_HFLAG_32BIT_ONLY = 8,
	AHCI_HFLAG_MV_PATA = 16,
	AHCI_HFLAG_NO_MSI = 32,
	AHCI_HFLAG_NO_PMP = 64,
	AHCI_HFLAG_SECT255 = 256,
	AHCI_HFLAG_YES_NCQ = 512,
	AHCI_HFLAG_NO_SUSPEND = 1024,
	AHCI_HFLAG_SRST_TOUT_IS_OFFLINE = 2048,
	AHCI_HFLAG_NO_SNTF = 4096,
	AHCI_HFLAG_NO_FPDMA_AA = 8192,
	AHCI_HFLAG_YES_FBS = 16384,
	AHCI_HFLAG_DELAY_ENGINE = 32768,
	AHCI_HFLAG_NO_DEVSLP = 131072,
	AHCI_HFLAG_NO_FBS = 262144,
	AHCI_HFLAG_MULTI_MSI = 1048576,
	AHCI_HFLAG_WAKE_BEFORE_STOP = 4194304,
	AHCI_HFLAG_YES_ALPM = 8388608,
	AHCI_HFLAG_NO_WRITE_TO_RO = 16777216,
	AHCI_HFLAG_IS_MOBILE = 33554432,
	AHCI_HFLAG_SUSPEND_PHYS = 67108864,
	AHCI_HFLAG_IGN_NOTSUPP_POWER_ON = 134217728,
	AHCI_HFLAG_NO_SXS = 268435456,
	AHCI_FLAG_COMMON = 393346,
	ICH_MAP = 144,
	PCS_6 = 146,
	PCS_7 = 148,
	EM_MAX_SLOTS = 8,
	EM_MAX_RETRY = 5,
	EM_CTL_RST = 512,
	EM_CTL_TM = 256,
	EM_CTL_MR = 1,
	EM_CTL_ALHD = 67108864,
	EM_CTL_XMT = 33554432,
	EM_CTL_SMB = 16777216,
	EM_CTL_SGPIO = 524288,
	EM_CTL_SES = 262144,
	EM_CTL_SAFTE = 131072,
	EM_CTL_LED = 65536,
	EM_MSG_TYPE_LED = 1,
	EM_MSG_TYPE_SAFTE = 2,
	EM_MSG_TYPE_SES2 = 4,
	EM_MSG_TYPE_SGPIO = 8,
};

enum {
	MTIP_PF_IC_ACTIVE_BIT = 0,
	MTIP_PF_EH_ACTIVE_BIT = 1,
	MTIP_PF_SE_ACTIVE_BIT = 2,
	MTIP_PF_DM_ACTIVE_BIT = 3,
	MTIP_PF_TO_ACTIVE_BIT = 9,
	MTIP_PF_PAUSE_IO = 527,
	MTIP_PF_HOST_CAP_64 = 10,
	MTIP_PF_SVC_THD_ACTIVE_BIT = 4,
	MTIP_PF_ISSUE_CMDS_BIT = 5,
	MTIP_PF_REBUILD_BIT = 6,
	MTIP_PF_SVC_THD_STOP_BIT = 8,
	MTIP_PF_SVC_THD_WORK = 866,
	MTIP_DDF_SEC_LOCK_BIT = 0,
	MTIP_DDF_REMOVE_PENDING_BIT = 1,
	MTIP_DDF_OVER_TEMP_BIT = 2,
	MTIP_DDF_WRITE_PROTECT_BIT = 3,
	MTIP_DDF_CLEANUP_BIT = 5,
	MTIP_DDF_RESUME_BIT = 6,
	MTIP_DDF_INIT_DONE_BIT = 7,
	MTIP_DDF_REBUILD_FAILED_BIT = 8,
	MTIP_DDF_REMOVAL_BIT = 9,
	MTIP_DDF_STOP_IO = 271,
};

struct smart_attr {
	u8 attr_id;
	__le16 flags;
	u8 cur;
	u8 worst;
	__le32 data;
	u8 res[3];
} __attribute__((packed));

struct mtip_work {
	struct work_struct work;
	void *port;
	int cpu_binding;
	u32 completed;
};

struct host_to_dev_fis {
	unsigned char type;
	unsigned char opts;
	unsigned char command;
	unsigned char features;
	union {
		unsigned char lba_low;
		unsigned char sector;
	};
	union {
		unsigned char lba_mid;
		unsigned char cyl_low;
	};
	union {
		unsigned char lba_hi;
		unsigned char cyl_hi;
	};
	union {
		unsigned char device;
		unsigned char head;
	};
	union {
		unsigned char lba_low_ex;
		unsigned char sector_ex;
	};
	union {
		unsigned char lba_mid_ex;
		unsigned char cyl_low_ex;
	};
	union {
		unsigned char lba_hi_ex;
		unsigned char cyl_hi_ex;
	};
	unsigned char features_ex;
	unsigned char sect_count;
	unsigned char sect_cnt_ex;
	unsigned char res2;
	unsigned char control;
	unsigned int res3;
};

struct mtip_cmd_hdr {
	__le32 opts;
	union {
		__le32 byte_count;
		__le32 status;
	};
	__le32 ctba;
	__le32 ctbau;
	u32 res[4];
};

struct mtip_cmd_sg {
	__le32 dba;
	__le32 dba_upper;
	__le32 reserved;
	__le32 info;
};

struct mtip_int_cmd {
	int fis_len;
	dma_addr_t buffer;
	int buf_len;
	u32 opts;
};

struct mtip_cmd {
	void *command;
	dma_addr_t command_dma;
	int scatter_ents;
	int unaligned;
	union {
		struct scatterlist sg[504];
		struct mtip_int_cmd *icmd;
	};
	int retries;
	int direction;
	blk_status_t status;
};

struct driver_data;

struct mtip_port {
	struct driver_data *dd;
	long unsigned int identify_valid;
	void *mmio;
	void *s_active[8];
	void *completed[8];
	void *cmd_issue[8];
	void *command_list;
	dma_addr_t command_list_dma;
	void *rxfis;
	dma_addr_t rxfis_dma;
	void *block1;
	dma_addr_t block1_dma;
	u16 *identify;
	dma_addr_t identify_dma;
	u16 *sector_buffer;
	dma_addr_t sector_buffer_dma;
	u16 *log_buf;
	dma_addr_t log_buf_dma;
	u8 *smart_buf;
	dma_addr_t smart_buf_dma;
	long unsigned int cmds_to_issue[4];
	wait_queue_head_t svc_wait;
	long unsigned int flags;
	long unsigned int ic_pause_timer;
	atomic_t cmd_slot_unal;
	spinlock_t cmd_issue_lock[8];
};

struct driver_data {
	void *mmio;
	int major;
	int instance;
	struct gendisk *disk;
	struct pci_dev *pdev;
	struct request_queue *queue;
	struct blk_mq_tag_set tags;
	struct mtip_port *port;
	unsigned int product_type;
	unsigned int slot_groups;
	long unsigned int index;
	long unsigned int dd_flag;
	struct task_struct *mtip_svc_handler;
	struct dentry *dfs_node;
	bool sr;
	int numa_node;
	char workq_name[32];
	struct workqueue_struct *isr_workq;
	atomic_t irq_workers_active;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct mtip_work work[8];
	int isr_binding;
	struct block_device *bdev;
	struct list_head online_list;
	struct list_head remove_list;
	int unal_qdepth;
	long: 32;
	long: 64;
};

struct mtip_compat_ide_task_request_s {
	__u8 io_ports[8];
	__u8 hob_ports[8];
	ide_reg_valid_t out_flags;
	ide_reg_valid_t in_flags;
	int data_phase;
	int req_cmd;
	compat_ulong_t out_size;
	compat_ulong_t in_size;
};

struct badrange {
	struct list_head list;
	spinlock_t lock;
};

struct nvdimm {
	long unsigned int flags;
	void *provider_data;
	long unsigned int cmd_mask;
	struct device dev;
	atomic_t busy;
	int id;
	int num_flush;
	struct resource *flush_wpq;
	const char *dimm_id;
	struct {
		const struct nvdimm_security_ops *ops;
		long unsigned int flags;
		long unsigned int ext_flags;
		unsigned int overwrite_tmo;
		struct kernfs_node *overwrite_state;
	} sec;
	struct delayed_work dwork;
};

struct nvdimm_bus {
	struct nvdimm_bus_descriptor *nd_desc;
	wait_queue_head_t wait;
	struct list_head list;
	struct device dev;
	int id;
	int probe_active;
	atomic_t ioctl_active;
	struct list_head mapping_list;
	struct mutex reconfig_mutex;
	struct badrange badrange;
};

enum {
	NSINDEX_SIG_LEN = 16,
	NSINDEX_ALIGN = 256,
	NSINDEX_SEQ_MASK = 3,
	NSLABEL_UUID_LEN = 16,
	NSLABEL_NAME_LEN = 64,
	NSLABEL_FLAG_ROLABEL = 1,
	NSLABEL_FLAG_LOCAL = 2,
	NSLABEL_FLAG_BTT = 4,
	NSLABEL_FLAG_UPDATING = 8,
	BTT_ALIGN = 4096,
	BTTINFO_SIG_LEN = 16,
	BTTINFO_UUID_LEN = 16,
	BTTINFO_FLAG_ERROR = 1,
	BTTINFO_MAJOR_VERSION = 1,
	ND_LABEL_MIN_SIZE = 1024,
	ND_LABEL_ID_SIZE = 50,
	ND_NSINDEX_INIT = 1,
};

struct nvdimm_map {
	struct nvdimm_bus *nvdimm_bus;
	struct list_head list;
	resource_size_t offset;
	long unsigned int flags;
	size_t size;
	union {
		void *mem;
		void *iomem;
	};
	struct kref kref;
};

struct badrange_entry {
	u64 start;
	u64 length;
	struct list_head list;
};

struct nvdimm_drvdata;

struct nd_mapping {
	struct nvdimm *nvdimm;
	u64 start;
	u64 size;
	int position;
	struct list_head labels;
	struct mutex lock;
	struct nvdimm_drvdata *ndd;
};

struct nd_percpu_lane;

struct nd_region {
	struct device dev;
	struct ida ns_ida;
	struct ida btt_ida;
	struct ida pfn_ida;
	struct ida dax_ida;
	long unsigned int flags;
	struct device *ns_seed;
	struct device *btt_seed;
	struct device *pfn_seed;
	struct device *dax_seed;
	u16 ndr_mappings;
	u64 ndr_size;
	u64 ndr_start;
	int id;
	int num_lanes;
	int ro;
	int numa_node;
	int target_node;
	void *provider_data;
	struct kernfs_node *bb_state;
	struct badblocks bb;
	struct nd_interleave_set *nd_set;
	struct nd_percpu_lane *lane;
	int (*flush)(struct nd_region *, struct bio *);
	struct nd_mapping mapping[0];
};

struct nd_cmd_get_config_size {
	__u32 status;
	__u32 config_size;
	__u32 max_xfer;
};

struct nd_cmd_vendor_hdr {
	__u32 opcode;
	__u32 in_length;
	__u8 in_buf[0];
};

enum nvdimm_claim_class {
	NVDIMM_CCLASS_NONE = 0,
	NVDIMM_CCLASS_BTT = 1,
	NVDIMM_CCLASS_BTT2 = 2,
	NVDIMM_CCLASS_PFN = 3,
	NVDIMM_CCLASS_DAX = 4,
	NVDIMM_CCLASS_UNKNOWN = 5,
};

struct nd_device_driver {
	struct device_driver drv;
	long unsigned int type;
	int (*probe)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	void (*notify)(struct device *, enum nvdimm_event);
};

struct nd_namespace_common {
	int force_raw;
	struct device dev;
	struct device *claim;
	enum nvdimm_claim_class claim_class;
	int (*rw_bytes)(struct nd_namespace_common *, resource_size_t, void *, size_t, int, long unsigned int);
};

struct nd_namespace_io {
	struct nd_namespace_common common;
	struct resource res;
	resource_size_t size;
	void *addr;
	struct badblocks bb;
};

struct nvdimm_drvdata {
	struct device *dev;
	int nslabel_size;
	struct nd_cmd_get_config_size nsarea;
	void *data;
	int ns_current;
	int ns_next;
	struct resource dpa;
	struct kref kref;
};

struct nd_percpu_lane {
	int count;
	spinlock_t lock;
};

struct btt;

struct nd_btt {
	struct device dev;
	struct nd_namespace_common *ndns;
	struct btt *btt;
	long unsigned int lbasize;
	u64 size;
	u8 *uuid;
	int id;
	int initial_offset;
	u16 version_major;
	u16 version_minor;
};

enum nd_pfn_mode {
	PFN_MODE_NONE = 0,
	PFN_MODE_RAM = 1,
	PFN_MODE_PMEM = 2,
};

struct nd_pfn_sb;

struct nd_pfn {
	int id;
	u8 *uuid;
	struct device dev;
	long unsigned int align;
	long unsigned int npfns;
	enum nd_pfn_mode mode;
	struct nd_pfn_sb *pfn_sb;
	struct nd_namespace_common *ndns;
};

struct nd_pfn_sb {
	u8 signature[16];
	u8 uuid[16];
	u8 parent_uuid[16];
	__le32 flags;
	__le16 version_major;
	__le16 version_minor;
	__le64 dataoff;
	__le64 npfns;
	__le32 mode;
	__le32 start_pad;
	__le32 end_trunc;
	__le32 align;
	__le32 page_size;
	__le16 page_struct_size;
	u8 padding[3994];
	__le64 checksum;
};

struct nd_dax {
	struct nd_pfn nd_pfn;
};

enum nd_async_mode {
	ND_SYNC = 0,
	ND_ASYNC = 1,
};

struct clear_badblocks_context {
	resource_size_t phys;
	resource_size_t cleared;
};

enum nd_ioctl_mode {
	BUS_IOCTL = 0,
	DIMM_IOCTL = 1,
};

struct nd_blk_region {
	int (*enable)(struct nvdimm_bus *, struct device *);
	int (*do_io)(struct nd_blk_region *, resource_size_t, void *, u64, int);
	void *blk_provider_data;
	struct nd_region nd_region;
};

struct nd_label_id {
	char id[50];
};

struct blk_alloc_info {
	struct nd_mapping *nd_mapping;
	resource_size_t available;
	resource_size_t busy;
	struct resource *res;
};

enum nd_driver_flags {
	ND_DRIVER_DIMM = 2,
	ND_DRIVER_REGION_PMEM = 4,
	ND_DRIVER_REGION_BLK = 8,
	ND_DRIVER_NAMESPACE_IO = 16,
	ND_DRIVER_NAMESPACE_PMEM = 32,
	ND_DRIVER_NAMESPACE_BLK = 64,
	ND_DRIVER_DAX_PMEM = 128,
};

struct nd_namespace_index {
	u8 sig[16];
	u8 flags[3];
	u8 labelsize;
	__le32 seq;
	__le64 myoff;
	__le64 mysize;
	__le64 otheroff;
	__le64 labeloff;
	__le32 nslot;
	__le16 major;
	__le16 minor;
	__le64 checksum;
	u8 free[0];
};

struct nd_namespace_label {
	u8 uuid[16];
	u8 name[64];
	__le32 flags;
	__le16 nlabel;
	__le16 position;
	__le64 isetcookie;
	__le64 lbasize;
	__le64 dpa;
	__le64 rawsize;
	__le32 slot;
	u8 align;
	u8 reserved[3];
	guid_t type_guid;
	guid_t abstraction_guid;
	u8 reserved2[88];
	__le64 checksum;
};

enum {
	ND_MAX_LANES = 256,
	INT_LBASIZE_ALIGNMENT = 64,
	NVDIMM_IO_ATOMIC = 1,
};

struct nd_region_data {
	int ns_count;
	int ns_active;
	unsigned int hints_shift;
	void *flush_wpq[0];
};

struct nd_label_ent {
	struct list_head list;
	long unsigned int flags;
	struct nd_namespace_label *label;
};

struct conflict_context {
	struct nd_region *nd_region;
	resource_size_t start;
	resource_size_t size;
};

enum {
	ND_MIN_NAMESPACE_SIZE = 4096,
};

struct nd_namespace_pmem {
	struct nd_namespace_io nsio;
	long unsigned int lbasize;
	char *alt_name;
	u8 *uuid;
	int id;
};

struct nd_namespace_blk {
	struct nd_namespace_common common;
	char *alt_name;
	u8 *uuid;
	int id;
	long unsigned int lbasize;
	resource_size_t size;
	int num_resources;
	struct resource **res;
};

enum nd_label_flags {
	ND_LABEL_REAP = 0,
};

enum alloc_loc {
	ALLOC_ERR = 0,
	ALLOC_BEFORE = 1,
	ALLOC_MID = 2,
	ALLOC_AFTER = 3,
};

struct btt {
	struct gendisk *btt_disk;
	struct request_queue *btt_queue;
	struct list_head arena_list;
	struct dentry *debugfs_dir;
	struct nd_btt *nd_btt;
	u64 nlba;
	long long unsigned int rawsize;
	u32 lbasize;
	u32 sector_size;
	struct nd_region *nd_region;
	struct mutex init_lock;
	int init_state;
	int num_arenas;
	struct badblocks *phys_bb;
};

struct nd_gen_sb {
	char reserved[4088];
	__le64 checksum;
};

struct btt_sb {
	u8 signature[16];
	u8 uuid[16];
	u8 parent_uuid[16];
	__le32 flags;
	__le16 version_major;
	__le16 version_minor;
	__le32 external_lbasize;
	__le32 external_nlba;
	__le32 internal_lbasize;
	__le32 internal_nlba;
	__le32 nfree;
	__le32 infosize;
	__le64 nextoff;
	__le64 dataoff;
	__le64 mapoff;
	__le64 logoff;
	__le64 info2off;
	u8 padding[3968];
	__le64 checksum;
};

enum nvdimmsec_op_ids {
	OP_FREEZE = 0,
	OP_DISABLE = 1,
	OP_UPDATE = 2,
	OP_ERASE = 3,
	OP_OVERWRITE = 4,
	OP_MASTER_UPDATE = 5,
	OP_MASTER_ERASE = 6,
};

struct dax_operations {
	long int (*direct_access)(struct dax_device *, long unsigned int, long int, void **, pfn_t *);
	bool (*dax_supported)(struct dax_device *, struct block_device *, int, sector_t, sector_t);
	size_t (*copy_from_iter)(struct dax_device *, long unsigned int, void *, size_t, struct iov_iter *);
	size_t (*copy_to_iter)(struct dax_device *, long unsigned int, void *, size_t, struct iov_iter *);
};

struct pmem_device {
	phys_addr_t phys_addr;
	phys_addr_t data_offset;
	u64 pfn_flags;
	void *virt_addr;
	size_t size;
	u32 pfn_pad;
	struct kernfs_node *bb_state;
	struct badblocks bb;
	struct dax_device *dax_dev;
	struct gendisk *disk;
	struct dev_pagemap pgmap;
};

enum btt_init_state {
	INIT_UNCHECKED = 0,
	INIT_NOTFOUND = 1,
	INIT_READY = 2,
};

struct log_entry {
	__le32 lba;
	__le32 old_map;
	__le32 new_map;
	__le32 seq;
};

struct log_group {
	struct log_entry ent[4];
};

struct free_entry {
	u32 block;
	u8 sub;
	u8 seq;
	u8 has_err;
};

struct aligned_lock {
	union {
		spinlock_t lock;
		u8 cacheline_padding[64];
	};
};

struct arena_info {
	u64 size;
	u64 external_lba_start;
	u32 internal_nlba;
	u32 internal_lbasize;
	u32 external_nlba;
	u32 external_lbasize;
	u32 nfree;
	u16 version_major;
	u16 version_minor;
	u32 sector_size;
	u64 nextoff;
	u64 infooff;
	u64 dataoff;
	u64 mapoff;
	u64 logoff;
	u64 info2off;
	struct free_entry *freelist;
	u32 *rtt;
	struct aligned_lock *map_locks;
	struct nd_btt *nd_btt;
	struct list_head list;
	struct dentry *debugfs_dir;
	u32 flags;
	struct mutex err_lock;
	int log_index[2];
};

enum log_ent_request {
	LOG_NEW_ENT = 0,
	LOG_OLD_ENT = 1,
};

struct dax_device {
	struct hlist_node list;
	struct inode inode;
	struct cdev cdev;
	const char *host;
	void *private;
	long unsigned int flags;
	const struct dax_operations *ops;
};

enum dax_device_flags {
	DAXDEV_ALIVE = 0,
	DAXDEV_WRITE_CACHE = 1,
	DAXDEV_SYNC = 2,
};

struct dax_region {
	int id;
	int target_node;
	struct kref kref;
	struct device *dev;
	unsigned int align;
	struct resource res;
	long long unsigned int pfn_flags;
};

struct dev_dax {
	struct dax_region *region;
	struct dax_device *dax_dev;
	int target_node;
	struct device dev;
	struct dev_pagemap pgmap;
	struct resource *dax_kmem_res;
};

enum dev_dax_subsys {
	DEV_DAX_BUS = 0,
	DEV_DAX_CLASS = 1,
};

struct dax_device_driver {
	struct device_driver drv;
	struct list_head ids;
	int match_always;
};

struct dax_id {
	struct list_head list;
	char dev_name[30];
};

enum id_action {
	ID_REMOVE = 0,
	ID_ADD = 1,
};

struct dma_fence_ops;

struct dma_fence {
	spinlock_t *lock;
	const struct dma_fence_ops *ops;
	union {
		struct list_head cb_list;
		ktime_t timestamp;
		struct callback_head rcu;
	};
	u64 context;
	u64 seqno;
	long unsigned int flags;
	struct kref refcount;
	int error;
};

struct dma_fence_ops {
	bool use_64bit_seqno;
	const char * (*get_driver_name)(struct dma_fence *);
	const char * (*get_timeline_name)(struct dma_fence *);
	bool (*enable_signaling)(struct dma_fence *);
	bool (*signaled)(struct dma_fence *);
	long int (*wait)(struct dma_fence *, bool, long int);
	void (*release)(struct dma_fence *);
	void (*fence_value_str)(struct dma_fence *, char *, int);
	void (*timeline_value_str)(struct dma_fence *, char *, int);
};

enum dma_fence_flag_bits {
	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
	DMA_FENCE_FLAG_USER_BITS = 3,
};

struct dma_fence_cb;

typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);

struct dma_fence_cb {
	struct list_head node;
	dma_fence_func_t func;
};

struct dma_buf;

struct dma_buf_attachment;

struct dma_buf_ops {
	bool cache_sgt_mapping;
	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
	void (*release)(struct dma_buf *);
	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
	void * (*map)(struct dma_buf *, long unsigned int);
	void (*unmap)(struct dma_buf *, long unsigned int, void *);
	void * (*vmap)(struct dma_buf *);
	void (*vunmap)(struct dma_buf *, void *);
};

struct dma_buf_poll_cb_t {
	struct dma_fence_cb cb;
	wait_queue_head_t *poll;
	__poll_t active;
};

struct dma_resv;

struct dma_buf {
	size_t size;
	struct file *file;
	struct list_head attachments;
	const struct dma_buf_ops *ops;
	struct mutex lock;
	unsigned int vmapping_counter;
	void *vmap_ptr;
	const char *exp_name;
	const char *name;
	spinlock_t name_lock;
	struct module *owner;
	struct list_head list_node;
	void *priv;
	struct dma_resv *resv;
	wait_queue_head_t poll;
	struct dma_buf_poll_cb_t cb_excl;
	struct dma_buf_poll_cb_t cb_shared;
};

struct dma_buf_attachment {
	struct dma_buf *dmabuf;
	struct device *dev;
	struct list_head node;
	struct sg_table *sgt;
	enum dma_data_direction dir;
	void *priv;
};

struct dma_resv_list;

struct dma_resv {
	struct ww_mutex lock;
	seqcount_t seq;
	struct dma_fence *fence_excl;
	struct dma_resv_list *fence;
};

struct dma_buf_export_info {
	const char *exp_name;
	struct module *owner;
	const struct dma_buf_ops *ops;
	size_t size;
	int flags;
	struct dma_resv *resv;
	void *priv;
};

struct dma_resv_list {
	struct callback_head rcu;
	u32 shared_count;
	u32 shared_max;
	struct dma_fence *shared[0];
};

struct dma_buf_sync {
	__u64 flags;
};

struct dma_buf_list {
	struct list_head head;
	struct mutex lock;
};

struct trace_event_raw_dma_fence {
	struct trace_entry ent;
	u32 __data_loc_driver;
	u32 __data_loc_timeline;
	unsigned int context;
	unsigned int seqno;
	char __data[0];
};

struct trace_event_data_offsets_dma_fence {
	u32 driver;
	u32 timeline;
};

typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);

struct default_wait_cb {
	struct dma_fence_cb base;
	struct task_struct *task;
};

struct dma_fence_array;

struct dma_fence_array_cb {
	struct dma_fence_cb cb;
	struct dma_fence_array *array;
};

struct dma_fence_array {
	struct dma_fence base;
	spinlock_t lock;
	unsigned int num_fences;
	atomic_t num_pending;
	struct dma_fence **fences;
	struct irq_work work;
};

struct dma_fence_chain {
	struct dma_fence base;
	spinlock_t lock;
	struct dma_fence *prev;
	u64 prev_seqno;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
	struct irq_work work;
};

struct ww_class {
	atomic_long_t stamp;
	struct lock_class_key acquire_key;
	struct lock_class_key mutex_key;
	const char *acquire_name;
	const char *mutex_name;
	unsigned int is_wait_die;
};

enum seqno_fence_condition {
	SEQNO_FENCE_WAIT_GEQUAL = 0,
	SEQNO_FENCE_WAIT_NONZERO = 1,
};

struct seqno_fence {
	struct dma_fence base;
	const struct dma_fence_ops *ops;
	struct dma_buf *sync_buf;
	uint32_t seqno_ofs;
	enum seqno_fence_condition condition;
};

struct sync_file {
	struct file *file;
	char user_name[32];
	struct list_head sync_file_list;
	wait_queue_head_t wq;
	long unsigned int flags;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct sync_merge_data {
	char name[32];
	__s32 fd2;
	__s32 fence;
	__u32 flags;
	__u32 pad;
};

struct sync_fence_info {
	char obj_name[32];
	char driver_name[32];
	__s32 status;
	__u32 flags;
	__u64 timestamp_ns;
};

struct sync_file_info {
	char name[32];
	__s32 status;
	__u32 flags;
	__u32 num_fences;
	__u32 pad;
	__u64 sync_fence_info;
};

struct nvme_user_io {
	__u8 opcode;
	__u8 flags;
	__u16 control;
	__u16 nblocks;
	__u16 rsvd;
	__u64 metadata;
	__u64 addr;
	__u64 slba;
	__u32 dsmgmt;
	__u32 reftag;
	__u16 apptag;
	__u16 appmask;
};

struct nvme_passthru_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 rsvd1;
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	__u32 data_len;
	__u32 cdw10;
	__u32 cdw11;
	__u32 cdw12;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u32 timeout_ms;
	__u32 result;
};

struct nvme_passthru_cmd64 {
	__u8 opcode;
	__u8 flags;
	__u16 rsvd1;
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	__u32 data_len;
	__u32 cdw10;
	__u32 cdw11;
	__u32 cdw12;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u32 timeout_ms;
	__u32 rsvd2;
	__u64 result;
};

struct nvme_id_power_state {
	__le16 max_power;
	__u8 rsvd2;
	__u8 flags;
	__le32 entry_lat;
	__le32 exit_lat;
	__u8 read_tput;
	__u8 read_lat;
	__u8 write_tput;
	__u8 write_lat;
	__le16 idle_power;
	__u8 idle_scale;
	__u8 rsvd19;
	__le16 active_power;
	__u8 active_work_scale;
	__u8 rsvd23[9];
};

enum {
	NVME_PS_FLAGS_MAX_POWER_SCALE = 1,
	NVME_PS_FLAGS_NON_OP_STATE = 2,
};

enum nvme_ctrl_attr {
	NVME_CTRL_ATTR_HID_128_BIT = 1,
	NVME_CTRL_ATTR_TBKAS = 64,
};

struct nvme_id_ctrl {
	__le16 vid;
	__le16 ssvid;
	char sn[20];
	char mn[40];
	char fr[8];
	__u8 rab;
	__u8 ieee[3];
	__u8 cmic;
	__u8 mdts;
	__le16 cntlid;
	__le32 ver;
	__le32 rtd3r;
	__le32 rtd3e;
	__le32 oaes;
	__le32 ctratt;
	__u8 rsvd100[28];
	__le16 crdt1;
	__le16 crdt2;
	__le16 crdt3;
	__u8 rsvd134[122];
	__le16 oacs;
	__u8 acl;
	__u8 aerl;
	__u8 frmw;
	__u8 lpa;
	__u8 elpe;
	__u8 npss;
	__u8 avscc;
	__u8 apsta;
	__le16 wctemp;
	__le16 cctemp;
	__le16 mtfa;
	__le32 hmpre;
	__le32 hmmin;
	__u8 tnvmcap[16];
	__u8 unvmcap[16];
	__le32 rpmbs;
	__le16 edstt;
	__u8 dsto;
	__u8 fwug;
	__le16 kas;
	__le16 hctma;
	__le16 mntmt;
	__le16 mxtmt;
	__le32 sanicap;
	__le32 hmminds;
	__le16 hmmaxd;
	__u8 rsvd338[4];
	__u8 anatt;
	__u8 anacap;
	__le32 anagrpmax;
	__le32 nanagrpid;
	__u8 rsvd352[160];
	__u8 sqes;
	__u8 cqes;
	__le16 maxcmd;
	__le32 nn;
	__le16 oncs;
	__le16 fuses;
	__u8 fna;
	__u8 vwc;
	__le16 awun;
	__le16 awupf;
	__u8 nvscc;
	__u8 nwpc;
	__le16 acwu;
	__u8 rsvd534[2];
	__le32 sgls;
	__le32 mnan;
	__u8 rsvd544[224];
	char subnqn[256];
	__u8 rsvd1024[768];
	__le32 ioccsz;
	__le32 iorcsz;
	__le16 icdoff;
	__u8 ctrattr;
	__u8 msdbd;
	__u8 rsvd1804[244];
	struct nvme_id_power_state psd[32];
	__u8 vs[1024];
};

enum {
	NVME_CTRL_ONCS_COMPARE = 1,
	NVME_CTRL_ONCS_WRITE_UNCORRECTABLE = 2,
	NVME_CTRL_ONCS_DSM = 4,
	NVME_CTRL_ONCS_WRITE_ZEROES = 8,
	NVME_CTRL_ONCS_TIMESTAMP = 64,
	NVME_CTRL_VWC_PRESENT = 1,
	NVME_CTRL_OACS_SEC_SUPP = 1,
	NVME_CTRL_OACS_DIRECTIVES = 32,
	NVME_CTRL_OACS_DBBUF_SUPP = 256,
	NVME_CTRL_LPA_CMD_EFFECTS_LOG = 2,
};

struct nvme_lbaf {
	__le16 ms;
	__u8 ds;
	__u8 rp;
};

struct nvme_id_ns {
	__le64 nsze;
	__le64 ncap;
	__le64 nuse;
	__u8 nsfeat;
	__u8 nlbaf;
	__u8 flbas;
	__u8 mc;
	__u8 dpc;
	__u8 dps;
	__u8 nmic;
	__u8 rescap;
	__u8 fpi;
	__u8 dlfeat;
	__le16 nawun;
	__le16 nawupf;
	__le16 nacwu;
	__le16 nabsn;
	__le16 nabo;
	__le16 nabspf;
	__le16 noiob;
	__u8 nvmcap[16];
	__le16 npwg;
	__le16 npwa;
	__le16 npdg;
	__le16 npda;
	__le16 nows;
	__u8 rsvd74[18];
	__le32 anagrpid;
	__u8 rsvd96[3];
	__u8 nsattr;
	__le16 nvmsetid;
	__le16 endgid;
	__u8 nguid[16];
	__u8 eui64[8];
	struct nvme_lbaf lbaf[16];
	__u8 rsvd192[192];
	__u8 vs[3712];
};

enum {
	NVME_ID_CNS_NS = 0,
	NVME_ID_CNS_CTRL = 1,
	NVME_ID_CNS_NS_ACTIVE_LIST = 2,
	NVME_ID_CNS_NS_DESC_LIST = 3,
	NVME_ID_CNS_NS_PRESENT_LIST = 16,
	NVME_ID_CNS_NS_PRESENT = 17,
	NVME_ID_CNS_CTRL_NS_LIST = 18,
	NVME_ID_CNS_CTRL_LIST = 19,
};

enum {
	NVME_DIR_IDENTIFY = 0,
	NVME_DIR_STREAMS = 1,
	NVME_DIR_SND_ID_OP_ENABLE = 1,
	NVME_DIR_SND_ST_OP_REL_ID = 1,
	NVME_DIR_SND_ST_OP_REL_RSC = 2,
	NVME_DIR_RCV_ID_OP_PARAM = 1,
	NVME_DIR_RCV_ST_OP_PARAM = 1,
	NVME_DIR_RCV_ST_OP_STATUS = 2,
	NVME_DIR_RCV_ST_OP_RESOURCE = 3,
	NVME_DIR_ENDIR = 1,
};

enum {
	NVME_NS_FEAT_THIN = 1,
	NVME_NS_FLBAS_LBA_MASK = 15,
	NVME_NS_FLBAS_META_EXT = 16,
	NVME_LBAF_RP_BEST = 0,
	NVME_LBAF_RP_BETTER = 1,
	NVME_LBAF_RP_GOOD = 2,
	NVME_LBAF_RP_DEGRADED = 3,
	NVME_NS_DPC_PI_LAST = 16,
	NVME_NS_DPC_PI_FIRST = 8,
	NVME_NS_DPC_PI_TYPE3 = 4,
	NVME_NS_DPC_PI_TYPE2 = 2,
	NVME_NS_DPC_PI_TYPE1 = 1,
	NVME_NS_DPS_PI_FIRST = 8,
	NVME_NS_DPS_PI_MASK = 7,
	NVME_NS_DPS_PI_TYPE1 = 1,
	NVME_NS_DPS_PI_TYPE2 = 2,
	NVME_NS_DPS_PI_TYPE3 = 3,
};

struct nvme_ns_id_desc {
	__u8 nidt;
	__u8 nidl;
	__le16 reserved;
};

enum {
	NVME_NIDT_EUI64 = 1,
	NVME_NIDT_NGUID = 2,
	NVME_NIDT_UUID = 3,
};

struct nvme_fw_slot_info_log {
	__u8 afi;
	__u8 rsvd1[7];
	__le64 frs[7];
	__u8 rsvd64[448];
};

enum {
	NVME_CMD_EFFECTS_CSUPP = 1,
	NVME_CMD_EFFECTS_LBCC = 2,
	NVME_CMD_EFFECTS_NCC = 4,
	NVME_CMD_EFFECTS_NIC = 8,
	NVME_CMD_EFFECTS_CCC = 16,
	NVME_CMD_EFFECTS_CSE_MASK = 196608,
};

struct nvme_effects_log {
	__le32 acs[256];
	__le32 iocs[256];
	__u8 resv[2048];
};

enum nvme_ana_state {
	NVME_ANA_OPTIMIZED = 1,
	NVME_ANA_NONOPTIMIZED = 2,
	NVME_ANA_INACCESSIBLE = 3,
	NVME_ANA_PERSISTENT_LOSS = 4,
	NVME_ANA_CHANGE = 15,
};

struct nvme_ana_rsp_hdr {
	__le64 chgcnt;
	__le16 ngrps;
	__le16 rsvd10[3];
};

enum {
	NVME_AER_ERROR = 0,
	NVME_AER_SMART = 1,
	NVME_AER_NOTICE = 2,
	NVME_AER_CSS = 6,
	NVME_AER_VS = 7,
};

enum {
	NVME_AER_NOTICE_NS_CHANGED = 0,
	NVME_AER_NOTICE_FW_ACT_STARTING = 1,
	NVME_AER_NOTICE_ANA = 3,
	NVME_AER_NOTICE_DISC_CHANGED = 240,
};

enum {
	NVME_AEN_CFG_NS_ATTR = 256,
	NVME_AEN_CFG_FW_ACT = 512,
	NVME_AEN_CFG_ANA_CHANGE = 2048,
	NVME_AEN_CFG_DISC_CHANGE = 2147483648,
};

enum nvme_opcode {
	nvme_cmd_flush = 0,
	nvme_cmd_write = 1,
	nvme_cmd_read = 2,
	nvme_cmd_write_uncor = 4,
	nvme_cmd_compare = 5,
	nvme_cmd_write_zeroes = 8,
	nvme_cmd_dsm = 9,
	nvme_cmd_resv_register = 13,
	nvme_cmd_resv_report = 14,
	nvme_cmd_resv_acquire = 17,
	nvme_cmd_resv_release = 21,
};

struct nvme_sgl_desc {
	__le64 addr;
	__le32 length;
	__u8 rsvd[3];
	__u8 type;
};

struct nvme_keyed_sgl_desc {
	__le64 addr;
	__u8 length[3];
	__u8 key[4];
	__u8 type;
};

union nvme_data_ptr {
	struct {
		__le64 prp1;
		__le64 prp2;
	};
	struct nvme_sgl_desc sgl;
	struct nvme_keyed_sgl_desc ksgl;
};

struct nvme_common_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le32 cdw2[2];
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le32 cdw10;
	__le32 cdw11;
	__le32 cdw12;
	__le32 cdw13;
	__le32 cdw14;
	__le32 cdw15;
};

struct nvme_rw_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2;
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le16 length;
	__le16 control;
	__le32 dsmgmt;
	__le32 reftag;
	__le16 apptag;
	__le16 appmask;
};

enum {
	NVME_RW_LR = 32768,
	NVME_RW_FUA = 16384,
	NVME_RW_DSM_FREQ_UNSPEC = 0,
	NVME_RW_DSM_FREQ_TYPICAL = 1,
	NVME_RW_DSM_FREQ_RARE = 2,
	NVME_RW_DSM_FREQ_READS = 3,
	NVME_RW_DSM_FREQ_WRITES = 4,
	NVME_RW_DSM_FREQ_RW = 5,
	NVME_RW_DSM_FREQ_ONCE = 6,
	NVME_RW_DSM_FREQ_PREFETCH = 7,
	NVME_RW_DSM_FREQ_TEMP = 8,
	NVME_RW_DSM_LATENCY_NONE = 0,
	NVME_RW_DSM_LATENCY_IDLE = 16,
	NVME_RW_DSM_LATENCY_NORM = 32,
	NVME_RW_DSM_LATENCY_LOW = 48,
	NVME_RW_DSM_SEQ_REQ = 64,
	NVME_RW_DSM_COMPRESSED = 128,
	NVME_RW_PRINFO_PRCHK_REF = 1024,
	NVME_RW_PRINFO_PRCHK_APP = 2048,
	NVME_RW_PRINFO_PRCHK_GUARD = 4096,
	NVME_RW_PRINFO_PRACT = 8192,
	NVME_RW_DTYPE_STREAMS = 16,
};

struct nvme_dsm_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 nr;
	__le32 attributes;
	__u32 rsvd12[4];
};

enum {
	NVME_DSMGMT_IDR = 1,
	NVME_DSMGMT_IDW = 2,
	NVME_DSMGMT_AD = 4,
};

struct nvme_dsm_range {
	__le32 cattr;
	__le32 nlb;
	__le64 slba;
};

struct nvme_write_zeroes_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2;
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le16 length;
	__le16 control;
	__le32 dsmgmt;
	__le32 reftag;
	__le16 apptag;
	__le16 appmask;
};

struct nvme_feat_auto_pst {
	__le64 entries[32];
};

struct nvme_feat_host_behavior {
	__u8 acre;
	__u8 resv1[511];
};

enum {
	NVME_ENABLE_ACRE = 1,
};

enum nvme_admin_opcode {
	nvme_admin_delete_sq = 0,
	nvme_admin_create_sq = 1,
	nvme_admin_get_log_page = 2,
	nvme_admin_delete_cq = 4,
	nvme_admin_create_cq = 5,
	nvme_admin_identify = 6,
	nvme_admin_abort_cmd = 8,
	nvme_admin_set_features = 9,
	nvme_admin_get_features = 10,
	nvme_admin_async_event = 12,
	nvme_admin_ns_mgmt = 13,
	nvme_admin_activate_fw = 16,
	nvme_admin_download_fw = 17,
	nvme_admin_ns_attach = 21,
	nvme_admin_keep_alive = 24,
	nvme_admin_directive_send = 25,
	nvme_admin_directive_recv = 26,
	nvme_admin_dbbuf = 124,
	nvme_admin_format_nvm = 128,
	nvme_admin_security_send = 129,
	nvme_admin_security_recv = 130,
	nvme_admin_sanitize_nvm = 132,
	nvme_admin_get_lba_status = 134,
};

enum {
	NVME_QUEUE_PHYS_CONTIG = 1,
	NVME_CQ_IRQ_ENABLED = 2,
	NVME_SQ_PRIO_URGENT = 0,
	NVME_SQ_PRIO_HIGH = 2,
	NVME_SQ_PRIO_MEDIUM = 4,
	NVME_SQ_PRIO_LOW = 6,
	NVME_FEAT_ARBITRATION = 1,
	NVME_FEAT_POWER_MGMT = 2,
	NVME_FEAT_LBA_RANGE = 3,
	NVME_FEAT_TEMP_THRESH = 4,
	NVME_FEAT_ERR_RECOVERY = 5,
	NVME_FEAT_VOLATILE_WC = 6,
	NVME_FEAT_NUM_QUEUES = 7,
	NVME_FEAT_IRQ_COALESCE = 8,
	NVME_FEAT_IRQ_CONFIG = 9,
	NVME_FEAT_WRITE_ATOMIC = 10,
	NVME_FEAT_ASYNC_EVENT = 11,
	NVME_FEAT_AUTO_PST = 12,
	NVME_FEAT_HOST_MEM_BUF = 13,
	NVME_FEAT_TIMESTAMP = 14,
	NVME_FEAT_KATO = 15,
	NVME_FEAT_HCTM = 16,
	NVME_FEAT_NOPSC = 17,
	NVME_FEAT_RRL = 18,
	NVME_FEAT_PLM_CONFIG = 19,
	NVME_FEAT_PLM_WINDOW = 20,
	NVME_FEAT_HOST_BEHAVIOR = 22,
	NVME_FEAT_SW_PROGRESS = 128,
	NVME_FEAT_HOST_ID = 129,
	NVME_FEAT_RESV_MASK = 130,
	NVME_FEAT_RESV_PERSIST = 131,
	NVME_FEAT_WRITE_PROTECT = 132,
	NVME_LOG_ERROR = 1,
	NVME_LOG_SMART = 2,
	NVME_LOG_FW_SLOT = 3,
	NVME_LOG_CHANGED_NS = 4,
	NVME_LOG_CMD_EFFECTS = 5,
	NVME_LOG_ANA = 12,
	NVME_LOG_DISC = 112,
	NVME_LOG_RESERVATION = 128,
	NVME_FWACT_REPL = 0,
	NVME_FWACT_REPL_ACTV = 8,
	NVME_FWACT_ACTV = 16,
};

struct nvme_identify {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__u8 cns;
	__u8 rsvd3;
	__le16 ctrlid;
	__u32 rsvd11[5];
};

struct nvme_features {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 fid;
	__le32 dword11;
	__le32 dword12;
	__le32 dword13;
	__le32 dword14;
	__le32 dword15;
};

struct nvme_create_cq {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__u64 rsvd8;
	__le16 cqid;
	__le16 qsize;
	__le16 cq_flags;
	__le16 irq_vector;
	__u32 rsvd12[4];
};

struct nvme_create_sq {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__u64 rsvd8;
	__le16 sqid;
	__le16 qsize;
	__le16 sq_flags;
	__le16 cqid;
	__u32 rsvd12[4];
};

struct nvme_delete_queue {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[9];
	__le16 qid;
	__u16 rsvd10;
	__u32 rsvd11[5];
};

struct nvme_abort_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[9];
	__le16 sqid;
	__u16 cid;
	__u32 rsvd11[5];
};

struct nvme_download_firmware {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	union nvme_data_ptr dptr;
	__le32 numd;
	__le32 offset;
	__u32 rsvd12[4];
};

struct nvme_format_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[4];
	__le32 cdw10;
	__u32 rsvd11[5];
};

struct nvme_get_log_page_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__u8 lid;
	__u8 lsp;
	__le16 numdl;
	__le16 numdu;
	__u16 rsvd11;
	union {
		struct {
			__le32 lpol;
			__le32 lpou;
		};
		__le64 lpo;
	};
	__u32 rsvd14[2];
};

struct nvme_directive_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 numd;
	__u8 doper;
	__u8 dtype;
	__le16 dspec;
	__u8 endir;
	__u8 tdtype;
	__u16 rsvd15;
	__u32 rsvd16[3];
};

enum nvmf_fabrics_opcode {
	nvme_fabrics_command = 127,
};

enum nvmf_capsule_command {
	nvme_fabrics_type_property_set = 0,
	nvme_fabrics_type_connect = 1,
	nvme_fabrics_type_property_get = 4,
};

struct nvmf_common_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 ts[24];
};

struct nvmf_connect_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[19];
	union nvme_data_ptr dptr;
	__le16 recfmt;
	__le16 qid;
	__le16 sqsize;
	__u8 cattr;
	__u8 resv3;
	__le32 kato;
	__u8 resv4[12];
};

struct nvmf_property_set_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 attrib;
	__u8 resv3[3];
	__le32 offset;
	__le64 value;
	__u8 resv4[8];
};

struct nvmf_property_get_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 attrib;
	__u8 resv3[3];
	__le32 offset;
	__u8 resv4[16];
};

struct nvme_dbbuf {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__le64 prp2;
	__u32 rsvd12[6];
};

struct streams_directive_params {
	__le16 msl;
	__le16 nssa;
	__le16 nsso;
	__u8 rsvd[10];
	__le32 sws;
	__le16 sgs;
	__le16 nsa;
	__le16 nso;
	__u8 rsvd2[6];
};

struct nvme_command {
	union {
		struct nvme_common_command common;
		struct nvme_rw_command rw;
		struct nvme_identify identify;
		struct nvme_features features;
		struct nvme_create_cq create_cq;
		struct nvme_create_sq create_sq;
		struct nvme_delete_queue delete_queue;
		struct nvme_download_firmware dlfw;
		struct nvme_format_cmd format;
		struct nvme_dsm_cmd dsm;
		struct nvme_write_zeroes_cmd write_zeroes;
		struct nvme_abort_cmd abort;
		struct nvme_get_log_page_command get_log_page;
		struct nvmf_common_command fabrics;
		struct nvmf_connect_command connect;
		struct nvmf_property_set_command prop_set;
		struct nvmf_property_get_command prop_get;
		struct nvme_dbbuf dbbuf;
		struct nvme_directive_cmd directive;
	};
};

enum {
	NVME_SC_SUCCESS = 0,
	NVME_SC_INVALID_OPCODE = 1,
	NVME_SC_INVALID_FIELD = 2,
	NVME_SC_CMDID_CONFLICT = 3,
	NVME_SC_DATA_XFER_ERROR = 4,
	NVME_SC_POWER_LOSS = 5,
	NVME_SC_INTERNAL = 6,
	NVME_SC_ABORT_REQ = 7,
	NVME_SC_ABORT_QUEUE = 8,
	NVME_SC_FUSED_FAIL = 9,
	NVME_SC_FUSED_MISSING = 10,
	NVME_SC_INVALID_NS = 11,
	NVME_SC_CMD_SEQ_ERROR = 12,
	NVME_SC_SGL_INVALID_LAST = 13,
	NVME_SC_SGL_INVALID_COUNT = 14,
	NVME_SC_SGL_INVALID_DATA = 15,
	NVME_SC_SGL_INVALID_METADATA = 16,
	NVME_SC_SGL_INVALID_TYPE = 17,
	NVME_SC_SGL_INVALID_OFFSET = 22,
	NVME_SC_SGL_INVALID_SUBTYPE = 23,
	NVME_SC_NS_WRITE_PROTECTED = 32,
	NVME_SC_LBA_RANGE = 128,
	NVME_SC_CAP_EXCEEDED = 129,
	NVME_SC_NS_NOT_READY = 130,
	NVME_SC_RESERVATION_CONFLICT = 131,
	NVME_SC_CQ_INVALID = 256,
	NVME_SC_QID_INVALID = 257,
	NVME_SC_QUEUE_SIZE = 258,
	NVME_SC_ABORT_LIMIT = 259,
	NVME_SC_ABORT_MISSING = 260,
	NVME_SC_ASYNC_LIMIT = 261,
	NVME_SC_FIRMWARE_SLOT = 262,
	NVME_SC_FIRMWARE_IMAGE = 263,
	NVME_SC_INVALID_VECTOR = 264,
	NVME_SC_INVALID_LOG_PAGE = 265,
	NVME_SC_INVALID_FORMAT = 266,
	NVME_SC_FW_NEEDS_CONV_RESET = 267,
	NVME_SC_INVALID_QUEUE = 268,
	NVME_SC_FEATURE_NOT_SAVEABLE = 269,
	NVME_SC_FEATURE_NOT_CHANGEABLE = 270,
	NVME_SC_FEATURE_NOT_PER_NS = 271,
	NVME_SC_FW_NEEDS_SUBSYS_RESET = 272,
	NVME_SC_FW_NEEDS_RESET = 273,
	NVME_SC_FW_NEEDS_MAX_TIME = 274,
	NVME_SC_FW_ACTIVATE_PROHIBITED = 275,
	NVME_SC_OVERLAPPING_RANGE = 276,
	NVME_SC_NS_INSUFFICIENT_CAP = 277,
	NVME_SC_NS_ID_UNAVAILABLE = 278,
	NVME_SC_NS_ALREADY_ATTACHED = 280,
	NVME_SC_NS_IS_PRIVATE = 281,
	NVME_SC_NS_NOT_ATTACHED = 282,
	NVME_SC_THIN_PROV_NOT_SUPP = 283,
	NVME_SC_CTRL_LIST_INVALID = 284,
	NVME_SC_BAD_ATTRIBUTES = 384,
	NVME_SC_INVALID_PI = 385,
	NVME_SC_READ_ONLY = 386,
	NVME_SC_ONCS_NOT_SUPPORTED = 387,
	NVME_SC_CONNECT_FORMAT = 384,
	NVME_SC_CONNECT_CTRL_BUSY = 385,
	NVME_SC_CONNECT_INVALID_PARAM = 386,
	NVME_SC_CONNECT_RESTART_DISC = 387,
	NVME_SC_CONNECT_INVALID_HOST = 388,
	NVME_SC_DISCOVERY_RESTART = 400,
	NVME_SC_AUTH_REQUIRED = 401,
	NVME_SC_WRITE_FAULT = 640,
	NVME_SC_READ_ERROR = 641,
	NVME_SC_GUARD_CHECK = 642,
	NVME_SC_APPTAG_CHECK = 643,
	NVME_SC_REFTAG_CHECK = 644,
	NVME_SC_COMPARE_FAILED = 645,
	NVME_SC_ACCESS_DENIED = 646,
	NVME_SC_UNWRITTEN_BLOCK = 647,
	NVME_SC_ANA_PERSISTENT_LOSS = 769,
	NVME_SC_ANA_INACCESSIBLE = 770,
	NVME_SC_ANA_TRANSITION = 771,
	NVME_SC_HOST_PATH_ERROR = 880,
	NVME_SC_HOST_ABORTED_CMD = 881,
	NVME_SC_CRD = 6144,
	NVME_SC_DNR = 16384,
};

union nvme_result {
	__le16 u16;
	__le32 u32;
	__le64 u64;
};

struct nvm_dev;

enum nvme_quirks {
	NVME_QUIRK_STRIPE_SIZE = 1,
	NVME_QUIRK_IDENTIFY_CNS = 2,
	NVME_QUIRK_DEALLOCATE_ZEROES = 4,
	NVME_QUIRK_DELAY_BEFORE_CHK_RDY = 8,
	NVME_QUIRK_NO_APST = 16,
	NVME_QUIRK_NO_DEEPEST_PS = 32,
	NVME_QUIRK_LIGHTNVM = 64,
	NVME_QUIRK_MEDIUM_PRIO_SQ = 128,
	NVME_QUIRK_IGNORE_DEV_SUBNQN = 256,
	NVME_QUIRK_DISABLE_WRITE_ZEROES = 512,
	NVME_QUIRK_SIMPLE_SUSPEND = 1024,
	NVME_QUIRK_SINGLE_VECTOR = 2048,
	NVME_QUIRK_128_BYTES_SQES = 4096,
	NVME_QUIRK_SHARED_TAGS = 8192,
	NVME_QUIRK_NO_NS_DESC_LIST = 32768,
};

struct nvme_ctrl;

struct nvme_request {
	struct nvme_command *cmd;
	union nvme_result result;
	u8 retries;
	u8 flags;
	u16 status;
	struct nvme_ctrl *ctrl;
	u8 opcode;
};

enum nvme_ctrl_state {
	NVME_CTRL_NEW = 0,
	NVME_CTRL_LIVE = 1,
	NVME_CTRL_RESETTING = 2,
	NVME_CTRL_CONNECTING = 3,
	NVME_CTRL_DELETING = 4,
	NVME_CTRL_DEAD = 5,
};

struct opal_dev;

struct nvme_fault_inject {};

struct nvme_ctrl_ops;

struct nvme_subsystem;

struct nvmf_ctrl_options;

struct nvme_ctrl {
	bool comp_seen;
	enum nvme_ctrl_state state;
	bool identified;
	spinlock_t lock;
	struct mutex scan_lock;
	const struct nvme_ctrl_ops *ops;
	struct request_queue *admin_q;
	struct request_queue *connect_q;
	struct request_queue *fabrics_q;
	struct device *dev;
	int instance;
	int numa_node;
	struct blk_mq_tag_set *tagset;
	struct blk_mq_tag_set *admin_tagset;
	struct list_head namespaces;
	struct rw_semaphore namespaces_rwsem;
	struct device ctrl_device;
	struct device *device;
	struct cdev cdev;
	struct work_struct reset_work;
	struct work_struct delete_work;
	wait_queue_head_t state_wq;
	struct nvme_subsystem *subsys;
	struct list_head subsys_entry;
	struct opal_dev *opal_dev;
	char name[12];
	u16 cntlid;
	u32 ctrl_config;
	u16 mtfa;
	u32 queue_count;
	u64 cap;
	u32 page_size;
	u32 max_hw_sectors;
	u32 max_segments;
	u16 crdt[3];
	u16 oncs;
	u16 oacs;
	u16 nssa;
	u16 nr_streams;
	u16 sqsize;
	u32 max_namespaces;
	atomic_t abort_limit;
	u8 vwc;
	u32 vs;
	u32 sgls;
	u16 kas;
	u8 npss;
	u8 apsta;
	u32 oaes;
	u32 aen_result;
	u32 ctratt;
	unsigned int shutdown_timeout;
	unsigned int kato;
	bool subsystem;
	long unsigned int quirks;
	struct nvme_id_power_state psd[32];
	struct nvme_effects_log *effects;
	struct work_struct scan_work;
	struct work_struct async_event_work;
	struct delayed_work ka_work;
	struct nvme_command ka_cmd;
	struct work_struct fw_act_work;
	long unsigned int events;
	bool created;
	u8 anacap;
	u8 anatt;
	u32 anagrpmax;
	u32 nanagrpid;
	struct mutex ana_lock;
	struct nvme_ana_rsp_hdr *ana_log_buf;
	size_t ana_log_size;
	struct timer_list anatt_timer;
	struct work_struct ana_work;
	u64 ps_max_latency_us;
	bool apst_enabled;
	u32 hmpre;
	u32 hmmin;
	u32 hmminds;
	u16 hmmaxd;
	u32 ioccsz;
	u32 iorcsz;
	u16 icdoff;
	u16 maxcmd;
	int nr_reconnects;
	struct nvmf_ctrl_options *opts;
	struct page *discard_page;
	long unsigned int discard_page_busy;
	struct nvme_fault_inject fault_inject;
};

enum {
	NVME_REQ_CANCELLED = 1,
	NVME_REQ_USERCMD = 2,
};

struct nvme_ctrl_ops {
	const char *name;
	struct module *module;
	unsigned int flags;
	int (*reg_read32)(struct nvme_ctrl *, u32, u32 *);
	int (*reg_write32)(struct nvme_ctrl *, u32, u32);
	int (*reg_read64)(struct nvme_ctrl *, u32, u64 *);
	void (*free_ctrl)(struct nvme_ctrl *);
	void (*submit_async_event)(struct nvme_ctrl *);
	void (*delete_ctrl)(struct nvme_ctrl *);
	int (*get_address)(struct nvme_ctrl *, char *, int);
};

enum nvme_iopolicy {
	NVME_IOPOLICY_NUMA = 0,
	NVME_IOPOLICY_RR = 1,
};

struct nvme_subsystem {
	int instance;
	struct device dev;
	struct kref ref;
	struct list_head entry;
	struct mutex lock;
	struct list_head ctrls;
	struct list_head nsheads;
	char subnqn[223];
	char serial[20];
	char model[40];
	char firmware_rev[8];
	u8 cmic;
	u16 vendor_id;
	u16 awupf;
	struct ida ns_ida;
	enum nvme_iopolicy iopolicy;
};

struct nvmf_host;

struct nvmf_ctrl_options {
	unsigned int mask;
	char *transport;
	char *subsysnqn;
	char *traddr;
	char *trsvcid;
	char *host_traddr;
	size_t queue_size;
	unsigned int nr_io_queues;
	unsigned int reconnect_delay;
	bool discovery_nqn;
	bool duplicate_connect;
	unsigned int kato;
	struct nvmf_host *host;
	int max_reconnects;
	bool disable_sqflow;
	bool hdr_digest;
	bool data_digest;
	unsigned int nr_write_queues;
	unsigned int nr_poll_queues;
	int tos;
};

struct nvme_ns_ids {
	u8 eui64[8];
	u8 nguid[16];
	uuid_t uuid;
};

struct nvme_ns;

struct nvme_ns_head {
	struct list_head list;
	struct srcu_struct srcu;
	struct nvme_subsystem *subsys;
	unsigned int ns_id;
	struct nvme_ns_ids ids;
	struct list_head entry;
	struct kref ref;
	int instance;
	struct gendisk *disk;
	struct bio_list requeue_list;
	spinlock_t requeue_lock;
	struct work_struct requeue_work;
	struct mutex lock;
	long unsigned int flags;
	struct nvme_ns *current_path[0];
};

struct nvme_ns {
	struct list_head list;
	struct nvme_ctrl *ctrl;
	struct request_queue *queue;
	struct gendisk *disk;
	enum nvme_ana_state ana_state;
	u32 ana_grpid;
	struct list_head siblings;
	struct nvm_dev *ndev;
	struct kref kref;
	struct nvme_ns_head *head;
	int lba_shift;
	u16 ms;
	u16 sgs;
	u32 sws;
	bool ext;
	u8 pi_type;
	long unsigned int flags;
	struct nvme_fault_inject fault_inject;
};

struct nvmf_host {
	struct kref ref;
	struct list_head list;
	char nqn[223];
	uuid_t id;
};

struct trace_event_raw_nvme_setup_cmd {
	struct trace_entry ent;
	char disk[32];
	int ctrl_id;
	int qid;
	u8 opcode;
	u8 flags;
	u8 fctype;
	u16 cid;
	u32 nsid;
	u64 metadata;
	u8 cdw10[24];
	char __data[0];
};

struct trace_event_raw_nvme_complete_rq {
	struct trace_entry ent;
	char disk[32];
	int ctrl_id;
	int qid;
	int cid;
	u64 result;
	u8 retries;
	u8 flags;
	u16 status;
	char __data[0];
};

struct trace_event_raw_nvme_async_event {
	struct trace_entry ent;
	int ctrl_id;
	u32 result;
	char __data[0];
};

struct trace_event_raw_nvme_sq {
	struct trace_entry ent;
	int ctrl_id;
	char disk[32];
	int qid;
	u16 sq_head;
	u16 sq_tail;
	char __data[0];
};

struct trace_event_data_offsets_nvme_setup_cmd {};

struct trace_event_data_offsets_nvme_complete_rq {};

struct trace_event_data_offsets_nvme_async_event {};

struct trace_event_data_offsets_nvme_sq {};

typedef void (*btf_trace_nvme_setup_cmd)(void *, struct request *, struct nvme_command *);

typedef void (*btf_trace_nvme_complete_rq)(void *, struct request *);

typedef void (*btf_trace_nvme_async_event)(void *, struct nvme_ctrl *, u32);

typedef void (*btf_trace_nvme_sq)(void *, struct request *, __le16, int);

struct nvme_core_quirk_entry {
	u16 vid;
	const char *mn;
	const char *fr;
	long unsigned int quirks;
};

struct nvme_ana_group_desc {
	__le32 grpid;
	__le32 nnsids;
	__le64 chgcnt;
	__u8 state;
	__u8 rsvd17[15];
	__le32 nsids[0];
};

enum {
	NVME_CMBSZ_SQS = 1,
	NVME_CMBSZ_CQS = 2,
	NVME_CMBSZ_LISTS = 4,
	NVME_CMBSZ_RDS = 8,
	NVME_CMBSZ_WDS = 16,
	NVME_CMBSZ_SZ_SHIFT = 12,
	NVME_CMBSZ_SZ_MASK = 1048575,
	NVME_CMBSZ_SZU_SHIFT = 8,
	NVME_CMBSZ_SZU_MASK = 15,
};

enum {
	NVME_SGL_FMT_DATA_DESC = 0,
	NVME_SGL_FMT_SEG_DESC = 2,
	NVME_SGL_FMT_LAST_SEG_DESC = 3,
	NVME_KEY_SGL_FMT_DATA_DESC = 4,
	NVME_TRANSPORT_SGL_DATA_DESC = 5,
};

enum {
	NVME_CMD_FUSE_FIRST = 1,
	NVME_CMD_FUSE_SECOND = 2,
	NVME_CMD_SGL_METABUF = 64,
	NVME_CMD_SGL_METASEG = 128,
	NVME_CMD_SGL_ALL = 192,
};

enum {
	NVME_HOST_MEM_ENABLE = 1,
	NVME_HOST_MEM_RETURN = 2,
};

struct nvme_host_mem_buf_desc {
	__le64 addr;
	__le32 size;
	__u32 rsvd;
};

struct nvme_completion {
	union nvme_result result;
	__le16 sq_head;
	__le16 sq_id;
	__u16 command_id;
	__le16 status;
};

struct nvme_queue;

struct nvme_dev {
	struct nvme_queue *queues;
	struct blk_mq_tag_set tagset;
	struct blk_mq_tag_set admin_tagset;
	u32 *dbs;
	struct device *dev;
	struct dma_pool *prp_page_pool;
	struct dma_pool *prp_small_pool;
	unsigned int online_queues;
	unsigned int max_qid;
	unsigned int io_queues[3];
	unsigned int num_vecs;
	int q_depth;
	int io_sqes;
	u32 db_stride;
	void *bar;
	long unsigned int bar_mapped_size;
	struct work_struct remove_work;
	struct mutex shutdown_lock;
	bool subsystem;
	u64 cmb_size;
	bool cmb_use_sqes;
	u32 cmbsz;
	u32 cmbloc;
	struct nvme_ctrl ctrl;
	u32 last_ps;
	mempool_t *iod_mempool;
	u32 *dbbuf_dbs;
	dma_addr_t dbbuf_dbs_dma_addr;
	u32 *dbbuf_eis;
	dma_addr_t dbbuf_eis_dma_addr;
	u64 host_mem_size;
	u32 nr_host_mem_descs;
	dma_addr_t host_mem_descs_dma;
	struct nvme_host_mem_buf_desc *host_mem_descs;
	void **host_mem_desc_bufs;
	unsigned int nr_allocated_queues;
	unsigned int nr_write_queues;
	unsigned int nr_poll_queues;
};

struct nvme_queue {
	struct nvme_dev *dev;
	spinlock_t sq_lock;
	void *sq_cmds;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t cq_poll_lock;
	volatile struct nvme_completion *cqes;
	dma_addr_t sq_dma_addr;
	dma_addr_t cq_dma_addr;
	u32 *q_db;
	u16 q_depth;
	u16 cq_vector;
	u16 sq_tail;
	u16 last_sq_tail;
	u16 cq_head;
	u16 last_cq_head;
	u16 qid;
	u8 cq_phase;
	u8 sqes;
	long unsigned int flags;
	u32 *dbbuf_sq_db;
	u32 *dbbuf_cq_db;
	u32 *dbbuf_sq_ei;
	u32 *dbbuf_cq_ei;
	struct completion delete_done;
};

struct nvme_iod {
	struct nvme_request req;
	struct nvme_queue *nvmeq;
	bool use_sgl;
	int aborted;
	int npages;
	int nents;
	dma_addr_t first_dma;
	unsigned int dma_len;
	dma_addr_t meta_dma;
	struct scatterlist *sg;
};

struct pci_saved_state;

typedef __u64 blist_flags_t;

enum scsi_device_state {
	SDEV_CREATED = 1,
	SDEV_RUNNING = 2,
	SDEV_CANCEL = 3,
	SDEV_DEL = 4,
	SDEV_QUIESCE = 5,
	SDEV_OFFLINE = 6,
	SDEV_TRANSPORT_OFFLINE = 7,
	SDEV_BLOCK = 8,
	SDEV_CREATED_BLOCK = 9,
};

struct scsi_vpd {
	struct callback_head rcu;
	int len;
	unsigned char data[0];
};

struct Scsi_Host;

struct scsi_target;

struct scsi_device_handler;

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;
	struct list_head siblings;
	struct list_head same_target_siblings;
	atomic_t device_busy;
	atomic_t device_blocked;
	spinlock_t list_lock;
	struct list_head cmd_list;
	struct list_head starved_entry;
	short unsigned int queue_depth;
	short unsigned int max_queue_depth;
	short unsigned int last_queue_full_depth;
	short unsigned int last_queue_full_count;
	long unsigned int last_queue_full_time;
	long unsigned int queue_ramp_up_period;
	long unsigned int last_queue_ramp_up;
	unsigned int id;
	unsigned int channel;
	u64 lun;
	unsigned int manufacturer;
	unsigned int sector_size;
	void *hostdata;
	unsigned char type;
	char scsi_level;
	char inq_periph_qual;
	struct mutex inquiry_mutex;
	unsigned char inquiry_len;
	unsigned char *inquiry;
	const char *vendor;
	const char *model;
	const char *rev;
	struct scsi_vpd *vpd_pg83;
	struct scsi_vpd *vpd_pg80;
	unsigned char current_tag;
	struct scsi_target *sdev_target;
	blist_flags_t sdev_bflags;
	unsigned int eh_timeout;
	unsigned int removable: 1;
	unsigned int changed: 1;
	unsigned int busy: 1;
	unsigned int lockable: 1;
	unsigned int locked: 1;
	unsigned int borken: 1;
	unsigned int disconnect: 1;
	unsigned int soft_reset: 1;
	unsigned int sdtr: 1;
	unsigned int wdtr: 1;
	unsigned int ppr: 1;
	unsigned int tagged_supported: 1;
	unsigned int simple_tags: 1;
	unsigned int was_reset: 1;
	unsigned int expecting_cc_ua: 1;
	unsigned int use_10_for_rw: 1;
	unsigned int use_10_for_ms: 1;
	unsigned int no_report_opcodes: 1;
	unsigned int no_write_same: 1;
	unsigned int use_16_for_rw: 1;
	unsigned int skip_ms_page_8: 1;
	unsigned int skip_ms_page_3f: 1;
	unsigned int skip_vpd_pages: 1;
	unsigned int try_vpd_pages: 1;
	unsigned int use_192_bytes_for_3f: 1;
	unsigned int no_start_on_add: 1;
	unsigned int allow_restart: 1;
	unsigned int manage_start_stop: 1;
	unsigned int start_stop_pwr_cond: 1;
	unsigned int no_uld_attach: 1;
	unsigned int select_no_atn: 1;
	unsigned int fix_capacity: 1;
	unsigned int guess_capacity: 1;
	unsigned int retry_hwerror: 1;
	unsigned int last_sector_bug: 1;
	unsigned int no_read_disc_info: 1;
	unsigned int no_read_capacity_16: 1;
	unsigned int try_rc_10_first: 1;
	unsigned int security_supported: 1;
	unsigned int is_visible: 1;
	unsigned int wce_default_on: 1;
	unsigned int no_dif: 1;
	unsigned int broken_fua: 1;
	unsigned int lun_in_cdb: 1;
	unsigned int unmap_limit_for_ws: 1;
	atomic_t disk_events_disable_depth;
	long unsigned int supported_events[1];
	long unsigned int pending_events[1];
	struct list_head event_list;
	struct work_struct event_work;
	unsigned int max_device_blocked;
	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;
	struct device sdev_gendev;
	struct device sdev_dev;
	struct execute_work ew;
	struct work_struct requeue_work;
	struct scsi_device_handler *handler;
	void *handler_data;
	unsigned char access_state;
	struct mutex state_mutex;
	enum scsi_device_state sdev_state;
	struct task_struct *quiesced_by;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long unsigned int sdev_data[0];
};

enum scsi_host_state {
	SHOST_CREATED = 1,
	SHOST_RUNNING = 2,
	SHOST_CANCEL = 3,
	SHOST_DEL = 4,
	SHOST_RECOVERY = 5,
	SHOST_CANCEL_RECOVERY = 6,
	SHOST_DEL_RECOVERY = 7,
};

struct scsi_host_template;

struct scsi_transport_template;

struct Scsi_Host {
	struct list_head __devices;
	struct list_head __targets;
	struct list_head starved_list;
	spinlock_t default_lock;
	spinlock_t *host_lock;
	struct mutex scan_mutex;
	struct list_head eh_cmd_q;
	struct task_struct *ehandler;
	struct completion *eh_action;
	wait_queue_head_t host_wait;
	struct scsi_host_template *hostt;
	struct scsi_transport_template *transportt;
	struct blk_mq_tag_set tag_set;
	atomic_t host_busy;
	atomic_t host_blocked;
	unsigned int host_failed;
	unsigned int host_eh_scheduled;
	unsigned int host_no;
	int eh_deadline;
	long unsigned int last_reset;
	unsigned int max_channel;
	unsigned int max_id;
	u64 max_lun;
	unsigned int unique_id;
	short unsigned int max_cmd_len;
	int this_id;
	int can_queue;
	short int cmd_per_lun;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	unsigned int nr_hw_queues;
	unsigned int active_mode: 2;
	unsigned int unchecked_isa_dma: 1;
	unsigned int host_self_blocked: 1;
	unsigned int reverse_ordering: 1;
	unsigned int tmf_in_progress: 1;
	unsigned int async_scan: 1;
	unsigned int eh_noresume: 1;
	unsigned int no_write_same: 1;
	unsigned int use_cmd_list: 1;
	unsigned int short_inquiry: 1;
	unsigned int no_scsi2_lun_in_cdb: 1;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	struct workqueue_struct *tmf_work_q;
	unsigned int max_host_blocked;
	unsigned int prot_capabilities;
	unsigned char prot_guard_type;
	long unsigned int base;
	long unsigned int io_port;
	unsigned char n_io_port;
	unsigned char dma_channel;
	unsigned int irq;
	enum scsi_host_state shost_state;
	struct device shost_gendev;
	struct device shost_dev;
	void *shost_data;
	struct device *dma_dev;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long unsigned int hostdata[0];
};

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING = 2,
	STARGET_REMOVE = 3,
	STARGET_CREATED_REMOVE = 4,
	STARGET_DEL = 5,
};

struct scsi_target {
	struct scsi_device *starget_sdev_user;
	struct list_head siblings;
	struct list_head devices;
	struct device dev;
	struct kref reap_ref;
	unsigned int channel;
	unsigned int id;
	unsigned int create: 1;
	unsigned int single_lun: 1;
	unsigned int pdt_1f_for_no_lun: 1;
	unsigned int no_report_luns: 1;
	unsigned int expecting_lun_change: 1;
	atomic_t target_busy;
	atomic_t target_blocked;
	unsigned int can_queue;
	unsigned int max_target_blocked;
	char scsi_level;
	enum scsi_target_state state;
	void *hostdata;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
	long unsigned int starget_data[0];
};

struct scsi_data_buffer {
	struct sg_table table;
	unsigned int length;
};

struct scsi_pointer {
	char *ptr;
	int this_residual;
	struct scatterlist *buffer;
	int buffers_residual;
	dma_addr_t dma_handle;
	volatile int Status;
	volatile int Message;
	volatile int have_data_in;
	volatile int sent_command;
	volatile int phase;
};

struct scsi_cmnd {
	struct scsi_request req;
	struct scsi_device *device;
	struct list_head list;
	struct list_head eh_entry;
	struct delayed_work abort_work;
	struct callback_head rcu;
	int eh_eflags;
	long unsigned int jiffies_at_alloc;
	int retries;
	int allowed;
	unsigned char prot_op;
	unsigned char prot_type;
	unsigned char prot_flags;
	short unsigned int cmd_len;
	enum dma_data_direction sc_data_direction;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	struct scsi_data_buffer *prot_sdb;
	unsigned int underflow;
	unsigned int transfersize;
	struct request *request;
	unsigned char *sense_buffer;
	void (*scsi_done)(struct scsi_cmnd *);
	struct scsi_pointer SCp;
	unsigned char *host_scribble;
	int result;
	int flags;
	long unsigned int state;
	unsigned char tag;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct scsi_host_cmd_pool;

struct scsi_host_template {
	struct module *module;
	const char *name;
	const char * (*info)(struct Scsi_Host *);
	int (*ioctl)(struct scsi_device *, unsigned int, void *);
	int (*compat_ioctl)(struct scsi_device *, unsigned int, void *);
	int (*queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
	void (*commit_rqs)(struct Scsi_Host *, u16);
	int (*eh_abort_handler)(struct scsi_cmnd *);
	int (*eh_device_reset_handler)(struct scsi_cmnd *);
	int (*eh_target_reset_handler)(struct scsi_cmnd *);
	int (*eh_bus_reset_handler)(struct scsi_cmnd *);
	int (*eh_host_reset_handler)(struct scsi_cmnd *);
	int (*slave_alloc)(struct scsi_device *);
	int (*slave_configure)(struct scsi_device *);
	void (*slave_destroy)(struct scsi_device *);
	int (*target_alloc)(struct scsi_target *);
	void (*target_destroy)(struct scsi_target *);
	int (*scan_finished)(struct Scsi_Host *, long unsigned int);
	void (*scan_start)(struct Scsi_Host *);
	int (*change_queue_depth)(struct scsi_device *, int);
	int (*map_queues)(struct Scsi_Host *);
	int (*bios_param)(struct scsi_device *, struct block_device *, sector_t, int *);
	void (*unlock_native_capacity)(struct scsi_device *);
	int (*show_info)(struct seq_file *, struct Scsi_Host *);
	int (*write_info)(struct Scsi_Host *, char *, int);
	enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd *);
	int (*host_reset)(struct Scsi_Host *, int);
	const char *proc_name;
	struct proc_dir_entry *proc_dir;
	int can_queue;
	int this_id;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	short int cmd_per_lun;
	unsigned char present;
	int tag_alloc_policy;
	unsigned int track_queue_depth: 1;
	unsigned int supported_mode: 2;
	unsigned int unchecked_isa_dma: 1;
	unsigned int emulated: 1;
	unsigned int skip_settle_delay: 1;
	unsigned int no_write_same: 1;
	unsigned int force_blk_mq: 1;
	unsigned int max_host_blocked;
	struct device_attribute **shost_attrs;
	struct device_attribute **sdev_attrs;
	const struct attribute_group **sdev_groups;
	u64 vendor_id;
	unsigned int cmd_size;
	struct scsi_host_cmd_pool *cmd_pool;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

enum ata_prot_flags {
	ATA_PROT_FLAG_PIO = 1,
	ATA_PROT_FLAG_DMA = 2,
	ATA_PROT_FLAG_NCQ = 4,
	ATA_PROT_FLAG_ATAPI = 8,
	ATA_PROT_UNKNOWN = 255,
	ATA_PROT_NODATA = 0,
	ATA_PROT_PIO = 1,
	ATA_PROT_DMA = 2,
	ATA_PROT_NCQ_NODATA = 4,
	ATA_PROT_NCQ = 6,
	ATAPI_PROT_NODATA = 8,
	ATAPI_PROT_PIO = 9,
	ATAPI_PROT_DMA = 10,
};

struct ata_bmdma_prd {
	__le32 addr;
	__le32 flags_len;
};

enum {
	ATA_MSG_DRV = 1,
	ATA_MSG_INFO = 2,
	ATA_MSG_PROBE = 4,
	ATA_MSG_WARN = 8,
	ATA_MSG_MALLOC = 16,
	ATA_MSG_CTL = 32,
	ATA_MSG_INTR = 64,
	ATA_MSG_ERR = 128,
};

enum ata_xfer_mask {
	ATA_MASK_PIO = 127,
	ATA_MASK_MWDMA = 3968,
	ATA_MASK_UDMA = 1044480,
};

enum ata_completion_errors {
	AC_ERR_OK = 0,
	AC_ERR_DEV = 1,
	AC_ERR_HSM = 2,
	AC_ERR_TIMEOUT = 4,
	AC_ERR_MEDIA = 8,
	AC_ERR_ATA_BUS = 16,
	AC_ERR_HOST_BUS = 32,
	AC_ERR_SYSTEM = 64,
	AC_ERR_INVALID = 128,
	AC_ERR_OTHER = 256,
	AC_ERR_NODEV_HINT = 512,
	AC_ERR_NCQ = 1024,
};

enum ata_lpm_policy {
	ATA_LPM_UNKNOWN = 0,
	ATA_LPM_MAX_POWER = 1,
	ATA_LPM_MED_POWER = 2,
	ATA_LPM_MED_POWER_WITH_DIPM = 3,
	ATA_LPM_MIN_POWER_WITH_PARTIAL = 4,
	ATA_LPM_MIN_POWER = 5,
};

struct ata_queued_cmd;

typedef void (*ata_qc_cb_t)(struct ata_queued_cmd *);

struct ata_taskfile {
	long unsigned int flags;
	u8 protocol;
	u8 ctl;
	u8 hob_feature;
	u8 hob_nsect;
	u8 hob_lbal;
	u8 hob_lbam;
	u8 hob_lbah;
	u8 feature;
	u8 nsect;
	u8 lbal;
	u8 lbam;
	u8 lbah;
	u8 device;
	u8 command;
	u32 auxiliary;
};

struct ata_port;

struct ata_device;

struct ata_queued_cmd {
	struct ata_port *ap;
	struct ata_device *dev;
	struct scsi_cmnd *scsicmd;
	void (*scsidone)(struct scsi_cmnd *);
	struct ata_taskfile tf;
	u8 cdb[16];
	long unsigned int flags;
	unsigned int tag;
	unsigned int hw_tag;
	unsigned int n_elem;
	unsigned int orig_n_elem;
	int dma_dir;
	unsigned int sect_size;
	unsigned int nbytes;
	unsigned int extrabytes;
	unsigned int curbytes;
	struct scatterlist sgent;
	struct scatterlist *sg;
	struct scatterlist *cursg;
	unsigned int cursg_ofs;
	unsigned int err_mask;
	struct ata_taskfile result_tf;
	ata_qc_cb_t complete_fn;
	void *private_data;
	void *lldd_task;
};

struct ata_link;

typedef int (*ata_prereset_fn_t)(struct ata_link *, long unsigned int);

struct ata_eh_info {
	struct ata_device *dev;
	u32 serror;
	unsigned int err_mask;
	unsigned int action;
	unsigned int dev_action[2];
	unsigned int flags;
	unsigned int probe_mask;
	char desc[80];
	int desc_len;
};

struct ata_eh_context {
	struct ata_eh_info i;
	int tries[2];
	int cmd_timeout_idx[12];
	unsigned int classes[2];
	unsigned int did_probe_mask;
	unsigned int unloaded_mask;
	unsigned int saved_ncq_enabled;
	u8 saved_xfer_mode[2];
	long unsigned int last_reset;
};

struct ata_ering_entry {
	unsigned int eflags;
	unsigned int err_mask;
	u64 timestamp;
};

struct ata_ering {
	int cursor;
	struct ata_ering_entry ring[32];
};

struct ata_device {
	struct ata_link *link;
	unsigned int devno;
	unsigned int horkage;
	long unsigned int flags;
	struct scsi_device *sdev;
	void *private_data;
	union acpi_object *gtf_cache;
	unsigned int gtf_filter;
	struct device tdev;
	u64 n_sectors;
	u64 n_native_sectors;
	unsigned int class;
	long unsigned int unpark_deadline;
	u8 pio_mode;
	u8 dma_mode;
	u8 xfer_mode;
	unsigned int xfer_shift;
	unsigned int multi_count;
	unsigned int max_sectors;
	unsigned int cdb_len;
	long unsigned int pio_mask;
	long unsigned int mwdma_mask;
	long unsigned int udma_mask;
	u16 cylinders;
	u16 heads;
	u16 sectors;
	union {
		u16 id[256];
		u32 gscr[128];
	};
	u8 devslp_timing[8];
	u8 ncq_send_recv_cmds[20];
	u8 ncq_non_data_cmds[64];
	u32 zac_zoned_cap;
	u32 zac_zones_optimal_open;
	u32 zac_zones_optimal_nonseq;
	u32 zac_zones_max_open;
	int spdn_cnt;
	struct ata_ering ering;
	long: 64;
};

struct ata_link {
	struct ata_port *ap;
	int pmp;
	struct device tdev;
	unsigned int active_tag;
	u32 sactive;
	unsigned int flags;
	u32 saved_scontrol;
	unsigned int hw_sata_spd_limit;
	unsigned int sata_spd_limit;
	unsigned int sata_spd;
	enum ata_lpm_policy lpm_policy;
	struct ata_eh_info eh_info;
	struct ata_eh_context eh_context;
	long: 64;
	long: 64;
	long: 64;
	struct ata_device device[2];
	long unsigned int last_lpm_change;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef int (*ata_reset_fn_t)(struct ata_link *, unsigned int *, long unsigned int);

typedef void (*ata_postreset_fn_t)(struct ata_link *, unsigned int *);

enum sw_activity {
	OFF = 0,
	BLINK_ON = 1,
	BLINK_OFF = 2,
};

struct ata_ioports {
	void *cmd_addr;
	void *data_addr;
	void *error_addr;
	void *feature_addr;
	void *nsect_addr;
	void *lbal_addr;
	void *lbam_addr;
	void *lbah_addr;
	void *device_addr;
	void *status_addr;
	void *command_addr;
	void *altstatus_addr;
	void *ctl_addr;
	void *bmdma_addr;
	void *scr_addr;
};

struct ata_port_operations;

struct ata_host {
	spinlock_t lock;
	struct device *dev;
	void * const *iomap;
	unsigned int n_ports;
	unsigned int n_tags;
	void *private_data;
	struct ata_port_operations *ops;
	long unsigned int flags;
	struct kref kref;
	struct mutex eh_mutex;
	struct task_struct *eh_owner;
	struct ata_port *simplex_claimed;
	struct ata_port *ports[0];
};

struct ata_port_operations {
	int (*qc_defer)(struct ata_queued_cmd *);
	int (*check_atapi_dma)(struct ata_queued_cmd *);
	enum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *);
	unsigned int (*qc_issue)(struct ata_queued_cmd *);
	bool (*qc_fill_rtf)(struct ata_queued_cmd *);
	int (*cable_detect)(struct ata_port *);
	long unsigned int (*mode_filter)(struct ata_device *, long unsigned int);
	void (*set_piomode)(struct ata_port *, struct ata_device *);
	void (*set_dmamode)(struct ata_port *, struct ata_device *);
	int (*set_mode)(struct ata_link *, struct ata_device **);
	unsigned int (*read_id)(struct ata_device *, struct ata_taskfile *, u16 *);
	void (*dev_config)(struct ata_device *);
	void (*freeze)(struct ata_port *);
	void (*thaw)(struct ata_port *);
	ata_prereset_fn_t prereset;
	ata_reset_fn_t softreset;
	ata_reset_fn_t hardreset;
	ata_postreset_fn_t postreset;
	ata_prereset_fn_t pmp_prereset;
	ata_reset_fn_t pmp_softreset;
	ata_reset_fn_t pmp_hardreset;
	ata_postreset_fn_t pmp_postreset;
	void (*error_handler)(struct ata_port *);
	void (*lost_interrupt)(struct ata_port *);
	void (*post_internal_cmd)(struct ata_queued_cmd *);
	void (*sched_eh)(struct ata_port *);
	void (*end_eh)(struct ata_port *);
	int (*scr_read)(struct ata_link *, unsigned int, u32 *);
	int (*scr_write)(struct ata_link *, unsigned int, u32);
	void (*pmp_attach)(struct ata_port *);
	void (*pmp_detach)(struct ata_port *);
	int (*set_lpm)(struct ata_link *, enum ata_lpm_policy, unsigned int);
	int (*port_suspend)(struct ata_port *, pm_message_t);
	int (*port_resume)(struct ata_port *);
	int (*port_start)(struct ata_port *);
	void (*port_stop)(struct ata_port *);
	void (*host_stop)(struct ata_host *);
	void (*sff_dev_select)(struct ata_port *, unsigned int);
	void (*sff_set_devctl)(struct ata_port *, u8);
	u8 (*sff_check_status)(struct ata_port *);
	u8 (*sff_check_altstatus)(struct ata_port *);
	void (*sff_tf_load)(struct ata_port *, const struct ata_taskfile *);
	void (*sff_tf_read)(struct ata_port *, struct ata_taskfile *);
	void (*sff_exec_command)(struct ata_port *, const struct ata_taskfile *);
	unsigned int (*sff_data_xfer)(struct ata_queued_cmd *, unsigned char *, unsigned int, int);
	void (*sff_irq_on)(struct ata_port *);
	bool (*sff_irq_check)(struct ata_port *);
	void (*sff_irq_clear)(struct ata_port *);
	void (*sff_drain_fifo)(struct ata_queued_cmd *);
	void (*bmdma_setup)(struct ata_queued_cmd *);
	void (*bmdma_start)(struct ata_queued_cmd *);
	void (*bmdma_stop)(struct ata_queued_cmd *);
	u8 (*bmdma_status)(struct ata_port *);
	ssize_t (*em_show)(struct ata_port *, char *);
	ssize_t (*em_store)(struct ata_port *, const char *, size_t);
	ssize_t (*sw_activity_show)(struct ata_device *, char *);
	ssize_t (*sw_activity_store)(struct ata_device *, enum sw_activity);
	ssize_t (*transmit_led_message)(struct ata_port *, u32, ssize_t);
	void (*phy_reset)(struct ata_port *);
	void (*eng_timeout)(struct ata_port *);
	const struct ata_port_operations *inherits;
};

struct ata_port_stats {
	long unsigned int unhandled_irq;
	long unsigned int idle_irq;
	long unsigned int rw_reqbuf;
};

struct ata_acpi_drive {
	u32 pio;
	u32 dma;
};

struct ata_acpi_gtm {
	struct ata_acpi_drive drive[2];
	u32 flags;
};

struct ata_port {
	struct Scsi_Host *scsi_host;
	struct ata_port_operations *ops;
	spinlock_t *lock;
	long unsigned int flags;
	unsigned int pflags;
	unsigned int print_id;
	unsigned int local_port_no;
	unsigned int port_no;
	struct ata_ioports ioaddr;
	u8 ctl;
	u8 last_ctl;
	struct ata_link *sff_pio_task_link;
	struct delayed_work sff_pio_task;
	struct ata_bmdma_prd *bmdma_prd;
	dma_addr_t bmdma_prd_dma;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	unsigned int cbl;
	struct ata_queued_cmd qcmd[33];
	long unsigned int sas_tag_allocated;
	u64 qc_active;
	int nr_active_links;
	unsigned int sas_last_tag;
	long: 64;
	long: 64;
	long: 64;
	struct ata_link link;
	struct ata_link *slave_link;
	int nr_pmp_links;
	struct ata_link *pmp_link;
	struct ata_link *excl_link;
	struct ata_port_stats stats;
	struct ata_host *host;
	struct device *dev;
	struct device tdev;
	struct mutex scsi_scan_mutex;
	struct delayed_work hotplug_task;
	struct work_struct scsi_rescan_task;
	unsigned int hsm_task_state;
	u32 msg_enable;
	struct list_head eh_done_q;
	wait_queue_head_t eh_wait_q;
	int eh_tries;
	struct completion park_req_pending;
	pm_message_t pm_mesg;
	enum ata_lpm_policy target_lpm_policy;
	struct timer_list fastdrain_timer;
	long unsigned int fastdrain_cnt;
	async_cookie_t cookie;
	int em_message_type;
	void *private_data;
	struct ata_acpi_gtm __acpi_init_gtm;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	u8 sector_buf[512];
};

struct ata_port_info {
	long unsigned int flags;
	long unsigned int link_flags;
	long unsigned int pio_mask;
	long unsigned int mwdma_mask;
	long unsigned int udma_mask;
	struct ata_port_operations *port_ops;
	void *private_data;
};

struct ata_timing {
	short unsigned int mode;
	short unsigned int setup;
	short unsigned int act8b;
	short unsigned int rec8b;
	short unsigned int cyc8b;
	short unsigned int active;
	short unsigned int recover;
	short unsigned int dmack_hold;
	short unsigned int cycle;
	short unsigned int udma;
};

struct pci_bits {
	unsigned int reg;
	unsigned int width;
	long unsigned int mask;
	long unsigned int val;
};

enum ata_link_iter_mode {
	ATA_LITER_EDGE = 0,
	ATA_LITER_HOST_FIRST = 1,
	ATA_LITER_PMP_FIRST = 2,
};

enum ata_dev_iter_mode {
	ATA_DITER_ENABLED = 0,
	ATA_DITER_ENABLED_REVERSE = 1,
	ATA_DITER_ALL = 2,
	ATA_DITER_ALL_REVERSE = 3,
};

struct trace_event_raw_ata_qc_issue {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	unsigned char proto;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_qc_complete_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char status;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char error;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy_qc {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_data_offsets_ata_qc_issue {};

struct trace_event_data_offsets_ata_qc_complete_template {};

struct trace_event_data_offsets_ata_eh_link_autopsy {};

struct trace_event_data_offsets_ata_eh_link_autopsy_qc {};

typedef void (*btf_trace_ata_qc_issue)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_internal)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_failed)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_done)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_eh_link_autopsy)(void *, struct ata_device *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy_qc)(void *, struct ata_queued_cmd *);

enum {
	ATA_READID_POSTRESET = 1,
	ATA_DNXFER_PIO = 0,
	ATA_DNXFER_DMA = 1,
	ATA_DNXFER_40C = 2,
	ATA_DNXFER_FORCE_PIO = 3,
	ATA_DNXFER_FORCE_PIO0 = 4,
	ATA_DNXFER_QUIET = 2147483648,
};

struct ata_force_param {
	const char *name;
	unsigned int cbl;
	int spd_limit;
	long unsigned int xfer_mask;
	unsigned int horkage_on;
	unsigned int horkage_off;
	unsigned int lflags;
};

struct ata_force_ent {
	int port;
	int device;
	struct ata_force_param param;
};

struct ata_xfer_ent {
	int shift;
	int bits;
	u8 base;
};

struct ata_blacklist_entry {
	const char *model_num;
	const char *model_rev;
	long unsigned int horkage;
};

struct scsi_sense_hdr {
	u8 response_code;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	u8 byte4;
	u8 byte5;
	u8 byte6;
	u8 additional_length;
};

struct scsi_transport_template {
	struct transport_container host_attrs;
	struct transport_container target_attrs;
	struct transport_container device_attrs;
	int (*user_scan)(struct Scsi_Host *, uint, uint, u64);
	int device_size;
	int device_private_offset;
	int target_size;
	int target_private_offset;
	int host_size;
	unsigned int create_work_queue: 1;
	void (*eh_strategy_handler)(struct Scsi_Host *);
};

typedef unsigned int (*ata_xlat_func_t)(struct ata_queued_cmd *);

struct ata_scsi_args {
	struct ata_device *dev;
	u16 *id;
	struct scsi_cmnd *cmd;
};

enum ata_lpm_hints {
	ATA_LPM_EMPTY = 1,
	ATA_LPM_HIPM = 2,
	ATA_LPM_WAKE_ONLY = 4,
};

enum {
	ATA_EH_SPDN_NCQ_OFF = 1,
	ATA_EH_SPDN_SPEED_DOWN = 2,
	ATA_EH_SPDN_FALLBACK_TO_PIO = 4,
	ATA_EH_SPDN_KEEP_ERRORS = 8,
	ATA_EFLAG_IS_IO = 1,
	ATA_EFLAG_DUBIOUS_XFER = 2,
	ATA_EFLAG_OLD_ER = 2147483648,
	ATA_ECAT_NONE = 0,
	ATA_ECAT_ATA_BUS = 1,
	ATA_ECAT_TOUT_HSM = 2,
	ATA_ECAT_UNK_DEV = 3,
	ATA_ECAT_DUBIOUS_NONE = 4,
	ATA_ECAT_DUBIOUS_ATA_BUS = 5,
	ATA_ECAT_DUBIOUS_TOUT_HSM = 6,
	ATA_ECAT_DUBIOUS_UNK_DEV = 7,
	ATA_ECAT_NR = 8,
	ATA_EH_CMD_DFL_TIMEOUT = 5000,
	ATA_EH_RESET_COOL_DOWN = 5000,
	ATA_EH_PRERESET_TIMEOUT = 10000,
	ATA_EH_FASTDRAIN_INTERVAL = 3000,
	ATA_EH_UA_TRIES = 5,
	ATA_EH_PROBE_TRIAL_INTERVAL = 60000,
	ATA_EH_PROBE_TRIALS = 2,
};

struct ata_eh_cmd_timeout_ent {
	const u8 *commands;
	const long unsigned int *timeouts;
};

struct speed_down_verdict_arg {
	u64 since;
	int xfer_ok;
	int nr_errors[8];
};

struct ata_internal {
	struct scsi_transport_template t;
	struct device_attribute private_port_attrs[3];
	struct device_attribute private_link_attrs[3];
	struct device_attribute private_dev_attrs[9];
	struct transport_container link_attr_cont;
	struct transport_container dev_attr_cont;
	struct device_attribute *link_attrs[4];
	struct device_attribute *port_attrs[4];
	struct device_attribute *dev_attrs[10];
};

struct ata_show_ering_arg {
	char *buf;
	int written;
};

enum hsm_task_states {
	HSM_ST_IDLE = 0,
	HSM_ST_FIRST = 1,
	HSM_ST = 2,
	HSM_ST_LAST = 3,
	HSM_ST_ERR = 4,
};

struct ata_acpi_gtf {
	u8 tf[7];
};

struct ata_acpi_hotplug_context {
	struct acpi_hotplug_context hp;
	union {
		struct ata_port *ap;
		struct ata_device *dev;
	} data;
};

struct ahci_cmd_hdr {
	__le32 opts;
	__le32 status;
	__le32 tbl_addr;
	__le32 tbl_addr_hi;
	__le32 reserved[4];
};

struct ahci_em_priv {
	enum sw_activity blink_policy;
	struct timer_list timer;
	long unsigned int saved_activity;
	long unsigned int activity;
	long unsigned int led_state;
	struct ata_link *link;
};

struct ahci_port_priv {
	struct ata_link *active_link;
	struct ahci_cmd_hdr *cmd_slot;
	dma_addr_t cmd_slot_dma;
	void *cmd_tbl;
	dma_addr_t cmd_tbl_dma;
	void *rx_fis;
	dma_addr_t rx_fis_dma;
	unsigned int ncq_saw_d2h: 1;
	unsigned int ncq_saw_dmas: 1;
	unsigned int ncq_saw_sdb: 1;
	spinlock_t lock;
	u32 intr_mask;
	bool fbs_supported;
	bool fbs_enabled;
	int fbs_last_dev;
	struct ahci_em_priv em_priv[8];
	char *irq_desc;
};

struct ahci_host_priv {
	unsigned int flags;
	u32 force_port_map;
	u32 mask_port_map;
	void *mmio;
	u32 cap;
	u32 cap2;
	u32 version;
	u32 port_map;
	u32 saved_cap;
	u32 saved_cap2;
	u32 saved_port_map;
	u32 em_loc;
	u32 em_buf_sz;
	u32 em_msg_type;
	bool got_runtime_pm;
	struct clk *clks[5];
	struct reset_control *rsts;
	struct regulator **target_pwrs;
	struct regulator *ahci_regulator;
	struct regulator *phy_regulator;
	struct phy **phys;
	unsigned int nports;
	void *plat_data;
	unsigned int irq;
	void (*start_engine)(struct ata_port *);
	int (*stop_engine)(struct ata_port *);
	irqreturn_t (*irq_handler)(int, void *);
	int (*get_irq_vector)(struct ata_host *, int);
};

enum {
	AHCI_PCI_BAR_STA2X11 = 0,
	AHCI_PCI_BAR_CAVIUM = 0,
	AHCI_PCI_BAR_ENMOTUS = 2,
	AHCI_PCI_BAR_CAVIUM_GEN5 = 4,
	AHCI_PCI_BAR_STANDARD = 5,
};

enum board_ids {
	board_ahci = 0,
	board_ahci_ign_iferr = 1,
	board_ahci_mobile = 2,
	board_ahci_nomsi = 3,
	board_ahci_noncq = 4,
	board_ahci_nosntf = 5,
	board_ahci_yes_fbs = 6,
	board_ahci_avn = 7,
	board_ahci_mcp65 = 8,
	board_ahci_mcp77 = 9,
	board_ahci_mcp89 = 10,
	board_ahci_mv = 11,
	board_ahci_sb600 = 12,
	board_ahci_sb700 = 13,
	board_ahci_vt8251 = 14,
	board_ahci_pcs7 = 15,
	board_ahci_mcp_linux = 8,
	board_ahci_mcp67 = 8,
	board_ahci_mcp73 = 8,
	board_ahci_mcp79 = 9,
};

struct ahci_sg {
	__le32 addr;
	__le32 addr_hi;
	__le32 reserved;
	__le32 flags_size;
};

enum {
	AHCI_PCI_BAR = 5,
};

enum board_ids___2 {
	board_acard_ahci = 0,
};

struct acard_sg {
	__le32 addr;
	__le32 addr_hi;
	__le32 reserved;
	__le32 size;
};

struct sil24_prb {
	__le16 ctrl;
	__le16 prot;
	__le32 rx_cnt;
	u8 fis[24];
};

struct sil24_sge {
	__le64 addr;
	__le32 cnt;
	__le32 flags;
};

enum {
	SIL24_HOST_BAR = 0,
	SIL24_PORT_BAR = 2,
	SIL24_PRB_SZ = 64,
	SIL24_MAX_SGT = 63,
	SIL24_MAX_SGE = 253,
	HOST_SLOT_STAT = 0,
	HOST_CTRL = 64,
	HOST_IRQ_STAT___2 = 68,
	HOST_PHY_CFG = 72,
	HOST_BIST_CTRL = 80,
	HOST_BIST_PTRN = 84,
	HOST_BIST_STAT = 88,
	HOST_MEM_BIST_STAT = 92,
	HOST_FLASH_CMD = 112,
	HOST_FLASH_DATA = 116,
	HOST_TRANSITION_DETECT = 117,
	HOST_GPIO_CTRL = 118,
	HOST_I2C_ADDR = 120,
	HOST_I2C_DATA = 124,
	HOST_I2C_XFER_CNT = 126,
	HOST_I2C_CTRL = 127,
	HOST_SSTAT_ATTN = 2147483648,
	HOST_CTRL_M66EN = 65536,
	HOST_CTRL_TRDY = 131072,
	HOST_CTRL_STOP = 262144,
	HOST_CTRL_DEVSEL = 524288,
	HOST_CTRL_REQ64 = 1048576,
	HOST_CTRL_GLOBAL_RST = 2147483648,
	PORT_REGS_SIZE = 8192,
	PORT_LRAM = 0,
	PORT_LRAM_SLOT_SZ = 128,
	PORT_PMP = 3968,
	PORT_PMP_STATUS = 0,
	PORT_PMP_QACTIVE = 4,
	PORT_PMP_SIZE = 8,
	PORT_CTRL_STAT = 4096,
	PORT_CTRL_CLR = 4100,
	PORT_IRQ_STAT___2 = 4104,
	PORT_IRQ_ENABLE_SET = 4112,
	PORT_IRQ_ENABLE_CLR = 4116,
	PORT_ACTIVATE_UPPER_ADDR = 4124,
	PORT_EXEC_FIFO = 4128,
	PORT_CMD_ERR = 4132,
	PORT_FIS_CFG = 4136,
	PORT_FIFO_THRES = 4140,
	PORT_DECODE_ERR_CNT = 4160,
	PORT_DECODE_ERR_THRESH = 4162,
	PORT_CRC_ERR_CNT = 4164,
	PORT_CRC_ERR_THRESH = 4166,
	PORT_HSHK_ERR_CNT = 4168,
	PORT_HSHK_ERR_THRESH = 4170,
	PORT_PHY_CFG = 4176,
	PORT_SLOT_STAT = 6144,
	PORT_CMD_ACTIVATE = 7168,
	PORT_CONTEXT = 7684,
	PORT_EXEC_DIAG = 7680,
	PORT_PSD_DIAG = 7744,
	PORT_SCONTROL = 7936,
	PORT_SSTATUS = 7940,
	PORT_SERROR = 7944,
	PORT_SACTIVE = 7948,
	PORT_CS_PORT_RST = 1,
	PORT_CS_DEV_RST = 2,
	PORT_CS_INIT = 4,
	PORT_CS_IRQ_WOC = 8,
	PORT_CS_CDB16 = 32,
	PORT_CS_PMP_RESUME = 64,
	PORT_CS_32BIT_ACTV = 1024,
	PORT_CS_PMP_EN = 8192,
	PORT_CS_RDY = 2147483648,
	PORT_IRQ_COMPLETE = 1,
	PORT_IRQ_ERROR___2 = 2,
	PORT_IRQ_PORTRDY_CHG = 4,
	PORT_IRQ_PWR_CHG = 8,
	PORT_IRQ_PHYRDY_CHG = 16,
	PORT_IRQ_COMWAKE = 32,
	PORT_IRQ_UNK_FIS___2 = 64,
	PORT_IRQ_DEV_XCHG = 128,
	PORT_IRQ_8B10B = 256,
	PORT_IRQ_CRC = 512,
	PORT_IRQ_HANDSHAKE = 1024,
	PORT_IRQ_SDB_NOTIFY = 2048,
	DEF_PORT_IRQ___2 = 2259,
	PORT_IRQ_RAW_SHIFT = 16,
	PORT_IRQ_MASKED_MASK = 2047,
	PORT_IRQ_RAW_MASK = 134152192,
	PORT_IRQ_STEER_SHIFT = 30,
	PORT_IRQ_STEER_MASK = 3221225472,
	PORT_CERR_DEV = 1,
	PORT_CERR_SDB = 2,
	PORT_CERR_DATA = 3,
	PORT_CERR_SEND = 4,
	PORT_CERR_INCONSISTENT = 5,
	PORT_CERR_DIRECTION = 6,
	PORT_CERR_UNDERRUN = 7,
	PORT_CERR_OVERRUN = 8,
	PORT_CERR_PKT_PROT = 11,
	PORT_CERR_SGT_BOUNDARY = 16,
	PORT_CERR_SGT_TGTABRT = 17,
	PORT_CERR_SGT_MSTABRT = 18,
	PORT_CERR_SGT_PCIPERR = 19,
	PORT_CERR_CMD_BOUNDARY = 24,
	PORT_CERR_CMD_TGTABRT = 25,
	PORT_CERR_CMD_MSTABRT = 26,
	PORT_CERR_CMD_PCIPERR = 27,
	PORT_CERR_XFR_UNDEF = 32,
	PORT_CERR_XFR_TGTABRT = 33,
	PORT_CERR_XFR_MSTABRT = 34,
	PORT_CERR_XFR_PCIPERR = 35,
	PORT_CERR_SENDSERVICE = 36,
	PRB_CTRL_PROTOCOL = 1,
	PRB_CTRL_PACKET_READ = 16,
	PRB_CTRL_PACKET_WRITE = 32,
	PRB_CTRL_NIEN = 64,
	PRB_CTRL_SRST = 128,
	PRB_PROT_PACKET = 1,
	PRB_PROT_TCQ = 2,
	PRB_PROT_NCQ = 4,
	PRB_PROT_READ = 8,
	PRB_PROT_WRITE = 16,
	PRB_PROT_TRANSPARENT = 32,
	SGE_TRM = 2147483648,
	SGE_LNK = 1073741824,
	SGE_DRD = 536870912,
	SIL24_MAX_CMDS = 31,
	BID_SIL3124 = 0,
	BID_SIL3132 = 1,
	BID_SIL3131 = 2,
	SIL24_COMMON_FLAGS = 918658,
	SIL24_FLAG_PCIX_IRQ_WOC = 16777216,
	IRQ_STAT_4PORTS = 15,
};

struct sil24_ata_block {
	struct sil24_prb prb;
	struct sil24_sge sge[253];
};

struct sil24_atapi_block {
	struct sil24_prb prb;
	u8 cdb[16];
	struct sil24_sge sge[253];
};

union sil24_cmd_block {
	struct sil24_ata_block ata;
	struct sil24_atapi_block atapi;
};

struct sil24_cerr_info {
	unsigned int err_mask;
	unsigned int action;
	const char *desc;
};

struct sil24_port_priv {
	union sil24_cmd_block *cmd_block;
	dma_addr_t cmd_block_dma;
	int do_port_rst;
};

enum {
	ADMA_MMIO_BAR = 4,
	ADMA_PORTS = 2,
	ADMA_CPB_BYTES = 40,
	ADMA_PRD_BYTES = 2048,
	ADMA_PKT_BYTES = 2088,
	ADMA_DMA_BOUNDARY = 4294967295,
	ADMA_MODE_LOCK = 199,
	ADMA_CONTROL = 0,
	ADMA_STATUS = 2,
	ADMA_CPB_COUNT = 4,
	ADMA_CPB_CURRENT = 12,
	ADMA_CPB_NEXT = 12,
	ADMA_CPB_LOOKUP = 16,
	ADMA_FIFO_IN = 20,
	ADMA_FIFO_OUT = 22,
	aNIEN = 256,
	aGO = 128,
	aRSTADM = 32,
	aPIOMD4 = 3,
	aPSD = 64,
	aUIRQ = 16,
	aPERR = 1,
	cDONE = 1,
	cATERR = 8,
	cVLD = 1,
	cDAT = 4,
	cIEN = 8,
	pORD = 16,
	pDIRO = 32,
	pEND = 128,
	rIGN = 32,
	rEND = 128,
	ADMA_REGS_CONTROL = 14,
	ADMA_REGS_SECTOR_COUNT = 18,
	ADMA_REGS_LBA_LOW = 19,
	ADMA_REGS_LBA_MID = 20,
	ADMA_REGS_LBA_HIGH = 21,
	ADMA_REGS_DEVICE = 22,
	ADMA_REGS_COMMAND = 23,
	board_1841_idx = 0,
};

typedef enum {
	adma_state_idle = 0,
	adma_state_pkt = 1,
	adma_state_mmio = 2,
} adma_state_t;

struct adma_port_priv {
	u8 *pkt;
	dma_addr_t pkt_dma;
	adma_state_t state;
};

enum {
	QS_MMIO_BAR = 4,
	QS_PORTS = 4,
	QS_MAX_PRD = 128,
	QS_CPB_ORDER = 6,
	QS_CPB_BYTES = 64,
	QS_PRD_BYTES = 2048,
	QS_PKT_BYTES = 2112,
	QS_HCF_CNFG3 = 3,
	QS_HID_HPHY = 4,
	QS_HCT_CTRL = 228,
	QS_HST_SFF = 256,
	QS_HVS_SERD3 = 915,
	QS_HPHY_64BIT = 2,
	QS_CNFG3_GSRST = 1,
	QS_SERD3_PHY_ENA = 240,
	QS_CCF_CPBA = 1808,
	QS_CCF_CSEP = 1816,
	QS_CFC_HUFT = 2048,
	QS_CFC_HDFT = 2052,
	QS_CFC_DUFT = 2056,
	QS_CFC_DDFT = 2060,
	QS_CCT_CTR0 = 2304,
	QS_CCT_CTR1 = 2305,
	QS_CCT_CFF = 2560,
	QS_CTR0_REG = 2,
	QS_CTR0_CLER = 4,
	QS_CTR1_RDEV = 2,
	QS_CTR1_RCHN = 16,
	QS_CCF_RUN_PKT = 263,
	QS_HCB_HDR = 1,
	QS_DCB_HDR = 2,
	QS_HF_DIRO = 1,
	QS_HF_DAT = 8,
	QS_HF_IEN = 16,
	QS_HF_VLD = 32,
	QS_DF_PORD = 4,
	QS_DF_ELBA = 8,
	board_2068_idx = 0,
};

enum {
	QS_DMA_BOUNDARY = 4294967295,
};

typedef enum {
	qs_state_mmio = 0,
	qs_state_pkt = 1,
} qs_state_t;

struct qs_port_priv {
	u8 *pkt;
	dma_addr_t pkt_dma;
	qs_state_t state;
};

enum pdc_packet_bits {
	PDC_PKT_READ = 4,
	PDC_PKT_NODATA = 8,
	PDC_PKT_SIZEMASK = 224,
	PDC_PKT_CLEAR_BSY = 16,
	PDC_PKT_WAIT_DRDY = 24,
	PDC_LAST_REG = 8,
	PDC_REG_DEVCTL = 14,
};

enum {
	PDC_MMIO_BAR = 3,
	PDC_DIMM_BAR = 4,
	PDC_PRD_TBL = 68,
	PDC_PKT_SUBMIT = 64,
	PDC_HDMA_PKT_SUBMIT = 256,
	PDC_INT_SEQMASK = 64,
	PDC_HDMA_CTLSTAT = 300,
	PDC_CTLSTAT = 96,
	PDC_20621_SEQCTL = 1024,
	PDC_20621_SEQMASK = 1152,
	PDC_20621_GENERAL_CTL = 1156,
	PDC_20621_PAGE_SIZE = 32768,
	PDC_20621_DIMM_WINDOW = 12,
	PDC_20621_DIMM_BASE = 2097152,
	PDC_20621_DIMM_DATA = 65536,
	PDC_DIMM_DATA_STEP = 262144,
	PDC_DIMM_WINDOW_STEP = 8192,
	PDC_DIMM_HOST_PRD = 6144,
	PDC_DIMM_HOST_PKT = 0,
	PDC_DIMM_HPKT_PRD = 128,
	PDC_DIMM_ATA_PKT = 256,
	PDC_DIMM_APKT_PRD = 384,
	PDC_DIMM_HEADER_SZ = 512,
	PDC_PAGE_WINDOW = 64,
	PDC_PAGE_DATA = 66,
	PDC_PAGE_SET = 8,
	PDC_CHIP0_OFS = 786432,
	PDC_20621_ERR_MASK = 16252928,
	board_20621 = 0,
	PDC_MASK_INT = 1024,
	PDC_RESET = 2048,
	PDC_DMA_ENABLE = 128,
	PDC_MAX_HDMA = 32,
	PDC_HDMA_Q_MASK = 31,
	PDC_DIMM0_SPD_DEV_ADDRESS = 80,
	PDC_DIMM1_SPD_DEV_ADDRESS = 81,
	PDC_I2C_CONTROL = 72,
	PDC_I2C_ADDR_DATA = 76,
	PDC_DIMM0_CONTROL = 128,
	PDC_DIMM1_CONTROL = 132,
	PDC_SDRAM_CONTROL = 136,
	PDC_I2C_WRITE = 0,
	PDC_I2C_READ = 64,
	PDC_I2C_START = 128,
	PDC_I2C_MASK_INT = 32,
	PDC_I2C_COMPLETE = 65536,
	PDC_I2C_NO_ACK = 1048576,
	PDC_DIMM_SPD_SUBADDRESS_START = 0,
	PDC_DIMM_SPD_SUBADDRESS_END = 127,
	PDC_DIMM_SPD_ROW_NUM = 3,
	PDC_DIMM_SPD_COLUMN_NUM = 4,
	PDC_DIMM_SPD_MODULE_ROW = 5,
	PDC_DIMM_SPD_TYPE = 11,
	PDC_DIMM_SPD_FRESH_RATE = 12,
	PDC_DIMM_SPD_BANK_NUM = 17,
	PDC_DIMM_SPD_CAS_LATENCY = 18,
	PDC_DIMM_SPD_ATTRIBUTE = 21,
	PDC_DIMM_SPD_ROW_PRE_CHARGE = 27,
	PDC_DIMM_SPD_ROW_ACTIVE_DELAY = 28,
	PDC_DIMM_SPD_RAS_CAS_DELAY = 29,
	PDC_DIMM_SPD_ACTIVE_PRECHARGE = 30,
	PDC_DIMM_SPD_SYSTEM_FREQ = 126,
	PDC_CTL_STATUS = 8,
	PDC_DIMM_WINDOW_CTLR = 12,
	PDC_TIME_CONTROL = 60,
	PDC_TIME_PERIOD = 64,
	PDC_TIME_COUNTER = 68,
	PDC_GENERAL_CTLR = 1156,
	PCI_PLL_INIT = 2320701476,
	PCI_X_TCOUNT = 3994967295,
	PDC_TIMER_BUZZER = 1024,
	PDC_TIMER_MODE_PERIODIC = 0,
	PDC_TIMER_MODE_ONCE = 256,
	PDC_TIMER_ENABLE = 128,
	PDC_TIMER_MASK_INT = 32,
	PDC_TIMER_SEQ_MASK = 31,
	PDC_TIMER_DEFAULT = 416,
};

struct pdc_port_priv {
	u8 dimm_buf[2560];
	u8 *pkt;
	dma_addr_t pkt_dma;
};

struct pdc_host_priv {
	unsigned int doing_hdma;
	unsigned int hdma_prod;
	unsigned int hdma_cons;
	struct {
		struct ata_queued_cmd *qc;
		unsigned int seq;
		long unsigned int pkt_ofs;
	} hdma[32];
};

enum {
	PIIX_IOCFG = 84,
	ICH5_PMR = 144,
	ICH5_PCS = 146,
	PIIX_SIDPR_BAR = 5,
	PIIX_SIDPR_LEN = 16,
	PIIX_SIDPR_IDX = 0,
	PIIX_SIDPR_DATA = 4,
	PIIX_FLAG_CHECKINTR = 268435456,
	PIIX_FLAG_SIDPR = 536870912,
	PIIX_PATA_FLAGS = 1,
	PIIX_SATA_FLAGS = 268435458,
	PIIX_FLAG_PIO16 = 1073741824,
	PIIX_80C_PRI = 48,
	PIIX_80C_SEC = 192,
	P0 = 0,
	P1 = 1,
	P2 = 2,
	P3 = 3,
	IDE = 4294967295,
	NA = 4294967294,
	RV = 4294967293,
	PIIX_AHCI_DEVICE = 6,
	PIIX_HOST_BROKEN_SUSPEND = 16777216,
};

enum piix_controller_ids {
	piix_pata_mwdma = 0,
	piix_pata_33 = 1,
	ich_pata_33 = 2,
	ich_pata_66 = 3,
	ich_pata_100 = 4,
	ich_pata_100_nomwdma1 = 5,
	ich5_sata = 6,
	ich6_sata = 7,
	ich6m_sata = 8,
	ich8_sata = 9,
	ich8_2port_sata = 10,
	ich8m_apple_sata = 11,
	tolapai_sata = 12,
	piix_pata_vmw = 13,
	ich8_sata_snb = 14,
	ich8_2port_sata_snb = 15,
	ich8_2port_sata_byt = 16,
};

struct piix_map_db {
	const u32 mask;
	const u16 port_enable;
	const int map[0];
};

struct piix_host_priv {
	const int *map;
	u32 saved_iocfg;
	void *sidpr;
};

struct ich_laptop {
	u16 device;
	u16 subvendor;
	u16 subdevice;
};

struct mv_sata_platform_data {
	int n_ports;
};

struct mbus_dram_window {
	u8 cs_index;
	u8 mbus_attr;
	u64 base;
	u64 size;
};

struct mbus_dram_target_info {
	u8 mbus_dram_target_id;
	int num_cs;
	struct mbus_dram_window cs[4];
};

enum {
	MV_PRIMARY_BAR = 0,
	MV_IO_BAR = 2,
	MV_MISC_BAR = 3,
	MV_MAJOR_REG_AREA_SZ = 65536,
	MV_MINOR_REG_AREA_SZ = 8192,
	COAL_CLOCKS_PER_USEC = 150,
	MAX_COAL_TIME_THRESHOLD = 16777215,
	MAX_COAL_IO_COUNT = 255,
	MV_PCI_REG_BASE = 0,
	COAL_REG_BASE = 98304,
	IRQ_COAL_CAUSE = 98312,
	ALL_PORTS_COAL_IRQ = 16,
	IRQ_COAL_IO_THRESHOLD = 98508,
	IRQ_COAL_TIME_THRESHOLD = 98512,
	TRAN_COAL_CAUSE_LO = 98440,
	TRAN_COAL_CAUSE_HI = 98444,
	SATAHC0_REG_BASE = 131072,
	FLASH_CTL = 66668,
	GPIO_PORT_CTL = 66800,
	RESET_CFG = 98520,
	MV_PCI_REG_SZ = 65536,
	MV_SATAHC_REG_SZ = 65536,
	MV_SATAHC_ARBTR_REG_SZ = 8192,
	MV_PORT_REG_SZ = 8192,
	MV_MAX_Q_DEPTH = 32,
	MV_MAX_Q_DEPTH_MASK = 31,
	MV_CRQB_Q_SZ = 1024,
	MV_CRPB_Q_SZ = 256,
	MV_MAX_SG_CT = 256,
	MV_SG_TBL_SZ = 4096,
	MV_PORT_HC_SHIFT = 2,
	MV_PORTS_PER_HC = 4,
	MV_PORT_MASK = 3,
	MV_FLAG_DUAL_HC = 1073741824,
	MV_COMMON_FLAGS = 514,
	MV_GEN_I_FLAGS = 578,
	MV_GEN_II_FLAGS = 656898,
	MV_GEN_IIE_FLAGS = 919042,
	CRQB_FLAG_READ = 1,
	CRQB_TAG_SHIFT = 1,
	CRQB_IOID_SHIFT = 6,
	CRQB_PMP_SHIFT = 12,
	CRQB_HOSTQ_SHIFT = 17,
	CRQB_CMD_ADDR_SHIFT = 8,
	CRQB_CMD_CS = 4096,
	CRQB_CMD_LAST = 32768,
	CRPB_FLAG_STATUS_SHIFT = 8,
	CRPB_IOID_SHIFT_6 = 5,
	CRPB_IOID_SHIFT_7 = 7,
	EPRD_FLAG_END_OF_TBL = 2147483648,
	MV_PCI_COMMAND = 3072,
	MV_PCI_COMMAND_MWRCOM = 16,
	MV_PCI_COMMAND_MRDTRIG = 128,
	PCI_MAIN_CMD_STS = 3376,
	STOP_PCI_MASTER = 4,
	PCI_MASTER_EMPTY = 8,
	GLOB_SFT_RST = 16,
	MV_PCI_MODE = 3328,
	MV_PCI_MODE_MASK = 48,
	MV_PCI_EXP_ROM_BAR_CTL = 3372,
	MV_PCI_DISC_TIMER = 3332,
	MV_PCI_MSI_TRIGGER = 3128,
	MV_PCI_SERR_MASK = 3112,
	MV_PCI_XBAR_TMOUT = 7428,
	MV_PCI_ERR_LOW_ADDRESS = 7488,
	MV_PCI_ERR_HIGH_ADDRESS = 7492,
	MV_PCI_ERR_ATTRIBUTE = 7496,
	MV_PCI_ERR_COMMAND = 7504,
	PCI_IRQ_CAUSE = 7512,
	PCI_IRQ_MASK = 7516,
	PCI_UNMASK_ALL_IRQS = 8388607,
	PCIE_IRQ_CAUSE = 6400,
	PCIE_IRQ_MASK = 6416,
	PCIE_UNMASK_ALL_IRQS = 1034,
	PCI_HC_MAIN_IRQ_CAUSE = 7520,
	PCI_HC_MAIN_IRQ_MASK = 7524,
	SOC_HC_MAIN_IRQ_CAUSE = 131104,
	SOC_HC_MAIN_IRQ_MASK = 131108,
	ERR_IRQ = 1,
	DONE_IRQ = 2,
	HC0_IRQ_PEND = 511,
	HC_SHIFT = 9,
	DONE_IRQ_0_3 = 170,
	DONE_IRQ_4_7 = 87040,
	PCI_ERR = 262144,
	TRAN_COAL_LO_DONE = 524288,
	TRAN_COAL_HI_DONE = 1048576,
	PORTS_0_3_COAL_DONE = 256,
	PORTS_4_7_COAL_DONE = 131072,
	ALL_PORTS_COAL_DONE = 2097152,
	GPIO_INT = 4194304,
	SELF_INT = 8388608,
	TWSI_INT = 16777216,
	HC_MAIN_RSVD = 4261412864,
	HC_MAIN_RSVD_5 = 4294443008,
	HC_MAIN_RSVD_SOC = 4294966976,
	HC_CFG = 0,
	HC_IRQ_CAUSE = 20,
	DMA_IRQ = 1,
	HC_COAL_IRQ = 16,
	DEV_IRQ = 256,
	HC_IRQ_COAL_IO_THRESHOLD = 12,
	HC_IRQ_COAL_TIME_THRESHOLD = 16,
	SOC_LED_CTRL = 44,
	SOC_LED_CTRL_BLINK = 1,
	SOC_LED_CTRL_ACT_PRESENCE = 4,
	SHD_BLK = 256,
	SHD_CTL_AST = 32,
	SATA_STATUS = 768,
	SATA_ACTIVE = 848,
	FIS_IRQ_CAUSE = 868,
	FIS_IRQ_CAUSE_AN = 512,
	LTMODE = 780,
	LTMODE_BIT8 = 256,
	PHY_MODE2 = 816,
	PHY_MODE3 = 784,
	PHY_MODE4 = 788,
	PHY_MODE4_CFG_MASK = 3,
	PHY_MODE4_CFG_VALUE = 1,
	PHY_MODE4_RSVD_ZEROS = 1575223290,
	PHY_MODE4_RSVD_ONES = 5,
	SATA_IFCTL = 836,
	SATA_TESTCTL = 840,
	SATA_IFSTAT = 844,
	VENDOR_UNIQUE_FIS = 860,
	FISCFG = 864,
	FISCFG_WAIT_DEV_ERR = 256,
	FISCFG_SINGLE_SYNC = 65536,
	PHY_MODE9_GEN2 = 920,
	PHY_MODE9_GEN1 = 924,
	PHYCFG_OFS = 928,
	MV5_PHY_MODE = 116,
	MV5_LTMODE = 48,
	MV5_PHY_CTL = 12,
	SATA_IFCFG = 80,
	LP_PHY_CTL = 88,
	LP_PHY_CTL_PIN_PU_PLL = 1,
	LP_PHY_CTL_PIN_PU_RX = 2,
	LP_PHY_CTL_PIN_PU_TX = 4,
	LP_PHY_CTL_GEN_TX_3G = 32,
	LP_PHY_CTL_GEN_RX_3G = 512,
	MV_M2_PREAMP_MASK = 2016,
	EDMA_CFG = 0,
	EDMA_CFG_Q_DEPTH = 31,
	EDMA_CFG_NCQ = 32,
	EDMA_CFG_NCQ_GO_ON_ERR = 16384,
	EDMA_CFG_RD_BRST_EXT = 2048,
	EDMA_CFG_WR_BUFF_LEN = 8192,
	EDMA_CFG_EDMA_FBS = 65536,
	EDMA_CFG_FBS = 67108864,
	EDMA_ERR_IRQ_CAUSE = 8,
	EDMA_ERR_IRQ_MASK = 12,
	EDMA_ERR_D_PAR = 1,
	EDMA_ERR_PRD_PAR = 2,
	EDMA_ERR_DEV = 4,
	EDMA_ERR_DEV_DCON = 8,
	EDMA_ERR_DEV_CON = 16,
	EDMA_ERR_SERR = 32,
	EDMA_ERR_SELF_DIS = 128,
	EDMA_ERR_SELF_DIS_5 = 256,
	EDMA_ERR_BIST_ASYNC = 256,
	EDMA_ERR_TRANS_IRQ_7 = 256,
	EDMA_ERR_CRQB_PAR = 512,
	EDMA_ERR_CRPB_PAR = 1024,
	EDMA_ERR_INTRL_PAR = 2048,
	EDMA_ERR_IORDY = 4096,
	EDMA_ERR_LNK_CTRL_RX = 122880,
	EDMA_ERR_LNK_CTRL_RX_0 = 8192,
	EDMA_ERR_LNK_CTRL_RX_1 = 16384,
	EDMA_ERR_LNK_CTRL_RX_2 = 32768,
	EDMA_ERR_LNK_CTRL_RX_3 = 65536,
	EDMA_ERR_LNK_DATA_RX = 1966080,
	EDMA_ERR_LNK_CTRL_TX = 65011712,
	EDMA_ERR_LNK_CTRL_TX_0 = 2097152,
	EDMA_ERR_LNK_CTRL_TX_1 = 4194304,
	EDMA_ERR_LNK_CTRL_TX_2 = 8388608,
	EDMA_ERR_LNK_CTRL_TX_3 = 16777216,
	EDMA_ERR_LNK_CTRL_TX_4 = 33554432,
	EDMA_ERR_LNK_DATA_TX = 2080374784,
	EDMA_ERR_TRANS_PROTO = 2147483648,
	EDMA_ERR_OVERRUN_5 = 32,
	EDMA_ERR_UNDERRUN_5 = 64,
	EDMA_ERR_IRQ_TRANSIENT = 65101824,
	EDMA_EH_FREEZE = 4229865147,
	EDMA_EH_FREEZE_5 = 8059,
	EDMA_REQ_Q_BASE_HI = 16,
	EDMA_REQ_Q_IN_PTR = 20,
	EDMA_REQ_Q_OUT_PTR = 24,
	EDMA_REQ_Q_PTR_SHIFT = 5,
	EDMA_RSP_Q_BASE_HI = 28,
	EDMA_RSP_Q_IN_PTR = 32,
	EDMA_RSP_Q_OUT_PTR = 36,
	EDMA_RSP_Q_PTR_SHIFT = 3,
	EDMA_CMD = 40,
	EDMA_EN = 1,
	EDMA_DS = 2,
	EDMA_RESET = 4,
	EDMA_STATUS = 48,
	EDMA_STATUS_CACHE_EMPTY = 64,
	EDMA_STATUS_IDLE = 128,
	EDMA_IORDY_TMOUT = 52,
	EDMA_ARB_CFG = 56,
	EDMA_HALTCOND = 96,
	EDMA_UNKNOWN_RSVD = 108,
	BMDMA_CMD = 548,
	BMDMA_STATUS = 552,
	BMDMA_PRD_LOW = 556,
	BMDMA_PRD_HIGH = 560,
	MV_HP_FLAG_MSI = 1,
	MV_HP_ERRATA_50XXB0 = 2,
	MV_HP_ERRATA_50XXB2 = 4,
	MV_HP_ERRATA_60X1B2 = 8,
	MV_HP_ERRATA_60X1C0 = 16,
	MV_HP_GEN_I = 64,
	MV_HP_GEN_II = 128,
	MV_HP_GEN_IIE = 256,
	MV_HP_PCIE = 512,
	MV_HP_CUT_THROUGH = 1024,
	MV_HP_FLAG_SOC = 2048,
	MV_HP_QUIRK_LED_BLINK_EN = 4096,
	MV_HP_FIX_LP_PHY_CTL = 8192,
	MV_PP_FLAG_EDMA_EN = 1,
	MV_PP_FLAG_NCQ_EN = 2,
	MV_PP_FLAG_FBS_EN = 4,
	MV_PP_FLAG_DELAYED_EH = 8,
	MV_PP_FLAG_FAKE_ATA_BUSY = 16,
};

enum {
	MV_DMA_BOUNDARY = 65535,
	EDMA_REQ_Q_BASE_LO_MASK = 4294966272,
	EDMA_RSP_Q_BASE_LO_MASK = 4294967040,
};

enum chip_type {
	chip_504x = 0,
	chip_508x = 1,
	chip_5080 = 2,
	chip_604x = 3,
	chip_608x = 4,
	chip_6042 = 5,
	chip_7042 = 6,
	chip_soc = 7,
};

struct mv_crqb {
	__le32 sg_addr;
	__le32 sg_addr_hi;
	__le16 ctrl_flags;
	__le16 ata_cmd[11];
};

struct mv_crqb_iie {
	__le32 addr;
	__le32 addr_hi;
	__le32 flags;
	__le32 len;
	__le32 ata_cmd[4];
};

struct mv_crpb {
	__le16 id;
	__le16 flags;
	__le32 tmstmp;
};

struct mv_sg {
	__le32 addr;
	__le32 flags_size;
	__le32 addr_hi;
	__le32 reserved;
};

struct mv_cached_regs {
	u32 fiscfg;
	u32 ltmode;
	u32 haltcond;
	u32 unknown_rsvd;
};

struct mv_port_priv {
	struct mv_crqb *crqb;
	dma_addr_t crqb_dma;
	struct mv_crpb *crpb;
	dma_addr_t crpb_dma;
	struct mv_sg *sg_tbl[32];
	dma_addr_t sg_tbl_dma[32];
	unsigned int req_idx;
	unsigned int resp_idx;
	u32 pp_flags;
	struct mv_cached_regs cached;
	unsigned int delayed_eh_pmp_map;
};

struct mv_port_signal {
	u32 amps;
	u32 pre;
};

struct mv_hw_ops;

struct mv_host_priv {
	u32 hp_flags;
	unsigned int board_idx;
	u32 main_irq_mask;
	struct mv_port_signal signal[8];
	const struct mv_hw_ops *ops;
	int n_ports;
	void *base;
	void *main_irq_cause_addr;
	void *main_irq_mask_addr;
	u32 irq_cause_offset;
	u32 irq_mask_offset;
	u32 unmask_all_irqs;
	struct clk *clk;
	struct clk **port_clks;
	struct phy **port_phys;
	struct dma_pool *crqb_pool;
	struct dma_pool *crpb_pool;
	struct dma_pool *sg_tbl_pool;
};

struct mv_hw_ops {
	void (*phy_errata)(struct mv_host_priv *, void *, unsigned int);
	void (*enable_leds)(struct mv_host_priv *, void *);
	void (*read_preamp)(struct mv_host_priv *, int, void *);
	int (*reset_hc)(struct mv_host_priv *, void *, unsigned int);
	void (*reset_flash)(struct mv_host_priv *, void *);
	void (*reset_bus)(struct ata_host *, void *);
};

enum {
	NV_MMIO_BAR = 5,
	NV_PORTS = 2,
	NV_PIO_MASK = 31,
	NV_MWDMA_MASK = 7,
	NV_UDMA_MASK = 127,
	NV_PORT0_SCR_REG_OFFSET = 0,
	NV_PORT1_SCR_REG_OFFSET = 64,
	NV_INT_STATUS = 16,
	NV_INT_ENABLE = 17,
	NV_INT_STATUS_CK804 = 1088,
	NV_INT_ENABLE_CK804 = 1089,
	NV_INT_DEV = 1,
	NV_INT_PM = 2,
	NV_INT_ADDED = 4,
	NV_INT_REMOVED = 8,
	NV_INT_PORT_SHIFT = 4,
	NV_INT_ALL = 15,
	NV_INT_MASK = 13,
	NV_INT_CONFIG = 18,
	NV_INT_CONFIG_METHD = 1,
	NV_MCP_SATA_CFG_20 = 80,
	NV_MCP_SATA_CFG_20_SATA_SPACE_EN = 4,
	NV_MCP_SATA_CFG_20_PORT0_EN = 131072,
	NV_MCP_SATA_CFG_20_PORT1_EN = 65536,
	NV_MCP_SATA_CFG_20_PORT0_PWB_EN = 16384,
	NV_MCP_SATA_CFG_20_PORT1_PWB_EN = 4096,
	NV_ADMA_MAX_CPBS = 32,
	NV_ADMA_CPB_SZ = 128,
	NV_ADMA_APRD_SZ = 16,
	NV_ADMA_SGTBL_LEN = 56,
	NV_ADMA_SGTBL_TOTAL_LEN = 61,
	NV_ADMA_SGTBL_SZ = 896,
	NV_ADMA_PORT_PRIV_DMA_SZ = 32768,
	NV_ADMA_GEN = 1024,
	NV_ADMA_GEN_CTL = 0,
	NV_ADMA_NOTIFIER_CLEAR = 48,
	NV_ADMA_PORT = 1152,
	NV_ADMA_PORT_SIZE = 256,
	NV_ADMA_CTL = 64,
	NV_ADMA_CPB_COUNT = 66,
	NV_ADMA_NEXT_CPB_IDX = 67,
	NV_ADMA_STAT = 68,
	NV_ADMA_CPB_BASE_LOW = 72,
	NV_ADMA_CPB_BASE_HIGH = 76,
	NV_ADMA_APPEND = 80,
	NV_ADMA_NOTIFIER = 104,
	NV_ADMA_NOTIFIER_ERROR = 108,
	NV_ADMA_CTL_HOTPLUG_IEN = 1,
	NV_ADMA_CTL_CHANNEL_RESET = 32,
	NV_ADMA_CTL_GO = 128,
	NV_ADMA_CTL_AIEN = 256,
	NV_ADMA_CTL_READ_NON_COHERENT = 2048,
	NV_ADMA_CTL_WRITE_NON_COHERENT = 4096,
	NV_CPB_RESP_DONE = 1,
	NV_CPB_RESP_ATA_ERR = 8,
	NV_CPB_RESP_CMD_ERR = 16,
	NV_CPB_RESP_CPB_ERR = 128,
	NV_CPB_CTL_CPB_VALID = 1,
	NV_CPB_CTL_QUEUE = 2,
	NV_CPB_CTL_APRD_VALID = 4,
	NV_CPB_CTL_IEN = 8,
	NV_CPB_CTL_FPDMA = 16,
	NV_APRD_WRITE = 2,
	NV_APRD_END = 4,
	NV_APRD_CONT = 8,
	NV_ADMA_STAT_TIMEOUT = 1,
	NV_ADMA_STAT_HOTUNPLUG = 2,
	NV_ADMA_STAT_HOTPLUG = 4,
	NV_ADMA_STAT_CPBERR = 16,
	NV_ADMA_STAT_SERROR = 32,
	NV_ADMA_STAT_CMD_COMPLETE = 64,
	NV_ADMA_STAT_IDLE = 256,
	NV_ADMA_STAT_LEGACY = 512,
	NV_ADMA_STAT_STOPPED = 1024,
	NV_ADMA_STAT_DONE = 4096,
	NV_ADMA_STAT_ERR = 17,
	NV_ADMA_PORT_REGISTER_MODE = 1,
	NV_ADMA_ATAPI_SETUP_COMPLETE = 2,
	NV_CTL_MCP55 = 1024,
	NV_INT_STATUS_MCP55 = 1088,
	NV_INT_ENABLE_MCP55 = 1092,
	NV_NCQ_REG_MCP55 = 1096,
	NV_INT_ALL_MCP55 = 65535,
	NV_INT_PORT_SHIFT_MCP55 = 16,
	NV_INT_MASK_MCP55 = 65533,
	NV_CTL_PRI_SWNCQ = 2,
	NV_CTL_SEC_SWNCQ = 4,
	NV_SWNCQ_IRQ_DEV = 1,
	NV_SWNCQ_IRQ_PM = 2,
	NV_SWNCQ_IRQ_ADDED = 4,
	NV_SWNCQ_IRQ_REMOVED = 8,
	NV_SWNCQ_IRQ_BACKOUT = 16,
	NV_SWNCQ_IRQ_SDBFIS = 32,
	NV_SWNCQ_IRQ_DHREGFIS = 64,
	NV_SWNCQ_IRQ_DMASETUP = 128,
	NV_SWNCQ_IRQ_HOTPLUG = 12,
};

struct nv_adma_prd {
	__le64 addr;
	__le32 len;
	u8 flags;
	u8 packet_len;
	__le16 reserved;
};

enum nv_adma_regbits {
	CMDEND = 32768,
	WNB = 16384,
	IGN = 8192,
	CS1n = 4096,
	DA2 = 1024,
	DA1 = 512,
	DA0 = 256,
};

struct nv_adma_cpb {
	u8 resp_flags;
	u8 reserved1;
	u8 ctl_flags;
	u8 len;
	u8 tag;
	u8 next_cpb_idx;
	__le16 reserved2;
	__le16 tf[12];
	struct nv_adma_prd aprd[5];
	__le64 next_aprd;
	__le64 reserved3;
};

struct nv_adma_port_priv {
	struct nv_adma_cpb *cpb;
	dma_addr_t cpb_dma;
	struct nv_adma_prd *aprd;
	dma_addr_t aprd_dma;
	void *ctl_block;
	void *gen_block;
	void *notifier_clear_block;
	u64 adma_dma_mask;
	u8 flags;
	int last_issue_ncq;
};

struct nv_host_priv {
	long unsigned int type;
};

struct defer_queue {
	u32 defer_bits;
	unsigned int head;
	unsigned int tail;
	unsigned int tag[32];
};

enum ncq_saw_flag_list {
	ncq_saw_d2h = 1,
	ncq_saw_dmas = 2,
	ncq_saw_sdb = 4,
	ncq_saw_backout = 8,
};

struct nv_swncq_port_priv {
	struct ata_bmdma_prd *prd;
	dma_addr_t prd_dma;
	void *sactive_block;
	void *irq_block;
	void *tag_block;
	u32 qc_active;
	unsigned int last_issue_tag;
	struct defer_queue defer_queue;
	u32 dhfis_bits;
	u32 dmafis_bits;
	u32 sdbfis_bits;
	unsigned int ncq_flags;
};

enum nv_host_type {
	GENERIC = 0,
	NFORCE2 = 1,
	NFORCE3 = 1,
	CK804 = 2,
	ADMA = 3,
	MCP5x = 4,
	SWNCQ = 5,
};

struct nv_pi_priv {
	irq_handler_t irq_handler;
	struct scsi_host_template *sht;
};

enum {
	PDC_MAX_PORTS = 4,
	PDC_MMIO_BAR___2 = 3,
	PDC_MAX_PRD = 127,
	PDC_INT_SEQMASK___2 = 64,
	PDC_FLASH_CTL = 68,
	PDC_PCI_CTL = 72,
	PDC_SATA_PLUG_CSR = 108,
	PDC2_SATA_PLUG_CSR = 96,
	PDC_TBG_MODE = 1052,
	PDC_SLEW_CTL = 1136,
	PDC_FEATURE = 4,
	PDC_SECTOR_COUNT = 8,
	PDC_SECTOR_NUMBER = 12,
	PDC_CYLINDER_LOW = 16,
	PDC_CYLINDER_HIGH = 20,
	PDC_DEVICE = 24,
	PDC_COMMAND = 28,
	PDC_ALTSTATUS = 56,
	PDC_PKT_SUBMIT___2 = 64,
	PDC_GLOBAL_CTL = 72,
	PDC_CTLSTAT___2 = 96,
	PDC_SATA_ERROR = 4,
	PDC_PHYMODE4 = 20,
	PDC_LINK_LAYER_ERRORS = 108,
	PDC_FPDMA_CTLSTAT = 216,
	PDC_INTERNAL_DEBUG_1 = 248,
	PDC_INTERNAL_DEBUG_2 = 252,
	PDC_FPDMA_CTLSTAT_RESET = 8,
	PDC_FPDMA_CTLSTAT_DMASETUP_INT_FLAG = 1024,
	PDC_FPDMA_CTLSTAT_SETDB_INT_FLAG = 2048,
	PDC_PH_ERR = 256,
	PDC_SH_ERR = 512,
	PDC_DH_ERR = 1024,
	PDC2_HTO_ERR = 4096,
	PDC2_ATA_HBA_ERR = 8192,
	PDC2_ATA_DMA_CNT_ERR = 16384,
	PDC_OVERRUN_ERR = 524288,
	PDC_UNDERRUN_ERR = 1048576,
	PDC_DRIVE_ERR = 2097152,
	PDC_PCI_SYS_ERR = 4194304,
	PDC1_PCI_PARITY_ERR = 8388608,
	PDC1_ERR_MASK = 8388608,
	PDC2_ERR_MASK = 28672,
	PDC_ERR_MASK = 16283392,
	board_2037x = 0,
	board_2037x_pata = 1,
	board_20319 = 2,
	board_20619 = 3,
	board_2057x = 4,
	board_2057x_pata = 5,
	board_40518 = 6,
	PDC_HAS_PATA = 2,
	PDC_SEQCNTRL_INT_MASK = 32,
	PDC_FEATURE_ATAPI_PIO = 0,
	PDC_FEATURE_ATAPI_DMA = 1,
	PDC_DEVICE_SATA = 224,
	PDC_DMA_ENABLE___2 = 128,
	PDC_IRQ_DISABLE = 1024,
	PDC_RESET___2 = 2048,
	PDC_COMMON_FLAGS = 512,
	PDC_FLAG_GEN_II = 16777216,
	PDC_FLAG_SATA_PATA = 33554432,
	PDC_FLAG_4_PORTS = 67108864,
};

struct pdc_port_priv___2 {
	u8 *pkt;
	dma_addr_t pkt_dma;
};

struct pdc_host_priv___2 {
	spinlock_t hard_reset_lock;
};

enum {
	SIL_MMIO_BAR = 5,
	SIL_FLAG_NO_SATA_IRQ = 268435456,
	SIL_FLAG_RERR_ON_DMA_ACT = 536870912,
	SIL_FLAG_MOD15WRITE = 1073741824,
	SIL_DFL_PORT_FLAGS = 2,
	sil_3112 = 0,
	sil_3112_no_sata_irq = 1,
	sil_3512 = 2,
	sil_3114 = 3,
	SIL_SYSCFG = 72,
	SIL_MASK_IDE0_INT = 4194304,
	SIL_MASK_IDE1_INT = 8388608,
	SIL_MASK_IDE2_INT = 16777216,
	SIL_MASK_IDE3_INT = 33554432,
	SIL_MASK_2PORT = 12582912,
	SIL_MASK_4PORT = 62914560,
	SIL_INTR_STEERING = 2,
	SIL_DMA_ENABLE = 1,
	SIL_DMA_RDWR = 8,
	SIL_DMA_SATA_IRQ = 16,
	SIL_DMA_ACTIVE = 65536,
	SIL_DMA_ERROR = 131072,
	SIL_DMA_COMPLETE = 262144,
	SIL_DMA_N_SATA_IRQ = 64,
	SIL_DMA_N_ACTIVE = 16777216,
	SIL_DMA_N_ERROR = 33554432,
	SIL_DMA_N_COMPLETE = 67108864,
	SIL_SIEN_N = 65536,
	SIL_QUIRK_MOD15WRITE = 1,
	SIL_QUIRK_UDMA5MAX = 2,
};

struct sil_drivelist {
	const char *product;
	unsigned int quirk;
};

enum {
	sis_180 = 0,
	SIS_SCR_PCI_BAR = 5,
	SIS_GENCTL = 84,
	SIS_SCR_BASE = 192,
	SIS180_SATA1_OFS = 16,
	SIS182_SATA1_OFS = 32,
	SIS_PMR = 144,
	SIS_PMR_COMBINED = 48,
	SIS_FLAG_CFGSCR = 1073741824,
	GENCTL_IOMAPPED_SCR = 67108864,
};

enum {
	K2_FLAG_SATA_8_PORTS = 16777216,
	K2_FLAG_NO_ATAPI_DMA = 33554432,
	K2_FLAG_BAR_POS_3 = 67108864,
	K2_SATA_TF_CMD_OFFSET = 0,
	K2_SATA_TF_DATA_OFFSET = 0,
	K2_SATA_TF_ERROR_OFFSET = 4,
	K2_SATA_TF_NSECT_OFFSET = 8,
	K2_SATA_TF_LBAL_OFFSET = 12,
	K2_SATA_TF_LBAM_OFFSET = 16,
	K2_SATA_TF_LBAH_OFFSET = 20,
	K2_SATA_TF_DEVICE_OFFSET = 24,
	K2_SATA_TF_CMDSTAT_OFFSET = 28,
	K2_SATA_TF_CTL_OFFSET = 32,
	K2_SATA_DMA_CMD_OFFSET = 48,
	K2_SATA_SCR_STATUS_OFFSET = 64,
	K2_SATA_SCR_ERROR_OFFSET = 68,
	K2_SATA_SCR_CONTROL_OFFSET = 72,
	K2_SATA_SICR1_OFFSET = 128,
	K2_SATA_SICR2_OFFSET = 132,
	K2_SATA_SIM_OFFSET = 136,
	K2_SATA_PORT_OFFSET = 256,
	chip_svw4 = 0,
	chip_svw8 = 1,
	chip_svw42 = 2,
	chip_svw43 = 3,
};

enum {
	uli_5289 = 0,
	uli_5287 = 1,
	uli_5281 = 2,
	uli_max_ports = 4,
	ULI5287_BASE = 144,
	ULI5287_OFFS = 16,
	ULI5281_BASE = 96,
	ULI5281_OFFS = 96,
};

struct uli_priv {
	unsigned int scr_cfg_addr[4];
};

enum board_ids_enum {
	vt6420 = 0,
	vt6421 = 1,
	vt8251 = 2,
};

enum {
	SATA_CHAN_ENAB = 64,
	SATA_INT_GATE = 65,
	SATA_NATIVE_MODE = 66,
	SVIA_MISC_3 = 70,
	PATA_UDMA_TIMING = 179,
	PATA_PIO_TIMING = 171,
	PORT0 = 2,
	PORT1 = 1,
	ALL_PORTS = 3,
	NATIVE_MODE_ALL = 240,
	SATA_EXT_PHY = 64,
	SATA_HOTPLUG = 32,
};

struct svia_priv {
	bool wd_workaround;
};

enum {
	VSC_MMIO_BAR = 0,
	VSC_SATA_INT_STAT_OFFSET = 0,
	VSC_SATA_INT_MASK_OFFSET = 4,
	VSC_SATA_TF_CMD_OFFSET = 0,
	VSC_SATA_TF_DATA_OFFSET = 0,
	VSC_SATA_TF_ERROR_OFFSET = 4,
	VSC_SATA_TF_FEATURE_OFFSET = 6,
	VSC_SATA_TF_NSECT_OFFSET = 8,
	VSC_SATA_TF_LBAL_OFFSET = 12,
	VSC_SATA_TF_LBAM_OFFSET = 16,
	VSC_SATA_TF_LBAH_OFFSET = 20,
	VSC_SATA_TF_DEVICE_OFFSET = 24,
	VSC_SATA_TF_STATUS_OFFSET = 28,
	VSC_SATA_TF_COMMAND_OFFSET = 29,
	VSC_SATA_TF_ALTSTATUS_OFFSET = 40,
	VSC_SATA_TF_CTL_OFFSET = 41,
	VSC_SATA_UP_DESCRIPTOR_OFFSET = 100,
	VSC_SATA_UP_DATA_BUFFER_OFFSET = 108,
	VSC_SATA_DMA_CMD_OFFSET = 112,
	VSC_SATA_SCR_STATUS_OFFSET = 256,
	VSC_SATA_SCR_ERROR_OFFSET = 260,
	VSC_SATA_SCR_CONTROL_OFFSET = 264,
	VSC_SATA_PORT_OFFSET = 512,
	VSC_SATA_INT_ERROR_CRC = 64,
	VSC_SATA_INT_ERROR_T = 32,
	VSC_SATA_INT_ERROR_P = 16,
	VSC_SATA_INT_ERROR_R = 8,
	VSC_SATA_INT_ERROR_E = 4,
	VSC_SATA_INT_ERROR_M = 2,
	VSC_SATA_INT_PHY_CHANGE = 1,
	VSC_SATA_INT_ERROR = 127,
};

enum {
	ATIIXP_IDE_PIO_TIMING = 64,
	ATIIXP_IDE_MWDMA_TIMING = 68,
	ATIIXP_IDE_PIO_CONTROL = 72,
	ATIIXP_IDE_PIO_MODE = 74,
	ATIIXP_IDE_UDMA_CONTROL = 84,
	ATIIXP_IDE_UDMA_MODE = 86,
};

enum {
	ATP867X_IO_CHANNEL_OFFSET = 16,
	ATP867X_IO_PIOSPD_ACTIVE_SHIFT = 4,
	ATP867X_IO_PIOSPD_RECOVER_SHIFT = 0,
	ATP867X_IO_DMAMODE_MSTR_SHIFT = 0,
	ATP867X_IO_DMAMODE_MSTR_MASK = 7,
	ATP867X_IO_DMAMODE_SLAVE_SHIFT = 4,
	ATP867X_IO_DMAMODE_SLAVE_MASK = 112,
	ATP867X_IO_DMAMODE_UDMA_6 = 7,
	ATP867X_IO_DMAMODE_UDMA_5 = 6,
	ATP867X_IO_DMAMODE_UDMA_4 = 5,
	ATP867X_IO_DMAMODE_UDMA_3 = 4,
	ATP867X_IO_DMAMODE_UDMA_2 = 3,
	ATP867X_IO_DMAMODE_UDMA_1 = 2,
	ATP867X_IO_DMAMODE_UDMA_0 = 1,
	ATP867X_IO_DMAMODE_DISABLE = 0,
	ATP867X_IO_SYS_INFO_66MHZ = 4,
	ATP867X_IO_SYS_INFO_SLOW_UDMA5 = 2,
	ATP867X_IO_SYS_MASK_RESERVED = 4294967054,
	ATP867X_IO_PORTSPD_VAL = 4419,
	ATP867X_PREREAD_VAL = 512,
	ATP867X_NUM_PORTS = 4,
	ATP867X_BAR_IOBASE = 0,
	ATP867X_BAR_ROMBASE = 6,
};

struct atp867x_priv {
	void *dma_mode;
	void *mstr_piospd;
	void *slave_piospd;
	void *eightb_piospd;
	int pci66mhz;
};

enum {
	CFR = 80,
	CFR_INTR_CH0 = 4,
	CNTRL = 81,
	CNTRL_CH0 = 4,
	CNTRL_CH1 = 8,
	CMDTIM = 82,
	ARTTIM0 = 83,
	DRWTIM0 = 84,
	ARTTIM1 = 85,
	DRWTIM1 = 86,
	ARTTIM23 = 87,
	ARTTIM23_DIS_RA2 = 4,
	ARTTIM23_DIS_RA3 = 8,
	ARTTIM23_INTR_CH1 = 16,
	DRWTIM2 = 88,
	BRST = 89,
	DRWTIM3 = 91,
	BMIDECR0 = 112,
	MRDMODE = 113,
	MRDMODE_INTR_CH0 = 4,
	MRDMODE_INTR_CH1 = 8,
	BMIDESR0 = 114,
	UDIDETCR0 = 115,
	DTPR0 = 116,
	BMIDECR1 = 120,
	BMIDECSR = 121,
	UDIDETCR1 = 123,
	DTPR1 = 124,
};

struct hpt_clock {
	u8 xfer_mode;
	u32 timing;
};

struct hpt_clock___2 {
	u8 xfer_speed;
	u32 timing;
};

struct hpt_chip {
	const char *name;
	unsigned int base;
	const struct hpt_clock___2 *clocks[4];
};

enum {
	HPT_PCI_FAST = 2147483648,
	PCI66 = 2,
	USE_DPLL = 1,
};

struct it821x_dev {
	unsigned int smart: 1;
	unsigned int timing10: 1;
	u8 clock_mode;
	u8 want[4];
	u16 pio[2];
	u16 mwdma[2];
	u16 udma[2];
	u16 last_device;
};

typedef enum {
	PORT_PATA0 = 0,
	PORT_PATA1 = 1,
	PORT_SATA = 2,
} port_type;

enum {
	PDC_MMIO_BAR___3 = 5,
	PDC_UDMA_100 = 0,
	PDC_UDMA_133 = 1,
	PDC_100_MHZ = 100000000,
	PDC_133_MHZ = 133333333,
	PDC_SYS_CTL = 4352,
	PDC_ATA_CTL = 4356,
	PDC_GLOBAL_CTL___2 = 4360,
	PDC_CTCR0 = 4364,
	PDC_CTCR1 = 4368,
	PDC_BYTE_COUNT = 4384,
	PDC_PLL_CTL = 4610,
};

struct pdc2027x_pio_timing {
	u8 value0;
	u8 value1;
	u8 value2;
};

struct pdc2027x_mdma_timing {
	u8 value0;
	u8 value1;
};

struct pdc2027x_udma_timing {
	u8 value0;
	u8 value1;
	u8 value2;
};

struct rdc_host_priv {
	u32 saved_iocfg;
};

enum {
	D0TIM = 128,
	D1TIM = 132,
	PM = 7,
	MDM = 768,
	UDM = 458752,
	PPE = 1073741824,
	USD = 2147483648,
};

struct sv_cable_table {
	int device;
	int subvendor;
	int (*cable_detect)(struct ata_port *);
};

struct sis_chipset {
	u16 device;
	const struct ata_port_info *info;
};

struct sis_laptop {
	u16 device;
	u16 subvendor;
	u16 subdevice;
};

enum {
	VIA_BAD_PREQ = 1,
	VIA_BAD_CLK66 = 2,
	VIA_SET_FIFO = 4,
	VIA_NO_UNMASK = 8,
	VIA_BAD_ID = 16,
	VIA_BAD_AST = 32,
	VIA_NO_ENABLES = 64,
	VIA_SATA_PATA = 128,
};

enum {
	VIA_IDFLAG_SINGLE = 1,
};

struct via_isa_bridge {
	const char *name;
	u16 id;
	u8 rev_min;
	u8 rev_max;
	u8 udma_mask;
	u8 flags;
};

struct via_port {
	u8 cached_device;
};

struct pata_acpi {
	struct ata_acpi_gtm gtm;
	void *last;
	long unsigned int mask[2];
};

enum {
	ATA_GEN_CLASS_MATCH = 1,
	ATA_GEN_FORCE_DMA = 2,
	ATA_GEN_INTEL_IDER = 4,
};

enum controller___2 {
	BIOS = 0,
	SNOOP = 1,
	PDC20230 = 2,
	HT6560A = 3,
	HT6560B = 4,
	OPTI611A = 5,
	OPTI46X = 6,
	QDI6500 = 7,
	QDI6580 = 8,
	QDI6580DP = 9,
	W83759A = 10,
	UNKNOWN___2 = 4294967295,
};

struct legacy_data {
	long unsigned int timing;
	u8 clock[2];
	u8 last;
	int fast;
	enum controller___2 type;
	struct platform_device *platform_dev;
};

struct legacy_probe {
	unsigned char *name;
	long unsigned int port;
	unsigned int irq;
	unsigned int slot;
	enum controller___2 type;
	long unsigned int private;
};

struct legacy_controller {
	const char *name;
	struct ata_port_operations *ops;
	unsigned int pio_mask;
	unsigned int flags;
	unsigned int pflags;
	int (*setup)(struct platform_device *, struct legacy_probe *, struct legacy_data *);
};

enum scsi_prot_operations {
	SCSI_PROT_NORMAL = 0,
	SCSI_PROT_READ_INSERT = 1,
	SCSI_PROT_WRITE_STRIP = 2,
	SCSI_PROT_READ_STRIP = 3,
	SCSI_PROT_WRITE_INSERT = 4,
	SCSI_PROT_READ_PASS = 5,
	SCSI_PROT_WRITE_PASS = 6,
};

struct scsi_driver {
	struct device_driver gendrv;
	void (*rescan)(struct device *);
	blk_status_t (*init_command)(struct scsi_cmnd *);
	void (*uninit_command)(struct scsi_cmnd *);
	int (*done)(struct scsi_cmnd *);
	int (*eh_action)(struct scsi_cmnd *, int);
	void (*eh_reset)(struct scsi_cmnd *);
};

struct trace_event_raw_scsi_dispatch_cmd_start {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_error {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int rtn;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_cmd_done_timeout_template {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int result;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_eh_wakeup {
	struct trace_entry ent;
	unsigned int host_no;
	char __data[0];
};

struct trace_event_data_offsets_scsi_dispatch_cmd_start {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_error {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_cmd_done_timeout_template {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_eh_wakeup {};

typedef void (*btf_trace_scsi_dispatch_cmd_start)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_error)(void *, struct scsi_cmnd *, int);

typedef void (*btf_trace_scsi_dispatch_cmd_done)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_timeout)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_eh_wakeup)(void *, struct Scsi_Host *);

struct scsi_idlun {
	__u32 dev_id;
	__u32 host_unique_id;
};

typedef void (*activate_complete)(void *, int);

struct scsi_device_handler {
	struct list_head list;
	struct module *module;
	const char *name;
	int (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	blk_status_t (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	void (*rescan)(struct scsi_device *);
};

struct scsi_eh_save {
	int result;
	unsigned int resid_len;
	int eh_eflags;
	enum dma_data_direction data_direction;
	unsigned int underflow;
	unsigned char cmd_len;
	unsigned char prot_op;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	unsigned char eh_cmnd[16];
	struct scatterlist sense_sgl;
};

struct scsi_varlen_cdb_hdr {
	__u8 opcode;
	__u8 control;
	__u8 misc[5];
	__u8 additional_cdb_length;
	__be16 service_action;
};

struct scsi_mode_data {
	__u32 length;
	__u16 block_descriptor_length;
	__u8 medium_type;
	__u8 device_specific;
	__u8 header_length;
	__u8 longlba: 1;
};

struct scsi_event {
	enum scsi_device_event evt_type;
	struct list_head node;
};

enum scsi_host_prot_capabilities {
	SHOST_DIF_TYPE1_PROTECTION = 1,
	SHOST_DIF_TYPE2_PROTECTION = 2,
	SHOST_DIF_TYPE3_PROTECTION = 4,
	SHOST_DIX_TYPE0_PROTECTION = 8,
	SHOST_DIX_TYPE1_PROTECTION = 16,
	SHOST_DIX_TYPE2_PROTECTION = 32,
	SHOST_DIX_TYPE3_PROTECTION = 64,
};

enum {
	ACTION_FAIL = 0,
	ACTION_REPREP = 1,
	ACTION_RETRY = 2,
	ACTION_DELAYED_RETRY = 3,
};

struct value_name_pair;

struct sa_name_list {
	int opcode;
	const struct value_name_pair *arr;
	int arr_sz;
};

struct value_name_pair {
	int value;
	const char *name;
};

struct error_info {
	short unsigned int code12;
	short unsigned int size;
};

struct error_info2 {
	unsigned char code1;
	unsigned char code2_min;
	unsigned char code2_max;
	const char *str;
	const char *fmt;
};

struct scsi_lun {
	__u8 scsi_lun[8];
};

enum scsi_timeouts {
	SCSI_DEFAULT_EH_TIMEOUT = 10000,
};

enum scsi_scan_mode {
	SCSI_SCAN_INITIAL = 0,
	SCSI_SCAN_RESCAN = 1,
	SCSI_SCAN_MANUAL = 2,
};

struct async_scan_data {
	struct list_head list;
	struct Scsi_Host *shost;
	struct completion prev_finished;
};

enum scsi_devinfo_key {
	SCSI_DEVINFO_GLOBAL = 0,
	SCSI_DEVINFO_SPI = 1,
};

struct scsi_dev_info_list {
	struct list_head dev_info_list;
	char vendor[8];
	char model[16];
	blist_flags_t flags;
	unsigned int compatible;
};

struct scsi_dev_info_list_table {
	struct list_head node;
	struct list_head scsi_dev_info_list;
	const char *name;
	int key;
};

struct double_list {
	struct list_head *top;
	struct list_head *bottom;
};

struct scsi_nl_hdr {
	__u8 version;
	__u8 transport;
	__u16 magic;
	__u16 msgtype;
	__u16 msglen;
};

enum {
	SCSI_DH_OK = 0,
	SCSI_DH_DEV_FAILED = 1,
	SCSI_DH_DEV_TEMP_BUSY = 2,
	SCSI_DH_DEV_UNSUPP = 3,
	SCSI_DH_DEVICE_MAX = 4,
	SCSI_DH_NOTCONN = 5,
	SCSI_DH_CONN_FAILURE = 6,
	SCSI_DH_TRANSPORT_MAX = 7,
	SCSI_DH_IO = 8,
	SCSI_DH_INVALID_IO = 9,
	SCSI_DH_RETRY = 10,
	SCSI_DH_IMM_RETRY = 11,
	SCSI_DH_TIMED_OUT = 12,
	SCSI_DH_RES_TEMP_UNAVAIL = 13,
	SCSI_DH_DEV_OFFLINED = 14,
	SCSI_DH_NOMEM = 15,
	SCSI_DH_NOSYS = 16,
	SCSI_DH_DRIVER_MAX = 17,
};

struct scsi_dh_blist {
	const char *vendor;
	const char *model;
	const char *driver;
};

struct raid_template {
	struct transport_container raid_attrs;
};

struct raid_function_template {
	void *cookie;
	int (*is_raid)(struct device *);
	void (*get_resync)(struct device *);
	void (*get_state)(struct device *);
};

enum raid_state {
	RAID_STATE_UNKNOWN = 0,
	RAID_STATE_ACTIVE = 1,
	RAID_STATE_DEGRADED = 2,
	RAID_STATE_RESYNCING = 3,
	RAID_STATE_OFFLINE = 4,
};

enum raid_level {
	RAID_LEVEL_UNKNOWN = 0,
	RAID_LEVEL_LINEAR = 1,
	RAID_LEVEL_0 = 2,
	RAID_LEVEL_1 = 3,
	RAID_LEVEL_10 = 4,
	RAID_LEVEL_1E = 5,
	RAID_LEVEL_3 = 6,
	RAID_LEVEL_4 = 7,
	RAID_LEVEL_5 = 8,
	RAID_LEVEL_50 = 9,
	RAID_LEVEL_6 = 10,
	RAID_LEVEL_JBOD = 11,
};

struct raid_data {
	struct list_head component_list;
	int component_count;
	enum raid_level level;
	enum raid_state state;
	int resync;
};

struct raid_internal {
	struct raid_template r;
	struct raid_function_template *f;
	struct device_attribute private_attrs[3];
	struct device_attribute *attrs[4];
};

struct raid_component {
	struct list_head node;
	struct device dev;
	int num;
};

struct spi_transport_attrs {
	int period;
	int min_period;
	int offset;
	int max_offset;
	unsigned int width: 1;
	unsigned int max_width: 1;
	unsigned int iu: 1;
	unsigned int max_iu: 1;
	unsigned int dt: 1;
	unsigned int qas: 1;
	unsigned int max_qas: 1;
	unsigned int wr_flow: 1;
	unsigned int rd_strm: 1;
	unsigned int rti: 1;
	unsigned int pcomp_en: 1;
	unsigned int hold_mcs: 1;
	unsigned int initial_dv: 1;
	long unsigned int flags;
	unsigned int support_sync: 1;
	unsigned int support_wide: 1;
	unsigned int support_dt: 1;
	unsigned int support_dt_only;
	unsigned int support_ius;
	unsigned int support_qas;
	unsigned int dv_pending: 1;
	unsigned int dv_in_progress: 1;
	struct mutex dv_mutex;
};

enum spi_signal_type {
	SPI_SIGNAL_UNKNOWN = 1,
	SPI_SIGNAL_SE = 2,
	SPI_SIGNAL_LVD = 3,
	SPI_SIGNAL_HVD = 4,
};

struct spi_host_attrs {
	enum spi_signal_type signalling;
};

struct spi_function_template {
	void (*get_period)(struct scsi_target *);
	void (*set_period)(struct scsi_target *, int);
	void (*get_offset)(struct scsi_target *);
	void (*set_offset)(struct scsi_target *, int);
	void (*get_width)(struct scsi_target *);
	void (*set_width)(struct scsi_target *, int);
	void (*get_iu)(struct scsi_target *);
	void (*set_iu)(struct scsi_target *, int);
	void (*get_dt)(struct scsi_target *);
	void (*set_dt)(struct scsi_target *, int);
	void (*get_qas)(struct scsi_target *);
	void (*set_qas)(struct scsi_target *, int);
	void (*get_wr_flow)(struct scsi_target *);
	void (*set_wr_flow)(struct scsi_target *, int);
	void (*get_rd_strm)(struct scsi_target *);
	void (*set_rd_strm)(struct scsi_target *, int);
	void (*get_rti)(struct scsi_target *);
	void (*set_rti)(struct scsi_target *, int);
	void (*get_pcomp_en)(struct scsi_target *);
	void (*set_pcomp_en)(struct scsi_target *, int);
	void (*get_hold_mcs)(struct scsi_target *);
	void (*set_hold_mcs)(struct scsi_target *, int);
	void (*get_signalling)(struct Scsi_Host *);
	void (*set_signalling)(struct Scsi_Host *, enum spi_signal_type);
	int (*deny_binding)(struct scsi_target *);
	long unsigned int show_period: 1;
	long unsigned int show_offset: 1;
	long unsigned int show_width: 1;
	long unsigned int show_iu: 1;
	long unsigned int show_dt: 1;
	long unsigned int show_qas: 1;
	long unsigned int show_wr_flow: 1;
	long unsigned int show_rd_strm: 1;
	long unsigned int show_rti: 1;
	long unsigned int show_pcomp_en: 1;
	long unsigned int show_hold_mcs: 1;
};

enum {
	SPI_BLIST_NOIUS = 1,
};

struct spi_internal {
	struct scsi_transport_template t;
	struct spi_function_template *f;
};

enum spi_compare_returns {
	SPI_COMPARE_SUCCESS = 0,
	SPI_COMPARE_FAILURE = 1,
	SPI_COMPARE_SKIP_TEST = 2,
};

struct work_queue_wrapper {
	struct work_struct work;
	struct scsi_device *sdev;
};

enum fc_port_type {
	FC_PORTTYPE_UNKNOWN = 0,
	FC_PORTTYPE_OTHER = 1,
	FC_PORTTYPE_NOTPRESENT = 2,
	FC_PORTTYPE_NPORT = 3,
	FC_PORTTYPE_NLPORT = 4,
	FC_PORTTYPE_LPORT = 5,
	FC_PORTTYPE_PTP = 6,
	FC_PORTTYPE_NPIV = 7,
};

enum fc_port_state {
	FC_PORTSTATE_UNKNOWN = 0,
	FC_PORTSTATE_NOTPRESENT = 1,
	FC_PORTSTATE_ONLINE = 2,
	FC_PORTSTATE_OFFLINE = 3,
	FC_PORTSTATE_BLOCKED = 4,
	FC_PORTSTATE_BYPASSED = 5,
	FC_PORTSTATE_DIAGNOSTICS = 6,
	FC_PORTSTATE_LINKDOWN = 7,
	FC_PORTSTATE_ERROR = 8,
	FC_PORTSTATE_LOOPBACK = 9,
	FC_PORTSTATE_DELETED = 10,
};

enum fc_vport_state {
	FC_VPORT_UNKNOWN = 0,
	FC_VPORT_ACTIVE = 1,
	FC_VPORT_DISABLED = 2,
	FC_VPORT_LINKDOWN = 3,
	FC_VPORT_INITIALIZING = 4,
	FC_VPORT_NO_FABRIC_SUPP = 5,
	FC_VPORT_NO_FABRIC_RSCS = 6,
	FC_VPORT_FABRIC_LOGOUT = 7,
	FC_VPORT_FABRIC_REJ_WWN = 8,
	FC_VPORT_FAILED = 9,
};

enum fc_tgtid_binding_type {
	FC_TGTID_BIND_NONE = 0,
	FC_TGTID_BIND_BY_WWPN = 1,
	FC_TGTID_BIND_BY_WWNN = 2,
	FC_TGTID_BIND_BY_ID = 3,
};

struct fc_vport_identifiers {
	u64 node_name;
	u64 port_name;
	u32 roles;
	bool disable;
	enum fc_port_type vport_type;
	char symbolic_name[64];
};

struct fc_vport {
	enum fc_vport_state vport_state;
	enum fc_vport_state vport_last_state;
	u64 node_name;
	u64 port_name;
	u32 roles;
	u32 vport_id;
	enum fc_port_type vport_type;
	char symbolic_name[64];
	void *dd_data;
	struct Scsi_Host *shost;
	unsigned int channel;
	u32 number;
	u8 flags;
	struct list_head peers;
	struct device dev;
	struct work_struct vport_delete_work;
};

struct fc_rport_identifiers {
	u64 node_name;
	u64 port_name;
	u32 port_id;
	u32 roles;
};

struct fc_rport {
	u32 maxframe_size;
	u32 supported_classes;
	u32 dev_loss_tmo;
	u64 node_name;
	u64 port_name;
	u32 port_id;
	u32 roles;
	enum fc_port_state port_state;
	u32 scsi_target_id;
	u32 fast_io_fail_tmo;
	void *dd_data;
	unsigned int channel;
	u32 number;
	u8 flags;
	struct list_head peers;
	struct device dev;
	struct delayed_work dev_loss_work;
	struct work_struct scan_work;
	struct delayed_work fail_io_work;
	struct work_struct stgt_delete_work;
	struct work_struct rport_delete_work;
	struct request_queue *rqst_q;
};

struct fc_starget_attrs {
	u64 node_name;
	u64 port_name;
	u32 port_id;
};

struct fc_host_statistics {
	u64 seconds_since_last_reset;
	u64 tx_frames;
	u64 tx_words;
	u64 rx_frames;
	u64 rx_words;
	u64 lip_count;
	u64 nos_count;
	u64 error_frames;
	u64 dumped_frames;
	u64 link_failure_count;
	u64 loss_of_sync_count;
	u64 loss_of_signal_count;
	u64 prim_seq_protocol_err_count;
	u64 invalid_tx_word_count;
	u64 invalid_crc_count;
	u64 fcp_input_requests;
	u64 fcp_output_requests;
	u64 fcp_control_requests;
	u64 fcp_input_megabytes;
	u64 fcp_output_megabytes;
	u64 fcp_packet_alloc_failures;
	u64 fcp_packet_aborts;
	u64 fcp_frame_alloc_failures;
	u64 fc_no_free_exch;
	u64 fc_no_free_exch_xid;
	u64 fc_xid_not_found;
	u64 fc_xid_busy;
	u64 fc_seq_not_found;
	u64 fc_non_bls_resp;
};

enum fc_host_event_code {
	FCH_EVT_LIP = 1,
	FCH_EVT_LINKUP = 2,
	FCH_EVT_LINKDOWN = 3,
	FCH_EVT_LIPRESET = 4,
	FCH_EVT_RSCN = 5,
	FCH_EVT_ADAPTER_CHANGE = 259,
	FCH_EVT_PORT_UNKNOWN = 512,
	FCH_EVT_PORT_OFFLINE = 513,
	FCH_EVT_PORT_ONLINE = 514,
	FCH_EVT_PORT_FABRIC = 516,
	FCH_EVT_LINK_UNKNOWN = 1280,
	FCH_EVT_LINK_FPIN = 1281,
	FCH_EVT_VENDOR_UNIQUE = 65535,
};

struct fc_host_attrs {
	u64 node_name;
	u64 port_name;
	u64 permanent_port_name;
	u32 supported_classes;
	u8 supported_fc4s[32];
	u32 supported_speeds;
	u32 maxframe_size;
	u16 max_npiv_vports;
	char serial_number[80];
	char manufacturer[80];
	char model[256];
	char model_description[256];
	char hardware_version[64];
	char driver_version[64];
	char firmware_version[64];
	char optionrom_version[64];
	u32 port_id;
	enum fc_port_type port_type;
	enum fc_port_state port_state;
	u8 active_fc4s[32];
	u32 speed;
	u64 fabric_name;
	char symbolic_name[256];
	char system_hostname[256];
	u32 dev_loss_tmo;
	enum fc_tgtid_binding_type tgtid_bind_type;
	struct list_head rports;
	struct list_head rport_bindings;
	struct list_head vports;
	u32 next_rport_number;
	u32 next_target_id;
	u32 next_vport_number;
	u16 npiv_vports_inuse;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	char devloss_work_q_name[20];
	struct workqueue_struct *devloss_work_q;
	struct request_queue *rqst_q;
};

struct fc_function_template {
	void (*get_rport_dev_loss_tmo)(struct fc_rport *);
	void (*set_rport_dev_loss_tmo)(struct fc_rport *, u32);
	void (*get_starget_node_name)(struct scsi_target *);
	void (*get_starget_port_name)(struct scsi_target *);
	void (*get_starget_port_id)(struct scsi_target *);
	void (*get_host_port_id)(struct Scsi_Host *);
	void (*get_host_port_type)(struct Scsi_Host *);
	void (*get_host_port_state)(struct Scsi_Host *);
	void (*get_host_active_fc4s)(struct Scsi_Host *);
	void (*get_host_speed)(struct Scsi_Host *);
	void (*get_host_fabric_name)(struct Scsi_Host *);
	void (*get_host_symbolic_name)(struct Scsi_Host *);
	void (*set_host_system_hostname)(struct Scsi_Host *);
	struct fc_host_statistics * (*get_fc_host_stats)(struct Scsi_Host *);
	void (*reset_fc_host_stats)(struct Scsi_Host *);
	int (*issue_fc_host_lip)(struct Scsi_Host *);
	void (*dev_loss_tmo_callbk)(struct fc_rport *);
	void (*terminate_rport_io)(struct fc_rport *);
	void (*set_vport_symbolic_name)(struct fc_vport *);
	int (*vport_create)(struct fc_vport *, bool);
	int (*vport_disable)(struct fc_vport *, bool);
	int (*vport_delete)(struct fc_vport *);
	int (*bsg_request)(struct bsg_job *);
	int (*bsg_timeout)(struct bsg_job *);
	u32 dd_fcrport_size;
	u32 dd_fcvport_size;
	u32 dd_bsg_size;
	long unsigned int show_rport_maxframe_size: 1;
	long unsigned int show_rport_supported_classes: 1;
	long unsigned int show_rport_dev_loss_tmo: 1;
	long unsigned int show_starget_node_name: 1;
	long unsigned int show_starget_port_name: 1;
	long unsigned int show_starget_port_id: 1;
	long unsigned int show_host_node_name: 1;
	long unsigned int show_host_port_name: 1;
	long unsigned int show_host_permanent_port_name: 1;
	long unsigned int show_host_supported_classes: 1;
	long unsigned int show_host_supported_fc4s: 1;
	long unsigned int show_host_supported_speeds: 1;
	long unsigned int show_host_maxframe_size: 1;
	long unsigned int show_host_serial_number: 1;
	long unsigned int show_host_manufacturer: 1;
	long unsigned int show_host_model: 1;
	long unsigned int show_host_model_description: 1;
	long unsigned int show_host_hardware_version: 1;
	long unsigned int show_host_driver_version: 1;
	long unsigned int show_host_firmware_version: 1;
	long unsigned int show_host_optionrom_version: 1;
	long unsigned int show_host_port_id: 1;
	long unsigned int show_host_port_type: 1;
	long unsigned int show_host_port_state: 1;
	long unsigned int show_host_active_fc4s: 1;
	long unsigned int show_host_speed: 1;
	long unsigned int show_host_fabric_name: 1;
	long unsigned int show_host_symbolic_name: 1;
	long unsigned int show_host_system_hostname: 1;
	long unsigned int disable_target_scan: 1;
};

struct fc_nl_event {
	struct scsi_nl_hdr snlh;
	__u64 seconds;
	__u64 vendor_id;
	__u16 host_no;
	__u16 event_datalen;
	__u32 event_num;
	__u32 event_code;
	__u32 event_data;
};

struct fc_bsg_host_add_rport {
	__u8 reserved;
	__u8 port_id[3];
};

struct fc_bsg_host_del_rport {
	__u8 reserved;
	__u8 port_id[3];
};

struct fc_bsg_host_els {
	__u8 command_code;
	__u8 port_id[3];
};

struct fc_bsg_ctels_reply {
	__u32 status;
	struct {
		__u8 action;
		__u8 reason_code;
		__u8 reason_explanation;
		__u8 vendor_unique;
	} rjt_data;
};

struct fc_bsg_host_ct {
	__u8 reserved;
	__u8 port_id[3];
	__u32 preamble_word0;
	__u32 preamble_word1;
	__u32 preamble_word2;
};

struct fc_bsg_host_vendor {
	__u64 vendor_id;
	__u32 vendor_cmd[0];
};

struct fc_bsg_host_vendor_reply {
	__u32 vendor_rsp[0];
};

struct fc_bsg_rport_els {
	__u8 els_code;
};

struct fc_bsg_rport_ct {
	__u32 preamble_word0;
	__u32 preamble_word1;
	__u32 preamble_word2;
};

struct fc_bsg_request {
	__u32 msgcode;
	union {
		struct fc_bsg_host_add_rport h_addrport;
		struct fc_bsg_host_del_rport h_delrport;
		struct fc_bsg_host_els h_els;
		struct fc_bsg_host_ct h_ct;
		struct fc_bsg_host_vendor h_vendor;
		struct fc_bsg_rport_els r_els;
		struct fc_bsg_rport_ct r_ct;
	} rqst_data;
} __attribute__((packed));

struct fc_bsg_reply {
	__u32 result;
	__u32 reply_payload_rcv_len;
	union {
		struct fc_bsg_host_vendor_reply vendor_reply;
		struct fc_bsg_ctels_reply ctels_reply;
	} reply_data;
};

struct fc_internal {
	struct scsi_transport_template t;
	struct fc_function_template *f;
	struct device_attribute private_starget_attrs[3];
	struct device_attribute *starget_attrs[4];
	struct device_attribute private_host_attrs[29];
	struct device_attribute *host_attrs[30];
	struct transport_container rport_attr_cont;
	struct device_attribute private_rport_attrs[10];
	struct device_attribute *rport_attrs[11];
	struct transport_container vport_attr_cont;
	struct device_attribute private_vport_attrs[9];
	struct device_attribute *vport_attrs[10];
};

struct in_addr {
	__be32 s_addr;
};

typedef uint32_t itt_t;

struct iscsi_hdr {
	uint8_t opcode;
	uint8_t flags;
	uint8_t rsvd2[2];
	uint8_t hlength;
	uint8_t dlength[3];
	struct scsi_lun lun;
	itt_t itt;
	__be32 ttt;
	__be32 statsn;
	__be32 exp_statsn;
	__be32 max_statsn;
	uint8_t other[12];
};

enum iscsi_uevent_e {
	ISCSI_UEVENT_UNKNOWN = 0,
	ISCSI_UEVENT_CREATE_SESSION = 11,
	ISCSI_UEVENT_DESTROY_SESSION = 12,
	ISCSI_UEVENT_CREATE_CONN = 13,
	ISCSI_UEVENT_DESTROY_CONN = 14,
	ISCSI_UEVENT_BIND_CONN = 15,
	ISCSI_UEVENT_SET_PARAM = 16,
	ISCSI_UEVENT_START_CONN = 17,
	ISCSI_UEVENT_STOP_CONN = 18,
	ISCSI_UEVENT_SEND_PDU = 19,
	ISCSI_UEVENT_GET_STATS = 20,
	ISCSI_UEVENT_GET_PARAM = 21,
	ISCSI_UEVENT_TRANSPORT_EP_CONNECT = 22,
	ISCSI_UEVENT_TRANSPORT_EP_POLL = 23,
	ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT = 24,
	ISCSI_UEVENT_TGT_DSCVR = 25,
	ISCSI_UEVENT_SET_HOST_PARAM = 26,
	ISCSI_UEVENT_UNBIND_SESSION = 27,
	ISCSI_UEVENT_CREATE_BOUND_SESSION = 28,
	ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST = 29,
	ISCSI_UEVENT_PATH_UPDATE = 30,
	ISCSI_UEVENT_SET_IFACE_PARAMS = 31,
	ISCSI_UEVENT_PING = 32,
	ISCSI_UEVENT_GET_CHAP = 33,
	ISCSI_UEVENT_DELETE_CHAP = 34,
	ISCSI_UEVENT_SET_FLASHNODE_PARAMS = 35,
	ISCSI_UEVENT_NEW_FLASHNODE = 36,
	ISCSI_UEVENT_DEL_FLASHNODE = 37,
	ISCSI_UEVENT_LOGIN_FLASHNODE = 38,
	ISCSI_UEVENT_LOGOUT_FLASHNODE = 39,
	ISCSI_UEVENT_LOGOUT_FLASHNODE_SID = 40,
	ISCSI_UEVENT_SET_CHAP = 41,
	ISCSI_UEVENT_GET_HOST_STATS = 42,
	ISCSI_KEVENT_RECV_PDU = 101,
	ISCSI_KEVENT_CONN_ERROR = 102,
	ISCSI_KEVENT_IF_ERROR = 103,
	ISCSI_KEVENT_DESTROY_SESSION = 104,
	ISCSI_KEVENT_UNBIND_SESSION = 105,
	ISCSI_KEVENT_CREATE_SESSION = 106,
	ISCSI_KEVENT_PATH_REQ = 107,
	ISCSI_KEVENT_IF_DOWN = 108,
	ISCSI_KEVENT_CONN_LOGIN_STATE = 109,
	ISCSI_KEVENT_HOST_EVENT = 110,
	ISCSI_KEVENT_PING_COMP = 111,
};

enum iscsi_tgt_dscvr {
	ISCSI_TGT_DSCVR_SEND_TARGETS = 1,
	ISCSI_TGT_DSCVR_ISNS = 2,
	ISCSI_TGT_DSCVR_SLP = 3,
};

enum iscsi_host_event_code {
	ISCSI_EVENT_LINKUP = 1,
	ISCSI_EVENT_LINKDOWN = 2,
	ISCSI_EVENT_MAX = 3,
};

struct msg_create_session {
	uint32_t initial_cmdsn;
	uint16_t cmds_max;
	uint16_t queue_depth;
};

struct msg_create_bound_session {
	uint64_t ep_handle;
	uint32_t initial_cmdsn;
	uint16_t cmds_max;
	uint16_t queue_depth;
};

struct msg_destroy_session {
	uint32_t sid;
};

struct msg_create_conn {
	uint32_t sid;
	uint32_t cid;
};

struct msg_bind_conn {
	uint32_t sid;
	uint32_t cid;
	uint64_t transport_eph;
	uint32_t is_leading;
};

struct msg_destroy_conn {
	uint32_t sid;
	uint32_t cid;
};

struct msg_send_pdu {
	uint32_t sid;
	uint32_t cid;
	uint32_t hdr_size;
	uint32_t data_size;
};

struct msg_set_param {
	uint32_t sid;
	uint32_t cid;
	uint32_t param;
	uint32_t len;
};

struct msg_start_conn {
	uint32_t sid;
	uint32_t cid;
};

struct msg_stop_conn {
	uint32_t sid;
	uint32_t cid;
	uint64_t conn_handle;
	uint32_t flag;
};

struct msg_get_stats {
	uint32_t sid;
	uint32_t cid;
};

struct msg_transport_connect {
	uint32_t non_blocking;
};

struct msg_transport_connect_through_host {
	uint32_t host_no;
	uint32_t non_blocking;
};

struct msg_transport_poll {
	uint64_t ep_handle;
	uint32_t timeout_ms;
};

struct msg_transport_disconnect {
	uint64_t ep_handle;
};

struct msg_tgt_dscvr {
	enum iscsi_tgt_dscvr type;
	uint32_t host_no;
	uint32_t enable;
};

struct msg_set_host_param {
	uint32_t host_no;
	uint32_t param;
	uint32_t len;
};

struct msg_set_path {
	uint32_t host_no;
};

struct msg_set_iface_params {
	uint32_t host_no;
	uint32_t count;
};

struct msg_iscsi_ping {
	uint32_t host_no;
	uint32_t iface_num;
	uint32_t iface_type;
	uint32_t payload_size;
	uint32_t pid;
};

struct msg_get_chap {
	uint32_t host_no;
	uint32_t num_entries;
	uint16_t chap_tbl_idx;
};

struct msg_delete_chap {
	uint32_t host_no;
	uint16_t chap_tbl_idx;
};

struct msg_set_flashnode_param {
	uint32_t host_no;
	uint32_t flashnode_idx;
	uint32_t count;
};

struct msg_new_flashnode {
	uint32_t host_no;
	uint32_t len;
};

struct msg_del_flashnode {
	uint32_t host_no;
	uint32_t flashnode_idx;
};

struct msg_login_flashnode {
	uint32_t host_no;
	uint32_t flashnode_idx;
};

struct msg_logout_flashnode {
	uint32_t host_no;
	uint32_t flashnode_idx;
};

struct msg_logout_flashnode_sid {
	uint32_t host_no;
	uint32_t sid;
};

struct msg_get_host_stats {
	uint32_t host_no;
};

struct msg_create_session_ret {
	uint32_t sid;
	uint32_t host_no;
};

struct msg_create_conn_ret {
	uint32_t sid;
	uint32_t cid;
};

struct msg_unbind_session {
	uint32_t sid;
	uint32_t host_no;
};

struct msg_recv_req {
	uint32_t sid;
	uint32_t cid;
	uint64_t recv_handle;
};

struct msg_conn_login {
	uint32_t sid;
	uint32_t cid;
	uint32_t state;
};

struct msg_conn_error {
	uint32_t sid;
	uint32_t cid;
	uint32_t error;
};

struct msg_session_destroyed {
	uint32_t host_no;
	uint32_t sid;
};

struct msg_transport_connect_ret {
	uint64_t handle;
};

struct msg_req_path {
	uint32_t host_no;
};

struct msg_notify_if_down {
	uint32_t host_no;
};

struct msg_host_event {
	uint32_t host_no;
	uint32_t data_size;
	enum iscsi_host_event_code code;
};

struct msg_ping_comp {
	uint32_t host_no;
	uint32_t status;
	uint32_t pid;
	uint32_t data_size;
};

struct msg_new_flashnode_ret {
	uint32_t flashnode_idx;
};

struct iscsi_uevent {
	uint32_t type;
	uint32_t iferror;
	uint64_t transport_handle;
	union {
		struct msg_create_session c_session;
		struct msg_create_bound_session c_bound_session;
		struct msg_destroy_session d_session;
		struct msg_create_conn c_conn;
		struct msg_bind_conn b_conn;
		struct msg_destroy_conn d_conn;
		struct msg_send_pdu send_pdu;
		struct msg_set_param set_param;
		struct msg_start_conn start_conn;
		struct msg_stop_conn stop_conn;
		struct msg_get_stats get_stats;
		struct msg_transport_connect ep_connect;
		struct msg_transport_connect_through_host ep_connect_through_host;
		struct msg_transport_poll ep_poll;
		struct msg_transport_disconnect ep_disconnect;
		struct msg_tgt_dscvr tgt_dscvr;
		struct msg_set_host_param set_host_param;
		struct msg_set_path set_path;
		struct msg_set_iface_params set_iface_params;
		struct msg_iscsi_ping iscsi_ping;
		struct msg_get_chap get_chap;
		struct msg_delete_chap delete_chap;
		struct msg_set_flashnode_param set_flashnode;
		struct msg_new_flashnode new_flashnode;
		struct msg_del_flashnode del_flashnode;
		struct msg_login_flashnode login_flashnode;
		struct msg_logout_flashnode logout_flashnode;
		struct msg_logout_flashnode_sid logout_flashnode_sid;
		struct msg_get_host_stats get_host_stats;
	} u;
	union {
		int retcode;
		struct msg_create_session_ret c_session_ret;
		struct msg_create_conn_ret c_conn_ret;
		struct msg_unbind_session unbind_session;
		struct msg_recv_req recv_req;
		struct msg_conn_login conn_login;
		struct msg_conn_error connerror;
		struct msg_session_destroyed d_session;
		struct msg_transport_connect_ret ep_connect_ret;
		struct msg_req_path req_path;
		struct msg_notify_if_down notify_if_down;
		struct msg_host_event host_event;
		struct msg_ping_comp ping_comp;
		struct msg_new_flashnode_ret new_flashnode_ret;
	} r;
};

enum iscsi_param_type {
	ISCSI_PARAM = 0,
	ISCSI_HOST_PARAM = 1,
	ISCSI_NET_PARAM = 2,
	ISCSI_FLASHNODE_PARAM = 3,
	ISCSI_CHAP_PARAM = 4,
	ISCSI_IFACE_PARAM = 5,
};

struct iscsi_path {
	uint64_t handle;
	uint8_t mac_addr[6];
	uint8_t mac_addr_old[6];
	uint32_t ip_addr_len;
	union {
		struct in_addr v4_addr;
		struct in6_addr v6_addr;
	} src;
	union {
		struct in_addr v4_addr;
		struct in6_addr v6_addr;
	} dst;
	uint16_t vlan_id;
	uint16_t pmtu;
};

enum iscsi_net_param {
	ISCSI_NET_PARAM_IPV4_ADDR = 1,
	ISCSI_NET_PARAM_IPV4_SUBNET = 2,
	ISCSI_NET_PARAM_IPV4_GW = 3,
	ISCSI_NET_PARAM_IPV4_BOOTPROTO = 4,
	ISCSI_NET_PARAM_MAC = 5,
	ISCSI_NET_PARAM_IPV6_LINKLOCAL = 6,
	ISCSI_NET_PARAM_IPV6_ADDR = 7,
	ISCSI_NET_PARAM_IPV6_ROUTER = 8,
	ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG = 9,
	ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG = 10,
	ISCSI_NET_PARAM_IPV6_ROUTER_AUTOCFG = 11,
	ISCSI_NET_PARAM_IFACE_ENABLE = 12,
	ISCSI_NET_PARAM_VLAN_ID = 13,
	ISCSI_NET_PARAM_VLAN_PRIORITY = 14,
	ISCSI_NET_PARAM_VLAN_ENABLED = 15,
	ISCSI_NET_PARAM_VLAN_TAG = 16,
	ISCSI_NET_PARAM_IFACE_TYPE = 17,
	ISCSI_NET_PARAM_IFACE_NAME = 18,
	ISCSI_NET_PARAM_MTU = 19,
	ISCSI_NET_PARAM_PORT = 20,
	ISCSI_NET_PARAM_IPADDR_STATE = 21,
	ISCSI_NET_PARAM_IPV6_LINKLOCAL_STATE = 22,
	ISCSI_NET_PARAM_IPV6_ROUTER_STATE = 23,
	ISCSI_NET_PARAM_DELAYED_ACK_EN = 24,
	ISCSI_NET_PARAM_TCP_NAGLE_DISABLE = 25,
	ISCSI_NET_PARAM_TCP_WSF_DISABLE = 26,
	ISCSI_NET_PARAM_TCP_WSF = 27,
	ISCSI_NET_PARAM_TCP_TIMER_SCALE = 28,
	ISCSI_NET_PARAM_TCP_TIMESTAMP_EN = 29,
	ISCSI_NET_PARAM_CACHE_ID = 30,
	ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN = 31,
	ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN = 32,
	ISCSI_NET_PARAM_IPV4_TOS_EN = 33,
	ISCSI_NET_PARAM_IPV4_TOS = 34,
	ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN = 35,
	ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN = 36,
	ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID = 37,
	ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN = 38,
	ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN = 39,
	ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID = 40,
	ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN = 41,
	ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE = 42,
	ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN = 43,
	ISCSI_NET_PARAM_IPV4_TTL = 44,
	ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN = 45,
	ISCSI_NET_PARAM_IPV6_MLD_EN = 46,
	ISCSI_NET_PARAM_IPV6_FLOW_LABEL = 47,
	ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS = 48,
	ISCSI_NET_PARAM_IPV6_HOP_LIMIT = 49,
	ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO = 50,
	ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME = 51,
	ISCSI_NET_PARAM_IPV6_ND_STALE_TMO = 52,
	ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT = 53,
	ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU = 54,
	ISCSI_NET_PARAM_REDIRECT_EN = 55,
};

enum iscsi_ipaddress_state {
	ISCSI_IPDDRESS_STATE_UNCONFIGURED = 0,
	ISCSI_IPDDRESS_STATE_ACQUIRING = 1,
	ISCSI_IPDDRESS_STATE_TENTATIVE = 2,
	ISCSI_IPDDRESS_STATE_VALID = 3,
	ISCSI_IPDDRESS_STATE_DISABLING = 4,
	ISCSI_IPDDRESS_STATE_INVALID = 5,
	ISCSI_IPDDRESS_STATE_DEPRECATED = 6,
};

enum iscsi_router_state {
	ISCSI_ROUTER_STATE_UNKNOWN = 0,
	ISCSI_ROUTER_STATE_ADVERTISED = 1,
	ISCSI_ROUTER_STATE_MANUAL = 2,
	ISCSI_ROUTER_STATE_STALE = 3,
};

enum iscsi_iface_param {
	ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO = 0,
	ISCSI_IFACE_PARAM_HDRDGST_EN = 1,
	ISCSI_IFACE_PARAM_DATADGST_EN = 2,
	ISCSI_IFACE_PARAM_IMM_DATA_EN = 3,
	ISCSI_IFACE_PARAM_INITIAL_R2T_EN = 4,
	ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN = 5,
	ISCSI_IFACE_PARAM_PDU_INORDER_EN = 6,
	ISCSI_IFACE_PARAM_ERL = 7,
	ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH = 8,
	ISCSI_IFACE_PARAM_FIRST_BURST = 9,
	ISCSI_IFACE_PARAM_MAX_R2T = 10,
	ISCSI_IFACE_PARAM_MAX_BURST = 11,
	ISCSI_IFACE_PARAM_CHAP_AUTH_EN = 12,
	ISCSI_IFACE_PARAM_BIDI_CHAP_EN = 13,
	ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL = 14,
	ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN = 15,
	ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN = 16,
	ISCSI_IFACE_PARAM_INITIATOR_NAME = 17,
};

enum iscsi_conn_state {
	ISCSI_CONN_STATE_FREE = 0,
	ISCSI_CONN_STATE_XPT_WAIT = 1,
	ISCSI_CONN_STATE_IN_LOGIN = 2,
	ISCSI_CONN_STATE_LOGGED_IN = 3,
	ISCSI_CONN_STATE_IN_LOGOUT = 4,
	ISCSI_CONN_STATE_LOGOUT_REQUESTED = 5,
	ISCSI_CONN_STATE_CLEANUP_WAIT = 6,
};

enum iscsi_err {
	ISCSI_OK = 0,
	ISCSI_ERR_DATASN = 1001,
	ISCSI_ERR_DATA_OFFSET = 1002,
	ISCSI_ERR_MAX_CMDSN = 1003,
	ISCSI_ERR_EXP_CMDSN = 1004,
	ISCSI_ERR_BAD_OPCODE = 1005,
	ISCSI_ERR_DATALEN = 1006,
	ISCSI_ERR_AHSLEN = 1007,
	ISCSI_ERR_PROTO = 1008,
	ISCSI_ERR_LUN = 1009,
	ISCSI_ERR_BAD_ITT = 1010,
	ISCSI_ERR_CONN_FAILED = 1011,
	ISCSI_ERR_R2TSN = 1012,
	ISCSI_ERR_SESSION_FAILED = 1013,
	ISCSI_ERR_HDR_DGST = 1014,
	ISCSI_ERR_DATA_DGST = 1015,
	ISCSI_ERR_PARAM_NOT_FOUND = 1016,
	ISCSI_ERR_NO_SCSI_CMD = 1017,
	ISCSI_ERR_INVALID_HOST = 1018,
	ISCSI_ERR_XMIT_FAILED = 1019,
	ISCSI_ERR_TCP_CONN_CLOSE = 1020,
	ISCSI_ERR_SCSI_EH_SESSION_RST = 1021,
	ISCSI_ERR_NOP_TIMEDOUT = 1022,
};

enum iscsi_param {
	ISCSI_PARAM_MAX_RECV_DLENGTH = 0,
	ISCSI_PARAM_MAX_XMIT_DLENGTH = 1,
	ISCSI_PARAM_HDRDGST_EN = 2,
	ISCSI_PARAM_DATADGST_EN = 3,
	ISCSI_PARAM_INITIAL_R2T_EN = 4,
	ISCSI_PARAM_MAX_R2T = 5,
	ISCSI_PARAM_IMM_DATA_EN = 6,
	ISCSI_PARAM_FIRST_BURST = 7,
	ISCSI_PARAM_MAX_BURST = 8,
	ISCSI_PARAM_PDU_INORDER_EN = 9,
	ISCSI_PARAM_DATASEQ_INORDER_EN = 10,
	ISCSI_PARAM_ERL = 11,
	ISCSI_PARAM_IFMARKER_EN = 12,
	ISCSI_PARAM_OFMARKER_EN = 13,
	ISCSI_PARAM_EXP_STATSN = 14,
	ISCSI_PARAM_TARGET_NAME = 15,
	ISCSI_PARAM_TPGT = 16,
	ISCSI_PARAM_PERSISTENT_ADDRESS = 17,
	ISCSI_PARAM_PERSISTENT_PORT = 18,
	ISCSI_PARAM_SESS_RECOVERY_TMO = 19,
	ISCSI_PARAM_CONN_PORT = 20,
	ISCSI_PARAM_CONN_ADDRESS = 21,
	ISCSI_PARAM_USERNAME = 22,
	ISCSI_PARAM_USERNAME_IN = 23,
	ISCSI_PARAM_PASSWORD = 24,
	ISCSI_PARAM_PASSWORD_IN = 25,
	ISCSI_PARAM_FAST_ABORT = 26,
	ISCSI_PARAM_ABORT_TMO = 27,
	ISCSI_PARAM_LU_RESET_TMO = 28,
	ISCSI_PARAM_HOST_RESET_TMO = 29,
	ISCSI_PARAM_PING_TMO = 30,
	ISCSI_PARAM_RECV_TMO = 31,
	ISCSI_PARAM_IFACE_NAME = 32,
	ISCSI_PARAM_ISID = 33,
	ISCSI_PARAM_INITIATOR_NAME = 34,
	ISCSI_PARAM_TGT_RESET_TMO = 35,
	ISCSI_PARAM_TARGET_ALIAS = 36,
	ISCSI_PARAM_CHAP_IN_IDX = 37,
	ISCSI_PARAM_CHAP_OUT_IDX = 38,
	ISCSI_PARAM_BOOT_ROOT = 39,
	ISCSI_PARAM_BOOT_NIC = 40,
	ISCSI_PARAM_BOOT_TARGET = 41,
	ISCSI_PARAM_AUTO_SND_TGT_DISABLE = 42,
	ISCSI_PARAM_DISCOVERY_SESS = 43,
	ISCSI_PARAM_PORTAL_TYPE = 44,
	ISCSI_PARAM_CHAP_AUTH_EN = 45,
	ISCSI_PARAM_DISCOVERY_LOGOUT_EN = 46,
	ISCSI_PARAM_BIDI_CHAP_EN = 47,
	ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL = 48,
	ISCSI_PARAM_DEF_TIME2WAIT = 49,
	ISCSI_PARAM_DEF_TIME2RETAIN = 50,
	ISCSI_PARAM_MAX_SEGMENT_SIZE = 51,
	ISCSI_PARAM_STATSN = 52,
	ISCSI_PARAM_KEEPALIVE_TMO = 53,
	ISCSI_PARAM_LOCAL_PORT = 54,
	ISCSI_PARAM_TSID = 55,
	ISCSI_PARAM_DEF_TASKMGMT_TMO = 56,
	ISCSI_PARAM_TCP_TIMESTAMP_STAT = 57,
	ISCSI_PARAM_TCP_WSF_DISABLE = 58,
	ISCSI_PARAM_TCP_NAGLE_DISABLE = 59,
	ISCSI_PARAM_TCP_TIMER_SCALE = 60,
	ISCSI_PARAM_TCP_TIMESTAMP_EN = 61,
	ISCSI_PARAM_TCP_XMIT_WSF = 62,
	ISCSI_PARAM_TCP_RECV_WSF = 63,
	ISCSI_PARAM_IP_FRAGMENT_DISABLE = 64,
	ISCSI_PARAM_IPV4_TOS = 65,
	ISCSI_PARAM_IPV6_TC = 66,
	ISCSI_PARAM_IPV6_FLOW_LABEL = 67,
	ISCSI_PARAM_IS_FW_ASSIGNED_IPV6 = 68,
	ISCSI_PARAM_DISCOVERY_PARENT_IDX = 69,
	ISCSI_PARAM_DISCOVERY_PARENT_TYPE = 70,
	ISCSI_PARAM_LOCAL_IPADDR = 71,
	ISCSI_PARAM_MAX = 72,
};

enum iscsi_host_param {
	ISCSI_HOST_PARAM_HWADDRESS = 0,
	ISCSI_HOST_PARAM_INITIATOR_NAME = 1,
	ISCSI_HOST_PARAM_NETDEV_NAME = 2,
	ISCSI_HOST_PARAM_IPADDRESS = 3,
	ISCSI_HOST_PARAM_PORT_STATE = 4,
	ISCSI_HOST_PARAM_PORT_SPEED = 5,
	ISCSI_HOST_PARAM_MAX = 6,
};

enum iscsi_flashnode_param {
	ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6 = 0,
	ISCSI_FLASHNODE_PORTAL_TYPE = 1,
	ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE = 2,
	ISCSI_FLASHNODE_DISCOVERY_SESS = 3,
	ISCSI_FLASHNODE_ENTRY_EN = 4,
	ISCSI_FLASHNODE_HDR_DGST_EN = 5,
	ISCSI_FLASHNODE_DATA_DGST_EN = 6,
	ISCSI_FLASHNODE_IMM_DATA_EN = 7,
	ISCSI_FLASHNODE_INITIAL_R2T_EN = 8,
	ISCSI_FLASHNODE_DATASEQ_INORDER = 9,
	ISCSI_FLASHNODE_PDU_INORDER = 10,
	ISCSI_FLASHNODE_CHAP_AUTH_EN = 11,
	ISCSI_FLASHNODE_SNACK_REQ_EN = 12,
	ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN = 13,
	ISCSI_FLASHNODE_BIDI_CHAP_EN = 14,
	ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL = 15,
	ISCSI_FLASHNODE_ERL = 16,
	ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT = 17,
	ISCSI_FLASHNODE_TCP_NAGLE_DISABLE = 18,
	ISCSI_FLASHNODE_TCP_WSF_DISABLE = 19,
	ISCSI_FLASHNODE_TCP_TIMER_SCALE = 20,
	ISCSI_FLASHNODE_TCP_TIMESTAMP_EN = 21,
	ISCSI_FLASHNODE_IP_FRAG_DISABLE = 22,
	ISCSI_FLASHNODE_MAX_RECV_DLENGTH = 23,
	ISCSI_FLASHNODE_MAX_XMIT_DLENGTH = 24,
	ISCSI_FLASHNODE_FIRST_BURST = 25,
	ISCSI_FLASHNODE_DEF_TIME2WAIT = 26,
	ISCSI_FLASHNODE_DEF_TIME2RETAIN = 27,
	ISCSI_FLASHNODE_MAX_R2T = 28,
	ISCSI_FLASHNODE_KEEPALIVE_TMO = 29,
	ISCSI_FLASHNODE_ISID = 30,
	ISCSI_FLASHNODE_TSID = 31,
	ISCSI_FLASHNODE_PORT = 32,
	ISCSI_FLASHNODE_MAX_BURST = 33,
	ISCSI_FLASHNODE_DEF_TASKMGMT_TMO = 34,
	ISCSI_FLASHNODE_IPADDR = 35,
	ISCSI_FLASHNODE_ALIAS = 36,
	ISCSI_FLASHNODE_REDIRECT_IPADDR = 37,
	ISCSI_FLASHNODE_MAX_SEGMENT_SIZE = 38,
	ISCSI_FLASHNODE_LOCAL_PORT = 39,
	ISCSI_FLASHNODE_IPV4_TOS = 40,
	ISCSI_FLASHNODE_IPV6_TC = 41,
	ISCSI_FLASHNODE_IPV6_FLOW_LABEL = 42,
	ISCSI_FLASHNODE_NAME = 43,
	ISCSI_FLASHNODE_TPGT = 44,
	ISCSI_FLASHNODE_LINK_LOCAL_IPV6 = 45,
	ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX = 46,
	ISCSI_FLASHNODE_DISCOVERY_PARENT_TYPE = 47,
	ISCSI_FLASHNODE_TCP_XMIT_WSF = 48,
	ISCSI_FLASHNODE_TCP_RECV_WSF = 49,
	ISCSI_FLASHNODE_CHAP_IN_IDX = 50,
	ISCSI_FLASHNODE_CHAP_OUT_IDX = 51,
	ISCSI_FLASHNODE_USERNAME = 52,
	ISCSI_FLASHNODE_USERNAME_IN = 53,
	ISCSI_FLASHNODE_PASSWORD = 54,
	ISCSI_FLASHNODE_PASSWORD_IN = 55,
	ISCSI_FLASHNODE_STATSN = 56,
	ISCSI_FLASHNODE_EXP_STATSN = 57,
	ISCSI_FLASHNODE_IS_BOOT_TGT = 58,
	ISCSI_FLASHNODE_MAX = 59,
};

enum iscsi_discovery_parent_type {
	ISCSI_DISC_PARENT_UNKNOWN = 1,
	ISCSI_DISC_PARENT_SENDTGT = 2,
	ISCSI_DISC_PARENT_ISNS = 3,
};

enum iscsi_port_speed {
	ISCSI_PORT_SPEED_UNKNOWN = 1,
	ISCSI_PORT_SPEED_10MBPS = 2,
	ISCSI_PORT_SPEED_100MBPS = 4,
	ISCSI_PORT_SPEED_1GBPS = 8,
	ISCSI_PORT_SPEED_10GBPS = 16,
	ISCSI_PORT_SPEED_25GBPS = 32,
	ISCSI_PORT_SPEED_40GBPS = 64,
};

enum iscsi_port_state {
	ISCSI_PORT_STATE_DOWN = 1,
	ISCSI_PORT_STATE_UP = 2,
};

struct iscsi_stats_custom {
	char desc[64];
	uint64_t value;
};

struct iscsi_stats {
	uint64_t txdata_octets;
	uint64_t rxdata_octets;
	uint32_t noptx_pdus;
	uint32_t scsicmd_pdus;
	uint32_t tmfcmd_pdus;
	uint32_t login_pdus;
	uint32_t text_pdus;
	uint32_t dataout_pdus;
	uint32_t logout_pdus;
	uint32_t snack_pdus;
	uint32_t noprx_pdus;
	uint32_t scsirsp_pdus;
	uint32_t tmfrsp_pdus;
	uint32_t textrsp_pdus;
	uint32_t datain_pdus;
	uint32_t logoutrsp_pdus;
	uint32_t r2t_pdus;
	uint32_t async_pdus;
	uint32_t rjt_pdus;
	uint32_t digest_err;
	uint32_t timeout_err;
	uint32_t custom_length;
	struct iscsi_stats_custom custom[0];
};

enum chap_type_e {
	CHAP_TYPE_OUT = 0,
	CHAP_TYPE_IN = 1,
};

struct iscsi_chap_rec {
	uint16_t chap_tbl_idx;
	enum chap_type_e chap_type;
	char username[256];
	uint8_t password[256];
	uint8_t password_length;
};

struct iscsi_cls_session;

struct iscsi_endpoint;

struct iscsi_cls_conn;

struct iscsi_task;

struct iscsi_conn;

struct iscsi_iface;

struct iscsi_bus_flash_session;

struct iscsi_bus_flash_conn;

struct iscsi_transport {
	struct module *owner;
	char *name;
	unsigned int caps;
	struct iscsi_cls_session * (*create_session)(struct iscsi_endpoint *, uint16_t, uint16_t, uint32_t);
	void (*destroy_session)(struct iscsi_cls_session *);
	struct iscsi_cls_conn * (*create_conn)(struct iscsi_cls_session *, uint32_t);
	int (*bind_conn)(struct iscsi_cls_session *, struct iscsi_cls_conn *, uint64_t, int);
	int (*start_conn)(struct iscsi_cls_conn *);
	void (*stop_conn)(struct iscsi_cls_conn *, int);
	void (*destroy_conn)(struct iscsi_cls_conn *);
	int (*set_param)(struct iscsi_cls_conn *, enum iscsi_param, char *, int);
	int (*get_ep_param)(struct iscsi_endpoint *, enum iscsi_param, char *);
	int (*get_conn_param)(struct iscsi_cls_conn *, enum iscsi_param, char *);
	int (*get_session_param)(struct iscsi_cls_session *, enum iscsi_param, char *);
	int (*get_host_param)(struct Scsi_Host *, enum iscsi_host_param, char *);
	int (*set_host_param)(struct Scsi_Host *, enum iscsi_host_param, char *, int);
	int (*send_pdu)(struct iscsi_cls_conn *, struct iscsi_hdr *, char *, uint32_t);
	void (*get_stats)(struct iscsi_cls_conn *, struct iscsi_stats *);
	int (*init_task)(struct iscsi_task *);
	int (*xmit_task)(struct iscsi_task *);
	void (*cleanup_task)(struct iscsi_task *);
	int (*alloc_pdu)(struct iscsi_task *, uint8_t);
	int (*xmit_pdu)(struct iscsi_task *);
	int (*init_pdu)(struct iscsi_task *, unsigned int, unsigned int);
	void (*parse_pdu_itt)(struct iscsi_conn *, itt_t, int *, int *);
	void (*session_recovery_timedout)(struct iscsi_cls_session *);
	struct iscsi_endpoint * (*ep_connect)(struct Scsi_Host *, struct sockaddr *, int);
	int (*ep_poll)(struct iscsi_endpoint *, int);
	void (*ep_disconnect)(struct iscsi_endpoint *);
	int (*tgt_dscvr)(struct Scsi_Host *, enum iscsi_tgt_dscvr, uint32_t, struct sockaddr *);
	int (*set_path)(struct Scsi_Host *, struct iscsi_path *);
	int (*set_iface_param)(struct Scsi_Host *, void *, uint32_t);
	int (*get_iface_param)(struct iscsi_iface *, enum iscsi_param_type, int, char *);
	umode_t (*attr_is_visible)(int, int);
	int (*bsg_request)(struct bsg_job *);
	int (*send_ping)(struct Scsi_Host *, uint32_t, uint32_t, uint32_t, uint32_t, struct sockaddr *);
	int (*get_chap)(struct Scsi_Host *, uint16_t, uint32_t *, char *);
	int (*delete_chap)(struct Scsi_Host *, uint16_t);
	int (*set_chap)(struct Scsi_Host *, void *, int);
	int (*get_flashnode_param)(struct iscsi_bus_flash_session *, int, char *);
	int (*set_flashnode_param)(struct iscsi_bus_flash_session *, struct iscsi_bus_flash_conn *, void *, int);
	int (*new_flashnode)(struct Scsi_Host *, const char *, int);
	int (*del_flashnode)(struct iscsi_bus_flash_session *);
	int (*login_flashnode)(struct iscsi_bus_flash_session *, struct iscsi_bus_flash_conn *);
	int (*logout_flashnode)(struct iscsi_bus_flash_session *, struct iscsi_bus_flash_conn *);
	int (*logout_flashnode_sid)(struct iscsi_cls_session *);
	int (*get_host_stats)(struct Scsi_Host *, char *, int);
	u8 (*check_protection)(struct iscsi_task *, sector_t *);
};

struct iscsi_cls_session {
	struct list_head sess_list;
	struct iscsi_transport *transport;
	spinlock_t lock;
	struct work_struct block_work;
	struct work_struct unblock_work;
	struct work_struct scan_work;
	struct work_struct unbind_work;
	int recovery_tmo;
	bool recovery_tmo_sysfs_override;
	struct delayed_work recovery_work;
	unsigned int target_id;
	bool ida_used;
	pid_t creator;
	int state;
	int sid;
	void *dd_data;
	struct device dev;
};

struct iscsi_endpoint {
	void *dd_data;
	struct device dev;
	uint64_t id;
	struct iscsi_cls_conn *conn;
};

struct iscsi_cls_conn {
	struct list_head conn_list;
	void *dd_data;
	struct iscsi_transport *transport;
	uint32_t cid;
	struct mutex ep_mutex;
	struct iscsi_endpoint *ep;
	struct device dev;
};

struct iscsi_iface {
	struct device dev;
	struct iscsi_transport *transport;
	uint32_t iface_type;
	uint32_t iface_num;
	void *dd_data;
};

struct iscsi_bus_flash_session {
	struct list_head sess_list;
	struct iscsi_transport *transport;
	unsigned int target_id;
	int flash_state;
	void *dd_data;
	struct device dev;
	unsigned int first_burst;
	unsigned int max_burst;
	short unsigned int max_r2t;
	int default_taskmgmt_timeout;
	int initial_r2t_en;
	int imm_data_en;
	int time2wait;
	int time2retain;
	int pdu_inorder_en;
	int dataseq_inorder_en;
	int erl;
	int tpgt;
	char *username;
	char *username_in;
	char *password;
	char *password_in;
	char *targetname;
	char *targetalias;
	char *portal_type;
	uint16_t tsid;
	uint16_t chap_in_idx;
	uint16_t chap_out_idx;
	uint16_t discovery_parent_idx;
	uint16_t discovery_parent_type;
	uint8_t auto_snd_tgt_disable;
	uint8_t discovery_sess;
	uint8_t entry_state;
	uint8_t chap_auth_en;
	uint8_t discovery_logout_en;
	uint8_t bidi_chap_en;
	uint8_t discovery_auth_optional;
	uint8_t isid[6];
	uint8_t is_boot_target;
};

struct iscsi_bus_flash_conn {
	struct list_head conn_list;
	void *dd_data;
	struct iscsi_transport *transport;
	struct device dev;
	uint32_t exp_statsn;
	uint32_t statsn;
	unsigned int max_recv_dlength;
	unsigned int max_xmit_dlength;
	unsigned int max_segment_size;
	unsigned int tcp_xmit_wsf;
	unsigned int tcp_recv_wsf;
	int hdrdgst_en;
	int datadgst_en;
	int port;
	char *ipaddress;
	char *link_local_ipv6_addr;
	char *redirect_ipaddr;
	uint16_t keepalive_timeout;
	uint16_t local_port;
	uint8_t snack_req_en;
	uint8_t tcp_timestamp_stat;
	uint8_t tcp_nagle_disable;
	uint8_t tcp_wsf_disable;
	uint8_t tcp_timer_scale;
	uint8_t tcp_timestamp_en;
	uint8_t ipv4_tos;
	uint8_t ipv6_traffic_class;
	uint8_t ipv6_flow_label;
	uint8_t fragment_disable;
	uint8_t is_fw_assigned_ipv6;
};

enum {
	ISCSI_SESSION_LOGGED_IN = 0,
	ISCSI_SESSION_FAILED = 1,
	ISCSI_SESSION_FREE = 2,
};

struct iscsi_cls_host {
	atomic_t nr_scans;
	struct mutex mutex;
	struct request_queue *bsg_q;
	uint32_t port_speed;
	uint32_t port_state;
};

struct iscsi_bsg_host_vendor {
	uint64_t vendor_id;
	uint32_t vendor_cmd[0];
};

struct iscsi_bsg_host_vendor_reply {
	uint32_t vendor_rsp[0];
};

struct iscsi_bsg_request {
	uint32_t msgcode;
	union {
		struct iscsi_bsg_host_vendor h_vendor;
	} rqst_data;
} __attribute__((packed));

struct iscsi_bsg_reply {
	uint32_t result;
	uint32_t reply_payload_rcv_len;
	union {
		struct iscsi_bsg_host_vendor_reply vendor_reply;
	} reply_data;
};

struct trace_event_raw_iscsi_log_msg {
	struct trace_entry ent;
	u32 __data_loc_dname;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_iscsi_log_msg {
	u32 dname;
	u32 msg;
};

typedef void (*btf_trace_iscsi_dbg_conn)(void *, struct device *, struct va_format *);

typedef void (*btf_trace_iscsi_dbg_session)(void *, struct device *, struct va_format *);

typedef void (*btf_trace_iscsi_dbg_eh)(void *, struct device *, struct va_format *);

typedef void (*btf_trace_iscsi_dbg_tcp)(void *, struct device *, struct va_format *);

typedef void (*btf_trace_iscsi_dbg_sw_tcp)(void *, struct device *, struct va_format *);

typedef void (*btf_trace_iscsi_dbg_trans_session)(void *, struct device *, struct va_format *);

typedef void (*btf_trace_iscsi_dbg_trans_conn)(void *, struct device *, struct va_format *);

struct iscsi_internal {
	struct scsi_transport_template t;
	struct iscsi_transport *iscsi_transport;
	struct list_head list;
	struct device dev;
	struct transport_container conn_cont;
	struct transport_container session_cont;
};

struct iscsi_scan_data {
	unsigned int channel;
	unsigned int id;
	u64 lun;
	enum scsi_scan_mode rescan;
};

enum sas_device_type {
	SAS_PHY_UNUSED = 0,
	SAS_END_DEVICE = 1,
	SAS_EDGE_EXPANDER_DEVICE = 2,
	SAS_FANOUT_EXPANDER_DEVICE = 3,
	SAS_HA = 4,
	SAS_SATA_DEV = 5,
	SAS_SATA_PM = 7,
	SAS_SATA_PM_PORT = 8,
	SAS_SATA_PENDING = 9,
};

enum sas_protocol {
	SAS_PROTOCOL_NONE = 0,
	SAS_PROTOCOL_SATA = 1,
	SAS_PROTOCOL_SMP = 2,
	SAS_PROTOCOL_STP = 4,
	SAS_PROTOCOL_SSP = 8,
	SAS_PROTOCOL_ALL = 14,
	SAS_PROTOCOL_STP_ALL = 5,
};

enum sas_linkrate {
	SAS_LINK_RATE_UNKNOWN = 0,
	SAS_PHY_DISABLED = 1,
	SAS_PHY_RESET_PROBLEM = 2,
	SAS_SATA_SPINUP_HOLD = 3,
	SAS_SATA_PORT_SELECTOR = 4,
	SAS_PHY_RESET_IN_PROGRESS = 5,
	SAS_LINK_RATE_1_5_GBPS = 8,
	SAS_LINK_RATE_G1 = 8,
	SAS_LINK_RATE_3_0_GBPS = 9,
	SAS_LINK_RATE_G2 = 9,
	SAS_LINK_RATE_6_0_GBPS = 10,
	SAS_LINK_RATE_12_0_GBPS = 11,
	SAS_LINK_RATE_FAILED = 16,
	SAS_PHY_VIRTUAL = 17,
};

struct sas_identify {
	enum sas_device_type device_type;
	enum sas_protocol initiator_port_protocols;
	enum sas_protocol target_port_protocols;
	u64 sas_address;
	u8 phy_identifier;
};

struct sas_phy {
	struct device dev;
	int number;
	int enabled;
	struct sas_identify identify;
	enum sas_linkrate negotiated_linkrate;
	enum sas_linkrate minimum_linkrate_hw;
	enum sas_linkrate minimum_linkrate;
	enum sas_linkrate maximum_linkrate_hw;
	enum sas_linkrate maximum_linkrate;
	u32 invalid_dword_count;
	u32 running_disparity_error_count;
	u32 loss_of_dword_sync_count;
	u32 phy_reset_problem_count;
	struct list_head port_siblings;
	void *hostdata;
};

struct sas_rphy {
	struct device dev;
	struct sas_identify identify;
	struct list_head list;
	struct request_queue *q;
	u32 scsi_target_id;
};

struct sas_end_device {
	struct sas_rphy rphy;
	unsigned int ready_led_meaning: 1;
	unsigned int tlr_supported: 1;
	unsigned int tlr_enabled: 1;
	u16 I_T_nexus_loss_timeout;
	u16 initiator_response_timeout;
};

struct sas_expander_device {
	int level;
	int next_port_id;
	char vendor_id[9];
	char product_id[17];
	char product_rev[5];
	char component_vendor_id[9];
	u16 component_id;
	u8 component_revision_id;
	struct sas_rphy rphy;
};

struct sas_port {
	struct device dev;
	int port_identifier;
	int num_phys;
	unsigned int is_backlink: 1;
	struct sas_rphy *rphy;
	struct mutex phy_list_mutex;
	struct list_head phy_list;
	struct list_head del_list;
};

struct sas_phy_linkrates {
	enum sas_linkrate maximum_linkrate;
	enum sas_linkrate minimum_linkrate;
};

struct sas_function_template {
	int (*get_linkerrors)(struct sas_phy *);
	int (*get_enclosure_identifier)(struct sas_rphy *, u64 *);
	int (*get_bay_identifier)(struct sas_rphy *);
	int (*phy_reset)(struct sas_phy *, int);
	int (*phy_enable)(struct sas_phy *, int);
	int (*phy_setup)(struct sas_phy *);
	void (*phy_release)(struct sas_phy *);
	int (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);
	void (*smp_handler)(struct bsg_job *, struct Scsi_Host *, struct sas_rphy *);
};

struct sas_domain_function_template;

struct sas_internal {
	struct scsi_transport_template t;
	struct sas_function_template *f;
	struct sas_domain_function_template *dft;
	struct device_attribute private_host_attrs[0];
	struct device_attribute private_phy_attrs[17];
	struct device_attribute private_port_attrs[1];
	struct device_attribute private_rphy_attrs[8];
	struct device_attribute private_end_dev_attrs[5];
	struct device_attribute private_expander_attrs[7];
	struct transport_container phy_attr_cont;
	struct transport_container port_attr_cont;
	struct transport_container rphy_attr_cont;
	struct transport_container end_dev_attr_cont;
	struct transport_container expander_attr_cont;
	struct device_attribute *host_attrs[1];
	struct device_attribute *phy_attrs[18];
	struct device_attribute *port_attrs[2];
	struct device_attribute *rphy_attrs[9];
	struct device_attribute *end_dev_attrs[6];
	struct device_attribute *expander_attrs[8];
};

struct sas_host_attrs {
	struct list_head rphy_list;
	struct mutex lock;
	struct request_queue *q;
	u32 next_target_id;
	u32 next_expander_id;
	int next_port_id;
};

enum sas_oob_mode {
	OOB_NOT_CONNECTED = 0,
	SATA_OOB_MODE = 1,
	SAS_OOB_MODE = 2,
};

enum phy_func {
	PHY_FUNC_NOP = 0,
	PHY_FUNC_LINK_RESET = 1,
	PHY_FUNC_HARD_RESET = 2,
	PHY_FUNC_DISABLE = 3,
	PHY_FUNC_CLEAR_ERROR_LOG = 5,
	PHY_FUNC_CLEAR_AFFIL = 6,
	PHY_FUNC_TX_SATA_PS_SIGNAL = 7,
	PHY_FUNC_RELEASE_SPINUP_HOLD = 16,
	PHY_FUNC_SET_LINK_RATE = 17,
	PHY_FUNC_GET_EVENTS = 18,
};

enum sas_open_rej_reason {
	SAS_OREJ_UNKNOWN = 0,
	SAS_OREJ_BAD_DEST = 1,
	SAS_OREJ_CONN_RATE = 2,
	SAS_OREJ_EPROTO = 3,
	SAS_OREJ_RESV_AB0 = 4,
	SAS_OREJ_RESV_AB1 = 5,
	SAS_OREJ_RESV_AB2 = 6,
	SAS_OREJ_RESV_AB3 = 7,
	SAS_OREJ_WRONG_DEST = 8,
	SAS_OREJ_STP_NORES = 9,
	SAS_OREJ_NO_DEST = 10,
	SAS_OREJ_PATH_BLOCKED = 11,
	SAS_OREJ_RSVD_CONT0 = 12,
	SAS_OREJ_RSVD_CONT1 = 13,
	SAS_OREJ_RSVD_INIT0 = 14,
	SAS_OREJ_RSVD_INIT1 = 15,
	SAS_OREJ_RSVD_STOP0 = 16,
	SAS_OREJ_RSVD_STOP1 = 17,
	SAS_OREJ_RSVD_RETRY = 18,
};

struct dev_to_host_fis {
	u8 fis_type;
	u8 flags;
	u8 status;
	u8 error;
	u8 lbal;
	union {
		u8 lbam;
		u8 byte_count_low;
	};
	union {
		u8 lbah;
		u8 byte_count_high;
	};
	u8 device;
	u8 lbal_exp;
	u8 lbam_exp;
	u8 lbah_exp;
	u8 _r_a;
	union {
		u8 sector_count;
		u8 interrupt_reason;
	};
	u8 sector_count_exp;
	u8 _r_b;
	u8 _r_c;
	u32 _r_d;
};

struct host_to_dev_fis___2 {
	u8 fis_type;
	u8 flags;
	u8 command;
	u8 features;
	u8 lbal;
	union {
		u8 lbam;
		u8 byte_count_low;
	};
	union {
		u8 lbah;
		u8 byte_count_high;
	};
	u8 device;
	u8 lbal_exp;
	u8 lbam_exp;
	u8 lbah_exp;
	u8 features_exp;
	union {
		u8 sector_count;
		u8 interrupt_reason;
	};
	u8 sector_count_exp;
	u8 _r_a;
	u8 control;
	u32 _r_b;
};

struct report_general_resp {
	__be16 change_count;
	__be16 route_indexes;
	u8 _r_a;
	u8 num_phys;
	u8 conf_route_table: 1;
	u8 configuring: 1;
	u8 config_others: 1;
	u8 orej_retry_supp: 1;
	u8 stp_cont_awt: 1;
	u8 self_config: 1;
	u8 zone_config: 1;
	u8 t2t_supp: 1;
	u8 _r_c;
	u8 enclosure_logical_id[8];
	u8 _r_d[12];
};

struct discover_resp {
	u8 _r_a[5];
	u8 phy_id;
	__be16 _r_b;
	u8 _r_c: 4;
	u8 attached_dev_type: 3;
	u8 _r_d: 1;
	u8 linkrate: 4;
	u8 _r_e: 4;
	u8 attached_sata_host: 1;
	u8 iproto: 3;
	u8 _r_f: 4;
	u8 attached_sata_dev: 1;
	u8 tproto: 3;
	u8 _r_g: 3;
	u8 attached_sata_ps: 1;
	u8 sas_addr[8];
	u8 attached_sas_addr[8];
	u8 attached_phy_id;
	u8 _r_h[7];
	u8 hmin_linkrate: 4;
	u8 pmin_linkrate: 4;
	u8 hmax_linkrate: 4;
	u8 pmax_linkrate: 4;
	u8 change_count;
	u8 pptv: 4;
	u8 _r_i: 3;
	u8 virtual: 1;
	u8 routing_attr: 4;
	u8 _r_j: 4;
	u8 conn_type;
	u8 conn_el_index;
	u8 conn_phy_link;
	u8 _r_k[8];
};

struct report_phy_sata_resp {
	u8 _r_a[5];
	u8 phy_id;
	u8 _r_b;
	u8 affil_valid: 1;
	u8 affil_supp: 1;
	u8 _r_c: 6;
	u32 _r_d;
	u8 stp_sas_addr[8];
	struct dev_to_host_fis fis;
	u32 _r_e;
	u8 affil_stp_ini_addr[8];
	__be32 crc;
};

struct smp_resp {
	u8 frame_type;
	u8 function;
	u8 result;
	u8 reserved;
	union {
		struct report_general_resp rg;
		struct discover_resp disc;
		struct report_phy_sata_resp rps;
	};
};

enum sas_class {
	SAS = 0,
	EXPANDER = 1,
};

enum sas_phy_role {
	PHY_ROLE_NONE = 0,
	PHY_ROLE_TARGET = 64,
	PHY_ROLE_INITIATOR = 128,
};

enum sas_phy_type {
	PHY_TYPE_PHYSICAL = 0,
	PHY_TYPE_VIRTUAL = 1,
};

enum port_event {
	PORTE_BYTES_DMAED = 0,
	PORTE_BROADCAST_RCVD = 1,
	PORTE_LINK_RESET_ERR = 2,
	PORTE_TIMER_EVENT = 3,
	PORTE_HARD_RESET = 4,
	PORT_NUM_EVENTS = 5,
};

enum phy_event {
	PHYE_LOSS_OF_SIGNAL = 0,
	PHYE_OOB_DONE = 1,
	PHYE_OOB_ERROR = 2,
	PHYE_SPINUP_HOLD = 3,
	PHYE_RESUME_TIMEOUT = 4,
	PHYE_SHUTDOWN = 5,
	PHY_NUM_EVENTS = 6,
};

enum discover_event {
	DISCE_DISCOVER_DOMAIN = 0,
	DISCE_REVALIDATE_DOMAIN = 1,
	DISCE_SUSPEND = 2,
	DISCE_RESUME = 3,
	DISC_NUM_EVENTS = 4,
};

enum routing_attribute {
	DIRECT_ROUTING = 0,
	SUBTRACTIVE_ROUTING = 1,
	TABLE_ROUTING = 2,
};

enum ex_phy_state {
	PHY_EMPTY = 0,
	PHY_VACANT = 1,
	PHY_NOT_PRESENT = 2,
	PHY_DEVICE_DISCOVERED = 3,
};

struct ex_phy {
	int phy_id;
	enum ex_phy_state phy_state;
	enum sas_device_type attached_dev_type;
	enum sas_linkrate linkrate;
	u8 attached_sata_host: 1;
	u8 attached_sata_dev: 1;
	u8 attached_sata_ps: 1;
	enum sas_protocol attached_tproto;
	enum sas_protocol attached_iproto;
	u8 attached_sas_addr[8];
	u8 attached_phy_id;
	int phy_change_count;
	enum routing_attribute routing_attr;
	u8 virtual: 1;
	int last_da_index;
	struct sas_phy *phy;
	struct sas_port *port;
};

struct expander_device {
	struct list_head children;
	int ex_change_count;
	u16 max_route_indexes;
	u8 num_phys;
	u8 t2t_supp: 1;
	u8 configuring: 1;
	u8 conf_route_table: 1;
	u8 enclosure_logical_id[8];
	struct ex_phy *ex_phy;
	struct sas_port *parent_port;
	struct mutex cmd_mutex;
};

struct sata_device {
	unsigned int class;
	u8 port_no;
	struct ata_port *ap;
	struct ata_host *ata_host;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct smp_resp rps_resp;
	u8 fis[24];
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ssp_device {
	struct list_head eh_list_node;
	struct scsi_lun reset_lun;
};

struct asd_sas_port;

struct domain_device {
	spinlock_t done_lock;
	enum sas_device_type dev_type;
	enum sas_linkrate linkrate;
	enum sas_linkrate min_linkrate;
	enum sas_linkrate max_linkrate;
	int pathways;
	struct domain_device *parent;
	struct list_head siblings;
	struct asd_sas_port *port;
	struct sas_phy *phy;
	struct list_head dev_list_node;
	struct list_head disco_list_node;
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	struct sas_rphy *rphy;
	u8 sas_addr[8];
	u8 hashed_sas_addr[3];
	u8 frame_rcvd[32];
	long: 40;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct expander_device ex_dev;
		struct sata_device sata_dev;
		struct ssp_device ssp_dev;
	};
	void *lldd_dev;
	long unsigned int state;
	struct kref kref;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sas_work {
	struct list_head drain_node;
	struct work_struct work;
};

struct sas_discovery_event {
	struct sas_work work;
	struct asd_sas_port *port;
};

struct sas_discovery {
	struct sas_discovery_event disc_work[4];
	long unsigned int pending;
	u8 fanout_sas_addr[8];
	u8 eeds_a[8];
	u8 eeds_b[8];
	int max_level;
};

struct sas_ha_struct;

struct asd_sas_port {
	struct sas_discovery disc;
	struct domain_device *port_dev;
	spinlock_t dev_list_lock;
	struct list_head dev_list;
	struct list_head disco_list;
	struct list_head destroy_list;
	struct list_head sas_port_del_list;
	enum sas_linkrate linkrate;
	struct sas_work work;
	int suspended;
	int id;
	enum sas_class class;
	u8 sas_addr[8];
	u8 attached_sas_addr[8];
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	enum sas_oob_mode oob_mode;
	spinlock_t phy_list_lock;
	struct list_head phy_list;
	int num_phys;
	u32 phy_mask;
	struct sas_ha_struct *ha;
	struct sas_port *port;
	void *lldd_port;
};

struct scsi_core {
	struct Scsi_Host *shost;
};

struct asd_sas_phy;

struct sas_ha_struct {
	struct list_head defer_q;
	struct mutex drain_mutex;
	long unsigned int state;
	spinlock_t lock;
	int eh_active;
	wait_queue_head_t eh_wait_q;
	struct list_head eh_dev_q;
	struct mutex disco_mutex;
	struct scsi_core core;
	char *sas_ha_name;
	struct device *dev;
	struct module *lldd_module;
	struct workqueue_struct *event_q;
	struct workqueue_struct *disco_q;
	u8 *sas_addr;
	u8 hashed_sas_addr[3];
	spinlock_t phy_port_lock;
	struct asd_sas_phy **sas_phy;
	struct asd_sas_port **sas_port;
	int num_phys;
	int strict_wide_ports;
	int (*notify_port_event)(struct asd_sas_phy *, enum port_event);
	int (*notify_phy_event)(struct asd_sas_phy *, enum phy_event);
	void *lldd_ha;
	struct list_head eh_done_q;
	struct list_head eh_ata_q;
	int event_thres;
};

struct asd_sas_event {
	struct sas_work work;
	struct asd_sas_phy *phy;
	int event;
};

struct asd_sas_phy {
	atomic_t event_nr;
	int in_shutdown;
	int error;
	int suspended;
	struct sas_phy *phy;
	int enabled;
	int id;
	enum sas_class class;
	enum sas_protocol iproto;
	enum sas_protocol tproto;
	enum sas_phy_type type;
	enum sas_phy_role role;
	enum sas_oob_mode oob_mode;
	enum sas_linkrate linkrate;
	u8 *sas_addr;
	u8 attached_sas_addr[8];
	spinlock_t frame_rcvd_lock;
	u8 *frame_rcvd;
	int frame_rcvd_size;
	spinlock_t sas_prim_lock;
	u32 sas_prim;
	struct list_head port_phy_el;
	struct asd_sas_port *port;
	struct sas_ha_struct *ha;
	void *lldd_phy;
};

enum sas_ha_state {
	SAS_HA_REGISTERED = 0,
	SAS_HA_DRAINING = 1,
	SAS_HA_ATA_EH_ACTIVE = 2,
	SAS_HA_FROZEN = 3,
};

enum service_response {
	SAS_TASK_COMPLETE = 0,
	SAS_TASK_UNDELIVERED = 4294967295,
};

enum exec_status {
	__SAM_STAT_CHECK_CONDITION = 2,
	SAS_DEV_NO_RESPONSE = 128,
	SAS_DATA_UNDERRUN = 129,
	SAS_DATA_OVERRUN = 130,
	SAS_INTERRUPTED = 131,
	SAS_QUEUE_FULL = 132,
	SAS_DEVICE_UNKNOWN = 133,
	SAS_SG_ERR = 134,
	SAS_OPEN_REJECT = 135,
	SAS_OPEN_TO = 136,
	SAS_PROTO_RESPONSE = 137,
	SAS_PHY_DOWN = 138,
	SAS_NAK_R_ERR = 139,
	SAS_PENDING = 140,
	SAS_ABORTED_TASK = 141,
};

struct task_status_struct {
	enum service_response resp;
	enum exec_status stat;
	int buf_valid_size;
	u8 buf[96];
	u32 residual;
	enum sas_open_rej_reason open_rej_reason;
};

struct sas_ata_task {
	struct host_to_dev_fis___2 fis;
	u8 atapi_packet[16];
	u8 retry_count;
	u8 dma_xfer: 1;
	u8 use_ncq: 1;
	u8 set_affil_pol: 1;
	u8 stp_affil_pol: 1;
	u8 device_control_reg_update: 1;
} __attribute__((packed));

struct sas_smp_task {
	struct scatterlist smp_req;
	struct scatterlist smp_resp;
};

enum task_attribute {
	TASK_ATTR_SIMPLE = 0,
	TASK_ATTR_HOQ = 1,
	TASK_ATTR_ORDERED = 2,
	TASK_ATTR_ACA = 4,
};

struct sas_ssp_task {
	u8 retry_count;
	u8 LUN[8];
	u8 enable_first_burst: 1;
	enum task_attribute task_attr;
	u8 task_prio;
	struct scsi_cmnd *cmd;
};

struct sas_task_slow;

struct sas_task {
	struct domain_device *dev;
	spinlock_t task_state_lock;
	unsigned int task_state_flags;
	enum sas_protocol task_proto;
	union {
		struct sas_ata_task ata_task;
		struct sas_smp_task smp_task;
		struct sas_ssp_task ssp_task;
	};
	struct scatterlist *scatter;
	int num_scatter;
	u32 total_xfer_len;
	u8 data_dir: 2;
	struct task_status_struct task_status;
	void (*task_done)(struct sas_task *);
	void *lldd_task;
	void *uldd_task;
	struct sas_task_slow *slow_task;
};

struct sas_task_slow {
	struct timer_list timer;
	struct completion completion;
	struct sas_task *task;
};

struct sas_domain_function_template {
	void (*lldd_port_formed)(struct asd_sas_phy *);
	void (*lldd_port_deformed)(struct asd_sas_phy *);
	int (*lldd_dev_found)(struct domain_device *);
	void (*lldd_dev_gone)(struct domain_device *);
	int (*lldd_execute_task)(struct sas_task *, gfp_t);
	int (*lldd_abort_task)(struct sas_task *);
	int (*lldd_abort_task_set)(struct domain_device *, u8 *);
	int (*lldd_clear_aca)(struct domain_device *, u8 *);
	int (*lldd_clear_task_set)(struct domain_device *, u8 *);
	int (*lldd_I_T_nexus_reset)(struct domain_device *);
	int (*lldd_ata_check_ready)(struct domain_device *);
	void (*lldd_ata_set_dmamode)(struct domain_device *);
	int (*lldd_lu_reset)(struct domain_device *, u8 *);
	int (*lldd_query_task)(struct sas_task *);
	int (*lldd_clear_nexus_port)(struct asd_sas_port *);
	int (*lldd_clear_nexus_ha)(struct sas_ha_struct *);
	int (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func, void *);
	int (*lldd_write_gpio)(struct sas_ha_struct *, u8, u8, u8, u8 *);
};

struct sas_phy_data {
	struct sas_phy *phy;
	struct mutex event_lock;
	int hard_reset;
	int reset_result;
	struct sas_work reset_work;
	int enable;
	int enable_result;
	struct sas_work enable_work;
};

struct sas_identify_frame {
	u8 frame_type: 4;
	u8 dev_type: 3;
	u8 _un0: 1;
	u8 _un1;
	union {
		struct {
			u8 _un20: 1;
			u8 smp_iport: 1;
			u8 stp_iport: 1;
			u8 ssp_iport: 1;
			u8 _un247: 4;
		};
		u8 initiator_bits;
	};
	union {
		struct {
			u8 _un30: 1;
			u8 smp_tport: 1;
			u8 stp_tport: 1;
			u8 ssp_tport: 1;
			u8 _un347: 4;
		};
		u8 target_bits;
	};
	u8 _un4_11[8];
	u8 sas_addr[8];
	u8 phy_id;
	u8 _un21_27[7];
	__be32 crc;
};

enum {
	SAS_DEV_GONE = 0,
	SAS_DEV_FOUND = 1,
	SAS_DEV_DESTROY = 2,
	SAS_DEV_EH_PENDING = 3,
	SAS_DEV_LU_RESET = 4,
	SAS_DEV_RESET = 5,
};

enum task_disposition {
	TASK_IS_DONE = 0,
	TASK_IS_ABORTED = 1,
	TASK_IS_AT_LU = 2,
	TASK_IS_NOT_AT_LU = 3,
	TASK_ABORT_FAILED = 4,
};

struct ssp_response_iu {
	u8 _r_a[10];
	u8 datapres: 2;
	u8 _r_b: 6;
	u8 status;
	u32 _r_c;
	__be32 sense_data_len;
	__be32 response_data_len;
	u8 resp_data[0];
	u8 sense_data[0];
};

struct ata_task_resp {
	u16 frame_len;
	u8 ending_fis[24];
};

struct srp_rport_identifiers {
	u8 port_id[16];
	u8 roles;
};

enum srp_rport_state {
	SRP_RPORT_RUNNING = 0,
	SRP_RPORT_BLOCKED = 1,
	SRP_RPORT_FAIL_FAST = 2,
	SRP_RPORT_LOST = 3,
};

struct srp_rport {
	struct device dev;
	u8 port_id[16];
	u8 roles;
	void *lld_data;
	struct mutex mutex;
	enum srp_rport_state state;
	int reconnect_delay;
	int failed_reconnects;
	struct delayed_work reconnect_work;
	int fast_io_fail_tmo;
	int dev_loss_tmo;
	struct delayed_work fast_io_fail_work;
	struct delayed_work dev_loss_work;
};

struct srp_function_template {
	bool has_rport_state;
	bool reset_timer_if_blocked;
	int *reconnect_delay;
	int *fast_io_fail_tmo;
	int *dev_loss_tmo;
	int (*reconnect)(struct srp_rport *);
	void (*terminate_rport_io)(struct srp_rport *);
	void (*rport_delete)(struct srp_rport *);
};

struct srp_host_attrs {
	atomic_t next_port_id;
};

struct srp_internal {
	struct scsi_transport_template t;
	struct srp_function_template *f;
	struct device_attribute *host_attrs[1];
	struct device_attribute *rport_attrs[9];
	struct transport_container rport_attr_cont;
};

struct rdac_mode_6_hdr {
	u8 data_len;
	u8 medium_type;
	u8 device_params;
	u8 block_desc_len;
};

struct rdac_mode_10_hdr {
	u16 data_len;
	u8 medium_type;
	u8 device_params;
	u16 reserved;
	u16 block_desc_len;
};

struct rdac_mode_common {
	u8 controller_serial[16];
	u8 alt_controller_serial[16];
	u8 rdac_mode[2];
	u8 alt_rdac_mode[2];
	u8 quiescence_timeout;
	u8 rdac_options;
};

struct rdac_pg_legacy {
	struct rdac_mode_6_hdr hdr;
	u8 page_code;
	u8 page_len;
	struct rdac_mode_common common;
	u8 lun_table[32];
	u8 reserved2[32];
	u8 reserved3;
	u8 reserved4;
};

struct rdac_pg_expanded {
	struct rdac_mode_10_hdr hdr;
	u8 page_code;
	u8 subpage_code;
	u8 page_len[2];
	struct rdac_mode_common common;
	u8 lun_table[256];
	u8 reserved3;
	u8 reserved4;
};

struct c9_inquiry {
	u8 peripheral_info;
	u8 page_code;
	u8 reserved1;
	u8 page_len;
	u8 page_id[4];
	u8 avte_cvp;
	u8 path_prio;
	u8 reserved2[38];
};

struct c4_inquiry {
	u8 peripheral_info;
	u8 page_code;
	u8 reserved1;
	u8 page_len;
	u8 page_id[4];
	u8 subsys_id[16];
	u8 revision[4];
	u8 slot_id[2];
	u8 reserved[2];
};

struct c8_inquiry {
	u8 peripheral_info;
	u8 page_code;
	u8 reserved1;
	u8 page_len;
	u8 page_id[4];
	u8 reserved2[3];
	u8 vol_uniq_id_len;
	u8 vol_uniq_id[16];
	u8 vol_user_label_len;
	u8 vol_user_label[60];
	u8 array_uniq_id_len;
	u8 array_unique_id[16];
	u8 array_user_label_len;
	u8 array_user_label[60];
	u8 lun[8];
};

struct rdac_controller {
	u8 array_id[16];
	int use_ms10;
	struct kref kref;
	struct list_head node;
	union {
		struct rdac_pg_legacy legacy;
		struct rdac_pg_expanded expanded;
	} mode_select;
	u8 index;
	u8 array_name[31];
	struct Scsi_Host *host;
	spinlock_t ms_lock;
	int ms_queued;
	struct work_struct ms_work;
	struct scsi_device *ms_sdev;
	struct list_head ms_head;
	struct list_head dh_list;
};

struct c2_inquiry {
	u8 peripheral_info;
	u8 page_code;
	u8 reserved1;
	u8 page_len;
	u8 page_id[4];
	u8 sw_version[3];
	u8 sw_date[3];
	u8 features_enabled;
	u8 max_lun_supported;
	u8 partitions[239];
};

struct rdac_dh_data {
	struct list_head node;
	struct rdac_controller *ctlr;
	struct scsi_device *sdev;
	unsigned int lun;
	unsigned char mode;
	unsigned char state;
	char lun_state;
	char preferred;
	union {
		struct c2_inquiry c2;
		struct c4_inquiry c4;
		struct c8_inquiry c8;
		struct c9_inquiry c9;
	} inq;
};

struct rdac_queue_data {
	struct list_head entry;
	struct rdac_dh_data *h;
	activate_complete callback_fn;
	void *callback_data;
};

struct hp_sw_dh_data {
	int path_state;
	int retries;
	int retry_cnt;
	struct scsi_device *sdev;
};

struct clariion_dh_data {
	unsigned int flags;
	unsigned char buffer[252];
	int lun_state;
	int port;
	int default_sp;
	int current_sp;
};

struct alua_port_group {
	struct kref kref;
	struct callback_head rcu;
	struct list_head node;
	struct list_head dh_list;
	unsigned char device_id_str[256];
	int device_id_len;
	int group_id;
	int tpgs;
	int state;
	int pref;
	int valid_states;
	unsigned int flags;
	unsigned char transition_tmo;
	long unsigned int expiry;
	long unsigned int interval;
	struct delayed_work rtpg_work;
	spinlock_t lock;
	struct list_head rtpg_list;
	struct scsi_device *rtpg_sdev;
};

struct alua_dh_data {
	struct list_head node;
	struct alua_port_group *pg;
	int group_id;
	spinlock_t pg_lock;
	struct scsi_device *sdev;
	int init_error;
	struct mutex init_mutex;
};

struct alua_queue_data {
	struct list_head entry;
	activate_complete callback_fn;
	void *callback_data;
};

struct fcp_cmnd {
	struct scsi_lun fc_lun;
	__u8 fc_cmdref;
	__u8 fc_pri_ta;
	__u8 fc_tm_flags;
	__u8 fc_flags;
	__u8 fc_cdb[16];
	__be32 fc_dl;
};

struct fc_ns_fts {
	__be32 ff_type_map[8];
};

struct fc_gpn_ft_resp {
	__u8 fp_flags;
	__u8 fp_fid[3];
	__be32 fp_resvd;
	__be64 fp_wwpn;
};

struct fc_els_spp {
	__u8 spp_type;
	__u8 spp_type_ext;
	__u8 spp_flags;
	__u8 _spp_resvd;
	__be32 spp_orig_pa;
	__be32 spp_resp_pa;
	__be32 spp_params;
};

struct fc_els_rnid_gen {
	__u8 rnid_vend_id[16];
	__be32 rnid_atype;
	__be32 rnid_phys_port;
	__be32 rnid_att_nodes;
	__u8 rnid_node_mgmt;
	__u8 rnid_ip_ver;
	__be16 rnid_prot_port;
	__be32 rnid_ip_addr[4];
	__u8 rnid_resvd[2];
	__be16 rnid_vend_spec;
};

struct fc_els_lesb {
	__be32 lesb_link_fail;
	__be32 lesb_sync_loss;
	__be32 lesb_sig_loss;
	__be32 lesb_prim_err;
	__be32 lesb_inv_word;
	__be32 lesb_inv_crc;
};

struct fc_frame_header {
	__u8 fh_r_ctl;
	__u8 fh_d_id[3];
	__u8 fh_cs_ctl;
	__u8 fh_s_id[3];
	__u8 fh_type;
	__u8 fh_f_ctl[3];
	__u8 fh_seq_id;
	__u8 fh_df_ctl;
	__be16 fh_seq_cnt;
	__be16 fh_ox_id;
	__be16 fh_rx_id;
	__be32 fh_parm_offset;
};

enum fc_rctl {
	FC_RCTL_DD_UNCAT = 0,
	FC_RCTL_DD_SOL_DATA = 1,
	FC_RCTL_DD_UNSOL_CTL = 2,
	FC_RCTL_DD_SOL_CTL = 3,
	FC_RCTL_DD_UNSOL_DATA = 4,
	FC_RCTL_DD_DATA_DESC = 5,
	FC_RCTL_DD_UNSOL_CMD = 6,
	FC_RCTL_DD_CMD_STATUS = 7,
	FC_RCTL_ELS_REQ = 34,
	FC_RCTL_ELS_REP = 35,
	FC_RCTL_ELS4_REQ = 50,
	FC_RCTL_ELS4_REP = 51,
	FC_RCTL_VFTH = 80,
	FC_RCTL_IFRH = 81,
	FC_RCTL_ENCH = 82,
	FC_RCTL_BA_NOP = 128,
	FC_RCTL_BA_ABTS = 129,
	FC_RCTL_BA_RMC = 130,
	FC_RCTL_BA_ACC = 132,
	FC_RCTL_BA_RJT = 133,
	FC_RCTL_BA_PRMT = 134,
	FC_RCTL_ACK_1 = 192,
	FC_RCTL_ACK_0 = 193,
	FC_RCTL_P_RJT = 194,
	FC_RCTL_F_RJT = 195,
	FC_RCTL_P_BSY = 196,
	FC_RCTL_F_BSY = 197,
	FC_RCTL_F_BSYL = 198,
	FC_RCTL_LCR = 199,
	FC_RCTL_END = 201,
};

enum fc_fh_type {
	FC_TYPE_BLS = 0,
	FC_TYPE_ELS = 1,
	FC_TYPE_IP = 5,
	FC_TYPE_FCP = 8,
	FC_TYPE_CT = 32,
	FC_TYPE_ILS = 34,
	FC_TYPE_NVME = 40,
};

enum fc_sof {
	FC_SOF_F = 40,
	FC_SOF_I4 = 41,
	FC_SOF_I2 = 45,
	FC_SOF_I3 = 46,
	FC_SOF_N4 = 49,
	FC_SOF_N2 = 53,
	FC_SOF_N3 = 54,
	FC_SOF_C4 = 57,
};

enum fc_eof {
	FC_EOF_N = 65,
	FC_EOF_T = 66,
	FC_EOF_RT = 68,
	FC_EOF_DT = 70,
	FC_EOF_NI = 73,
	FC_EOF_DTI = 78,
	FC_EOF_RTI = 79,
	FC_EOF_A = 80,
};

struct fc_frame {
	struct sk_buff skb;
};

struct fc_lport;

struct fc_seq;

struct fc_fcp_pkt;

struct fcoe_rcv_info {
	struct fc_lport *fr_dev;
	struct fc_seq *fr_seq;
	struct fc_fcp_pkt *fr_fsp;
	u32 fr_crc;
	u16 fr_max_payload;
	u8 fr_sof;
	u8 fr_eof;
	u8 fr_flags;
	u8 fr_encaps;
	u8 granted_mac[6];
};

enum fc_disc_event {
	DISC_EV_NONE = 0,
	DISC_EV_SUCCESS = 1,
	DISC_EV_FAILED = 2,
};

struct fc_disc {
	unsigned char retry_count;
	unsigned char pending;
	unsigned char requested;
	short unsigned int seq_count;
	unsigned char buf_len;
	u16 disc_id;
	struct list_head rports;
	void *priv;
	struct mutex disc_mutex;
	struct fc_gpn_ft_resp partial_buf;
	struct delayed_work disc_work;
	void (*disc_callback)(struct fc_lport *, enum fc_disc_event);
};

enum fc_rport_event {
	RPORT_EV_NONE = 0,
	RPORT_EV_READY = 1,
	RPORT_EV_FAILED = 2,
	RPORT_EV_STOP = 3,
	RPORT_EV_LOGO = 4,
};

struct fc_rport_priv;

struct libfc_function_template {
	int (*frame_send)(struct fc_lport *, struct fc_frame *);
	struct fc_seq * (*elsct_send)(struct fc_lport *, u32, struct fc_frame *, unsigned int, void (*)(struct fc_seq *, struct fc_frame *, void *), void *, u32);
	int (*ddp_setup)(struct fc_lport *, u16, struct scatterlist *, unsigned int);
	int (*ddp_done)(struct fc_lport *, u16);
	int (*ddp_target)(struct fc_lport *, u16, struct scatterlist *, unsigned int);
	void (*get_lesb)(struct fc_lport *, struct fc_els_lesb *);
	void (*exch_mgr_reset)(struct fc_lport *, u32, u32);
	void (*lport_set_port_id)(struct fc_lport *, u32, struct fc_frame *);
	void (*rport_event_callback)(struct fc_lport *, struct fc_rport_priv *, enum fc_rport_event);
	int (*fcp_cmd_send)(struct fc_lport *, struct fc_fcp_pkt *, void (*)(struct fc_seq *, struct fc_frame *, void *));
	void (*fcp_cleanup)(struct fc_lport *);
	void (*fcp_abort_io)(struct fc_lport *);
	void (*disc_recv_req)(struct fc_lport *, struct fc_frame *);
	void (*disc_start)(void (*)(struct fc_lport *, enum fc_disc_event), struct fc_lport *);
	void (*disc_stop)(struct fc_lport *);
	void (*disc_stop_final)(struct fc_lport *);
};

enum fc_lport_state {
	LPORT_ST_DISABLED = 0,
	LPORT_ST_FLOGI = 1,
	LPORT_ST_DNS = 2,
	LPORT_ST_RNN_ID = 3,
	LPORT_ST_RSNN_NN = 4,
	LPORT_ST_RSPN_ID = 5,
	LPORT_ST_RFT_ID = 6,
	LPORT_ST_RFF_ID = 7,
	LPORT_ST_FDMI = 8,
	LPORT_ST_RHBA = 9,
	LPORT_ST_RPA = 10,
	LPORT_ST_DHBA = 11,
	LPORT_ST_DPRT = 12,
	LPORT_ST_SCR = 13,
	LPORT_ST_READY = 14,
	LPORT_ST_LOGO = 15,
	LPORT_ST_RESET = 16,
};

struct fc_stats;

struct fc_lport {
	struct Scsi_Host *host;
	struct list_head ema_list;
	struct fc_rport_priv *dns_rdata;
	struct fc_rport_priv *ms_rdata;
	struct fc_rport_priv *ptp_rdata;
	void *scsi_priv;
	struct fc_disc disc;
	struct list_head vports;
	struct fc_vport *vport;
	struct libfc_function_template tt;
	u8 link_up;
	u8 qfull;
	u16 vlan;
	enum fc_lport_state state;
	long unsigned int boot_time;
	struct fc_host_statistics host_stats;
	struct fc_stats *stats;
	u8 retry_count;
	u32 port_id;
	u64 wwpn;
	u64 wwnn;
	unsigned int service_params;
	unsigned int e_d_tov;
	unsigned int r_a_tov;
	struct fc_els_rnid_gen rnid_gen;
	u32 sg_supp: 1;
	u32 seq_offload: 1;
	u32 crc_offload: 1;
	u32 lro_enabled: 1;
	u32 does_npiv: 1;
	u32 npiv_enabled: 1;
	u32 point_to_multipoint: 1;
	u32 fdmi_enabled: 1;
	u32 mfs;
	u8 max_retry_count;
	u8 max_rport_retry_count;
	u16 rport_priv_size;
	u16 link_speed;
	u16 link_supported_speeds;
	u16 lro_xid;
	unsigned int lso_max;
	struct fc_ns_fts fcts;
	struct mutex lp_mutex;
	struct list_head list;
	struct delayed_work retry_work;
	void *prov[9];
	struct list_head lport_list;
};

struct fc_seq {
	u8 id;
	u16 ssb_stat;
	u16 cnt;
	u32 rec_data;
};

struct fc_fcp_pkt {
	spinlock_t scsi_pkt_lock;
	refcount_t ref_cnt;
	u32 data_len;
	struct scsi_cmnd *cmd;
	struct list_head list;
	struct fc_lport *lp;
	u8 state;
	u8 cdb_status;
	u8 status_code;
	u8 scsi_comp_flags;
	u32 io_status;
	u32 req_flags;
	u32 scsi_resid;
	size_t xfer_len;
	struct fcp_cmnd cdb_cmd;
	u32 xfer_contig_end;
	u16 max_payload;
	u16 xfer_ddp;
	struct fc_rport *rport;
	struct fc_seq *seq_ptr;
	struct timer_list timer;
	int wait_for_comp;
	int timer_delay;
	u32 recov_retry;
	struct fc_seq *recov_seq;
	struct completion tm_done;
	long: 64;
};

enum fc_rport_state {
	RPORT_ST_INIT = 0,
	RPORT_ST_FLOGI = 1,
	RPORT_ST_PLOGI_WAIT = 2,
	RPORT_ST_PLOGI = 3,
	RPORT_ST_PRLI = 4,
	RPORT_ST_RTV = 5,
	RPORT_ST_READY = 6,
	RPORT_ST_ADISC = 7,
	RPORT_ST_DELETE = 8,
};

struct fc_rport_operations {
	void (*event_callback)(struct fc_lport *, struct fc_rport_priv *, enum fc_rport_event);
};

struct fc_rport_priv {
	struct fc_lport *local_port;
	struct fc_rport *rport;
	struct kref kref;
	enum fc_rport_state rp_state;
	struct fc_rport_identifiers ids;
	u16 flags;
	u16 max_seq;
	u16 disc_id;
	u16 maxframe_size;
	unsigned int retries;
	unsigned int major_retries;
	unsigned int e_d_tov;
	unsigned int r_a_tov;
	struct mutex rp_mutex;
	struct delayed_work retry_work;
	enum fc_rport_event event;
	struct fc_rport_operations *ops;
	struct list_head peers;
	struct work_struct event_work;
	u32 supported_classes;
	u16 prli_count;
	struct callback_head rcu;
	u16 sp_features;
	u8 spp_type;
	void (*lld_event_callback)(struct fc_lport *, struct fc_rport_priv *, enum fc_rport_event);
};

struct fc_stats {
	u64 SecondsSinceLastReset;
	u64 TxFrames;
	u64 TxWords;
	u64 RxFrames;
	u64 RxWords;
	u64 ErrorFrames;
	u64 DumpedFrames;
	u64 FcpPktAllocFails;
	u64 FcpPktAborts;
	u64 FcpFrameAllocFails;
	u64 LinkFailureCount;
	u64 LossOfSignalCount;
	u64 InvalidTxWordCount;
	u64 InvalidCRCCount;
	u64 InputRequests;
	u64 OutputRequests;
	u64 ControlRequests;
	u64 InputBytes;
	u64 OutputBytes;
	u64 VLinkFailureCount;
	u64 MissDiscAdvCount;
};

enum fc_lport_event {
	FC_LPORT_EV_ADD = 0,
	FC_LPORT_EV_DEL = 1,
};

struct fc4_prov {
	int (*prli)(struct fc_rport_priv *, u32, const struct fc_els_spp *, struct fc_els_spp *);
	void (*prlo)(struct fc_rport_priv *);
	void (*recv)(struct fc_lport *, struct fc_frame *);
	struct module *module;
};

struct fc_ct_hdr {
	__u8 ct_rev;
	__u8 ct_in_id[3];
	__u8 ct_fs_type;
	__u8 ct_fs_subtype;
	__u8 ct_options;
	__u8 _ct_resvd1;
	__be16 ct_cmd;
	__be16 ct_mr_size;
	__u8 _ct_resvd2;
	__u8 ct_reason;
	__u8 ct_explan;
	__u8 ct_vendor;
};

enum fc_ct_cmd {
	FC_FS_RJT = 32769,
	FC_FS_ACC = 32770,
};

enum fc_ct_reason {
	FC_FS_RJT_CMD = 1,
	FC_FS_RJT_VER = 2,
	FC_FS_RJT_LOG = 3,
	FC_FS_RJT_IUSIZ = 4,
	FC_FS_RJT_BSY = 5,
	FC_FS_RJT_PROTO = 7,
	FC_FS_RJT_UNABL = 9,
	FC_FS_RJT_UNSUP = 11,
};

enum fc_ct_explan {
	FC_FS_EXP_NONE = 0,
	FC_FS_EXP_PID = 1,
	FC_FS_EXP_PNAM = 2,
	FC_FS_EXP_NNAM = 3,
	FC_FS_EXP_COS = 4,
	FC_FS_EXP_FTNR = 7,
};

enum fc_ns_req {
	FC_NS_GA_NXT = 256,
	FC_NS_GI_A = 257,
	FC_NS_GPN_ID = 274,
	FC_NS_GNN_ID = 275,
	FC_NS_GSPN_ID = 280,
	FC_NS_GID_PN = 289,
	FC_NS_GID_NN = 305,
	FC_NS_GID_FT = 369,
	FC_NS_GPN_FT = 370,
	FC_NS_GID_PT = 417,
	FC_NS_RPN_ID = 530,
	FC_NS_RNN_ID = 531,
	FC_NS_RFT_ID = 535,
	FC_NS_RSPN_ID = 536,
	FC_NS_RFF_ID = 543,
	FC_NS_RSNN_NN = 569,
};

struct fc_ns_gid_pn {
	__be64 fn_wwpn;
};

enum fc_els_cmd {
	ELS_LS_RJT = 1,
	ELS_LS_ACC = 2,
	ELS_PLOGI = 3,
	ELS_FLOGI = 4,
	ELS_LOGO = 5,
	ELS_ABTX = 6,
	ELS_RCS = 7,
	ELS_RES = 8,
	ELS_RSS = 9,
	ELS_RSI = 10,
	ELS_ESTS = 11,
	ELS_ESTC = 12,
	ELS_ADVC = 13,
	ELS_RTV = 14,
	ELS_RLS = 15,
	ELS_ECHO = 16,
	ELS_TEST = 17,
	ELS_RRQ = 18,
	ELS_REC = 19,
	ELS_SRR = 20,
	ELS_FPIN = 22,
	ELS_PRLI = 32,
	ELS_PRLO = 33,
	ELS_SCN = 34,
	ELS_TPLS = 35,
	ELS_TPRLO = 36,
	ELS_LCLM = 37,
	ELS_GAID = 48,
	ELS_FACT = 49,
	ELS_FDACDT = 50,
	ELS_NACT = 51,
	ELS_NDACT = 52,
	ELS_QOSR = 64,
	ELS_RVCS = 65,
	ELS_PDISC = 80,
	ELS_FDISC = 81,
	ELS_ADISC = 82,
	ELS_RNC = 83,
	ELS_FARP_REQ = 84,
	ELS_FARP_REPL = 85,
	ELS_RPS = 86,
	ELS_RPL = 87,
	ELS_RPBC = 88,
	ELS_FAN = 96,
	ELS_RSCN = 97,
	ELS_SCR = 98,
	ELS_RNFT = 99,
	ELS_CSR = 104,
	ELS_CSU = 105,
	ELS_LINIT = 112,
	ELS_LSTS = 114,
	ELS_RNID = 120,
	ELS_RLIR = 121,
	ELS_LIRR = 122,
	ELS_SRL = 123,
	ELS_SBRP = 124,
	ELS_RPSC = 125,
	ELS_QSA = 126,
	ELS_EVFP = 127,
	ELS_LKA = 128,
	ELS_AUTH_ELS = 144,
};

enum fc_els_rjt_reason {
	ELS_RJT_NONE = 0,
	ELS_RJT_INVAL = 1,
	ELS_RJT_LOGIC = 3,
	ELS_RJT_BUSY = 5,
	ELS_RJT_PROT = 7,
	ELS_RJT_UNAB = 9,
	ELS_RJT_UNSUP = 11,
	ELS_RJT_INPROG = 14,
	ELS_RJT_FIP = 32,
	ELS_RJT_VENDOR = 255,
};

enum fc_els_rjt_explan {
	ELS_EXPL_NONE = 0,
	ELS_EXPL_SPP_OPT_ERR = 1,
	ELS_EXPL_SPP_ICTL_ERR = 3,
	ELS_EXPL_AH = 17,
	ELS_EXPL_AH_REQ = 19,
	ELS_EXPL_SID = 21,
	ELS_EXPL_OXID_RXID = 23,
	ELS_EXPL_INPROG = 25,
	ELS_EXPL_PLOGI_REQD = 30,
	ELS_EXPL_INSUF_RES = 41,
	ELS_EXPL_UNAB_DATA = 42,
	ELS_EXPL_UNSUPR = 44,
	ELS_EXPL_INV_LEN = 45,
	ELS_EXPL_NOT_NEIGHBOR = 98,
};

struct fc_els_rscn {
	__u8 rscn_cmd;
	__u8 rscn_page_len;
	__be16 rscn_plen;
};

struct fc_els_rscn_page {
	__u8 rscn_page_flags;
	__u8 rscn_fid[3];
};

enum fc_els_rscn_ev_qual {
	ELS_EV_QUAL_NONE = 0,
	ELS_EV_QUAL_NS_OBJ = 1,
	ELS_EV_QUAL_PORT_ATTR = 2,
	ELS_EV_QUAL_SERV_OBJ = 3,
	ELS_EV_QUAL_SW_CONFIG = 4,
	ELS_EV_QUAL_REM_OBJ = 5,
};

enum fc_els_rscn_addr_fmt {
	ELS_ADDR_FMT_PORT = 0,
	ELS_ADDR_FMT_AREA = 1,
	ELS_ADDR_FMT_DOM = 2,
	ELS_ADDR_FMT_FAB = 3,
};

struct fc_disc_port {
	struct fc_lport *lp;
	struct list_head peers;
	struct work_struct rport_work;
	u32 port_id;
};

struct fc_seq_els_data {
	enum fc_els_rjt_reason reason;
	enum fc_els_rjt_explan explan;
};

struct fc_els_ls_acc {
	__u8 la_cmd;
	__u8 la_resv[3];
};

struct fc_els_ls_rjt {
	__u8 er_cmd;
	__u8 er_resv[4];
	__u8 er_reason;
	__u8 er_explan;
	__u8 er_vendor;
};

struct fc_els_rrq {
	__u8 rrq_cmd;
	__u8 rrq_zero[3];
	__u8 rrq_resvd;
	__u8 rrq_s_id[3];
	__be16 rrq_ox_id;
	__be16 rrq_rx_id;
};

struct fc_els_rec {
	__u8 rec_cmd;
	__u8 rec_zero[3];
	__u8 rec_resvd;
	__u8 rec_s_id[3];
	__be16 rec_ox_id;
	__be16 rec_rx_id;
};

struct fc_els_rec_acc {
	__u8 reca_cmd;
	__u8 reca_zero[3];
	__be16 reca_ox_id;
	__be16 reca_rx_id;
	__u8 reca_resvd1;
	__u8 reca_ofid[3];
	__u8 reca_resvd2;
	__u8 reca_rfid[3];
	__be32 reca_fc4value;
	__be32 reca_e_stat;
};

enum fc_well_known_fid {
	FC_FID_NONE = 0,
	FC_FID_BCAST = 16777215,
	FC_FID_FLOGI = 16777214,
	FC_FID_FCTRL = 16777213,
	FC_FID_DIR_SERV = 16777212,
	FC_FID_TIME_SERV = 16777211,
	FC_FID_MGMT_SERV = 16777210,
	FC_FID_QOS = 16777209,
	FC_FID_ALIASES = 16777208,
	FC_FID_SEC_KEY = 16777207,
	FC_FID_CLOCK = 16777206,
	FC_FID_MCAST_SERV = 16777205,
};

struct fc_ba_acc {
	__u8 ba_seq_id_val;
	__u8 ba_seq_id;
	__u8 ba_resvd[2];
	__be16 ba_ox_id;
	__be16 ba_rx_id;
	__be16 ba_low_seq_cnt;
	__be16 ba_high_seq_cnt;
};

struct fc_ba_rjt {
	__u8 br_resvd;
	__u8 br_reason;
	__u8 br_explan;
	__u8 br_vendor;
};

enum fc_ba_rjt_reason {
	FC_BA_RJT_NONE = 0,
	FC_BA_RJT_INVL_CMD = 1,
	FC_BA_RJT_LOG_ERR = 3,
	FC_BA_RJT_LOG_BUSY = 5,
	FC_BA_RJT_PROTO_ERR = 7,
	FC_BA_RJT_UNABLE = 9,
	FC_BA_RJT_VENDOR = 255,
};

enum fc_ba_rjt_explan {
	FC_BA_RJT_EXP_NONE = 0,
	FC_BA_RJT_INV_XID = 3,
	FC_BA_RJT_ABT = 5,
};

enum fc_pf_rjt_reason {
	FC_RJT_NONE = 0,
	FC_RJT_INVL_DID = 1,
	FC_RJT_INVL_SID = 2,
	FC_RJT_P_UNAV_T = 3,
	FC_RJT_P_UNAV = 4,
	FC_RJT_CLS_UNSUP = 5,
	FC_RJT_DEL_USAGE = 6,
	FC_RJT_TYPE_UNSUP = 7,
	FC_RJT_LINK_CTL = 8,
	FC_RJT_R_CTL = 9,
	FC_RJT_F_CTL = 10,
	FC_RJT_OX_ID = 11,
	FC_RJT_RX_ID = 12,
	FC_RJT_SEQ_ID = 13,
	FC_RJT_DF_CTL = 14,
	FC_RJT_SEQ_CNT = 15,
	FC_RJT_PARAM = 16,
	FC_RJT_EXCH_ERR = 17,
	FC_RJT_PROTO = 18,
	FC_RJT_LEN = 19,
	FC_RJT_UNEXP_ACK = 20,
	FC_RJT_FAB_CLASS = 21,
	FC_RJT_LOGI_REQ = 22,
	FC_RJT_SEQ_XS = 23,
	FC_RJT_EXCH_EST = 24,
	FC_RJT_FAB_UNAV = 26,
	FC_RJT_VC_ID = 27,
	FC_RJT_CS_CTL = 28,
	FC_RJT_INSUF_RES = 29,
	FC_RJT_INVL_CLS = 31,
	FC_RJT_PREEMT_RJT = 32,
	FC_RJT_PREEMT_DIS = 33,
	FC_RJT_MCAST_ERR = 34,
	FC_RJT_MCAST_ET = 35,
	FC_RJT_PRLI_REQ = 36,
	FC_RJT_INVL_ATT = 37,
	FC_RJT_VENDOR = 255,
};

enum fc_class {
	FC_CLASS_NONE = 0,
	FC_CLASS_2 = 45,
	FC_CLASS_3 = 46,
	FC_CLASS_4 = 41,
	FC_CLASS_F = 40,
};

struct fc_exch_mgr;

struct fc_exch_pool;

struct fc_exch {
	spinlock_t ex_lock;
	atomic_t ex_refcnt;
	enum fc_class class;
	struct fc_exch_mgr *em;
	struct fc_exch_pool *pool;
	struct list_head ex_list;
	struct fc_lport *lp;
	u32 esb_stat;
	u8 state;
	u8 fh_type;
	u8 seq_id;
	u8 encaps;
	u16 xid;
	u16 oxid;
	u16 rxid;
	u32 oid;
	u32 sid;
	u32 did;
	u32 r_a_tov;
	u32 f_ctl;
	struct fc_seq seq;
	int resp_active;
	struct task_struct *resp_task;
	wait_queue_head_t resp_wq;
	void (*resp)(struct fc_seq *, struct fc_frame *, void *);
	void *arg;
	void (*destructor)(struct fc_seq *, void *);
	struct delayed_work timeout_work;
	long: 64;
	long: 64;
};

struct fc_exch_mgr {
	struct fc_exch_pool *pool;
	mempool_t *ep_pool;
	struct fc_lport *lport;
	enum fc_class class;
	struct kref kref;
	u16 min_xid;
	u16 max_xid;
	u16 pool_max_index;
	struct {
		atomic_t no_free_exch;
		atomic_t no_free_exch_xid;
		atomic_t xid_not_found;
		atomic_t xid_busy;
		atomic_t seq_not_found;
		atomic_t non_bls_resp;
	} stats;
};

struct fc_exch_pool {
	spinlock_t lock;
	struct list_head ex_list;
	u16 next_index;
	u16 total_exches;
	u16 left;
	u16 right;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct fc_exch_mgr_anchor {
	struct list_head ema_list;
	struct fc_exch_mgr *mp;
	bool (*match)(struct fc_frame *);
};

enum fc_ct_rev {
	FC_CT_REV = 1,
};

enum fc_ct_fs_type {
	FC_FST_ALIAS = 248,
	FC_FST_MGMT = 250,
	FC_FST_TIME = 251,
	FC_FST_DIR = 252,
};

struct fc_ns_fid {
	__u8 fp_flags;
	__u8 fp_fid[3];
};

struct fc_ns_gid_ft {
	__u8 fn_resvd;
	__u8 fn_domain_id_scope;
	__u8 fn_area_id_scope;
	__u8 fn_fc4_type;
};

struct fc_ns_rn_id {
	struct fc_ns_fid fr_fid;
	__be64 fr_wwn;
} __attribute__((packed));

struct fc_ns_rsnn {
	__be64 fr_wwn;
	__u8 fr_name_len;
	char fr_name[0];
} __attribute__((packed));

struct fc_ns_rspn {
	struct fc_ns_fid fr_fid;
	__u8 fr_name_len;
	char fr_name[0];
};

struct fc_ns_rff_id {
	struct fc_ns_fid fr_fid;
	__u8 fr_resvd[2];
	__u8 fr_feat;
	__u8 fr_type;
};

struct fc_els_csp {
	__u8 sp_hi_ver;
	__u8 sp_lo_ver;
	__be16 sp_bb_cred;
	__be16 sp_features;
	__be16 sp_bb_data;
	union {
		struct {
			__be16 _sp_tot_seq;
			__be16 _sp_rel_off;
		} sp_plogi;
		struct {
			__be32 _sp_r_a_tov;
		} sp_flogi_acc;
	} sp_u;
	__be32 sp_e_d_tov;
};

struct fc_els_cssp {
	__be16 cp_class;
	__be16 cp_init;
	__be16 cp_recip;
	__be16 cp_rdfs;
	__be16 cp_con_seq;
	__be16 cp_ee_cred;
	__u8 cp_resv1;
	__u8 cp_open_seq;
	__u8 _cp_resv2[2];
};

struct fc_els_flogi {
	__u8 fl_cmd;
	__u8 _fl_resvd[3];
	struct fc_els_csp fl_csp;
	__be64 fl_wwpn;
	__be64 fl_wwnn;
	struct fc_els_cssp fl_cssp[4];
	__u8 fl_vend[16];
} __attribute__((packed));

struct fc_els_prli {
	__u8 prli_cmd;
	__u8 prli_spp_len;
	__be16 prli_len;
};

struct fc_els_adisc {
	__u8 adisc_cmd;
	__u8 adisc_resv[3];
	__u8 adisc_resv1;
	__u8 adisc_hard_addr[3];
	__be64 adisc_wwpn;
	__be64 adisc_wwnn;
	__u8 adisc_resv2;
	__u8 adisc_port_id[3];
} __attribute__((packed));

struct fc_els_logo {
	__u8 fl_cmd;
	__u8 fl_zero[3];
	__u8 fl_resvd;
	__u8 fl_n_port_id[3];
	__be64 fl_n_port_wwn;
};

struct fc_els_rtv {
	__u8 rtv_cmd;
	__u8 rtv_zero[3];
};

struct fc_els_scr {
	__u8 scr_cmd;
	__u8 scr_resv[6];
	__u8 scr_reg_func;
};

enum fc_els_scr_func {
	ELS_SCRF_FAB = 1,
	ELS_SCRF_NPORT = 2,
	ELS_SCRF_FULL = 3,
	ELS_SCRF_CLEAR = 255,
};

enum fc_fdmi_req {
	FC_FDMI_GRHL = 256,
	FC_FDMI_GHAT = 257,
	FC_FDMI_GRPL = 258,
	FC_FDMI_GPAT = 272,
	FC_FDMI_RHBA = 512,
	FC_FDMI_RHAT = 513,
	FC_FDMI_RPRT = 528,
	FC_FDMI_RPA = 529,
	FC_FDMI_DHBA = 768,
	FC_FDMI_DHAT = 769,
	FC_FDMI_DPRT = 784,
	FC_FDMI_DPA = 785,
};

enum fc_fdmi_hba_attr_type {
	FC_FDMI_HBA_ATTR_NODENAME = 1,
	FC_FDMI_HBA_ATTR_MANUFACTURER = 2,
	FC_FDMI_HBA_ATTR_SERIALNUMBER = 3,
	FC_FDMI_HBA_ATTR_MODEL = 4,
	FC_FDMI_HBA_ATTR_MODELDESCRIPTION = 5,
	FC_FDMI_HBA_ATTR_HARDWAREVERSION = 6,
	FC_FDMI_HBA_ATTR_DRIVERVERSION = 7,
	FC_FDMI_HBA_ATTR_OPTIONROMVERSION = 8,
	FC_FDMI_HBA_ATTR_FIRMWAREVERSION = 9,
	FC_FDMI_HBA_ATTR_OSNAMEVERSION = 10,
	FC_FDMI_HBA_ATTR_MAXCTPAYLOAD = 11,
};

enum fc_fdmi_port_attr_type {
	FC_FDMI_PORT_ATTR_FC4TYPES = 1,
	FC_FDMI_PORT_ATTR_SUPPORTEDSPEED = 2,
	FC_FDMI_PORT_ATTR_CURRENTPORTSPEED = 3,
	FC_FDMI_PORT_ATTR_MAXFRAMESIZE = 4,
	FC_FDMI_PORT_ATTR_OSDEVICENAME = 5,
	FC_FDMI_PORT_ATTR_HOSTNAME = 6,
};

struct fc_fdmi_hba_identifier {
	__be64 id;
};

struct fc_fdmi_port_name {
	__be64 portname;
};

struct fc_fdmi_attr_entry {
	__be16 type;
	__be16 len;
	__u8 value[1];
} __attribute__((packed));

struct fs_fdmi_attrs {
	__be32 numattrs;
	struct fc_fdmi_attr_entry attr[1];
} __attribute__((packed));

struct fc_fdmi_rpl {
	__be32 numport;
	struct fc_fdmi_port_name port[1];
} __attribute__((packed));

struct fc_fdmi_rhba {
	struct fc_fdmi_hba_identifier hbaid;
	struct fc_fdmi_rpl port;
	struct fs_fdmi_attrs hba_attrs;
} __attribute__((packed));

struct fc_fdmi_rpa {
	struct fc_fdmi_port_name port;
	struct fs_fdmi_attrs hba_attrs;
} __attribute__((packed));

struct fc_fdmi_dprt {
	struct fc_fdmi_port_name port;
};

struct fc_fdmi_dhba {
	struct fc_fdmi_hba_identifier hbaid;
};

struct fc_ns_rft {
	struct fc_ns_fid fid;
	struct fc_ns_fts fts;
};

struct fc_ct_req {
	struct fc_ct_hdr hdr;
	union {
		struct fc_ns_gid_ft gid;
		struct fc_ns_rn_id rn;
		struct fc_ns_rft rft;
		struct fc_ns_rff_id rff;
		struct fc_ns_fid fid;
		struct fc_ns_rsnn snn;
		struct fc_ns_rspn spn;
		struct fc_fdmi_rhba rhba;
		struct fc_fdmi_rpa rpa;
		struct fc_fdmi_dprt dprt;
		struct fc_fdmi_dhba dhba;
	} payload;
} __attribute__((packed));

enum fc_els_spp_resp {
	FC_SPP_RESP_ACK = 1,
	FC_SPP_RESP_RES = 2,
	FC_SPP_RESP_INIT = 3,
	FC_SPP_RESP_NO_PA = 4,
	FC_SPP_RESP_CONF = 5,
	FC_SPP_RESP_COND = 6,
	FC_SPP_RESP_MULT = 7,
	FC_SPP_RESP_INVL = 8,
};

struct fc_els_rnid {
	__u8 rnid_cmd;
	__u8 rnid_resv[3];
	__u8 rnid_fmt;
	__u8 rnid_resv2[3];
};

enum fc_els_rnid_fmt {
	ELS_RNIDF_NONE = 0,
	ELS_RNIDF_GEN = 223,
};

struct fc_els_rnid_resp {
	__u8 rnid_cmd;
	__u8 rnid_resv[3];
	__u8 rnid_fmt;
	__u8 rnid_cid_len;
	__u8 rnid_resv2;
	__u8 rnid_sid_len;
};

struct fc_els_rnid_cid {
	__be64 rnid_wwpn;
	__be64 rnid_wwnn;
};

struct fc_bsg_info {
	struct bsg_job *job;
	struct fc_lport *lport;
	u16 rsp_code;
	struct scatterlist *sg;
	u32 nents;
	size_t offset;
};

struct fc_els_prlo {
	__u8 prlo_cmd;
	__u8 prlo_obs;
	__be16 prlo_len;
};

struct fc_els_rtv_acc {
	__u8 rtv_cmd;
	__u8 rtv_zero[3];
	__be32 rtv_r_a_tov;
	__be32 rtv_e_d_tov;
	__be32 rtv_toq;
};

struct fc_els_rls {
	__u8 rls_cmd;
	__u8 rls_resv[4];
	__u8 rls_port_id[3];
};

struct fc_els_rls_resp {
	__u8 rls_cmd;
	__u8 rls_resv[3];
	struct fc_els_lesb rls_lesb;
};

struct fc_rport_libfc_priv {
	struct fc_lport *local_port;
	enum fc_rport_state rp_state;
	u16 flags;
	unsigned int e_d_tov;
	unsigned int r_a_tov;
};

struct fcp_txrdy {
	__be32 ft_data_ro;
	__be32 ft_burst_len;
	__u8 _ft_resvd[4];
};

struct fcp_resp {
	__u8 _fr_resvd[8];
	__be16 fr_retry_delay;
	__u8 fr_flags;
	__u8 fr_status;
};

struct fcp_resp_ext {
	__be32 fr_resid;
	__be32 fr_sns_len;
	__be32 fr_rsp_len;
};

struct fcp_resp_rsp_info {
	__u8 _fr_resvd[3];
	__u8 rsp_code;
	__u8 _fr_resvd2[4];
};

enum fcp_resp_rsp_codes {
	FCP_TMF_CMPL = 0,
	FCP_DATA_LEN_INVALID = 1,
	FCP_CMND_FIELDS_INVALID = 2,
	FCP_DATA_PARAM_MISMATCH = 3,
	FCP_TMF_REJECTED = 4,
	FCP_TMF_FAILED = 5,
	FCP_TMF_INVALID_LUN = 9,
};

struct fcp_srr {
	__u8 srr_op;
	__u8 srr_resvd[3];
	__be16 srr_ox_id;
	__be16 srr_rx_id;
	__be32 srr_rel_off;
	__u8 srr_r_ctl;
	__u8 srr_resvd2[3];
};

struct fc_fcp_internal {
	mempool_t *scsi_pkt_pool;
	spinlock_t scsi_queue_lock;
	struct list_head scsi_pkt_queue;
	long unsigned int last_can_queue_ramp_down_time;
	long unsigned int last_can_queue_ramp_up_time;
	int max_can_queue;
};

struct fc_remote_port;

enum {
	IF_OPER_UNKNOWN = 0,
	IF_OPER_NOTPRESENT = 1,
	IF_OPER_DOWN = 2,
	IF_OPER_LOWERLAYERDOWN = 3,
	IF_OPER_TESTING = 4,
	IF_OPER_DORMANT = 5,
	IF_OPER_UP = 6,
};

enum {
	NETIF_F_SG_BIT = 0,
	NETIF_F_IP_CSUM_BIT = 1,
	__UNUSED_NETIF_F_1 = 2,
	NETIF_F_HW_CSUM_BIT = 3,
	NETIF_F_IPV6_CSUM_BIT = 4,
	NETIF_F_HIGHDMA_BIT = 5,
	NETIF_F_FRAGLIST_BIT = 6,
	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
	NETIF_F_VLAN_CHALLENGED_BIT = 10,
	NETIF_F_GSO_BIT = 11,
	NETIF_F_LLTX_BIT = 12,
	NETIF_F_NETNS_LOCAL_BIT = 13,
	NETIF_F_GRO_BIT = 14,
	NETIF_F_LRO_BIT = 15,
	NETIF_F_GSO_SHIFT = 16,
	NETIF_F_TSO_BIT = 16,
	NETIF_F_GSO_ROBUST_BIT = 17,
	NETIF_F_TSO_ECN_BIT = 18,
	NETIF_F_TSO_MANGLEID_BIT = 19,
	NETIF_F_TSO6_BIT = 20,
	NETIF_F_FSO_BIT = 21,
	NETIF_F_GSO_GRE_BIT = 22,
	NETIF_F_GSO_GRE_CSUM_BIT = 23,
	NETIF_F_GSO_IPXIP4_BIT = 24,
	NETIF_F_GSO_IPXIP6_BIT = 25,
	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
	NETIF_F_GSO_PARTIAL_BIT = 28,
	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
	NETIF_F_GSO_SCTP_BIT = 30,
	NETIF_F_GSO_ESP_BIT = 31,
	NETIF_F_GSO_UDP_BIT = 32,
	NETIF_F_GSO_UDP_L4_BIT = 33,
	NETIF_F_GSO_LAST = 33,
	NETIF_F_FCOE_CRC_BIT = 34,
	NETIF_F_SCTP_CRC_BIT = 35,
	NETIF_F_FCOE_MTU_BIT = 36,
	NETIF_F_NTUPLE_BIT = 37,
	NETIF_F_RXHASH_BIT = 38,
	NETIF_F_RXCSUM_BIT = 39,
	NETIF_F_NOCACHE_COPY_BIT = 40,
	NETIF_F_LOOPBACK_BIT = 41,
	NETIF_F_RXFCS_BIT = 42,
	NETIF_F_RXALL_BIT = 43,
	NETIF_F_HW_VLAN_STAG_TX_BIT = 44,
	NETIF_F_HW_VLAN_STAG_RX_BIT = 45,
	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 46,
	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 47,
	NETIF_F_HW_TC_BIT = 48,
	NETIF_F_HW_ESP_BIT = 49,
	NETIF_F_HW_ESP_TX_CSUM_BIT = 50,
	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 51,
	NETIF_F_HW_TLS_TX_BIT = 52,
	NETIF_F_HW_TLS_RX_BIT = 53,
	NETIF_F_GRO_HW_BIT = 54,
	NETIF_F_HW_TLS_RECORD_BIT = 55,
	NETDEV_FEATURE_COUNT = 56,
};

enum {
	SKB_GSO_TCPV4 = 1,
	SKB_GSO_DODGY = 2,
	SKB_GSO_TCP_ECN = 4,
	SKB_GSO_TCP_FIXEDID = 8,
	SKB_GSO_TCPV6 = 16,
	SKB_GSO_FCOE = 32,
	SKB_GSO_GRE = 64,
	SKB_GSO_GRE_CSUM = 128,
	SKB_GSO_IPXIP4 = 256,
	SKB_GSO_IPXIP6 = 512,
	SKB_GSO_UDP_TUNNEL = 1024,
	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
	SKB_GSO_PARTIAL = 4096,
	SKB_GSO_TUNNEL_REMCSUM = 8192,
	SKB_GSO_SCTP = 16384,
	SKB_GSO_ESP = 32768,
	SKB_GSO_UDP = 65536,
	SKB_GSO_UDP_L4 = 131072,
};

struct dcb_app_type {
	int ifindex;
	struct dcb_app app;
	struct list_head list;
	u8 dcbx;
};

struct netdev_hw_addr {
	struct list_head list;
	unsigned char addr[32];
	unsigned char type;
	bool global_use;
	int sync_cnt;
	int refcount;
	int synced;
	struct callback_head callback_head;
};

enum netdev_priv_flags {
	IFF_802_1Q_VLAN = 1,
	IFF_EBRIDGE = 2,
	IFF_BONDING = 4,
	IFF_ISATAP = 8,
	IFF_WAN_HDLC = 16,
	IFF_XMIT_DST_RELEASE = 32,
	IFF_DONT_BRIDGE = 64,
	IFF_DISABLE_NETPOLL = 128,
	IFF_MACVLAN_PORT = 256,
	IFF_BRIDGE_PORT = 512,
	IFF_OVS_DATAPATH = 1024,
	IFF_TX_SKB_SHARING = 2048,
	IFF_UNICAST_FLT = 4096,
	IFF_TEAM_PORT = 8192,
	IFF_SUPP_NOFCS = 16384,
	IFF_LIVE_ADDR_CHANGE = 32768,
	IFF_MACVLAN = 65536,
	IFF_XMIT_DST_RELEASE_PERM = 131072,
	IFF_L3MDEV_MASTER = 262144,
	IFF_NO_QUEUE = 524288,
	IFF_OPENVSWITCH = 1048576,
	IFF_L3MDEV_SLAVE = 2097152,
	IFF_TEAM = 4194304,
	IFF_RXFH_CONFIGURED = 8388608,
	IFF_PHONY_HEADROOM = 16777216,
	IFF_MACSEC = 33554432,
	IFF_NO_RX_HANDLER = 67108864,
	IFF_FAILOVER = 134217728,
	IFF_FAILOVER_SLAVE = 268435456,
	IFF_L3MDEV_RX_HANDLER = 536870912,
	IFF_LIVE_RENAME_OK = 1073741824,
};

struct packet_type {
	__be16 type;
	bool ignore_outgoing;
	struct net_device *dev;
	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
	bool (*id_match)(struct packet_type *, struct sock *);
	void *af_packet_priv;
	struct list_head list;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct fip_header {
	__u8 fip_ver;
	__u8 fip_resv1;
	__be16 fip_op;
	__u8 fip_resv2;
	__u8 fip_subcode;
	__be16 fip_dl_len;
	__be16 fip_flags;
};

enum fip_opcode {
	FIP_OP_DISC = 1,
	FIP_OP_LS = 2,
	FIP_OP_CTRL = 3,
	FIP_OP_VLAN = 4,
	FIP_OP_VN2VN = 5,
	FIP_OP_VENDOR_MIN = 65528,
	FIP_OP_VENDOR_MAX = 65534,
};

struct fcoe_hdr {
	__u8 fcoe_ver;
	__u8 fcoe_resvd[12];
	__u8 fcoe_sof;
};

struct fcoe_crc_eof {
	__le32 fcoe_crc32;
	__u8 fcoe_eof;
	__u8 fcoe_resvd[3];
};

struct fcoe_fc_els_lesb {
	__be32 lesb_link_fail;
	__be32 lesb_vlink_fail;
	__be32 lesb_miss_fka;
	__be32 lesb_symb_err;
	__be32 lesb_err_block;
	__be32 lesb_fcs_error;
};

struct fcoe_ctlr_device;

struct fcoe_fcf_device;

struct fcoe_sysfs_function_template {
	void (*get_fcoe_ctlr_link_fail)(struct fcoe_ctlr_device *);
	void (*get_fcoe_ctlr_vlink_fail)(struct fcoe_ctlr_device *);
	void (*get_fcoe_ctlr_miss_fka)(struct fcoe_ctlr_device *);
	void (*get_fcoe_ctlr_symb_err)(struct fcoe_ctlr_device *);
	void (*get_fcoe_ctlr_err_block)(struct fcoe_ctlr_device *);
	void (*get_fcoe_ctlr_fcs_error)(struct fcoe_ctlr_device *);
	void (*set_fcoe_ctlr_mode)(struct fcoe_ctlr_device *);
	int (*set_fcoe_ctlr_enabled)(struct fcoe_ctlr_device *);
	void (*get_fcoe_fcf_selected)(struct fcoe_fcf_device *);
	void (*get_fcoe_fcf_vlan_id)(struct fcoe_fcf_device *);
};

enum fip_conn_type {
	FIP_CONN_TYPE_UNKNOWN = 0,
	FIP_CONN_TYPE_FABRIC = 1,
	FIP_CONN_TYPE_VN2VN = 2,
};

enum ctlr_enabled_state {
	FCOE_CTLR_ENABLED = 0,
	FCOE_CTLR_DISABLED = 1,
	FCOE_CTLR_UNUSED = 2,
};

struct fcoe_ctlr_device {
	u32 id;
	struct device dev;
	struct fcoe_sysfs_function_template *f;
	struct list_head fcfs;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	char devloss_work_q_name[20];
	struct workqueue_struct *devloss_work_q;
	struct mutex lock;
	int fcf_dev_loss_tmo;
	enum fip_conn_type mode;
	enum ctlr_enabled_state enabled;
	struct fcoe_fc_els_lesb lesb;
};

enum fcf_state {
	FCOE_FCF_STATE_UNKNOWN = 0,
	FCOE_FCF_STATE_DISCONNECTED = 1,
	FCOE_FCF_STATE_CONNECTED = 2,
	FCOE_FCF_STATE_DELETED = 3,
};

struct fcoe_fcf_device {
	u32 id;
	struct device dev;
	struct list_head peers;
	struct work_struct delete_work;
	struct delayed_work dev_loss_work;
	u32 dev_loss_tmo;
	void *priv;
	enum fcf_state state;
	u64 fabric_name;
	u64 switch_name;
	u32 fc_map;
	u16 vfid;
	u8 mac[6];
	u8 priority;
	u32 fka_period;
	u8 selected;
	u16 vlan_id;
};

enum fip_state {
	FIP_ST_DISABLED = 0,
	FIP_ST_LINK_WAIT = 1,
	FIP_ST_AUTO = 2,
	FIP_ST_NON_FIP = 3,
	FIP_ST_ENABLED = 4,
	FIP_ST_VNMP_START = 5,
	FIP_ST_VNMP_PROBE1 = 6,
	FIP_ST_VNMP_PROBE2 = 7,
	FIP_ST_VNMP_CLAIM = 8,
	FIP_ST_VNMP_UP = 9,
};

enum fip_mode {
	FIP_MODE_AUTO = 0,
	FIP_MODE_NON_FIP = 1,
	FIP_MODE_FABRIC = 2,
	FIP_MODE_VN2VN = 3,
};

struct fcoe_fcf;

struct fcoe_ctlr {
	enum fip_state state;
	enum fip_mode mode;
	struct fc_lport *lp;
	struct fcoe_fcf *sel_fcf;
	struct list_head fcfs;
	struct fcoe_ctlr_device *cdev;
	u16 fcf_count;
	long unsigned int sol_time;
	long unsigned int sel_time;
	long unsigned int port_ka_time;
	long unsigned int ctlr_ka_time;
	struct timer_list timer;
	struct work_struct timer_work;
	struct work_struct recv_work;
	struct sk_buff_head fip_recv_list;
	struct sk_buff *flogi_req;
	struct rnd_state rnd_state;
	u32 port_id;
	u16 user_mfs;
	u16 flogi_oxid;
	u8 flogi_req_send;
	u8 flogi_count;
	bool map_dest;
	bool fip_resp;
	u8 spma;
	u8 probe_tries;
	u8 priority;
	u8 dest_addr[6];
	u8 ctl_src_addr[6];
	void (*send)(struct fcoe_ctlr *, struct sk_buff *);
	void (*update_mac)(struct fc_lport *, u8 *);
	u8 * (*get_src_addr)(struct fc_lport *);
	struct mutex ctlr_mutex;
	spinlock_t ctlr_lock;
};

struct fcoe_fcf {
	struct list_head list;
	struct work_struct event_work;
	struct fcoe_ctlr *fip;
	struct fcoe_fcf_device *fcf_dev;
	long unsigned int time;
	u64 switch_name;
	u64 fabric_name;
	u32 fc_map;
	u16 vfid;
	u8 fcf_mac[6];
	u8 fcoe_mac[6];
	u8 pri;
	u8 flogi_sent;
	u16 flags;
	u32 fka_period;
	u8 fd_flags: 1;
};

struct fcoe_transport {
	char name[16];
	bool attached;
	struct list_head list;
	bool (*match)(struct net_device *);
	int (*alloc)(struct net_device *);
	int (*create)(struct net_device *, enum fip_mode);
	int (*destroy)(struct net_device *);
	int (*enable)(struct net_device *);
	int (*disable)(struct net_device *);
};

struct fcoe_percpu_s {
	struct task_struct *kthread;
	struct work_struct work;
	struct sk_buff_head fcoe_rx_list;
	struct page *crc_eof_page;
	int crc_eof_offset;
};

struct fcoe_port {
	void *priv;
	struct fc_lport *lport;
	struct sk_buff_head fcoe_pending_queue;
	u8 fcoe_pending_queue_active;
	u32 max_queue_depth;
	u32 min_queue_depth;
	struct timer_list timer;
	struct work_struct destroy_work;
	u8 data_src_addr[6];
	struct net_device * (*get_netdev)(const struct fc_lport *);
};

struct fcoe_interface {
	struct list_head list;
	struct net_device *netdev;
	struct net_device *realdev;
	struct packet_type fcoe_packet_type;
	struct packet_type fip_packet_type;
	struct packet_type fip_vlan_packet_type;
	struct fc_exch_mgr *oem;
	u8 removed;
	u8 priority;
};

enum fcoe_create_link_state {
	FCOE_CREATE_LINK_DOWN = 0,
	FCOE_CREATE_LINK_UP = 1,
};

struct fc_exch_mgr_anchor;

struct fip_frame {
	struct ethhdr eth;
	struct fip_header fip;
};

struct fc_ns_ff {
	__be32 fd_feat[32];
};

enum fip_disc_subcode {
	FIP_SC_SOL = 1,
	FIP_SC_ADV = 2,
};

enum fip_trans_subcode {
	FIP_SC_REQ = 1,
	FIP_SC_REP = 2,
};

enum fip_reset_subcode {
	FIP_SC_KEEP_ALIVE = 1,
	FIP_SC_CLR_VLINK = 2,
};

enum fip_vlan_subcode {
	FIP_SC_VL_REQ = 1,
	FIP_SC_VL_NOTE = 2,
	FIP_SC_VL_VN2VN_NOTE = 3,
};

enum fip_vn2vn_subcode {
	FIP_SC_VN_PROBE_REQ = 1,
	FIP_SC_VN_PROBE_REP = 2,
	FIP_SC_VN_CLAIM_NOTIFY = 3,
	FIP_SC_VN_CLAIM_REP = 4,
	FIP_SC_VN_BEACON = 5,
};

enum fip_flag {
	FIP_FL_FPMA = 32768,
	FIP_FL_SPMA = 16384,
	FIP_FL_FCF = 32,
	FIP_FL_FDF = 16,
	FIP_FL_REC_OR_P2P = 8,
	FIP_FL_AVAIL = 4,
	FIP_FL_SOL = 2,
	FIP_FL_FPORT = 1,
};

struct fip_desc {
	__u8 fip_dtype;
	__u8 fip_dlen;
};

enum fip_desc_type {
	FIP_DT_PRI = 1,
	FIP_DT_MAC = 2,
	FIP_DT_MAP_OUI = 3,
	FIP_DT_NAME = 4,
	FIP_DT_FAB = 5,
	FIP_DT_FCOE_SIZE = 6,
	FIP_DT_FLOGI = 7,
	FIP_DT_FDISC = 8,
	FIP_DT_LOGO = 9,
	FIP_DT_ELP = 10,
	FIP_DT_VN_ID = 11,
	FIP_DT_FKA = 12,
	FIP_DT_VENDOR = 13,
	FIP_DT_VLAN = 14,
	FIP_DT_FC4F = 15,
	FIP_DT_LIMIT = 16,
	FIP_DT_NON_CRITICAL = 128,
	FIP_DT_CLR_VLINKS = 128,
	FIP_DT_VENDOR_BASE = 241,
};

struct fip_pri_desc {
	struct fip_desc fd_desc;
	__u8 fd_resvd;
	__u8 fd_pri;
};

struct fip_mac_desc {
	struct fip_desc fd_desc;
	__u8 fd_mac[6];
};

struct fip_wwn_desc {
	struct fip_desc fd_desc;
	__u8 fd_resvd[2];
	__be64 fd_wwn;
} __attribute__((packed));

struct fip_fab_desc {
	struct fip_desc fd_desc;
	__be16 fd_vfid;
	__u8 fd_resvd;
	__u8 fd_map[3];
	__be64 fd_wwn;
};

struct fip_size_desc {
	struct fip_desc fd_desc;
	__be16 fd_size;
};

struct fip_encaps {
	struct fip_desc fd_desc;
	__u8 fd_resvd[2];
};

struct fip_vn_desc {
	struct fip_desc fd_desc;
	__u8 fd_mac[6];
	__u8 fd_resvd;
	__u8 fd_fc_id[3];
	__be64 fd_wwpn;
} __attribute__((packed));

struct fip_fka_desc {
	struct fip_desc fd_desc;
	__u8 fd_resvd;
	__u8 fd_flags;
	__be32 fd_fka_period;
};

enum fip_fka_flags {
	FIP_FKA_ADV_D = 1,
};

struct fip_vlan_desc {
	struct fip_desc fd_desc;
	__be16 fd_vlan;
};

struct fip_fc4_feat {
	struct fip_desc fd_desc;
	__u8 fd_resvd[2];
	struct fc_ns_fts fd_fts;
	struct fc_ns_ff fd_ff;
};

struct fcoe_rport {
	struct fc_rport_priv rdata;
	long unsigned int time;
	u16 fcoe_len;
	u16 flags;
	u8 login_count;
	u8 enode_mac[6];
	u8 vn_mac[6];
};

struct fip_vlan_notify_frame {
	struct ethhdr eth;
	struct fip_header fip;
	struct fip_mac_desc mac;
	struct fip_vlan_desc vlan;
};

struct fip_vn2vn_probe_frame {
	struct ethhdr eth;
	struct fip_header fip;
	struct fip_mac_desc mac;
	struct fip_wwn_desc wwnn;
	struct fip_vn_desc vn;
} __attribute__((packed));

struct fip_encaps_head {
	struct ethhdr eth;
	struct fip_header fip;
	struct fip_encaps encaps;
};

struct fip_kal {
	struct ethhdr eth;
	struct fip_header fip;
	struct fip_mac_desc mac;
};

struct fip_sol {
	struct ethhdr eth;
	struct fip_header fip;
	struct {
		struct fip_mac_desc mac;
		struct fip_wwn_desc wwnn;
		struct fip_size_desc size;
	} desc;
};

struct fcoe_netdev_mapping {
	struct list_head list;
	struct net_device *netdev;
	struct fcoe_transport *ft;
};

enum fnic_sgl_list_type {
	FNIC_SGL_CACHE_DFLT = 0,
	FNIC_SGL_CACHE_MAX = 1,
	FNIC_SGL_NUM_CACHES = 2,
};

struct vnic_dev_bar {
	void *vaddr;
	dma_addr_t bus_addr;
	long unsigned int len;
};

struct vnic_dev_ring {
	void *descs;
	size_t size;
	dma_addr_t base_addr;
	size_t base_align;
	void *descs_unaligned;
	size_t size_unaligned;
	dma_addr_t base_addr_unaligned;
	unsigned int desc_size;
	unsigned int desc_count;
	unsigned int desc_avail;
};

struct vnic_cq_ctrl {
	u64 ring_base;
	u32 ring_size;
	u32 pad0;
	u32 flow_control_enable;
	u32 pad1;
	u32 color_enable;
	u32 pad2;
	u32 cq_head;
	u32 pad3;
	u32 cq_tail;
	u32 pad4;
	u32 cq_tail_color;
	u32 pad5;
	u32 interrupt_enable;
	u32 pad6;
	u32 cq_entry_enable;
	u32 pad7;
	u32 cq_message_enable;
	u32 pad8;
	u32 interrupt_offset;
	u32 pad9;
	u64 cq_message_addr;
	u32 pad10;
};

struct vnic_dev;

struct vnic_cq {
	unsigned int index;
	struct vnic_dev *vdev;
	struct vnic_cq_ctrl *ctrl;
	struct vnic_dev_ring ring;
	unsigned int to_clean;
	unsigned int last_color;
};

struct vnic_wq_ctrl {
	u64 ring_base;
	u32 ring_size;
	u32 pad0;
	u32 posted_index;
	u32 pad1;
	u32 cq_index;
	u32 pad2;
	u32 enable;
	u32 pad3;
	u32 running;
	u32 pad4;
	u32 fetch_index;
	u32 pad5;
	u32 dca_value;
	u32 pad6;
	u32 error_interrupt_enable;
	u32 pad7;
	u32 error_interrupt_offset;
	u32 pad8;
	u32 error_status;
	u32 pad9;
};

struct vnic_wq_buf {
	struct vnic_wq_buf *next;
	dma_addr_t dma_addr;
	void *os_buf;
	unsigned int len;
	unsigned int index;
	int sop;
	void *desc;
};

struct vnic_wq {
	unsigned int index;
	struct vnic_dev *vdev;
	struct vnic_wq_ctrl *ctrl;
	struct vnic_dev_ring ring;
	struct vnic_wq_buf *bufs[64];
	struct vnic_wq_buf *to_use;
	struct vnic_wq_buf *to_clean;
	unsigned int pkts_outstanding;
};

struct vnic_rq_ctrl {
	u64 ring_base;
	u32 ring_size;
	u32 pad0;
	u32 posted_index;
	u32 pad1;
	u32 cq_index;
	u32 pad2;
	u32 enable;
	u32 pad3;
	u32 running;
	u32 pad4;
	u32 fetch_index;
	u32 pad5;
	u32 error_interrupt_enable;
	u32 pad6;
	u32 error_interrupt_offset;
	u32 pad7;
	u32 error_status;
	u32 pad8;
	u32 dropped_packet_count;
	u32 pad9;
	u32 dropped_packet_count_rc;
	u32 pad10;
};

struct vnic_rq_buf {
	struct vnic_rq_buf *next;
	dma_addr_t dma_addr;
	void *os_buf;
	unsigned int os_buf_index;
	unsigned int len;
	unsigned int index;
	void *desc;
};

struct vnic_rq {
	unsigned int index;
	struct vnic_dev *vdev;
	struct vnic_rq_ctrl *ctrl;
	struct vnic_dev_ring ring;
	struct vnic_rq_buf *bufs[64];
	struct vnic_rq_buf *to_use;
	struct vnic_rq_buf *to_clean;
	void *os_buf_head;
	unsigned int buf_index;
	unsigned int pkts_outstanding;
};

struct vnic_wq_copy {
	unsigned int index;
	struct vnic_dev *vdev;
	struct vnic_wq_ctrl *ctrl;
	struct vnic_dev_ring ring;
	unsigned int to_use_index;
	unsigned int to_clean_index;
};

struct stats_timestamps {
	struct timespec64 last_reset_time;
	struct timespec64 last_read_time;
};

struct io_path_stats {
	atomic64_t active_ios;
	atomic64_t max_active_ios;
	atomic64_t io_completions;
	atomic64_t io_failures;
	atomic64_t ioreq_null;
	atomic64_t alloc_failures;
	atomic64_t sc_null;
	atomic64_t io_not_found;
	atomic64_t num_ios;
	atomic64_t io_btw_0_to_10_msec;
	atomic64_t io_btw_10_to_100_msec;
	atomic64_t io_btw_100_to_500_msec;
	atomic64_t io_btw_500_to_5000_msec;
	atomic64_t io_btw_5000_to_10000_msec;
	atomic64_t io_btw_10000_to_30000_msec;
	atomic64_t io_greater_than_30000_msec;
	atomic64_t current_max_io_time;
};

struct abort_stats {
	atomic64_t aborts;
	atomic64_t abort_failures;
	atomic64_t abort_drv_timeouts;
	atomic64_t abort_fw_timeouts;
	atomic64_t abort_io_not_found;
	atomic64_t abort_issued_btw_0_to_6_sec;
	atomic64_t abort_issued_btw_6_to_20_sec;
	atomic64_t abort_issued_btw_20_to_30_sec;
	atomic64_t abort_issued_btw_30_to_40_sec;
	atomic64_t abort_issued_btw_40_to_50_sec;
	atomic64_t abort_issued_btw_50_to_60_sec;
	atomic64_t abort_issued_greater_than_60_sec;
};

struct terminate_stats {
	atomic64_t terminates;
	atomic64_t max_terminates;
	atomic64_t terminate_drv_timeouts;
	atomic64_t terminate_fw_timeouts;
	atomic64_t terminate_io_not_found;
	atomic64_t terminate_failures;
};

struct reset_stats {
	atomic64_t device_resets;
	atomic64_t device_reset_failures;
	atomic64_t device_reset_aborts;
	atomic64_t device_reset_timeouts;
	atomic64_t device_reset_terminates;
	atomic64_t fw_resets;
	atomic64_t fw_reset_completions;
	atomic64_t fw_reset_failures;
	atomic64_t fnic_resets;
	atomic64_t fnic_reset_completions;
	atomic64_t fnic_reset_failures;
};

struct fw_stats {
	atomic64_t active_fw_reqs;
	atomic64_t max_fw_reqs;
	atomic64_t fw_out_of_resources;
	atomic64_t io_fw_errs;
};

struct vlan_stats {
	atomic64_t vlan_disc_reqs;
	atomic64_t resp_withno_vlanID;
	atomic64_t sol_expiry_count;
	atomic64_t flogi_rejects;
};

struct misc_stats {
	u64 last_isr_time;
	u64 last_ack_time;
	atomic64_t max_isr_jiffies;
	atomic64_t max_isr_time_ms;
	atomic64_t corr_work_done;
	atomic64_t isr_count;
	atomic64_t max_cq_entries;
	atomic64_t ack_index_out_of_range;
	atomic64_t data_count_mismatch;
	atomic64_t fcpio_timeout;
	atomic64_t fcpio_aborted;
	atomic64_t sgl_invalid;
	atomic64_t mss_invalid;
	atomic64_t abts_cpwq_alloc_failures;
	atomic64_t devrst_cpwq_alloc_failures;
	atomic64_t io_cpwq_alloc_failures;
	atomic64_t no_icmnd_itmf_cmpls;
	atomic64_t check_condition;
	atomic64_t queue_fulls;
	atomic64_t rport_not_ready;
	atomic64_t frame_errors;
	atomic64_t current_port_speed;
};

struct fnic_stats {
	struct stats_timestamps stats_timestamps;
	struct io_path_stats io_stats;
	struct abort_stats abts_stats;
	struct terminate_stats term_stats;
	struct reset_stats reset_stats;
	struct fw_stats fw_stats;
	struct vlan_stats vlan_stats;
	struct misc_stats misc_stats;
};

struct vnic_intr_ctrl {
	u32 coalescing_timer;
	u32 pad0;
	u32 coalescing_value;
	u32 pad1;
	u32 coalescing_type;
	u32 pad2;
	u32 mask_on_assertion;
	u32 pad3;
	u32 mask;
	u32 pad4;
	u32 int_credits;
	u32 pad5;
	u32 int_credit_return;
	u32 pad6;
};

struct vnic_intr {
	unsigned int index;
	struct vnic_dev *vdev;
	struct vnic_intr_ctrl *ctrl;
};

struct vnic_tx_stats {
	u64 tx_frames_ok;
	u64 tx_unicast_frames_ok;
	u64 tx_multicast_frames_ok;
	u64 tx_broadcast_frames_ok;
	u64 tx_bytes_ok;
	u64 tx_unicast_bytes_ok;
	u64 tx_multicast_bytes_ok;
	u64 tx_broadcast_bytes_ok;
	u64 tx_drops;
	u64 tx_errors;
	u64 tx_tso;
	u64 rsvd[16];
};

struct vnic_rx_stats {
	u64 rx_frames_ok;
	u64 rx_frames_total;
	u64 rx_unicast_frames_ok;
	u64 rx_multicast_frames_ok;
	u64 rx_broadcast_frames_ok;
	u64 rx_bytes_ok;
	u64 rx_unicast_bytes_ok;
	u64 rx_multicast_bytes_ok;
	u64 rx_broadcast_bytes_ok;
	u64 rx_drop;
	u64 rx_no_bufs;
	u64 rx_errors;
	u64 rx_rss;
	u64 rx_crc_errors;
	u64 rx_frames_64;
	u64 rx_frames_127;
	u64 rx_frames_255;
	u64 rx_frames_511;
	u64 rx_frames_1023;
	u64 rx_frames_1518;
	u64 rx_frames_to_max;
	u64 rsvd[16];
};

struct vnic_stats {
	struct vnic_tx_stats tx;
	struct vnic_rx_stats rx;
};

struct vnic_fc_config {
	u64 node_wwn;
	u64 port_wwn;
	u32 flags;
	u32 wq_enet_desc_count;
	u32 wq_copy_desc_count;
	u32 rq_desc_count;
	u32 flogi_retries;
	u32 flogi_timeout;
	u32 plogi_retries;
	u32 plogi_timeout;
	u32 io_throttle_count;
	u32 link_down_timeout;
	u32 port_down_timeout;
	u32 port_down_io_retries;
	u32 luns_per_tgt;
	u16 maxdatafieldsize;
	u16 ed_tov;
	u16 ra_tov;
	u16 intr_timer;
	u8 intr_timer_type;
};

enum fnic_msix_intr_index {
	FNIC_MSIX_RQ = 0,
	FNIC_MSIX_WQ = 1,
	FNIC_MSIX_WQ_COPY = 2,
	FNIC_MSIX_ERR_NOTIFY = 3,
	FNIC_MSIX_INTR_MAX = 4,
};

struct fnic_msix_entry {
	int requested;
	char devname[27];
	irqreturn_t (*isr)(int, void *);
	void *devid;
};

enum fnic_state {
	FNIC_IN_FC_MODE = 0,
	FNIC_IN_FC_TRANS_ETH_MODE = 1,
	FNIC_IN_ETH_MODE = 2,
	FNIC_IN_ETH_TRANS_FC_MODE = 3,
};

struct vnic_nic_cfg;

struct fnic_host_tag;

struct fnic {
	struct fc_lport *lport;
	struct fcoe_ctlr ctlr;
	struct vnic_dev_bar bar0;
	struct fnic_msix_entry msix[4];
	struct vnic_stats *stats;
	long unsigned int stats_time;
	long unsigned int stats_reset_time;
	struct vnic_nic_cfg *nic_cfg;
	char name[16];
	struct timer_list notify_timer;
	unsigned int fnic_max_tag_id;
	unsigned int err_intr_offset;
	unsigned int link_intr_offset;
	unsigned int wq_count;
	unsigned int cq_count;
	struct dentry *fnic_stats_debugfs_host;
	struct dentry *fnic_stats_debugfs_file;
	struct dentry *fnic_reset_debugfs_file;
	unsigned int reset_stats;
	atomic64_t io_cmpl_skip;
	struct fnic_stats fnic_stats;
	u32 vlan_hw_insert: 1;
	u32 in_remove: 1;
	u32 stop_rx_link_events: 1;
	struct completion *remove_wait;
	atomic_t in_flight;
	bool internal_reset_inprogress;
	u32 _reserved;
	long unsigned int state_flags;
	enum fnic_state state;
	spinlock_t fnic_lock;
	u16 vlan_id;
	u8 data_src_addr[6];
	u64 fcp_input_bytes;
	u64 fcp_output_bytes;
	u32 link_down_cnt;
	int link_status;
	struct list_head list;
	struct pci_dev *pdev;
	struct vnic_fc_config config;
	struct vnic_dev *vdev;
	unsigned int raw_wq_count;
	unsigned int wq_copy_count;
	unsigned int rq_count;
	int fw_ack_index[1];
	short unsigned int fw_ack_recd[1];
	short unsigned int wq_copy_desc_low[1];
	unsigned int intr_count;
	u32 *legacy_pba;
	struct fnic_host_tag *tags;
	mempool_t *io_req_pool;
	mempool_t *io_sgl_pool[2];
	spinlock_t io_req_lock[64];
	struct work_struct link_work;
	struct work_struct frame_work;
	struct sk_buff_head frame_queue;
	struct sk_buff_head tx_queue;
	void (*set_vlan)(struct fnic *, u16);
	struct work_struct fip_frame_work;
	struct sk_buff_head fip_frame_queue;
	struct timer_list fip_timer;
	struct list_head vlans;
	spinlock_t vlans_lock;
	struct work_struct event_work;
	struct list_head evlist;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct vnic_wq_copy wq_copy[1];
	long: 64;
	long: 64;
	long: 64;
	struct vnic_cq cq[3];
	spinlock_t wq_copy_lock[1];
	struct vnic_wq wq[1];
	spinlock_t wq_lock[1];
	struct vnic_rq rq[1];
	struct vnic_intr intr[4];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum vnic_dev_intr_mode {
	VNIC_DEV_INTR_MODE_UNKNOWN = 0,
	VNIC_DEV_INTR_MODE_INTX = 1,
	VNIC_DEV_INTR_MODE_MSI = 2,
	VNIC_DEV_INTR_MODE_MSIX = 3,
};

enum fnic_intx_intr_index {
	FNIC_INTX_WQ_RQ_COPYWQ = 0,
	FNIC_INTX_ERR = 1,
	FNIC_INTX_NOTIFY = 2,
	FNIC_INTX_INTR_MAX = 3,
};

enum fnic_port_speeds {
	DCEM_PORTSPEED_NONE = 0,
	DCEM_PORTSPEED_1G = 1000,
	DCEM_PORTSPEED_10G = 10000,
	DCEM_PORTSPEED_20G = 20000,
	DCEM_PORTSPEED_25G = 25000,
	DCEM_PORTSPEED_40G = 40000,
	DCEM_PORTSPEED_4x10G = 41000,
	DCEM_PORTSPEED_100G = 100000,
};

struct fcpio_tag {
	union {
		u32 req_id;
		struct {
			u16 rx_id;
			u16 ox_id;
		} ex_id;
	} u;
};

struct fcpio_header {
	u8 type;
	u8 status;
	u16 _resvd;
	struct fcpio_tag tag;
};

struct fcpio_icmnd_16 {
	u32 lunmap_id;
	u8 special_req_flags;
	u8 _resvd0[3];
	u32 sgl_cnt;
	u32 sense_len;
	u64 sgl_addr;
	u64 sense_addr;
	u8 crn;
	u8 pri_ta;
	u8 _resvd1;
	u8 flags;
	u8 scsi_cdb[16];
	u32 data_len;
	u8 lun[8];
	u8 _resvd2;
	u8 d_id[3];
	u16 mss;
	u16 _resvd3;
	u32 r_a_tov;
	u32 e_d_tov;
};

struct fcpio_icmnd_32 {
	u32 lunmap_id;
	u8 special_req_flags;
	u8 _resvd0[3];
	u32 sgl_cnt;
	u32 sense_len;
	u64 sgl_addr;
	u64 sense_addr;
	u8 crn;
	u8 pri_ta;
	u8 _resvd1;
	u8 flags;
	u8 scsi_cdb[32];
	u32 data_len;
	u8 lun[8];
	u8 _resvd2;
	u8 d_id[3];
	u16 mss;
	u16 _resvd3;
	u32 r_a_tov;
	u32 e_d_tov;
};

struct fcpio_itmf {
	u32 lunmap_id;
	u32 tm_req;
	u32 t_tag;
	u32 _resvd;
	u8 lun[8];
	u8 _resvd1;
	u8 d_id[3];
	u32 r_a_tov;
	u32 e_d_tov;
};

struct fcpio_tdata {
	u16 rx_id;
	u16 flags;
	u32 rel_offset;
	u32 sgl_cnt;
	u32 data_len;
	u64 sgl_addr;
};

struct fcpio_txrdy {
	u16 rx_id;
	u16 _resvd0;
	u32 rel_offset;
	u32 sgl_cnt;
	u32 data_len;
	u64 sgl_addr;
};

struct fcpio_trsp {
	u16 rx_id;
	u16 _resvd0;
	u32 sense_len;
	u64 sense_addr;
	u16 _resvd1;
	u8 flags;
	u8 scsi_status;
	u32 residual;
};

struct fcpio_ttmf_ack {
	u16 rx_id;
	u16 _resvd0;
	u32 tmf_status;
};

struct fcpio_tabort {
	u16 rx_id;
};

struct fcpio_reset {
	u32 _resvd;
};

struct fcpio_flogi_reg {
	u8 format;
	u8 s_id[3];
	u8 gateway_mac[6];
	u16 _resvd;
	u32 r_a_tov;
	u32 e_d_tov;
};

struct fcpio_echo {
	u32 _resvd;
};

struct fcpio_lunmap_req {
	u64 addr;
	u32 len;
};

struct fcpio_flogi_fip_reg {
	u8 _resvd0;
	u8 s_id[3];
	u8 fcf_mac[6];
	u16 _resvd1;
	u32 r_a_tov;
	u32 e_d_tov;
	u8 ha_mac[6];
	u16 _resvd2;
};

struct fcpio_host_req {
	struct fcpio_header hdr;
	union {
		u8 buf[120];
		struct fcpio_icmnd_16 icmnd_16;
		struct fcpio_icmnd_32 icmnd_32;
		struct fcpio_itmf itmf;
		struct fcpio_tdata tdata;
		struct fcpio_txrdy txrdy;
		struct fcpio_trsp trsp;
		struct fcpio_ttmf_ack ttmf_ack;
		struct fcpio_tabort tabort;
		struct fcpio_reset reset;
		struct fcpio_flogi_reg flogi_reg;
		struct fcpio_echo echo;
		struct fcpio_lunmap_req lunmap_req;
		struct fcpio_flogi_fip_reg flogi_fip_reg;
	} u;
};

enum vnic_res_type {
	RES_TYPE_EOL = 0,
	RES_TYPE_WQ = 1,
	RES_TYPE_RQ = 2,
	RES_TYPE_CQ = 3,
	RES_TYPE_RSVD1 = 4,
	RES_TYPE_NIC_CFG = 5,
	RES_TYPE_RSVD2 = 6,
	RES_TYPE_RSVD3 = 7,
	RES_TYPE_RSVD4 = 8,
	RES_TYPE_RSVD5 = 9,
	RES_TYPE_INTR_CTRL = 10,
	RES_TYPE_INTR_TABLE = 11,
	RES_TYPE_INTR_PBA = 12,
	RES_TYPE_INTR_PBA_LEGACY = 13,
	RES_TYPE_RSVD6 = 14,
	RES_TYPE_RSVD7 = 15,
	RES_TYPE_DEVCMD = 16,
	RES_TYPE_PASS_THRU_PAGE = 17,
	RES_TYPE_SUBVNIC = 18,
	RES_TYPE_MQ_WQ = 19,
	RES_TYPE_MQ_RQ = 20,
	RES_TYPE_MQ_CQ = 21,
	RES_TYPE_DEPRECATED1 = 22,
	RES_TYPE_DEPRECATED2 = 23,
	RES_TYPE_DEVCMD2 = 24,
	RES_TYPE_MAX = 25,
};

enum vnic_devcmd_cmd {
	CMD_NONE = 0,
	CMD_MCPU_FW_INFO = 1073856513,
	CMD_DEV_SPEC = 3221340162,
	CMD_STATS_CLEAR = 16891907,
	CMD_STATS_DUMP = 1073856516,
	CMD_PACKET_FILTER = 1090633735,
	CMD_HANG_NOTIFY = 114696,
	CMD_MAC_ADDR = 2147532809,
	CMD_PROMISC_MODE = 1090535434,
	CMD_ALLMULTI_MODE = 1090535435,
	CMD_ADDR_ADD = 1090568204,
	CMD_ADDR_DEL = 1090568205,
	CMD_VLAN_ADD = 1090535438,
	CMD_VLAN_DEL = 1090535439,
	CMD_NIC_CFG = 1090633744,
	CMD_RSS_KEY = 1073758225,
	CMD_RSS_CPU = 1073758226,
	CMD_SOFT_RESET = 16891923,
	CMD_SOFT_RESET_STATUS = 2147598356,
	CMD_NOTIFY = 3221340181,
	CMD_UNDI = 1073758230,
	CMD_OPEN = 1090633751,
	CMD_OPEN_STATUS = 2147598360,
	CMD_CLOSE = 114713,
	CMD_INIT = 2164375578,
	CMD_INIT_PROV_INFO = 1073758235,
	CMD_ENABLE = 1090633756,
	CMD_DISABLE = 114717,
	CMD_STATS_DUMP_ALL = 1073856542,
	CMD_INIT_STATUS = 2147598367,
	CMD_INT13 = 1073774624,
	CMD_LOGICAL_UPLINK = 1090535457,
	CMD_DEINIT = 16891938,
	CMD_CAPABILITY = 3221340196,
	CMD_PERBI = 3221258277,
	CMD_IAR = 1090633766,
	CMD_HANG_RESET = 114727,
	CMD_HANG_RESET_STATUS = 2147598376,
	CMD_IG_VLAN_REWRITE_MODE = 3221241897,
	CMD_PROXY_BY_BDF = 3221340202,
	CMD_PROXY_BY_INDEX = 3221340203,
	CMD_CONFIG_INFO_GET = 3221340204,
	CMD_INT13_ALL = 1073856557,
	CMD_SET_DEFAULT_VLAN = 3221340206,
	CMD_INIT_PROV_INFO2 = 1073758255,
	CMD_ENABLE2 = 1073758256,
	CMD_STATUS = 3221340209,
	CMD_INTR_COAL_CONVERT = 2147598386,
	CMD_ISCSI_DUMP_REQ = 1073856563,
	CMD_ISCSI_DUMP_STATUS = 3221340212,
	CMD_MIGRATE_SUBVNIC = 1073758261,
	CMD_SUBVNIC_NOTIFY = 3221340214,
	CMD_SET_MAC_ADDR = 1073758263,
	CMD_PROV_INFO_UPDATE = 1073758264,
	CMD_INITIALIZE_DEVCMD2 = 1073856569,
};

enum skb_free_reason {
	SKB_REASON_CONSUMED = 0,
	SKB_REASON_DROPPED = 1,
};

struct vlan_ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct wq_enet_desc {
	__le64 address;
	__le16 length;
	__le16 mss_loopback;
	__le16 header_length_flags;
	__le16 vlan_tag;
};

struct rq_enet_desc {
	__le64 address;
	__le16 length_type;
	u8 reserved[6];
};

enum rq_enet_type_types {
	RQ_ENET_TYPE_ONLY_SOP = 0,
	RQ_ENET_TYPE_NOT_SOP = 1,
	RQ_ENET_TYPE_RESV2 = 2,
	RQ_ENET_TYPE_RESV3 = 3,
};

enum cq_desc_types {
	CQ_DESC_TYPE_WQ_ENET = 0,
	CQ_DESC_TYPE_DESC_COPY = 1,
	CQ_DESC_TYPE_WQ_EXCH = 2,
	CQ_DESC_TYPE_RQ_ENET = 3,
	CQ_DESC_TYPE_RQ_FCP = 4,
};

struct cq_desc {
	__le16 completed_index;
	__le16 q_number;
	u8 type_specfic[11];
	u8 type_color;
};

enum desc_return_options {
	VNIC_RQ_RETURN_DESC = 0,
	VNIC_RQ_DEFER_RETURN_DESC = 1,
};

enum fnic_evt {
	FNIC_EVT_START_VLAN_DISC = 1,
	FNIC_EVT_START_FCF_DISC = 2,
	FNIC_EVT_MAX = 3,
};

struct fnic_event {
	struct list_head list;
	struct fnic *fnic;
	enum fnic_evt event;
};

struct fcoe_vlan {
	struct list_head list;
	u16 vid;
	u16 sol_count;
	u16 state;
};

enum fip_vlan_state {
	FIP_VLAN_AVAIL = 0,
	FIP_VLAN_SENT = 1,
	FIP_VLAN_USED = 2,
	FIP_VLAN_FAILED = 3,
};

struct fip_vlan {
	struct ethhdr eth;
	struct fip_header fip;
	struct {
		struct fip_mac_desc mac;
		struct fip_wwn_desc wwnn;
	} __attribute__((packed)) desc;
} __attribute__((packed));

struct cq_enet_rq_desc {
	__le16 completed_index_flags;
	__le16 q_number_rss_type_flags;
	__le32 rss_hash;
	__le16 bytes_written_flags;
	__le16 vlan;
	__le16 checksum_fcoe;
	u8 flags;
	u8 type_color;
};

struct cq_fcp_rq_desc {
	u16 completed_index_eop_sop_prt;
	u16 q_number;
	u16 exchange_id;
	u16 tmpl;
	u16 bytes_written;
	u16 vlan;
	u8 sof;
	u8 eof;
	u8 fcs_fer_fck;
	u8 type_color;
};

struct host_sg_desc {
	__le64 addr;
	__le32 len;
	u32 _resvd;
};

enum fnic_ioreq_state {
	FNIC_IOREQ_NOT_INITED = 0,
	FNIC_IOREQ_CMD_PENDING = 1,
	FNIC_IOREQ_ABTS_PENDING = 2,
	FNIC_IOREQ_ABTS_COMPLETE = 3,
	FNIC_IOREQ_CMD_COMPLETE = 4,
};

struct fnic_io_req {
	struct host_sg_desc *sgl_list;
	void *sgl_list_alloc;
	dma_addr_t sense_buf_pa;
	dma_addr_t sgl_list_pa;
	u16 sgl_cnt;
	u8 sgl_type;
	u8 io_completed: 1;
	u32 port_id;
	long unsigned int start_time;
	struct completion *abts_done;
	struct completion *dr_done;
};

enum fcpio_type {
	FCPIO_ICMND_16 = 1,
	FCPIO_ICMND_32 = 2,
	FCPIO_ICMND_CMPL = 3,
	FCPIO_ITMF = 4,
	FCPIO_ITMF_CMPL = 5,
	FCPIO_TCMND_16 = 17,
	FCPIO_TCMND_32 = 18,
	FCPIO_TDATA = 19,
	FCPIO_TXRDY = 20,
	FCPIO_TRSP = 21,
	FCPIO_TDRSP_CMPL = 22,
	FCPIO_TTMF = 23,
	FCPIO_TTMF_ACK = 24,
	FCPIO_TABORT = 25,
	FCPIO_TABORT_CMPL = 26,
	FCPIO_ACK = 32,
	FCPIO_RESET = 33,
	FCPIO_RESET_CMPL = 34,
	FCPIO_FLOGI_REG = 35,
	FCPIO_FLOGI_REG_CMPL = 36,
	FCPIO_ECHO = 37,
	FCPIO_ECHO_CMPL = 38,
	FCPIO_LUNMAP_CHNG = 39,
	FCPIO_LUNMAP_REQ = 40,
	FCPIO_LUNMAP_REQ_CMPL = 41,
	FCPIO_FLOGI_FIP_REG = 42,
	FCPIO_FLOGI_FIP_REG_CMPL = 43,
};

enum fcpio_status {
	FCPIO_SUCCESS = 0,
	FCPIO_INVALID_HEADER = 1,
	FCPIO_OUT_OF_RESOURCE = 2,
	FCPIO_INVALID_PARAM = 3,
	FCPIO_REQ_NOT_SUPPORTED = 4,
	FCPIO_IO_NOT_FOUND = 5,
	FCPIO_ABORTED = 65,
	FCPIO_TIMEOUT = 66,
	FCPIO_SGL_INVALID = 67,
	FCPIO_MSS_INVALID = 68,
	FCPIO_DATA_CNT_MISMATCH = 69,
	FCPIO_FW_ERR = 70,
	FCPIO_ITMF_REJECTED = 71,
	FCPIO_ITMF_FAILED = 72,
	FCPIO_ITMF_INCORRECT_LUN = 73,
	FCPIO_CMND_REJECTED = 74,
	FCPIO_NO_PATH_AVAIL = 75,
	FCPIO_PATH_FAILED = 76,
	FCPIO_LUNMAP_CHNG_PEND = 77,
};

enum fcpio_itmf_tm_req_type {
	FCPIO_ITMF_ABT_TASK_TERM = 1,
	FCPIO_ITMF_ABT_TASK = 2,
	FCPIO_ITMF_ABT_TASK_SET = 3,
	FCPIO_ITMF_CLR_TASK_SET = 4,
	FCPIO_ITMF_LUN_RESET = 5,
	FCPIO_ITMF_CLR_ACA = 6,
};

enum fcpio_flogi_reg_format_type {
	FCPIO_FLOGI_REG_DEF_DEST = 0,
	FCPIO_FLOGI_REG_GW_DEST = 1,
};

struct fcpio_icmnd_cmpl {
	u8 _resvd0[6];
	u8 flags;
	u8 scsi_status;
	u32 residual;
	u32 sense_len;
};

struct fcpio_itmf_cmpl {
	u32 _resvd;
};

struct fcpio_tcmnd_16 {
	u8 lun[8];
	u8 crn;
	u8 pri_ta;
	u8 _resvd2;
	u8 flags;
	u8 scsi_cdb[16];
	u32 data_len;
	u8 _resvd1;
	u8 s_id[3];
};

struct fcpio_tcmnd_32 {
	u8 lun[8];
	u8 crn;
	u8 pri_ta;
	u8 _resvd2;
	u8 flags;
	u8 scsi_cdb[32];
	u32 data_len;
	u8 _resvd0;
	u8 s_id[3];
};

struct fcpio_tdrsp_cmpl {
	u16 rx_id;
	u16 _resvd0;
};

struct fcpio_ttmf {
	u8 _resvd0;
	u8 s_id[3];
	u8 lun[8];
	u8 crn;
	u8 _resvd2[3];
	u32 tmf_type;
};

struct fcpio_tabort_cmpl {
	u16 rx_id;
	u16 _resvd0;
};

struct fcpio_ack {
	u16 request_out;
	u16 _resvd;
};

struct fcpio_reset_cmpl {
	u16 vnic_id;
};

struct fcpio_flogi_reg_cmpl {
	u32 _resvd;
};

struct fcpio_echo_cmpl {
	u32 _resvd;
};

struct fcpio_lunmap_chng {
	u32 _resvd;
};

struct fcpio_lunmap_req_cmpl {
	u32 _resvd;
};

struct fcpio_fw_req {
	struct fcpio_header hdr;
	union {
		u8 buf[56];
		struct fcpio_icmnd_cmpl icmnd_cmpl;
		struct fcpio_itmf_cmpl itmf_cmpl;
		struct fcpio_tcmnd_16 tcmnd_16;
		struct fcpio_tcmnd_32 tcmnd_32;
		struct fcpio_tdrsp_cmpl tdrsp_cmpl;
		struct fcpio_ttmf ttmf;
		struct fcpio_tabort_cmpl tabort_cmpl;
		struct fcpio_ack ack;
		struct fcpio_reset_cmpl reset_cmpl;
		struct fcpio_flogi_reg_cmpl flogi_reg_cmpl;
		struct fcpio_echo_cmpl echo_cmpl;
		struct fcpio_lunmap_chng lunmap_chng;
		struct fcpio_lunmap_req_cmpl lunmap_req_cmpl;
	} u;
};

struct fnic_trace_data {
	union {
		struct {
			u32 low;
			u32 high;
		};
		u64 val;
	} timestamp;
	union {
		struct {
			u32 low;
			u32 high;
		};
		u64 val;
	} fnaddr;
	u32 host_no;
	u32 tag;
	u64 data[5];
};

typedef struct fnic_trace_data fnic_trace_data_t;

struct fnic_trace_dbg {
	int wr_idx;
	int rd_idx;
	long unsigned int *page_offset;
};

typedef struct fnic_trace_dbg fnic_trace_dbg_t;

struct fnic_dbgfs {
	int buffer_len;
	char *buffer;
};

typedef struct fnic_dbgfs fnic_dbgfs_t;

struct fc_trace_hdr {
	struct timespec64 time_stamp;
	u32 host_no;
	u8 frame_type;
	u8 frame_len;
} __attribute__((packed));

struct stats_debug_info {
	char *debug_buffer;
	void *i_private;
	int buf_size;
	int buffer_len;
};

struct fc_trace_flag_type {
	u8 fc_row_file;
	u8 fc_normal_file;
	u8 fnic_trace;
	u8 fc_trace;
	u8 fc_clear;
};

struct vnic_resource_header {
	u32 magic;
	u32 version;
};

struct vnic_resource {
	u8 type;
	u8 bar;
	u8 pad[2];
	u32 bar_offset;
	u32 count;
};

enum vnic_devcmd_status {
	STAT_NONE = 0,
	STAT_BUSY = 1,
	STAT_ERROR = 2,
};

enum vnic_devcmd_error {
	ERR_SUCCESS = 0,
	ERR_EINVAL = 1,
	ERR_EFAULT = 2,
	ERR_EPERM = 3,
	ERR_EBUSY = 4,
	ERR_ECMDUNKNOWN = 5,
	ERR_EBADSTATE = 6,
	ERR_ENOMEM = 7,
	ERR_ETIMEDOUT = 8,
	ERR_ELINKDOWN = 9,
};

struct vnic_devcmd_fw_info {
	char fw_version[32];
	char fw_build[32];
	char hw_version[32];
	char hw_serial_number[32];
};

struct vnic_devcmd_notify {
	u32 csum;
	u32 link_state;
	u32 port_speed;
	u32 mtu;
	u32 msglvl;
	u32 uif;
	u32 status;
	u32 error;
	u32 link_down_cnt;
};

struct vnic_devcmd {
	u32 status;
	u32 cmd;
	u64 args[15];
};

struct vnic_devcmd2 {
	u16 pad;
	u16 flags;
	u32 cmd;
	u64 args[15];
};

struct devcmd2_result {
	u64 results[15];
	u32 pad;
	u16 completed_index;
	u8 error;
	u8 color;
};

struct vnic_res {
	void *vaddr;
	unsigned int count;
};

enum vnic_proxy_type {
	PROXY_NONE = 0,
	PROXY_BY_BDF = 1,
	PROXY_BY_INDEX = 2,
};

struct devcmd2_controller;

struct vnic_dev {
	void *priv;
	struct pci_dev *pdev;
	struct vnic_res res[25];
	enum vnic_dev_intr_mode intr_mode;
	struct vnic_devcmd *devcmd;
	struct vnic_devcmd_notify *notify;
	struct vnic_devcmd_notify notify_copy;
	dma_addr_t notify_pa;
	u32 *linkstatus;
	dma_addr_t linkstatus_pa;
	struct vnic_stats *stats;
	dma_addr_t stats_pa;
	struct vnic_devcmd_fw_info *fw_info;
	dma_addr_t fw_info_pa;
	enum vnic_proxy_type proxy;
	u32 proxy_index;
	u64 args[15];
	struct devcmd2_controller *devcmd2;
	int (*devcmd_rtn)(struct vnic_dev *, enum vnic_devcmd_cmd, int);
};

struct devcmd2_controller {
	struct vnic_wq_ctrl *wq_ctrl;
	struct vnic_dev_ring results_ring;
	struct vnic_wq wq;
	struct vnic_devcmd2 *cmd_ring;
	struct devcmd2_result *result;
	u16 next_result;
	u16 result_size;
	int color;
};

struct kfifo {
	union {
		struct __kfifo kfifo;
		unsigned char *type;
		const unsigned char *const_type;
		char (*rectype)[0];
		void *ptr;
		const void *ptr_const;
	};
	unsigned char buf[0];
};

struct sockaddr_in6 {
	short unsigned int sin6_family;
	__be16 sin6_port;
	__be32 sin6_flowinfo;
	struct in6_addr sin6_addr;
	__u32 sin6_scope_id;
};

struct sockaddr_in {
	__kernel_sa_family_t sin_family;
	__be16 sin_port;
	struct in_addr sin_addr;
	unsigned char __pad[8];
};

enum scsi_prot_flags {
	SCSI_PROT_TRANSFER_PI = 1,
	SCSI_PROT_GUARD_CHECK = 2,
	SCSI_PROT_REF_CHECK = 4,
	SCSI_PROT_REF_INCREMENT = 8,
	SCSI_PROT_IP_CHECKSUM = 16,
};

struct iscsi_scsi_req {
	uint8_t opcode;
	uint8_t flags;
	__be16 rsvd2;
	uint8_t hlength;
	uint8_t dlength[3];
	struct scsi_lun lun;
	itt_t itt;
	__be32 data_length;
	__be32 cmdsn;
	__be32 exp_statsn;
	uint8_t cdb[16];
};

struct iscsi_ecdb_ahdr {
	__be16 ahslength;
	uint8_t ahstype;
	uint8_t reserved;
	uint8_t ecdb[244];
};

struct iscsi_scsi_rsp {
	uint8_t opcode;
	uint8_t flags;
	uint8_t response;
	uint8_t cmd_status;
	uint8_t hlength;
	uint8_t dlength[3];
	uint8_t rsvd[8];
	itt_t itt;
	__be32 rsvd1;
	__be32 statsn;
	__be32 exp_cmdsn;
	__be32 max_cmdsn;
	__be32 exp_datasn;
	__be32 bi_residual_count;
	__be32 residual_count;
};

struct iscsi_nopout {
	uint8_t opcode;
	uint8_t flags;
	__be16 rsvd2;
	uint8_t rsvd3;
	uint8_t dlength[3];
	struct scsi_lun lun;
	itt_t itt;
	__be32 ttt;
	__be32 cmdsn;
	__be32 exp_statsn;
	uint8_t rsvd4[16];
};

struct iscsi_nopin {
	uint8_t opcode;
	uint8_t flags;
	__be16 rsvd2;
	uint8_t rsvd3;
	uint8_t dlength[3];
	struct scsi_lun lun;
	itt_t itt;
	__be32 ttt;
	__be32 statsn;
	__be32 exp_cmdsn;
	__be32 max_cmdsn;
	uint8_t rsvd4[12];
};

struct iscsi_tm {
	uint8_t opcode;
	uint8_t flags;
	uint8_t rsvd1[2];
	uint8_t hlength;
	uint8_t dlength[3];
	struct scsi_lun lun;
	itt_t itt;
	itt_t rtt;
	__be32 cmdsn;
	__be32 exp_statsn;
	__be32 refcmdsn;
	__be32 exp_datasn;
	uint8_t rsvd2[8];
};

struct iscsi_tm_rsp {
	uint8_t opcode;
	uint8_t flags;
	uint8_t response;
	uint8_t qualifier;
	uint8_t hlength;
	uint8_t dlength[3];
	uint8_t rsvd2[8];
	itt_t itt;
	itt_t rtt;
	__be32 statsn;
	__be32 exp_cmdsn;
	__be32 max_cmdsn;
	uint8_t rsvd3[12];
};

struct iscsi_data {
	uint8_t opcode;
	uint8_t flags;
	uint8_t rsvd2[2];
	uint8_t rsvd3;
	uint8_t dlength[3];
	struct scsi_lun lun;
	itt_t itt;
	__be32 ttt;
	__be32 rsvd4;
	__be32 exp_statsn;
	__be32 rsvd5;
	__be32 datasn;
	__be32 offset;
	__be32 rsvd6;
};

struct iscsi_data_rsp {
	uint8_t opcode;
	uint8_t flags;
	uint8_t rsvd2;
	uint8_t cmd_status;
	uint8_t hlength;
	uint8_t dlength[3];
	struct scsi_lun lun;
	itt_t itt;
	__be32 ttt;
	__be32 statsn;
	__be32 exp_cmdsn;
	__be32 max_cmdsn;
	__be32 datasn;
	__be32 offset;
	__be32 residual_count;
};

struct iscsi_reject {
	uint8_t opcode;
	uint8_t flags;
	uint8_t reason;
	uint8_t rsvd2;
	uint8_t hlength;
	uint8_t dlength[3];
	uint8_t rsvd3[8];
	__be32 ffffffff;
	uint8_t rsvd4[4];
	__be32 statsn;
	__be32 exp_cmdsn;
	__be32 max_cmdsn;
	__be32 datasn;
	uint8_t rsvd5[8];
};

struct iscsi_r2t_info {
	__be32 ttt;
	__be32 exp_statsn;
	uint32_t data_length;
	uint32_t data_offset;
	int data_count;
	int datasn;
	int sent;
};

struct iscsi_task {
	struct iscsi_hdr *hdr;
	short unsigned int hdr_max;
	short unsigned int hdr_len;
	itt_t hdr_itt;
	__be32 cmdsn;
	struct scsi_lun lun;
	int itt;
	unsigned int imm_count;
	struct iscsi_r2t_info unsol_r2t;
	char *data;
	unsigned int data_count;
	struct scsi_cmnd *sc;
	struct iscsi_conn *conn;
	long unsigned int last_xfer;
	long unsigned int last_timeout;
	bool have_checked_conn;
	bool protected;
	int state;
	refcount_t refcount;
	struct list_head running;
	void *dd_data;
};

struct iscsi_session;

struct iscsi_conn {
	struct iscsi_cls_conn *cls_conn;
	void *dd_data;
	struct iscsi_session *session;
	int stop_stage;
	struct timer_list transport_timer;
	long unsigned int last_recv;
	long unsigned int last_ping;
	int ping_timeout;
	int recv_timeout;
	struct iscsi_task *ping_task;
	uint32_t exp_statsn;
	uint32_t statsn;
	int id;
	int c_stage;
	char *data;
	struct iscsi_task *login_task;
	struct iscsi_task *task;
	spinlock_t taskqueuelock;
	struct list_head mgmtqueue;
	struct list_head cmdqueue;
	struct list_head requeue;
	struct work_struct xmitwork;
	long unsigned int suspend_tx;
	long unsigned int suspend_rx;
	wait_queue_head_t ehwait;
	struct iscsi_tm tmhdr;
	struct timer_list tmf_timer;
	int tmf_state;
	unsigned int max_recv_dlength;
	unsigned int max_xmit_dlength;
	int hdrdgst_en;
	int datadgst_en;
	int ifmarker_en;
	int ofmarker_en;
	int persistent_port;
	char *persistent_address;
	unsigned int max_segment_size;
	unsigned int tcp_xmit_wsf;
	unsigned int tcp_recv_wsf;
	uint16_t keepalive_tmo;
	uint16_t local_port;
	uint8_t tcp_timestamp_stat;
	uint8_t tcp_nagle_disable;
	uint8_t tcp_wsf_disable;
	uint8_t tcp_timer_scale;
	uint8_t tcp_timestamp_en;
	uint8_t fragment_disable;
	uint8_t ipv4_tos;
	uint8_t ipv6_traffic_class;
	uint8_t ipv6_flow_label;
	uint8_t is_fw_assigned_ipv6;
	char *local_ipaddr;
	uint64_t txdata_octets;
	uint64_t rxdata_octets;
	uint32_t scsicmd_pdus_cnt;
	uint32_t dataout_pdus_cnt;
	uint32_t scsirsp_pdus_cnt;
	uint32_t datain_pdus_cnt;
	uint32_t r2t_pdus_cnt;
	uint32_t tmfcmd_pdus_cnt;
	int32_t tmfrsp_pdus_cnt;
	uint32_t eh_abort_cnt;
	uint32_t fmr_unalign_cnt;
};

enum {
	TMF_INITIAL = 0,
	TMF_QUEUED = 1,
	TMF_SUCCESS = 2,
	TMF_FAILED = 3,
	TMF_TIMEDOUT = 4,
	TMF_NOT_FOUND = 5,
};

enum {
	ISCSI_TASK_FREE = 0,
	ISCSI_TASK_COMPLETED = 1,
	ISCSI_TASK_PENDING = 2,
	ISCSI_TASK_RUNNING = 3,
	ISCSI_TASK_ABRT_TMF = 4,
	ISCSI_TASK_ABRT_SESS_RECOV = 5,
	ISCSI_TASK_REQUEUE_SCSIQ = 6,
};

enum {
	ISCSI_CONN_INITIAL_STAGE = 0,
	ISCSI_CONN_STARTED = 1,
	ISCSI_CONN_STOPPED = 2,
	ISCSI_CONN_CLEANUP_WAIT = 3,
};

struct iscsi_pool {
	struct kfifo queue;
	void **pool;
	int max;
};

struct iscsi_session {
	struct iscsi_cls_session *cls_session;
	struct mutex eh_mutex;
	uint32_t cmdsn;
	uint32_t exp_cmdsn;
	uint32_t max_cmdsn;
	uint32_t queued_cmdsn;
	int abort_timeout;
	int lu_reset_timeout;
	int tgt_reset_timeout;
	int initial_r2t_en;
	short unsigned int max_r2t;
	int imm_data_en;
	unsigned int first_burst;
	unsigned int max_burst;
	int time2wait;
	int time2retain;
	int pdu_inorder_en;
	int dataseq_inorder_en;
	int erl;
	int fast_abort;
	int tpgt;
	char *username;
	char *username_in;
	char *password;
	char *password_in;
	char *targetname;
	char *targetalias;
	char *ifacename;
	char *initiatorname;
	char *boot_root;
	char *boot_nic;
	char *boot_target;
	char *portal_type;
	char *discovery_parent_type;
	uint16_t discovery_parent_idx;
	uint16_t def_taskmgmt_tmo;
	uint16_t tsid;
	uint8_t auto_snd_tgt_disable;
	uint8_t discovery_sess;
	uint8_t chap_auth_en;
	uint8_t discovery_logout_en;
	uint8_t bidi_chap_en;
	uint8_t discovery_auth_optional;
	uint8_t isid[6];
	struct iscsi_transport *tt;
	struct Scsi_Host *host;
	struct iscsi_conn *leadconn;
	spinlock_t frwd_lock;
	spinlock_t back_lock;
	int state;
	int age;
	int scsi_cmds_max;
	int cmds_max;
	struct iscsi_task **cmds;
	struct iscsi_pool cmdpool;
	void *dd_data;
};

enum {
	ISCSI_STATE_FREE = 1,
	ISCSI_STATE_LOGGED_IN = 2,
	ISCSI_STATE_FAILED = 3,
	ISCSI_STATE_TERMINATE = 4,
	ISCSI_STATE_IN_RECOVERY = 5,
	ISCSI_STATE_RECOVERY_FAILED = 6,
	ISCSI_STATE_LOGGING_OUT = 7,
};

enum {
	ISCSI_HOST_SETUP = 0,
	ISCSI_HOST_REMOVED = 1,
};

struct iscsi_host {
	char *initiatorname;
	char *hwaddress;
	char *netdev;
	wait_queue_head_t session_removal_wq;
	spinlock_t lock;
	int num_sessions;
	int state;
	struct workqueue_struct *workq;
	char workq_name[20];
};

enum {
	FAILURE_BAD_HOST = 1,
	FAILURE_SESSION_FAILED = 2,
	FAILURE_SESSION_FREED = 3,
	FAILURE_WINDOW_CLOSED = 4,
	FAILURE_OOM = 5,
	FAILURE_SESSION_TERMINATE = 6,
	FAILURE_SESSION_IN_RECOVERY = 7,
	FAILURE_SESSION_RECOVERY_TIMEOUT = 8,
	FAILURE_SESSION_LOGGING_OUT = 9,
	FAILURE_SESSION_NOT_READY = 10,
};

struct skb_seq_state {
	__u32 lower_offset;
	__u32 upper_offset;
	__u32 frag_idx;
	__u32 stepped_offset;
	struct sk_buff *root_skb;
	struct sk_buff *cur_skb;
	__u8 *frag_data;
};

struct iscsi_r2t_rsp {
	uint8_t opcode;
	uint8_t flags;
	uint8_t rsvd2[2];
	uint8_t hlength;
	uint8_t dlength[3];
	struct scsi_lun lun;
	itt_t itt;
	__be32 ttt;
	__be32 statsn;
	__be32 exp_cmdsn;
	__be32 max_cmdsn;
	__be32 r2tsn;
	__be32 data_offset;
	__be32 data_length;
};

enum {
	ISCSI_MAX_AHS_SIZE = 256,
	ISCSI_DIGEST_SIZE = 4,
};

struct iscsi_tcp_conn;

struct iscsi_segment;

typedef int iscsi_segment_done_fn_t(struct iscsi_tcp_conn *, struct iscsi_segment *);

struct iscsi_segment {
	unsigned char *data;
	unsigned int size;
	unsigned int copied;
	unsigned int total_size;
	unsigned int total_copied;
	struct ahash_request *hash;
	unsigned char padbuf[4];
	unsigned char recv_digest[4];
	unsigned char digest[4];
	unsigned int digest_len;
	struct scatterlist *sg;
	void *sg_mapped;
	unsigned int sg_offset;
	bool atomic_mapped;
	iscsi_segment_done_fn_t *done;
};

struct iscsi_tcp_recv {
	struct iscsi_hdr *hdr;
	struct iscsi_segment segment;
	uint32_t hdr_buf[64];
	int datalen;
};

struct iscsi_tcp_conn {
	struct iscsi_conn *iscsi_conn;
	void *dd_data;
	int stop_stage;
	struct iscsi_tcp_recv in;
	struct ahash_request *rx_hash;
};

struct iscsi_tcp_task {
	uint32_t exp_datasn;
	int data_offset;
	struct iscsi_r2t_info *r2t;
	struct iscsi_pool r2tpool;
	struct kfifo r2tqueue;
	void *dd_data;
	spinlock_t pool2queue;
	spinlock_t queue2pool;
};

enum {
	ISCSI_TCP_SEGMENT_DONE = 0,
	ISCSI_TCP_SKB_DONE = 1,
	ISCSI_TCP_CONN_ERR = 2,
	ISCSI_TCP_SUSPENDED = 3,
};

struct iscsi_sw_tcp_send {
	struct iscsi_hdr *hdr;
	struct iscsi_segment segment;
	struct iscsi_segment data_segment;
};

struct iscsi_sw_tcp_conn {
	struct socket *sock;
	struct iscsi_sw_tcp_send out;
	void (*old_data_ready)(struct sock *);
	void (*old_state_change)(struct sock *);
	void (*old_write_space)(struct sock *);
	struct ahash_request *tx_hash;
	struct ahash_request *rx_hash;
	uint32_t sendpage_failures_cnt;
	uint32_t discontiguous_hdr_cnt;
	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
};

struct iscsi_sw_tcp_host {
	struct iscsi_session *session;
};

enum iscsi_boot_eth_properties_enum {
	ISCSI_BOOT_ETH_INDEX = 0,
	ISCSI_BOOT_ETH_FLAGS = 1,
	ISCSI_BOOT_ETH_IP_ADDR = 2,
	ISCSI_BOOT_ETH_PREFIX_LEN = 3,
	ISCSI_BOOT_ETH_SUBNET_MASK = 4,
	ISCSI_BOOT_ETH_ORIGIN = 5,
	ISCSI_BOOT_ETH_GATEWAY = 6,
	ISCSI_BOOT_ETH_PRIMARY_DNS = 7,
	ISCSI_BOOT_ETH_SECONDARY_DNS = 8,
	ISCSI_BOOT_ETH_DHCP = 9,
	ISCSI_BOOT_ETH_VLAN = 10,
	ISCSI_BOOT_ETH_MAC = 11,
	ISCSI_BOOT_ETH_HOSTNAME = 12,
	ISCSI_BOOT_ETH_END_MARKER = 13,
};

enum iscsi_boot_tgt_properties_enum {
	ISCSI_BOOT_TGT_INDEX = 0,
	ISCSI_BOOT_TGT_FLAGS = 1,
	ISCSI_BOOT_TGT_IP_ADDR = 2,
	ISCSI_BOOT_TGT_PORT = 3,
	ISCSI_BOOT_TGT_LUN = 4,
	ISCSI_BOOT_TGT_CHAP_TYPE = 5,
	ISCSI_BOOT_TGT_NIC_ASSOC = 6,
	ISCSI_BOOT_TGT_NAME = 7,
	ISCSI_BOOT_TGT_CHAP_NAME = 8,
	ISCSI_BOOT_TGT_CHAP_SECRET = 9,
	ISCSI_BOOT_TGT_REV_CHAP_NAME = 10,
	ISCSI_BOOT_TGT_REV_CHAP_SECRET = 11,
	ISCSI_BOOT_TGT_END_MARKER = 12,
};

enum iscsi_boot_initiator_properties_enum {
	ISCSI_BOOT_INI_INDEX = 0,
	ISCSI_BOOT_INI_FLAGS = 1,
	ISCSI_BOOT_INI_ISNS_SERVER = 2,
	ISCSI_BOOT_INI_SLP_SERVER = 3,
	ISCSI_BOOT_INI_PRI_RADIUS_SERVER = 4,
	ISCSI_BOOT_INI_SEC_RADIUS_SERVER = 5,
	ISCSI_BOOT_INI_INITIATOR_NAME = 6,
	ISCSI_BOOT_INI_END_MARKER = 7,
};

enum iscsi_boot_acpitbl_properties_enum {
	ISCSI_BOOT_ACPITBL_SIGNATURE = 0,
	ISCSI_BOOT_ACPITBL_OEM_ID = 1,
	ISCSI_BOOT_ACPITBL_OEM_TABLE_ID = 2,
};

struct iscsi_boot_kobj {
	struct kobject kobj;
	struct attribute_group *attr_group;
	struct list_head list;
	void *data;
	ssize_t (*show)(void *, int, char *);
	umode_t (*is_visible)(void *, int);
	void (*release)(void *);
};

struct iscsi_boot_kset {
	struct list_head kobj_list;
	struct kset *kset;
};

struct iscsi_boot_attr {
	struct attribute attr;
	int type;
	ssize_t (*show)(void *, int, char *);
};

enum blogic_msglevel {
	BLOGIC_ANNOUNCE_LEVEL = 0,
	BLOGIC_INFO_LEVEL = 1,
	BLOGIC_NOTICE_LEVEL = 2,
	BLOGIC_WARN_LEVEL = 3,
	BLOGIC_ERR_LEVEL = 4,
};

enum blogic_adapter_type {
	BLOGIC_MULTIMASTER = 1,
	BLOGIC_FLASHPOINT = 2,
};

enum blogic_adapter_bus_type {
	BLOGIC_UNKNOWN_BUS = 0,
	BLOGIC_ISA_BUS = 1,
	BLOGIC_EISA_BUS = 2,
	BLOGIC_PCI_BUS = 3,
	BLOGIC_VESA_BUS = 4,
	BLOGIC_MCA_BUS = 5,
};

enum blogic_bios_diskgeometry {
	BLOGIC_BIOS_NODISK = 0,
	BLOGIC_BIOS_DISK64x32 = 1,
	BLOGIC_BIOS_DISK128x32 = 2,
	BLOGIC_BIOS_DISK255x63 = 3,
};

struct blogic_byte_count {
	unsigned int units;
	unsigned int billions;
};

struct blogic_probeinfo {
	enum blogic_adapter_type adapter_type;
	enum blogic_adapter_bus_type adapter_bus_type;
	long unsigned int io_addr;
	long unsigned int pci_addr;
	struct pci_dev *pci_device;
	unsigned char bus;
	unsigned char dev;
	unsigned char irq_ch;
};

struct blogic_probe_options {
	bool noprobe: 1;
	bool noprobe_isa: 1;
	bool noprobe_pci: 1;
	bool nosort_pci: 1;
	bool multimaster_first: 1;
	bool flashpoint_first: 1;
	bool limited_isa: 1;
	bool probe330: 1;
	bool probe334: 1;
	bool probe230: 1;
	bool probe234: 1;
	bool probe130: 1;
	bool probe134: 1;
};

struct blogic_global_options {
	bool trace_probe: 1;
	bool trace_hw_reset: 1;
	bool trace_config: 1;
	bool trace_err: 1;
};

union blogic_cntrl_reg {
	unsigned char all;
	struct {
		char: 4;
		bool bus_reset: 1;
		bool int_reset: 1;
		bool soft_reset: 1;
		bool hard_reset: 1;
	} cr;
};

union blogic_stat_reg {
	unsigned char all;
	struct {
		bool cmd_invalid: 1;
		bool rsvd: 1;
		bool datain_ready: 1;
		bool cmd_param_busy: 1;
		bool adapter_ready: 1;
		bool init_reqd: 1;
		bool diag_failed: 1;
		bool diag_active: 1;
	} sr;
};

union blogic_int_reg {
	unsigned char all;
	struct {
		bool mailin_loaded: 1;
		bool mailout_avail: 1;
		bool cmd_complete: 1;
		bool ext_busreset: 1;
		unsigned char rsvd: 3;
		bool int_valid: 1;
	} ir;
};

union blogic_geo_reg {
	unsigned char all;
	struct {
		enum blogic_bios_diskgeometry d0_geo: 2;
		enum blogic_bios_diskgeometry d1_geo: 2;
		char: 3;
		bool ext_trans_enable: 1;
	} gr;
};

enum blogic_opcode {
	BLOGIC_TEST_CMP_COMPLETE = 0,
	BLOGIC_INIT_MBOX = 1,
	BLOGIC_EXEC_MBOX_CMD = 2,
	BLOGIC_EXEC_BIOS_CMD = 3,
	BLOGIC_GET_BOARD_ID = 4,
	BLOGIC_ENABLE_OUTBOX_AVAIL_INT = 5,
	BLOGIC_SET_SELECT_TIMEOUT = 6,
	BLOGIC_SET_PREEMPT_TIME = 7,
	BLOGIC_SET_TIMEOFF_BUS = 8,
	BLOGIC_SET_TXRATE = 9,
	BLOGIC_INQ_DEV0TO7 = 10,
	BLOGIC_INQ_CONFIG = 11,
	BLOGIC_TGT_MODE = 12,
	BLOGIC_INQ_SETUPINFO = 13,
	BLOGIC_WRITE_LOCALRAM = 26,
	BLOGIC_READ_LOCALRAM = 27,
	BLOGIC_WRITE_BUSMASTER_FIFO = 28,
	BLOGIC_READ_BUSMASTER_FIFO = 29,
	BLOGIC_ECHO_CMDDATA = 31,
	BLOGIC_ADAPTER_DIAG = 32,
	BLOGIC_SET_OPTIONS = 33,
	BLOGIC_INQ_DEV8TO15 = 35,
	BLOGIC_INQ_DEV = 36,
	BLOGIC_DISABLE_INT = 37,
	BLOGIC_INIT_EXT_MBOX = 129,
	BLOGIC_EXEC_SCS_CMD = 131,
	BLOGIC_INQ_FWVER_D3 = 132,
	BLOGIC_INQ_FWVER_LETTER = 133,
	BLOGIC_INQ_PCI_INFO = 134,
	BLOGIC_INQ_MODELNO = 139,
	BLOGIC_INQ_SYNC_PERIOD = 140,
	BLOGIC_INQ_EXTSETUP = 141,
	BLOGIC_STRICT_RR = 143,
	BLOGIC_STORE_LOCALRAM = 144,
	BLOGIC_FETCH_LOCALRAM = 145,
	BLOGIC_STORE_TO_EEPROM = 146,
	BLOGIC_LOAD_AUTOSCSICODE = 148,
	BLOGIC_MOD_IOADDR = 149,
	BLOGIC_SETCCB_FMT = 150,
	BLOGIC_WRITE_INQBUF = 154,
	BLOGIC_READ_INQBUF = 155,
	BLOGIC_FLASH_LOAD = 167,
	BLOGIC_READ_SCAMDATA = 168,
	BLOGIC_WRITE_SCAMDATA = 169,
};

struct blogic_board_id {
	unsigned char type;
	unsigned char custom_features;
	unsigned char fw_ver_digit1;
	unsigned char fw_ver_digit2;
};

struct blogic_config {
	char: 5;
	bool dma_ch5: 1;
	bool dma_ch6: 1;
	bool dma_ch7: 1;
	bool irq_ch9: 1;
	bool irq_ch10: 1;
	bool irq_ch11: 1;
	bool irq_ch12: 1;
	char: 1;
	bool irq_ch14: 1;
	bool irq_ch15: 1;
	char: 1;
	unsigned char id: 4;
};

struct blogic_syncval {
	unsigned char offset: 4;
	unsigned char tx_period: 3;
	bool sync: 1;
};

struct blogic_setup_info {
	bool sync: 1;
	bool parity: 1;
	unsigned char tx_rate;
	unsigned char preempt_time;
	unsigned char timeoff_bus;
	unsigned char mbox_count;
	unsigned char mbox_addr[3];
	struct blogic_syncval sync0to7[8];
	unsigned char disconnect_ok0to7;
	unsigned char sig;
	unsigned char char_d;
	unsigned char bus_type;
	unsigned char wide_tx_ok0to7;
	unsigned char wide_tx_active0to7;
	struct blogic_syncval sync8to15[8];
	unsigned char disconnect_ok8to15;
	char: 8;
	unsigned char wide_tx_ok8to15;
	unsigned char wide_tx_active8to15;
};

struct blogic_extmbox_req {
	unsigned char mbox_count;
	u32 base_mbox_addr;
} __attribute__((packed));

enum blogic_isa_ioport {
	BLOGIC_IO_330 = 0,
	BLOGIC_IO_334 = 1,
	BLOGIC_IO_230 = 2,
	BLOGIC_IO_234 = 3,
	BLOGIC_IO_130 = 4,
	BLOGIC_IO_134 = 5,
	BLOGIC_IO_DISABLE = 6,
	BLOGIC_IO_DISABLE2 = 7,
};

struct blogic_adapter_info {
	enum blogic_isa_ioport isa_port;
	unsigned char irq_ch;
	bool low_term: 1;
	bool high_term: 1;
	char: 2;
	bool JP1: 1;
	bool JP2: 1;
	bool JP3: 1;
	bool genericinfo_valid: 1;
	char: 8;
};

struct blogic_ext_setup {
	unsigned char bus_type;
	unsigned char bios_addr;
	short unsigned int sg_limit;
	unsigned char mbox_count;
	u32 base_mbox_addr;
	struct {
		char: 2;
		bool fast_on_eisa: 1;
		char: 3;
		bool level_int: 1;
	} misc;
	unsigned char fw_rev[3];
	bool wide: 1;
	bool differential: 1;
	bool scam: 1;
	bool ultra: 1;
	bool smart_term: 1;
} __attribute__((packed));

enum blogic_rr_req {
	BLOGIC_AGGRESSIVE_RR = 0,
	BLOGIC_STRICT_RR_MODE = 1,
};

struct blogic_fetch_localram {
	unsigned char offset;
	unsigned char count;
};

struct blogic_autoscsi {
	unsigned char factory_sig[2];
	unsigned char info_bytes;
	unsigned char adapter_type[6];
	char: 8;
	bool floppy: 1;
	bool floppy_sec: 1;
	bool level_int: 1;
	char: 2;
	unsigned char systemram_bios: 3;
	unsigned char dma_ch: 7;
	bool dma_autoconf: 1;
	unsigned char irq_ch: 7;
	bool irq_autoconf: 1;
	unsigned char dma_tx_rate;
	unsigned char scsi_id;
	bool low_term: 1;
	bool parity: 1;
	bool high_term: 1;
	bool noisy_cable: 1;
	bool fast_sync_neg: 1;
	bool reset_enabled: 1;
	char: 1;
	bool active_negation: 1;
	unsigned char bus_on_delay;
	unsigned char bus_off_delay;
	bool bios_enabled: 1;
	bool int19_redir_enabled: 1;
	bool ext_trans_enable: 1;
	bool removable_as_fixed: 1;
	char: 1;
	bool morethan2_drives: 1;
	bool bios_int: 1;
	bool floptical: 1;
	short unsigned int dev_enabled;
	short unsigned int wide_ok;
	short unsigned int fast_ok;
	short unsigned int sync_ok;
	short unsigned int discon_ok;
	short unsigned int send_start_unit;
	short unsigned int ignore_bios_scan;
	unsigned char pci_int_pin: 2;
	unsigned char adapter_ioport: 2;
	bool strict_rr_enabled: 1;
	bool vesabus_33mhzplus: 1;
	bool vesa_burst_write: 1;
	bool vesa_burst_read: 1;
	short unsigned int ultra_ok;
	long: 40;
	unsigned char autoscsi_maxlun;
	char: 1;
	bool scam_dominant: 1;
	bool scam_enabled: 1;
	bool scam_lev2: 1;
	char: 4;
	bool int13_exten: 1;
	char: 1;
	bool cd_boot: 1;
	char: 5;
	unsigned char boot_id: 4;
	unsigned char boot_ch: 4;
	unsigned char force_scan_order: 1;
	short unsigned int nontagged_to_alt_ok;
	short unsigned int reneg_sync_on_check;
	unsigned char rsvd[10];
	unsigned char manuf_diag[2];
	short unsigned int cksum;
} __attribute__((packed));

struct blogic_autoscsi_byte45 {
	unsigned char force_scan_order: 1;
};

struct blogic_bios_drvmap {
	unsigned char tgt_idbit3: 1;
	char: 2;
	enum blogic_bios_diskgeometry diskgeom: 2;
	unsigned char tgt_id: 3;
};

enum blogic_setccb_fmt {
	BLOGIC_LEGACY_LUN_CCB = 0,
	BLOGIC_EXT_LUN_CCB = 1,
};

enum blogic_action {
	BLOGIC_OUTBOX_FREE = 0,
	BLOGIC_MBOX_START = 1,
	BLOGIC_MBOX_ABORT = 2,
};

enum blogic_cmplt_code {
	BLOGIC_INBOX_FREE = 0,
	BLOGIC_CMD_COMPLETE_GOOD = 1,
	BLOGIC_CMD_ABORT_BY_HOST = 2,
	BLOGIC_CMD_NOTFOUND = 3,
	BLOGIC_CMD_COMPLETE_ERROR = 4,
	BLOGIC_INVALID_CCB = 5,
};

enum blogic_ccb_opcode {
	BLOGIC_INITIATOR_CCB = 0,
	BLOGIC_TGT_CCB = 1,
	BLOGIC_INITIATOR_CCB_SG = 2,
	BLOGIC_INITIATOR_CCBB_RESIDUAL = 3,
	BLOGIC_INITIATOR_CCB_SG_RESIDUAL = 4,
	BLOGIC_BDR = 129,
};

enum blogic_datadir {
	BLOGIC_UNCHECKED_TX = 0,
	BLOGIC_DATAIN_CHECKED = 1,
	BLOGIC_DATAOUT_CHECKED = 2,
	BLOGIC_NOTX = 3,
};

enum blogic_adapter_status {
	BLOGIC_CMD_CMPLT_NORMAL = 0,
	BLOGIC_LINK_CMD_CMPLT = 10,
	BLOGIC_LINK_CMD_CMPLT_FLAG = 11,
	BLOGIC_DATA_UNDERRUN = 12,
	BLOGIC_SELECT_TIMEOUT = 17,
	BLOGIC_DATA_OVERRUN = 18,
	BLOGIC_NOEXPECT_BUSFREE = 19,
	BLOGIC_INVALID_BUSPHASE = 20,
	BLOGIC_INVALID_OUTBOX_CODE = 21,
	BLOGIC_INVALID_CMD_CODE = 22,
	BLOGIC_LINKCCB_BADLUN = 23,
	BLOGIC_BAD_CMD_PARAM = 26,
	BLOGIC_AUTOREQSENSE_FAIL = 27,
	BLOGIC_TAGQUEUE_REJECT = 28,
	BLOGIC_BAD_MSG_RCVD = 29,
	BLOGIC_HW_FAIL = 32,
	BLOGIC_NORESPONSE_TO_ATN = 33,
	BLOGIC_HW_RESET = 34,
	BLOGIC_RST_FROM_OTHERDEV = 35,
	BLOGIC_BAD_RECONNECT = 36,
	BLOGIC_HW_BDR = 37,
	BLOGIC_ABRT_QUEUE = 38,
	BLOGIC_ADAPTER_SW_ERROR = 39,
	BLOGIC_HW_TIMEOUT = 48,
	BLOGIC_PARITY_ERR = 52,
};

enum blogic_tgt_status {
	BLOGIC_OP_GOOD = 0,
	BLOGIC_CHECKCONDITION = 2,
	BLOGIC_DEVBUSY = 8,
};

enum blogic_queuetag {
	BLOGIC_SIMPLETAG = 0,
	BLOGIC_HEADTAG = 1,
	BLOGIC_ORDEREDTAG = 2,
	BLOGIC_RSVDTAG = 3,
};

struct blogic_sg_seg {
	u32 segbytes;
	u32 segdata;
};

enum blogic_ccb_status {
	BLOGIC_CCB_FREE = 0,
	BLOGIC_CCB_ACTIVE = 1,
	BLOGIC_CCB_COMPLETE = 2,
	BLOGIC_CCB_RESET = 3,
};

struct blogic_adapter;

struct blogic_ccb {
	enum blogic_ccb_opcode opcode;
	char: 3;
	enum blogic_datadir datadir: 2;
	bool tag_enable: 1;
	enum blogic_queuetag queuetag: 2;
	unsigned char cdblen;
	unsigned char sense_datalen;
	u32 datalen;
	void *data;
	short: 16;
	enum blogic_adapter_status adapter_status;
	enum blogic_tgt_status tgt_status;
	unsigned char tgt_id;
	unsigned char lun: 5;
	bool legacytag_enable: 1;
	enum blogic_queuetag legacy_tag: 2;
	unsigned char cdb[12];
	u32 rsvd_int;
	u32 sensedata;
	void (*callback)(struct blogic_ccb *);
	u32 base_addr;
	enum blogic_cmplt_code comp_code;
	dma_addr_t allocgrp_head;
	unsigned int allocgrp_size;
	u32 dma_handle;
	enum blogic_ccb_status status;
	long unsigned int serial;
	struct scsi_cmnd *command;
	struct blogic_adapter *adapter;
	struct blogic_ccb *next;
	struct blogic_ccb *next_all;
	struct blogic_sg_seg sglist[128];
};

struct fpoint_info {
	u32 base_addr;
	bool present;
	unsigned char irq_ch;
	unsigned char scsi_id;
	unsigned char scsi_lun;
	u16 fw_rev;
	u16 sync_ok;
	u16 fast_ok;
	u16 ultra_ok;
	u16 discon_ok;
	u16 wide_ok;
	bool parity: 1;
	bool wide: 1;
	bool softreset: 1;
	bool ext_trans_enable: 1;
	bool low_term: 1;
	bool high_term: 1;
	bool report_underrun: 1;
	bool scam_enabled: 1;
	bool scam_lev2: 1;
	unsigned char family;
	unsigned char bus_type;
	unsigned char model[3];
	unsigned char relative_cardnum;
	unsigned char rsvd[4];
	u32 os_rsvd;
	unsigned char translation_info[4];
	u32 rsvd2[5];
	u32 sec_range;
};

struct blogic_tgt_flags {
	bool tgt_exists: 1;
	bool tagq_ok: 1;
	bool wide_ok: 1;
	bool tagq_active: 1;
	bool wide_active: 1;
	bool cmd_good: 1;
	bool tgt_info_in: 1;
};

struct blogic_tgt_stats {
	unsigned int cmds_tried;
	unsigned int cmds_complete;
	unsigned int read_cmds;
	unsigned int write_cmds;
	struct blogic_byte_count bytesread;
	struct blogic_byte_count byteswritten;
	unsigned int read_sz_buckets[10];
	unsigned int write_sz_buckets[10];
	short unsigned int aborts_request;
	short unsigned int aborts_tried;
	short unsigned int aborts_done;
	short unsigned int bdr_request;
	short unsigned int bdr_tried;
	short unsigned int bdr_done;
	short unsigned int adapter_reset_req;
	short unsigned int adapter_reset_attempt;
	short unsigned int adapter_reset_done;
};

struct blogic_drvr_options;

struct blogic_outbox;

struct blogic_inbox;

struct blogic_adapter {
	struct Scsi_Host *scsi_host;
	struct pci_dev *pci_device;
	enum blogic_adapter_type adapter_type;
	enum blogic_adapter_bus_type adapter_bus_type;
	long unsigned int io_addr;
	long unsigned int pci_addr;
	short unsigned int addr_count;
	unsigned char host_no;
	unsigned char model[9];
	unsigned char fw_ver[6];
	unsigned char full_model[18];
	unsigned char bus;
	unsigned char dev;
	unsigned char irq_ch;
	unsigned char dma_ch;
	unsigned char scsi_id;
	bool irq_acquired: 1;
	bool dma_chan_acquired: 1;
	bool ext_trans_enable: 1;
	bool parity: 1;
	bool reset_enabled: 1;
	bool level_int: 1;
	bool wide: 1;
	bool differential: 1;
	bool scam: 1;
	bool ultra: 1;
	bool ext_lun: 1;
	bool terminfo_valid: 1;
	bool low_term: 1;
	bool high_term: 1;
	bool need_bouncebuf: 1;
	bool strict_rr: 1;
	bool scam_enabled: 1;
	bool scam_lev2: 1;
	bool adapter_initd: 1;
	bool adapter_extreset: 1;
	bool adapter_intern_err: 1;
	bool processing_ccbs;
	volatile bool adapter_cmd_complete;
	short unsigned int adapter_sglimit;
	short unsigned int drvr_sglimit;
	short unsigned int maxdev;
	short unsigned int maxlun;
	short unsigned int mbox_count;
	short unsigned int initccbs;
	short unsigned int inc_ccbs;
	short unsigned int alloc_ccbs;
	short unsigned int drvr_qdepth;
	short unsigned int adapter_qdepth;
	short unsigned int untag_qdepth;
	short unsigned int common_qdepth;
	short unsigned int bus_settle_time;
	short unsigned int sync_ok;
	short unsigned int fast_ok;
	short unsigned int ultra_ok;
	short unsigned int wide_ok;
	short unsigned int discon_ok;
	short unsigned int tagq_ok;
	short unsigned int ext_resets;
	short unsigned int adapter_intern_errors;
	short unsigned int tgt_count;
	short unsigned int msgbuflen;
	u32 bios_addr;
	struct blogic_drvr_options *drvr_opts;
	struct fpoint_info fpinfo;
	void *cardhandle;
	struct list_head host_list;
	struct blogic_ccb *all_ccbs;
	struct blogic_ccb *free_ccbs;
	struct blogic_ccb *firstccb;
	struct blogic_ccb *lastccb;
	struct blogic_ccb *bdr_pend[16];
	struct blogic_tgt_flags tgt_flags[16];
	unsigned char qdepth[16];
	unsigned char sync_period[16];
	unsigned char sync_offset[16];
	unsigned char active_cmds[16];
	unsigned int cmds_since_rst[16];
	long unsigned int last_seqpoint[16];
	long unsigned int last_resettried[16];
	long unsigned int last_resetdone[16];
	struct blogic_outbox *first_outbox;
	struct blogic_outbox *last_outbox;
	struct blogic_outbox *next_outbox;
	struct blogic_inbox *first_inbox;
	struct blogic_inbox *last_inbox;
	struct blogic_inbox *next_inbox;
	struct blogic_tgt_stats tgt_stats[16];
	unsigned char *mbox_space;
	dma_addr_t mbox_space_handle;
	unsigned int mbox_sz;
	long unsigned int ccb_offset;
	char msgbuf[9700];
};

struct blogic_outbox {
	u32 ccb;
	int: 24;
	enum blogic_action action;
};

struct blogic_inbox {
	u32 ccb;
	enum blogic_adapter_status adapter_status;
	enum blogic_tgt_status tgt_status;
	char: 8;
	enum blogic_cmplt_code comp_code;
};

struct blogic_drvr_options {
	short unsigned int tagq_ok;
	short unsigned int tagq_ok_mask;
	short unsigned int bus_settle_time;
	short unsigned int stop_tgt_inquiry;
	unsigned char common_qdepth;
	unsigned char qdepth[16];
};

struct bios_diskparam {
	int heads;
	int sectors;
	int cylinders;
};

struct scsi_inquiry {
	unsigned char devtype: 5;
	unsigned char dev_qual: 3;
	unsigned char dev_modifier: 7;
	bool rmb: 1;
	unsigned char ansi_ver: 3;
	unsigned char ecma_ver: 3;
	unsigned char iso_ver: 2;
	unsigned char resp_fmt: 4;
	char: 2;
	bool TrmIOP: 1;
	bool AENC: 1;
	unsigned char addl_len;
	short: 16;
	bool SftRe: 1;
	bool CmdQue: 1;
	char: 1;
	bool linked: 1;
	bool sync: 1;
	bool WBus16: 1;
	bool WBus32: 1;
	bool RelAdr: 1;
	unsigned char vendor[8];
	unsigned char product[16];
	unsigned char product_rev[4];
};

struct SG32ENTRY {
	__le32 length;
	__le32 address;
};

struct SG64ENTRY {
	__le32 length;
	__le32 address;
	__le32 addresshigh;
};

struct QBUFFER {
	uint32_t data_len;
	uint8_t data[124];
};

struct ARCMSR_CDB {
	uint8_t Bus;
	uint8_t TargetID;
	uint8_t LUN;
	uint8_t Function;
	uint8_t CdbLength;
	uint8_t sgcount;
	uint8_t Flags;
	uint8_t msgPages;
	uint32_t msgContext;
	uint32_t DataLength;
	uint8_t Cdb[16];
	uint8_t DeviceStatus;
	uint8_t SenseData[15];
	union {
		struct SG32ENTRY sg32entry[1];
		struct SG64ENTRY sg64entry[1];
	} u;
};

struct MessageUnit_A {
	uint32_t resrved0[4];
	uint32_t inbound_msgaddr0;
	uint32_t inbound_msgaddr1;
	uint32_t outbound_msgaddr0;
	uint32_t outbound_msgaddr1;
	uint32_t inbound_doorbell;
	uint32_t inbound_intstatus;
	uint32_t inbound_intmask;
	uint32_t outbound_doorbell;
	uint32_t outbound_intstatus;
	uint32_t outbound_intmask;
	uint32_t reserved1[2];
	uint32_t inbound_queueport;
	uint32_t outbound_queueport;
	uint32_t reserved2[2];
	uint32_t reserved3[492];
	uint32_t reserved4[128];
	uint32_t message_rwbuffer[256];
	uint32_t message_wbuffer[32];
	uint32_t reserved5[32];
	uint32_t message_rbuffer[32];
	uint32_t reserved6[32];
};

struct MessageUnit_B {
	uint32_t post_qbuffer[264];
	uint32_t done_qbuffer[264];
	uint32_t postq_index;
	uint32_t doneq_index;
	uint32_t *drv2iop_doorbell;
	uint32_t *drv2iop_doorbell_mask;
	uint32_t *iop2drv_doorbell;
	uint32_t *iop2drv_doorbell_mask;
	uint32_t *message_rwbuffer;
	uint32_t *message_wbuffer;
	uint32_t *message_rbuffer;
};

struct MessageUnit_C {
	uint32_t message_unit_status;
	uint32_t slave_error_attribute;
	uint32_t slave_error_address;
	uint32_t posted_outbound_doorbell;
	uint32_t master_error_attribute;
	uint32_t master_error_address_low;
	uint32_t master_error_address_high;
	uint32_t hcb_size;
	uint32_t inbound_doorbell;
	uint32_t diagnostic_rw_data;
	uint32_t diagnostic_rw_address_low;
	uint32_t diagnostic_rw_address_high;
	uint32_t host_int_status;
	uint32_t host_int_mask;
	uint32_t dcr_data;
	uint32_t dcr_address;
	uint32_t inbound_queueport;
	uint32_t outbound_queueport;
	uint32_t hcb_pci_address_low;
	uint32_t hcb_pci_address_high;
	uint32_t iop_int_status;
	uint32_t iop_int_mask;
	uint32_t iop_inbound_queue_port;
	uint32_t iop_outbound_queue_port;
	uint32_t inbound_free_list_index;
	uint32_t inbound_post_list_index;
	uint32_t outbound_free_list_index;
	uint32_t outbound_post_list_index;
	uint32_t inbound_doorbell_clear;
	uint32_t i2o_message_unit_control;
	uint32_t last_used_message_source_address_low;
	uint32_t last_used_message_source_address_high;
	uint32_t pull_mode_data_byte_count[4];
	uint32_t message_dest_address_index;
	uint32_t done_queue_not_empty_int_counter_timer;
	uint32_t utility_A_int_counter_timer;
	uint32_t outbound_doorbell;
	uint32_t outbound_doorbell_clear;
	uint32_t message_source_address_index;
	uint32_t message_done_queue_index;
	uint32_t reserved0;
	uint32_t inbound_msgaddr0;
	uint32_t inbound_msgaddr1;
	uint32_t outbound_msgaddr0;
	uint32_t outbound_msgaddr1;
	uint32_t inbound_queueport_low;
	uint32_t inbound_queueport_high;
	uint32_t outbound_queueport_low;
	uint32_t outbound_queueport_high;
	uint32_t iop_inbound_queue_port_low;
	uint32_t iop_inbound_queue_port_high;
	uint32_t iop_outbound_queue_port_low;
	uint32_t iop_outbound_queue_port_high;
	uint32_t message_dest_queue_port_low;
	uint32_t message_dest_queue_port_high;
	uint32_t last_used_message_dest_address_low;
	uint32_t last_used_message_dest_address_high;
	uint32_t message_done_queue_base_address_low;
	uint32_t message_done_queue_base_address_high;
	uint32_t host_diagnostic;
	uint32_t write_sequence;
	uint32_t reserved1[34];
	uint32_t reserved2[1950];
	uint32_t message_wbuffer[32];
	uint32_t reserved3[32];
	uint32_t message_rbuffer[32];
	uint32_t reserved4[32];
	uint32_t msgcode_rwbuffer[256];
};

struct InBound_SRB {
	uint32_t addressLow;
	uint32_t addressHigh;
	uint32_t length;
	uint32_t reserved0;
};

struct OutBound_SRB {
	uint32_t addressLow;
	uint32_t addressHigh;
};

struct MessageUnit_D {
	struct InBound_SRB post_qbuffer[256];
	volatile struct OutBound_SRB done_qbuffer[257];
	u16 postq_index;
	volatile u16 doneq_index;
	u32 *chip_id;
	u32 *cpu_mem_config;
	u32 *i2o_host_interrupt_mask;
	u32 *sample_at_reset;
	u32 *reset_request;
	u32 *host_int_status;
	u32 *pcief0_int_enable;
	u32 *inbound_msgaddr0;
	u32 *inbound_msgaddr1;
	u32 *outbound_msgaddr0;
	u32 *outbound_msgaddr1;
	u32 *inbound_doorbell;
	u32 *outbound_doorbell;
	u32 *outbound_doorbell_enable;
	u32 *inboundlist_base_low;
	u32 *inboundlist_base_high;
	u32 *inboundlist_write_pointer;
	u32 *outboundlist_base_low;
	u32 *outboundlist_base_high;
	u32 *outboundlist_copy_pointer;
	u32 *outboundlist_read_pointer;
	u32 *outboundlist_interrupt_cause;
	u32 *outboundlist_interrupt_enable;
	u32 *message_wbuffer;
	u32 *message_rbuffer;
	u32 *msgcode_rwbuffer;
};

struct MessageUnit_E {
	uint32_t iobound_doorbell;
	uint32_t write_sequence_3xxx;
	uint32_t host_diagnostic_3xxx;
	uint32_t posted_outbound_doorbell;
	uint32_t master_error_attribute;
	uint32_t master_error_address_low;
	uint32_t master_error_address_high;
	uint32_t hcb_size;
	uint32_t inbound_doorbell;
	uint32_t diagnostic_rw_data;
	uint32_t diagnostic_rw_address_low;
	uint32_t diagnostic_rw_address_high;
	uint32_t host_int_status;
	uint32_t host_int_mask;
	uint32_t dcr_data;
	uint32_t dcr_address;
	uint32_t inbound_queueport;
	uint32_t outbound_queueport;
	uint32_t hcb_pci_address_low;
	uint32_t hcb_pci_address_high;
	uint32_t iop_int_status;
	uint32_t iop_int_mask;
	uint32_t iop_inbound_queue_port;
	uint32_t iop_outbound_queue_port;
	uint32_t inbound_free_list_index;
	uint32_t inbound_post_list_index;
	uint32_t reply_post_producer_index;
	uint32_t reply_post_consumer_index;
	uint32_t inbound_doorbell_clear;
	uint32_t i2o_message_unit_control;
	uint32_t last_used_message_source_address_low;
	uint32_t last_used_message_source_address_high;
	uint32_t pull_mode_data_byte_count[4];
	uint32_t message_dest_address_index;
	uint32_t done_queue_not_empty_int_counter_timer;
	uint32_t utility_A_int_counter_timer;
	uint32_t outbound_doorbell;
	uint32_t outbound_doorbell_clear;
	uint32_t message_source_address_index;
	uint32_t message_done_queue_index;
	uint32_t reserved0;
	uint32_t inbound_msgaddr0;
	uint32_t inbound_msgaddr1;
	uint32_t outbound_msgaddr0;
	uint32_t outbound_msgaddr1;
	uint32_t inbound_queueport_low;
	uint32_t inbound_queueport_high;
	uint32_t outbound_queueport_low;
	uint32_t outbound_queueport_high;
	uint32_t iop_inbound_queue_port_low;
	uint32_t iop_inbound_queue_port_high;
	uint32_t iop_outbound_queue_port_low;
	uint32_t iop_outbound_queue_port_high;
	uint32_t message_dest_queue_port_low;
	uint32_t message_dest_queue_port_high;
	uint32_t last_used_message_dest_address_low;
	uint32_t last_used_message_dest_address_high;
	uint32_t message_done_queue_base_address_low;
	uint32_t message_done_queue_base_address_high;
	uint32_t host_diagnostic;
	uint32_t write_sequence;
	uint32_t reserved1[34];
	uint32_t reserved2[1950];
	uint32_t message_wbuffer[32];
	uint32_t reserved3[32];
	uint32_t message_rbuffer[32];
	uint32_t reserved4[32];
	uint32_t msgcode_rwbuffer[256];
};

struct deliver_completeQ {
	uint16_t cmdFlag;
	uint16_t cmdSMID;
	uint16_t cmdLMID;
	uint16_t cmdFlag2;
};

typedef struct deliver_completeQ *pCompletion_Q;

struct CommandControlBlock;

struct AdapterControlBlock {
	uint32_t adapter_type;
	u32 ioqueue_size;
	struct pci_dev *pdev;
	struct Scsi_Host *host;
	long unsigned int vir2phy_offset;
	uint32_t outbound_int_enable;
	uint32_t cdb_phyaddr_hi32;
	uint32_t reg_mu_acc_handle0;
	uint64_t cdb_phyadd_hipart;
	spinlock_t eh_lock;
	spinlock_t ccblist_lock;
	spinlock_t postq_lock;
	spinlock_t doneq_lock;
	spinlock_t rqbuffer_lock;
	spinlock_t wqbuffer_lock;
	union {
		struct MessageUnit_A *pmuA;
		struct MessageUnit_B *pmuB;
		struct MessageUnit_C *pmuC;
		struct MessageUnit_D *pmuD;
		struct MessageUnit_E *pmuE;
	};
	void *mem_base0;
	void *mem_base1;
	uint32_t acb_flags;
	u16 dev_id;
	uint8_t adapter_index;
	struct CommandControlBlock *pccb_pool[1024];
	struct list_head ccb_free_list;
	atomic_t ccboutstandingcount;
	void *dma_coherent;
	dma_addr_t dma_coherent_handle;
	dma_addr_t dma_coherent_handle2;
	void *dma_coherent2;
	unsigned int uncache_size;
	uint8_t rqbuffer[4096];
	int32_t rqbuf_getIndex;
	int32_t rqbuf_putIndex;
	uint8_t wqbuffer[4096];
	int32_t wqbuf_getIndex;
	int32_t wqbuf_putIndex;
	uint8_t devstate[136];
	uint32_t num_resets;
	uint32_t num_aborts;
	uint32_t signature;
	uint32_t firm_request_len;
	uint32_t firm_numbers_queue;
	uint32_t firm_sdram_size;
	uint32_t firm_hd_channels;
	uint32_t firm_cfg_version;
	char firm_model[12];
	char firm_version[20];
	char device_map[20];
	struct work_struct arcmsr_do_message_isr_bh;
	struct timer_list eternal_timer;
	short unsigned int fw_flag;
	atomic_t rq_map_token;
	atomic_t ante_token_value;
	uint32_t maxOutstanding;
	int vector_count;
	uint32_t maxFreeCCB;
	struct timer_list refresh_timer;
	uint32_t doneq_index;
	uint32_t ccbsize;
	uint32_t in_doorbell;
	uint32_t out_doorbell;
	uint32_t completionQ_entry;
	pCompletion_Q pCompletionQ;
};

struct CommandControlBlock {
	struct list_head list;
	struct scsi_cmnd *pcmd;
	struct AdapterControlBlock *acb;
	long unsigned int cdb_phyaddr;
	uint32_t arc_cdb_size;
	uint16_t ccb_flags;
	uint16_t startdone;
	uint32_t smid;
	uint32_t reserved[3];
	struct ARCMSR_CDB arcmsr_cdb;
};

typedef s8 int8_t;

typedef s16 int16_t;

struct CMD_MESSAGE {
	uint32_t HeaderLength;
	uint8_t Signature[8];
	uint32_t Timeout;
	uint32_t ControlCode;
	uint32_t ReturnCode;
	uint32_t Length;
};

struct CMD_MESSAGE_FIELD {
	struct CMD_MESSAGE cmdmessage;
	uint8_t messagedatabuffer[1032];
};

struct SENSE_DATA {
	uint8_t ErrorCode: 7;
	uint8_t Valid: 1;
	uint8_t SegmentNumber;
	uint8_t SenseKey: 4;
	uint8_t Reserved: 1;
	uint8_t IncorrectLength: 1;
	uint8_t EndOfMedia: 1;
	uint8_t FileMark: 1;
	uint8_t Information[4];
	uint8_t AdditionalSenseLength;
	uint8_t CommandSpecificInformation[4];
	uint8_t AdditionalSenseCode;
	uint8_t AdditionalSenseCodeQualifier;
	uint8_t FieldReplaceableUnitCode;
	uint8_t SenseKeySpecific[3];
};

typedef long unsigned int u_long;

typedef enum {
	CAM_REQ_INPROG = 0,
	CAM_REQ_CMP = 1,
	CAM_REQ_ABORTED = 2,
	CAM_UA_ABORT = 3,
	CAM_REQ_CMP_ERR = 4,
	CAM_BUSY = 5,
	CAM_REQ_INVALID = 6,
	CAM_PATH_INVALID = 7,
	CAM_SEL_TIMEOUT = 8,
	CAM_CMD_TIMEOUT = 9,
	CAM_SCSI_STATUS_ERROR = 10,
	CAM_SCSI_BUS_RESET = 11,
	CAM_UNCOR_PARITY = 12,
	CAM_AUTOSENSE_FAIL = 13,
	CAM_NO_HBA = 14,
	CAM_DATA_RUN_ERR = 15,
	CAM_UNEXP_BUSFREE = 16,
	CAM_SEQUENCE_FAIL = 17,
	CAM_CCB_LEN_ERR = 18,
	CAM_PROVIDE_FAIL = 19,
	CAM_BDR_SENT = 20,
	CAM_REQ_TERMIO = 21,
	CAM_UNREC_HBA_ERROR = 22,
	CAM_REQ_TOO_BIG = 23,
	CAM_UA_TERMIO = 24,
	CAM_MSG_REJECT_REC = 25,
	CAM_DEV_NOT_THERE = 26,
	CAM_RESRC_UNAVAIL = 27,
	CAM_REQUEUE_REQ = 28,
	CAM_DEV_QFRZN = 64,
	CAM_STATUS_MASK = 63,
} cam_status;

typedef enum {
	AC_GETDEV_CHANGED = 2048,
	AC_INQ_CHANGED = 1024,
	AC_TRANSFER_NEG = 512,
	AC_LOST_DEVICE = 256,
	AC_FOUND_DEVICE = 128,
	AC_PATH_DEREGISTERED = 64,
	AC_PATH_REGISTERED = 32,
	AC_SENT_BDR = 16,
	AC_SCSI_AEN = 8,
	AC_UNSOL_RESEL = 2,
	AC_BUS_RESET = 1,
} ac_code;

enum {
	CAM_DIR_IN = 2,
	CAM_DIR_OUT = 1,
	CAM_DIR_NONE = 3,
};

struct scsi_sense {
	uint8_t opcode;
	uint8_t byte2;
	uint8_t unused[2];
	uint8_t length;
	uint8_t control;
};

struct scsi_sense_data {
	uint8_t error_code;
	uint8_t segment;
	uint8_t flags;
	uint8_t info[4];
	uint8_t extra_len;
	uint8_t cmd_spec_info[4];
	uint8_t add_sense_code;
	uint8_t add_sense_code_qual;
	uint8_t fru;
	uint8_t sense_key_spec[3];
	uint8_t extra_bytes[14];
};

typedef struct pci_dev *ahc_dev_softc_t;

typedef struct scsi_cmnd *ahc_io_ctx_t;

typedef uint32_t bus_size_t;

typedef enum {
	BUS_SPACE_MEMIO = 0,
	BUS_SPACE_PIO = 1,
} bus_space_tag_t;

typedef union {
	u_long ioport;
	volatile uint8_t *maddr;
} bus_space_handle_t;

struct bus_dma_segment {
	dma_addr_t ds_addr;
	bus_size_t ds_len;
};

typedef struct bus_dma_segment bus_dma_segment_t;

struct ahc_linux_dma_tag {
	bus_size_t alignment;
	bus_size_t boundary;
	bus_size_t maxsize;
};

typedef struct ahc_linux_dma_tag *bus_dma_tag_t;

typedef dma_addr_t bus_dmamap_t;

typedef int bus_dma_filter_t(void *, dma_addr_t);

typedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);

struct ahc_reg_parse_entry {
	char *name;
	uint8_t value;
	uint8_t mask;
};

typedef struct ahc_reg_parse_entry ahc_reg_parse_entry_t;

typedef enum {
	AHC_NONE = 0,
	AHC_CHIPID_MASK = 255,
	AHC_AIC7770 = 1,
	AHC_AIC7850 = 2,
	AHC_AIC7855 = 3,
	AHC_AIC7859 = 4,
	AHC_AIC7860 = 5,
	AHC_AIC7870 = 6,
	AHC_AIC7880 = 7,
	AHC_AIC7895 = 8,
	AHC_AIC7895C = 9,
	AHC_AIC7890 = 10,
	AHC_AIC7896 = 11,
	AHC_AIC7892 = 12,
	AHC_AIC7899 = 13,
	AHC_VL = 256,
	AHC_EISA = 512,
	AHC_PCI = 1024,
	AHC_BUS_MASK = 3840,
} ahc_chip;

typedef enum {
	AHC_FENONE = 0,
	AHC_ULTRA = 1,
	AHC_ULTRA2 = 2,
	AHC_WIDE = 4,
	AHC_TWIN = 8,
	AHC_MORE_SRAM = 16,
	AHC_CMD_CHAN = 32,
	AHC_QUEUE_REGS = 64,
	AHC_SG_PRELOAD = 128,
	AHC_SPIOCAP = 256,
	AHC_MULTI_TID = 512,
	AHC_HS_MAILBOX = 1024,
	AHC_DT = 2048,
	AHC_NEW_TERMCTL = 4096,
	AHC_MULTI_FUNC = 8192,
	AHC_LARGE_SCBS = 16384,
	AHC_AUTORATE = 32768,
	AHC_AUTOPAUSE = 65536,
	AHC_TARGETMODE = 131072,
	AHC_MULTIROLE = 262144,
	AHC_REMOVABLE = 524288,
	AHC_HVD = 1048576,
	AHC_AIC7770_FE = 0,
	AHC_AIC7850_FE = 196865,
	AHC_AIC7860_FE = 196865,
	AHC_AIC7870_FE = 196608,
	AHC_AIC7880_FE = 196609,
	AHC_AIC7890_FE = 153330,
	AHC_AIC7892_FE = 253682,
	AHC_AIC7895_FE = 221233,
	AHC_AIC7895C_FE = 221745,
	AHC_AIC7896_FE = 161522,
	AHC_AIC7899_FE = 261874,
} ahc_feature;

typedef enum {
	AHC_BUGNONE = 0,
	AHC_TMODE_WIDEODD_BUG = 1,
	AHC_AUTOFLUSH_BUG = 2,
	AHC_CACHETHEN_BUG = 4,
	AHC_CACHETHEN_DIS_BUG = 8,
	AHC_PCI_2_1_RETRY_BUG = 16,
	AHC_PCI_MWI_BUG = 32,
	AHC_SCBCHAN_UPLOAD_BUG = 64,
} ahc_bug;

typedef enum {
	AHC_FNONE = 0,
	AHC_PRIMARY_CHANNEL = 3,
	AHC_USEDEFAULTS = 4,
	AHC_SEQUENCER_DEBUG = 8,
	AHC_SHARED_SRAM = 16,
	AHC_LARGE_SEEPROM = 32,
	AHC_RESET_BUS_A = 64,
	AHC_RESET_BUS_B = 128,
	AHC_EXTENDED_TRANS_A = 256,
	AHC_EXTENDED_TRANS_B = 512,
	AHC_TERM_ENB_A = 1024,
	AHC_TERM_ENB_B = 2048,
	AHC_INITIATORROLE = 4096,
	AHC_TARGETROLE = 8192,
	AHC_NEWEEPROM_FMT = 16384,
	AHC_TQINFIFO_BLOCKED = 65536,
	AHC_INT50_SPEEDFLEX = 131072,
	AHC_SCB_BTT = 262144,
	AHC_BIOS_ENABLED = 524288,
	AHC_ALL_INTERRUPTS = 1048576,
	AHC_PAGESCBS = 4194304,
	AHC_EDGE_INTERRUPT = 8388608,
	AHC_39BIT_ADDRESSING = 16777216,
	AHC_LSCBS_ENABLED = 33554432,
	AHC_SCB_CONFIG_USED = 67108864,
	AHC_NO_BIOS_INIT = 134217728,
	AHC_DISABLE_PCI_PERR = 268435456,
	AHC_HAS_TERM_LOGIC = 536870912,
} ahc_flag;

struct status_pkt {
	uint32_t residual_datacnt;
	uint32_t residual_sg_ptr;
	uint8_t scsi_status;
};

struct target_data {
	uint32_t residual_datacnt;
	uint32_t residual_sg_ptr;
	uint8_t scsi_status;
	uint8_t target_phases;
	uint8_t data_phase;
	uint8_t initiator_tag;
};

struct hardware_scb {
	union {
		uint8_t cdb[12];
		uint32_t cdb_ptr;
		struct status_pkt status;
		struct target_data tdata;
	} shared_data;
	uint32_t dataptr;
	uint32_t datacnt;
	uint32_t sgptr;
	uint8_t control;
	uint8_t scsiid;
	uint8_t lun;
	uint8_t tag;
	uint8_t cdb_len;
	uint8_t scsirate;
	uint8_t scsioffset;
	uint8_t next;
	uint8_t cdb32[32];
};

struct ahc_dma_seg {
	uint32_t addr;
	uint32_t len;
};

struct sg_map_node {
	bus_dmamap_t sg_dmamap;
	dma_addr_t sg_physaddr;
	struct ahc_dma_seg *sg_vaddr;
	struct {
		struct sg_map_node *sle_next;
	} links;
};

typedef enum {
	SCB_FREE = 0,
	SCB_OTHERTCL_TIMEOUT = 2,
	SCB_DEVICE_RESET = 4,
	SCB_SENSE = 8,
	SCB_CDB32_PTR = 16,
	SCB_RECOVERY_SCB = 32,
	SCB_AUTO_NEGOTIATE = 64,
	SCB_NEGOTIATE = 128,
	SCB_ABORT = 256,
	SCB_UNTAGGEDQ = 512,
	SCB_ACTIVE = 1024,
	SCB_TARGET_IMMEDIATE = 2048,
	SCB_TRANSMISSION_ERROR = 4096,
	SCB_TARGET_SCB = 8192,
	SCB_SILENT = 16384,
} scb_flag;

struct ahc_softc;

struct scb_platform_data;

struct scb {
	struct hardware_scb *hscb;
	union {
		struct {
			struct scb *sle_next;
		} sle;
		struct {
			struct scb *tqe_next;
			struct scb **tqe_prev;
		} tqe;
	} links;
	struct {
		struct scb *le_next;
		struct scb **le_prev;
	} pending_links;
	ahc_io_ctx_t io_ctx;
	struct ahc_softc *ahc_softc;
	scb_flag flags;
	struct scb_platform_data *platform_data;
	struct sg_map_node *sg_map;
	struct ahc_dma_seg *sg_list;
	dma_addr_t sg_list_phys;
	u_int sg_count;
};

struct scb_tailq {
	struct scb *tqh_first;
	struct scb **tqh_last;
};

struct ahc_aic7770_softc {
	uint8_t busspd;
	uint8_t bustime;
};

struct ahc_pci_softc {
	uint32_t devconfig;
	uint16_t targcrccnt;
	uint8_t command;
	uint8_t csize_lattime;
	uint8_t optionmode;
	uint8_t crccontrol1;
	uint8_t dscommand0;
	uint8_t dspcistatus;
	uint8_t scbbaddr;
	uint8_t dff_thrsh;
};

union ahc_bus_softc {
	struct ahc_aic7770_softc aic7770_softc;
	struct ahc_pci_softc pci_softc;
};

typedef void (*ahc_bus_intr_t)(struct ahc_softc *);

typedef int (*ahc_bus_chip_init_t)(struct ahc_softc *);

struct ahc_tmode_lstate;

typedef enum {
	MSG_TYPE_NONE = 0,
	MSG_TYPE_INITIATOR_MSGOUT = 1,
	MSG_TYPE_INITIATOR_MSGIN = 2,
	MSG_TYPE_TARGET_MSGOUT = 3,
	MSG_TYPE_TARGET_MSGIN = 4,
} ahc_msg_type;

struct scb_data;

struct ahc_platform_data;

struct ahc_tmode_tstate;

struct seeprom_config;

struct cs;

struct target_cmd;

struct ahc_softc {
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	struct scb_data *scb_data;
	struct scb *next_queued_scb;
	struct {
		struct scb *lh_first;
	} pending_scbs;
	u_int untagged_queue_lock;
	struct scb_tailq untagged_queues[16];
	union ahc_bus_softc bus_softc;
	struct ahc_platform_data *platform_data;
	ahc_dev_softc_t dev_softc;
	struct device *dev;
	ahc_bus_intr_t bus_intr;
	ahc_bus_chip_init_t bus_chip_init;
	struct ahc_tmode_tstate *enabled_targets[16];
	struct ahc_tmode_lstate *black_hole;
	struct ahc_tmode_lstate *pending_device;
	ahc_chip chip;
	ahc_feature features;
	ahc_bug bugs;
	ahc_flag flags;
	struct seeprom_config *seep_config;
	uint8_t unpause;
	uint8_t pause;
	uint8_t qoutfifonext;
	uint8_t qinfifonext;
	uint8_t *qoutfifo;
	uint8_t *qinfifo;
	struct cs *critical_sections;
	u_int num_critical_sections;
	char channel;
	char channel_b;
	uint8_t our_id;
	uint8_t our_id_b;
	int unsolicited_ints;
	struct target_cmd *targetcmds;
	uint8_t tqinfifonext;
	uint8_t seqctl;
	uint8_t send_msg_perror;
	ahc_msg_type msg_type;
	uint8_t msgout_buf[12];
	uint8_t msgin_buf[12];
	u_int msgout_len;
	u_int msgout_index;
	u_int msgin_index;
	bus_dma_tag_t parent_dmat;
	bus_dma_tag_t shared_data_dmat;
	bus_dmamap_t shared_data_dmamap;
	dma_addr_t shared_data_busaddr;
	dma_addr_t dma_bug_buf;
	u_int enabled_luns;
	u_int init_level;
	u_int pci_cachesize;
	u_int pci_target_perr_count;
	u_int instruction_ram_size;
	const char *description;
	char *name;
	int unit;
	int seltime;
	int seltime_b;
	uint16_t user_discenable;
	uint16_t user_tagenable;
};

struct ahc_linux_device;

struct scb_platform_data {
	struct ahc_linux_device *dev;
	dma_addr_t buf_busaddr;
	uint32_t xfer_len;
	uint32_t sense_resid;
};

struct scb_data {
	struct {
		struct scb *slh_first;
	} free_scbs;
	struct scb *scbindex[256];
	struct hardware_scb *hscbs;
	struct scb *scbarray;
	struct scsi_sense_data *sense;
	bus_dma_tag_t hscb_dmat;
	bus_dmamap_t hscb_dmamap;
	dma_addr_t hscb_busaddr;
	bus_dma_tag_t sense_dmat;
	bus_dmamap_t sense_dmamap;
	dma_addr_t sense_busaddr;
	bus_dma_tag_t sg_dmat;
	struct {
		struct sg_map_node *slh_first;
	} sg_maps;
	uint8_t numscbs;
	uint8_t maxhscbs;
	uint8_t init_level;
};

struct target_cmd {
	uint8_t scsiid;
	uint8_t identify;
	uint8_t bytes[22];
	uint8_t cmd_valid;
	uint8_t pad[7];
};

struct ahc_transinfo {
	uint8_t protocol_version;
	uint8_t transport_version;
	uint8_t width;
	uint8_t period;
	uint8_t offset;
	uint8_t ppr_options;
};

struct ahc_initiator_tinfo {
	uint8_t scsirate;
	struct ahc_transinfo curr;
	struct ahc_transinfo goal;
	struct ahc_transinfo user;
};

struct ahc_tmode_tstate {
	struct ahc_tmode_lstate *enabled_luns[64];
	struct ahc_initiator_tinfo transinfo[16];
	uint16_t auto_negotiate;
	uint16_t ultraenb;
	uint16_t discenable;
	uint16_t tagenable;
};

struct ahc_syncrate {
	u_int sxfr_u2;
	u_int sxfr;
	uint8_t period;
	const char *rate;
};

struct ahc_phase_table_entry {
	uint8_t phase;
	uint8_t mesg_out;
	char *phasemsg;
};

struct seeprom_config {
	uint16_t device_flags[16];
	uint16_t bios_control;
	uint16_t adapter_control;
	uint16_t brtime_id;
	uint16_t max_targets;
	uint16_t res_1[10];
	uint16_t signature;
	uint16_t checksum;
};

enum {
	MSGLOOP_IN_PROG = 0,
	MSGLOOP_MSGCOMPLETE = 1,
	MSGLOOP_TERMINATED = 2,
};

struct ahc_platform_data {
	struct scsi_target *starget[16];
	spinlock_t spin_lock;
	u_int qfrozen;
	struct completion *eh_done;
	struct Scsi_Host *host;
	uint32_t irq;
	uint32_t bios_address;
	resource_size_t mem_busaddr;
};

struct cs {
	uint16_t begin;
	uint16_t end;
};

typedef enum {
	ROLE_UNKNOWN = 0,
	ROLE_INITIATOR = 1,
	ROLE_TARGET = 2,
} role_t;

struct ahc_devinfo {
	int our_scsiid;
	int target_offset;
	uint16_t target_mask;
	u_int target;
	u_int lun;
	char channel;
	role_t role;
};

typedef enum {
	SEARCH_COMPLETE = 0,
	SEARCH_COUNT = 1,
	SEARCH_REMOVE = 2,
} ahc_search_action;

typedef enum {
	AHC_NEG_TO_GOAL = 0,
	AHC_NEG_IF_NON_ASYNC = 1,
	AHC_NEG_ALWAYS = 2,
} ahc_neg_type;

typedef enum {
	AHC_QUEUE_NONE = 0,
	AHC_QUEUE_BASIC = 1,
	AHC_QUEUE_TAGGED = 2,
} ahc_queue_alg;

typedef enum {
	AHC_DEV_FREEZE_TIL_EMPTY = 2,
	AHC_DEV_Q_BASIC = 16,
	AHC_DEV_Q_TAGGED = 32,
	AHC_DEV_PERIODIC_OTAG = 64,
} ahc_linux_dev_flags;

struct ahc_linux_device {
	int active;
	int openings;
	u_int qfrozen;
	u_long commands_issued;
	u_int tag_success_count;
	ahc_linux_dev_flags flags;
	u_int maxtags;
	u_int tags_on_last_queuefull;
	u_int last_queuefull_same_count;
	u_int commands_since_idle_or_otag;
};

struct ins_format1 {
	uint32_t immediate: 8;
	uint32_t source: 9;
	uint32_t destination: 9;
	uint32_t ret: 1;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

struct ins_format2 {
	uint32_t shift_control: 8;
	uint32_t source: 9;
	uint32_t destination: 9;
	uint32_t ret: 1;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

struct ins_format3 {
	uint32_t immediate: 8;
	uint32_t source: 9;
	uint32_t address: 10;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

struct ins_format4 {
	uint32_t opcode_ext: 8;
	uint32_t source: 9;
	uint32_t destination: 9;
	uint32_t ret: 1;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

struct ins_format5 {
	uint32_t opcode_ext: 8;
	uint32_t source: 9;
	uint32_t address: 10;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

struct ins_format6 {
	uint32_t page: 3;
	uint32_t opcode_ext: 5;
	uint32_t source: 9;
	uint32_t address: 10;
	uint32_t opcode: 4;
	uint32_t parity: 1;
};

union ins_formats {
	struct ins_format1 format1;
	struct ins_format2 format2;
	struct ins_format3 format3;
	struct ins_format4 format4;
	struct ins_format5 format5;
	struct ins_format6 format6;
	uint8_t bytes[4];
	uint32_t integer;
};

struct ahc_hard_error_entry {
	uint8_t errno;
	const char *errmesg;
};

typedef int ahc_patch_func_t(struct ahc_softc *);

struct patch {
	ahc_patch_func_t *patch_func;
	uint32_t begin: 10;
	uint32_t skip_instr: 10;
	uint32_t skip_patch: 12;
};

typedef enum {
	AHCMSG_1B = 0,
	AHCMSG_2B = 1,
	AHCMSG_EXT = 2,
} ahc_msgtype;

typedef enum {
	C46 = 6,
	C56_66 = 8,
} seeprom_chip_t;

struct seeprom_descriptor {
	struct ahc_softc *sd_ahc;
	u_int sd_control_offset;
	u_int sd_status_offset;
	u_int sd_dataout_offset;
	seeprom_chip_t sd_chip;
	uint16_t sd_MS;
	uint16_t sd_RDY;
	uint16_t sd_CS;
	uint16_t sd_CK;
	uint16_t sd_DO;
	uint16_t sd_DI;
};

struct seeprom_cmd {
	uint8_t len;
	uint8_t bits[11];
};

typedef int ahc_device_setup_t(struct ahc_softc *);

struct ahc_pci_identity {
	uint64_t full_id;
	uint64_t id_mask;
	const char *name;
	ahc_device_setup_t *setup;
};

enum {
	AHC_POWER_STATE_D0 = 0,
	AHC_POWER_STATE_D1 = 1,
	AHC_POWER_STATE_D2 = 2,
	AHC_POWER_STATE_D3 = 3,
};

typedef struct {
	uint8_t tag_commands[16];
} adapter_tag_info_t;

struct ahc_linux_target;

typedef u16 u_int16_t;

struct scsi_status_iu_header {
	u_int8_t reserved[2];
	u_int8_t flags;
	u_int8_t status;
	u_int8_t sense_length[4];
	u_int8_t pkt_failures_length[4];
	u_int8_t pkt_failures[1];
};

typedef struct pci_dev *ahd_dev_softc_t;

typedef struct scsi_cmnd *ahd_io_ctx_t;

struct ahd_linux_dma_tag {
	bus_size_t alignment;
	bus_size_t boundary;
	bus_size_t maxsize;
};

typedef struct ahd_linux_dma_tag *bus_dma_tag_t___2;

struct ahd_reg_parse_entry {
	char *name;
	uint8_t value;
	uint8_t mask;
};

typedef struct ahd_reg_parse_entry ahd_reg_parse_entry_t;

typedef enum {
	AHD_NONE = 0,
	AHD_CHIPID_MASK = 255,
	AHD_AIC7901 = 1,
	AHD_AIC7902 = 2,
	AHD_AIC7901A = 3,
	AHD_PCI = 256,
	AHD_PCIX = 512,
	AHD_BUS_MASK = 3840,
} ahd_chip;

typedef enum {
	AHD_FENONE = 0,
	AHD_WIDE = 1,
	AHD_AIC79XXB_SLOWCRC = 2,
	AHD_MULTI_FUNC = 256,
	AHD_TARGETMODE = 4096,
	AHD_MULTIROLE = 8192,
	AHD_RTI = 16384,
	AHD_NEW_IOCELL_OPTS = 32768,
	AHD_NEW_DFCNTRL_OPTS = 65536,
	AHD_FAST_CDB_DELIVERY = 131072,
	AHD_REMOVABLE = 0,
	AHD_AIC7901_FE = 0,
	AHD_AIC7901A_FE = 0,
	AHD_AIC7902_FE = 256,
} ahd_feature;

typedef enum {
	AHD_BUGNONE = 0,
	AHD_SENT_SCB_UPDATE_BUG = 1,
	AHD_ABORT_LQI_BUG = 2,
	AHD_PKT_BITBUCKET_BUG = 4,
	AHD_LONG_SETIMO_BUG = 8,
	AHD_NLQICRC_DELAYED_BUG = 16,
	AHD_SCSIRST_BUG = 32,
	AHD_PCIX_CHIPRST_BUG = 64,
	AHD_PCIX_MMAPIO_BUG = 128,
	AHD_PCIX_SCBRAM_RD_BUG = 256,
	AHD_PCIX_BUG_MASK = 448,
	AHD_LQO_ATNO_BUG = 512,
	AHD_AUTOFLUSH_BUG = 1024,
	AHD_CLRLQO_AUTOCLR_BUG = 2048,
	AHD_PKTIZED_STATUS_BUG = 4096,
	AHD_PKT_LUN_BUG = 8192,
	AHD_NONPACKFIFO_BUG = 16384,
	AHD_MDFF_WSCBPTR_BUG = 32768,
	AHD_REG_SLOW_SETTLE_BUG = 65536,
	AHD_SET_MODE_BUG = 131072,
	AHD_BUSFREEREV_BUG = 262144,
	AHD_PACED_NEGTABLE_BUG = 524288,
	AHD_LQOOVERRUN_BUG = 1048576,
	AHD_INTCOLLISION_BUG = 2097152,
	AHD_EARLY_REQ_BUG = 4194304,
	AHD_FAINT_LED_BUG = 8388608,
} ahd_bug;

typedef enum {
	AHD_FNONE = 0,
	AHD_BOOT_CHANNEL = 1,
	AHD_USEDEFAULTS = 4,
	AHD_SEQUENCER_DEBUG = 8,
	AHD_RESET_BUS_A = 16,
	AHD_EXTENDED_TRANS_A = 32,
	AHD_TERM_ENB_A = 64,
	AHD_SPCHK_ENB_A = 128,
	AHD_STPWLEVEL_A = 256,
	AHD_INITIATORROLE = 512,
	AHD_TARGETROLE = 1024,
	AHD_RESOURCE_SHORTAGE = 2048,
	AHD_TQINFIFO_BLOCKED = 4096,
	AHD_INT50_SPEEDFLEX = 8192,
	AHD_BIOS_ENABLED = 16384,
	AHD_ALL_INTERRUPTS = 32768,
	AHD_39BIT_ADDRESSING = 65536,
	AHD_64BIT_ADDRESSING = 131072,
	AHD_CURRENT_SENSING = 262144,
	AHD_SCB_CONFIG_USED = 524288,
	AHD_HP_BOARD = 1048576,
	AHD_BUS_RESET_ACTIVE = 2097152,
	AHD_UPDATE_PEND_CMDS = 4194304,
	AHD_RUNNING_QOUTFIFO = 8388608,
	AHD_HAD_FIRST_SEL = 16777216,
} ahd_flag;

struct initiator_status {
	uint32_t residual_datacnt;
	uint32_t residual_sgptr;
	uint8_t scsi_status;
};

struct target_status {
	uint32_t residual_datacnt;
	uint32_t residual_sgptr;
	uint8_t scsi_status;
	uint8_t target_phases;
	uint8_t data_phase;
	uint8_t initiator_tag;
};

typedef uint32_t sense_addr_t;

union initiator_data {
	struct {
		uint64_t cdbptr;
		uint8_t cdblen;
	} cdb_from_host;
	uint8_t cdb[16];
	struct {
		uint8_t cdb[12];
		sense_addr_t sense_addr;
	} cdb_plus_saddr;
};

struct target_data___2 {
	uint32_t spare[2];
	uint8_t scsi_status;
	uint8_t target_phases;
	uint8_t data_phase;
	uint8_t initiator_tag;
};

struct hardware_scb___2 {
	union {
		union initiator_data idata;
		struct target_data___2 tdata;
		struct initiator_status istatus;
		struct target_status tstatus;
	} shared_data;
	uint16_t tag;
	uint8_t control;
	uint8_t scsiid;
	uint8_t lun;
	uint8_t task_attribute;
	uint8_t cdb_len;
	uint8_t task_management;
	uint64_t dataptr;
	uint32_t datacnt;
	uint32_t sgptr;
	uint32_t hscb_busaddr;
	uint32_t next_hscb_busaddr;
	uint8_t pkt_long_lun[8];
	uint8_t spare[8];
};

struct ahd_dma_seg {
	uint32_t addr;
	uint32_t len;
};

struct ahd_dma64_seg {
	uint64_t addr;
	uint32_t len;
	uint32_t pad;
};

struct map_node {
	bus_dmamap_t dmamap;
	dma_addr_t physaddr;
	uint8_t *vaddr;
	struct {
		struct map_node *sle_next;
	} links;
};

typedef enum {
	SCB_FLAG_NONE = 0,
	SCB_TRANSMISSION_ERROR___2 = 1,
	SCB_OTHERTCL_TIMEOUT___2 = 2,
	SCB_DEVICE_RESET___2 = 4,
	SCB_SENSE___2 = 8,
	SCB_CDB32_PTR___2 = 16,
	SCB_RECOVERY_SCB___2 = 32,
	SCB_AUTO_NEGOTIATE___2 = 64,
	SCB_NEGOTIATE___2 = 128,
	SCB_ABORT___2 = 256,
	SCB_ACTIVE___2 = 512,
	SCB_TARGET_IMMEDIATE___2 = 1024,
	SCB_PACKETIZED = 2048,
	SCB_EXPECT_PPR_BUSFREE = 4096,
	SCB_PKT_SENSE = 8192,
	SCB_EXTERNAL_RESET = 16384,
	SCB_ON_COL_LIST = 32768,
	SCB_SILENT___2 = 65536,
} scb_flag___2;

struct ahd_softc;

struct scb_platform_data___2;

struct scb___2 {
	struct hardware_scb___2 *hscb;
	union {
		struct {
			struct scb___2 *sle_next;
		} sle;
		struct {
			struct scb___2 *le_next;
			struct scb___2 **le_prev;
		} le;
		struct {
			struct scb___2 *tqe_next;
			struct scb___2 **tqe_prev;
		} tqe;
	} links;
	union {
		struct {
			struct scb___2 *sle_next;
		} sle;
		struct {
			struct scb___2 *le_next;
			struct scb___2 **le_prev;
		} le;
		struct {
			struct scb___2 *tqe_next;
			struct scb___2 **tqe_prev;
		} tqe;
	} links2;
	struct scb___2 *col_scb;
	ahd_io_ctx_t io_ctx;
	struct ahd_softc *ahd_softc;
	scb_flag___2 flags;
	struct scb_platform_data___2 *platform_data;
	struct map_node *hscb_map;
	struct map_node *sg_map;
	struct map_node *sense_map;
	void *sg_list;
	uint8_t *sense_data;
	dma_addr_t sg_list_busaddr;
	dma_addr_t sense_busaddr;
	u_int sg_count;
	u_int crc_retry_count;
};

struct scb_tailq___2 {
	struct scb___2 *tqh_first;
	struct scb___2 **tqh_last;
};

struct scb_list {
	struct scb___2 *lh_first;
};

struct scb_data___2 {
	struct scb_tailq___2 free_scbs;
	struct scb_list free_scb_lists[1024];
	struct scb_list any_dev_free_scb_list;
	struct scb___2 *scbindex[512];
	bus_dma_tag_t___2 hscb_dmat;
	bus_dma_tag_t___2 sg_dmat;
	bus_dma_tag_t___2 sense_dmat;
	struct {
		struct map_node *slh_first;
	} hscb_maps;
	struct {
		struct map_node *slh_first;
	} sg_maps;
	struct {
		struct map_node *slh_first;
	} sense_maps;
	int scbs_left;
	int sgs_left;
	int sense_left;
	uint16_t numscbs;
	uint16_t maxhscbs;
	uint8_t init_level;
};

typedef enum {
	AHD_MODE_DFF0 = 0,
	AHD_MODE_DFF1 = 1,
	AHD_MODE_CCHAN = 2,
	AHD_MODE_SCSI = 3,
	AHD_MODE_CFG = 4,
	AHD_MODE_UNKNOWN = 5,
} ahd_mode;

typedef void (*ahd_bus_intr_t)(struct ahd_softc *);

struct ahd_tmode_lstate;

typedef enum {
	MSG_FLAG_NONE = 0,
	MSG_FLAG_EXPECT_PPR_BUSFREE = 1,
	MSG_FLAG_IU_REQ_CHANGED = 2,
	MSG_FLAG_EXPECT_IDE_BUSFREE = 4,
	MSG_FLAG_EXPECT_QASREJ_BUSFREE = 8,
	MSG_FLAG_PACKETIZED = 16,
} ahd_msg_flags;

typedef enum {
	MSG_TYPE_NONE___2 = 0,
	MSG_TYPE_INITIATOR_MSGOUT___2 = 1,
	MSG_TYPE_INITIATOR_MSGIN___2 = 2,
	MSG_TYPE_TARGET_MSGOUT___2 = 3,
	MSG_TYPE_TARGET_MSGIN___2 = 4,
} ahd_msg_type;

struct ahd_suspend_channel_state {
	uint8_t scsiseq;
	uint8_t sxfrctl0;
	uint8_t sxfrctl1;
	uint8_t simode0;
	uint8_t simode1;
	uint8_t seltimer;
	uint8_t seqctl;
};

struct ahd_suspend_pci_state {
	uint32_t devconfig;
	uint8_t command;
	uint8_t csize_lattime;
};

struct ahd_suspend_state {
	struct ahd_suspend_channel_state channel[2];
	struct ahd_suspend_pci_state pci_state;
	uint8_t optionmode;
	uint8_t dscommand0;
	uint8_t dspcistatus;
	uint8_t crccontrol1;
	uint8_t scbbaddr;
	uint8_t dff_thrsh;
	uint8_t *scratch_ram;
	uint8_t *btt;
};

struct ahd_platform_data;

struct ahd_tmode_tstate;

struct ahd_completion;

struct ahd_softc {
	bus_space_tag_t tags[2];
	bus_space_handle_t bshs[2];
	struct scb_data___2 scb_data;
	struct hardware_scb___2 *next_queued_hscb;
	struct map_node *next_queued_hscb_map;
	struct {
		struct scb___2 *lh_first;
	} pending_scbs;
	ahd_mode dst_mode;
	ahd_mode src_mode;
	ahd_mode saved_dst_mode;
	ahd_mode saved_src_mode;
	struct ahd_platform_data *platform_data;
	ahd_dev_softc_t dev_softc;
	ahd_bus_intr_t bus_intr;
	struct ahd_tmode_tstate *enabled_targets[16];
	struct ahd_tmode_lstate *black_hole;
	struct ahd_tmode_lstate *pending_device;
	struct timer_list stat_timer;
	u_int cmdcmplt_bucket;
	uint32_t cmdcmplt_counts[4];
	uint32_t cmdcmplt_total;
	ahd_chip chip;
	ahd_feature features;
	ahd_bug bugs;
	ahd_flag flags;
	struct seeprom_config *seep_config;
	struct ahd_completion *qoutfifo;
	uint16_t qoutfifonext;
	uint16_t qoutfifonext_valid_tag;
	uint16_t qinfifonext;
	uint16_t qinfifo[512];
	uint16_t qfreeze_cnt;
	uint8_t unpause;
	uint8_t pause;
	struct cs *critical_sections;
	u_int num_critical_sections;
	uint8_t *overrun_buf;
	struct {
		struct ahd_softc *tqe_next;
		struct ahd_softc **tqe_prev;
	} links;
	char channel;
	uint8_t our_id;
	struct target_cmd *targetcmds;
	uint8_t tqinfifonext;
	uint8_t hs_mailbox;
	uint8_t send_msg_perror;
	ahd_msg_flags msg_flags;
	ahd_msg_type msg_type;
	uint8_t msgout_buf[12];
	uint8_t msgin_buf[12];
	u_int msgout_len;
	u_int msgout_index;
	u_int msgin_index;
	bus_dma_tag_t___2 parent_dmat;
	bus_dma_tag_t___2 shared_data_dmat;
	struct map_node shared_data_map;
	struct ahd_suspend_state suspend_state;
	u_int enabled_luns;
	u_int init_level;
	u_int pci_cachesize;
	uint8_t iocell_opts[4];
	u_int stack_size;
	uint16_t *saved_stack;
	const char *description;
	const char *bus_description;
	char *name;
	int unit;
	int seltime;
	u_int int_coalescing_timer;
	u_int int_coalescing_maxcmds;
	u_int int_coalescing_mincmds;
	u_int int_coalescing_threshold;
	u_int int_coalescing_stop_threshold;
	uint16_t user_discenable;
	uint16_t user_tagenable;
};

struct ahd_linux_device;

struct scb_platform_data___2 {
	struct ahd_linux_device *dev;
	dma_addr_t buf_busaddr;
	uint32_t xfer_len;
	uint32_t sense_resid;
};

struct ahd_transinfo {
	uint8_t protocol_version;
	uint8_t transport_version;
	uint8_t width;
	uint8_t period;
	uint8_t offset;
	uint8_t ppr_options;
};

struct ahd_initiator_tinfo {
	struct ahd_transinfo curr;
	struct ahd_transinfo goal;
	struct ahd_transinfo user;
};

struct ahd_tmode_tstate {
	struct ahd_tmode_lstate *enabled_luns[256];
	struct ahd_initiator_tinfo transinfo[16];
	uint16_t auto_negotiate;
	uint16_t discenable;
	uint16_t tagenable;
};

struct ahd_phase_table_entry {
	uint8_t phase;
	uint8_t mesg_out;
	const char *phasemsg;
};

struct vpd_config {
	uint8_t bios_flags;
	uint8_t reserved_1[21];
	uint8_t resource_type;
	uint8_t resource_len[2];
	uint8_t resource_data[8];
	uint8_t vpd_tag;
	uint16_t vpd_len;
	uint8_t vpd_keyword[2];
	uint8_t length;
	uint8_t revision;
	uint8_t device_flags;
	uint8_t termination_menus[2];
	uint8_t fifo_threshold;
	uint8_t end_tag;
	uint8_t vpd_checksum;
	uint16_t default_target_flags;
	uint16_t default_bios_flags;
	uint16_t default_ctrl_flags;
	uint8_t default_irq;
	uint8_t pci_lattime;
	uint8_t max_target;
	uint8_t boot_lun;
	uint16_t signature;
	uint8_t reserved_2;
	uint8_t checksum;
	uint8_t reserved_3[4];
};

typedef uint8_t ahd_mode_state;

struct ahd_completion {
	uint16_t tag;
	uint8_t sg_status;
	uint8_t valid_tag;
};

struct ahd_platform_data {
	struct scsi_target *starget[16];
	spinlock_t spin_lock;
	struct completion *eh_done;
	struct Scsi_Host *host;
	uint32_t irq;
	uint32_t bios_address;
	resource_size_t mem_busaddr;
};

struct ahd_devinfo {
	int our_scsiid;
	int target_offset;
	uint16_t target_mask;
	u_int target;
	u_int lun;
	char channel;
	role_t role;
};

typedef enum {
	SEARCH_COMPLETE___2 = 0,
	SEARCH_COUNT___2 = 1,
	SEARCH_REMOVE___2 = 2,
	SEARCH_PRINT = 3,
} ahd_search_action;

typedef enum {
	AHD_NEG_TO_GOAL = 0,
	AHD_NEG_IF_NON_ASYNC = 1,
	AHD_NEG_ALWAYS = 2,
} ahd_neg_type;

typedef enum {
	AHD_QUEUE_NONE = 0,
	AHD_QUEUE_BASIC = 1,
	AHD_QUEUE_TAGGED = 2,
} ahd_queue_alg;

typedef enum {
	AHD_DEV_FREEZE_TIL_EMPTY = 2,
	AHD_DEV_Q_BASIC = 16,
	AHD_DEV_Q_TAGGED = 32,
	AHD_DEV_PERIODIC_OTAG = 64,
} ahd_linux_dev_flags;

struct ahd_linux_device {
	struct {
		struct ahd_linux_device *tqe_next;
		struct ahd_linux_device **tqe_prev;
	} links;
	int active;
	int openings;
	u_int qfrozen;
	u_long commands_issued;
	u_int tag_success_count;
	ahd_linux_dev_flags flags;
	struct timer_list timer;
	u_int maxtags;
	u_int tags_on_last_queuefull;
	u_int last_queuefull_same_count;
	u_int commands_since_idle_or_otag;
};

struct ahd_hard_error_entry {
	uint8_t errno;
	const char *errmesg;
};

typedef int ahd_patch_func_t(struct ahd_softc *);

struct patch___2 {
	ahd_patch_func_t *patch_func;
	uint32_t begin: 10;
	uint32_t skip_instr: 10;
	uint32_t skip_patch: 12;
};

typedef enum {
	AHDMSG_1B = 0,
	AHDMSG_2B = 1,
	AHDMSG_EXT = 2,
} ahd_msgtype;

typedef int ahd_device_setup_t(struct ahd_softc *);

struct ahd_pci_identity {
	uint64_t full_id;
	uint64_t id_mask;
	const char *name;
	ahd_device_setup_t *setup;
};

typedef enum {
	AHD_POWER_STATE_D0 = 0,
	AHD_POWER_STATE_D1 = 1,
	AHD_POWER_STATE_D2 = 2,
	AHD_POWER_STATE_D3 = 3,
} ahd_power_state;

typedef struct {
	uint16_t tag_commands[16];
} adapter_tag_info_t___2;

struct ahd_linux_iocell_opts {
	uint8_t precomp;
	uint8_t slewrate;
	uint8_t amplitude;
};

enum {
	AAC_ENABLE_INTERRUPT = 0,
	AAC_DISABLE_INTERRUPT = 1,
	AAC_ENABLE_MSIX = 2,
	AAC_DISABLE_MSIX = 3,
	AAC_CLEAR_AIF_BIT = 4,
	AAC_CLEAR_SYNC_BIT = 5,
	AAC_ENABLE_INTX = 6,
};

struct aac_hba_sgl {
	u32 addr_lo;
	u32 addr_hi;
	u32 len;
	u32 flags;
};

enum {
	HBA_IU_TYPE_SCSI_CMD_REQ = 64,
	HBA_IU_TYPE_SCSI_TM_REQ = 65,
	HBA_IU_TYPE_SATA_REQ = 66,
	HBA_IU_TYPE_RESP = 96,
	HBA_IU_TYPE_COALESCED_RESP = 97,
	HBA_IU_TYPE_INT_COALESCING_CFG_REQ = 112,
};

enum {
	HBA_RESP_SVCRES_TASK_COMPLETE = 0,
	HBA_RESP_SVCRES_FAILURE = 1,
	HBA_RESP_SVCRES_TMF_COMPLETE = 2,
	HBA_RESP_SVCRES_TMF_SUCCEEDED = 3,
	HBA_RESP_SVCRES_TMF_REJECTED = 4,
	HBA_RESP_SVCRES_TMF_LUN_INVALID = 5,
};

struct aac_hba_cmd_req {
	u8 iu_type;
	u8 byte1;
	u8 reply_qid;
	u8 reserved1;
	__le32 it_nexus;
	__le32 request_id;
	__le32 tweak_value_lo;
	u8 cdb[16];
	u8 lun[8];
	__le32 data_length;
	u8 attr_prio;
	u8 emb_data_desc_count;
	__le16 dek_index;
	__le32 error_ptr_lo;
	__le32 error_ptr_hi;
	__le32 error_length;
	__le32 tweak_value_hi;
	struct aac_hba_sgl sge[92];
};

struct aac_hba_tm_req {
	u8 iu_type;
	u8 reply_qid;
	u8 tmf;
	u8 reserved1;
	__le32 it_nexus;
	u8 lun[8];
	__le32 request_id;
	__le32 reserved2;
	__le32 managed_request_id;
	__le32 reserved3;
	__le32 error_ptr_lo;
	__le32 error_ptr_hi;
	__le32 error_length;
};

struct aac_hba_reset_req {
	u8 iu_type;
	u8 reset_type;
	u8 reply_qid;
	u8 reserved1;
	__le32 it_nexus;
	__le32 request_id;
	__le32 error_ptr_lo;
	__le32 error_ptr_hi;
	__le32 error_length;
};

struct aac_hba_resp {
	u8 iu_type;
	u8 reserved1[3];
	__le32 request_identifier;
	__le32 reserved2;
	u8 service_response;
	u8 status;
	u8 datapres;
	u8 sense_response_data_len;
	__le32 residual_count;
	u8 sense_response_buf[32];
};

struct aac_native_hba {
	union {
		struct aac_hba_cmd_req cmd;
		struct aac_hba_tm_req tmr;
		u8 cmd_bytes[1536];
	} cmd;
	union {
		struct aac_hba_resp err;
		u8 resp_bytes[512];
	} resp;
};

struct _ciss_lun {
	u8 tid[3];
	u8 bus;
	u8 level3[2];
	u8 level2[2];
	u8 node_ident[16];
};

struct aac_ciss_phys_luns_resp {
	u8 list_length[4];
	u8 resp_flag;
	u8 reserved[3];
	struct _ciss_lun lun[1];
};

struct aac_ciss_identify_pd {
	u8 scsi_bus;
	u8 scsi_id;
	u16 block_size;
	u32 total_blocks;
	u32 reserved_blocks;
	u8 model[40];
	u8 serial_number[40];
	u8 firmware_revision[8];
	u8 scsi_inquiry_bits;
	u8 compaq_drive_stamp;
	u8 last_failure_reason;
	u8 flags;
	u8 more_flags;
	u8 scsi_lun;
	u8 yet_more_flags;
	u8 even_more_flags;
	u32 spi_speed_rules;
	u8 phys_connector[2];
	u8 phys_box_on_bus;
	u8 phys_bay_in_box;
	u32 rpm;
	u8 device_type;
	u8 sata_version;
	u64 big_total_block_count;
	u64 ris_starting_lba;
	u32 ris_size;
	u8 wwid[20];
	u8 controller_phy_map[32];
	u16 phy_count;
	u8 phy_connected_dev_type[256];
	u8 phy_to_drive_bay_num[256];
	u16 phy_to_attached_dev_index[256];
	u8 box_index;
	u8 spitfire_support;
	u16 extra_physical_drive_flags;
	u8 negotiated_link_rate[256];
	u8 phy_to_phy_map[256];
	u8 redundant_path_present_map;
	u8 redundant_path_failure_map;
	u8 active_path_number;
	u16 alternate_paths_phys_connector[8];
	u8 alternate_paths_phys_box_on_port[8];
	u8 multi_lun_device_lun_count;
	u8 minimum_good_fw_revision[8];
	u8 unique_inquiry_bytes[20];
	u8 current_temperature_degreesC;
	u8 temperature_threshold_degreesC;
	u8 max_temperature_degreesC;
	u8 logical_blocks_per_phys_block_exp;
	u16 current_queue_depth_limit;
	u8 switch_name[10];
	u16 switch_port;
	u8 alternate_paths_switch_name[40];
	u8 alternate_paths_switch_port[8];
	u16 power_on_hours;
	u16 percent_endurance_used;
	u8 drive_authentication;
	u8 smart_carrier_authentication;
	u8 smart_carrier_app_fw_version;
	u8 smart_carrier_bootloader_fw_version;
	u8 SanitizeSecureEraseSupport;
	u8 DriveKeyFlags;
	u8 encryption_key_name[64];
	u32 misc_drive_flags;
	u16 dek_index;
	u16 drive_encryption_flags;
	u8 sanitize_maximum_time[6];
	u8 connector_info_mode;
	u8 connector_info_number[4];
	u8 long_connector_name[64];
	u8 device_unique_identifier[16];
	u8 padto_2K[17];
} __attribute__((packed));

struct diskparm {
	int heads;
	int sectors;
	int cylinders;
};

struct aac_entry {
	__le32 size;
	__le32 addr;
};

struct aac_qhdr {
	__le64 header_addr;
	__le32 *producer;
	__le32 *consumer;
};

struct aac_fibhdr {
	__le32 XferState;
	__le16 Command;
	u8 StructType;
	u8 Unused;
	__le16 Size;
	__le16 SenderSize;
	__le32 SenderFibAddress;
	union {
		__le32 ReceiverFibAddress;
		__le32 SenderFibAddressHigh;
		__le32 TimeStamp;
	} u;
	__le32 Handle;
	u32 Previous;
	u32 Next;
};

struct hw_fib {
	struct aac_fibhdr header;
	u8 data[480];
};

enum fib_xfer_state {
	HostOwned = 1,
	AdapterOwned = 2,
	FibInitialized = 4,
	FibEmpty = 8,
	AllocatedFromPool = 16,
	SentFromHost = 32,
	SentFromAdapter = 64,
	ResponseExpected = 128,
	NoResponseExpected = 256,
	AdapterProcessed = 512,
	HostProcessed = 1024,
	HighPriority = 2048,
	NormalPriority = 4096,
	Async = 8192,
	AsyncIo = 8192,
	PageFileIo = 16384,
	ShutdownRequest = 32768,
	LazyWrite = 65536,
	AdapterMicroFib = 131072,
	BIOSFibPath = 262144,
	FastResponseCapable = 524288,
	ApiFib = 1048576,
	NoMoreAifDataAvailable = 2097152,
};

struct _r7 {
	__le32 init_struct_revision;
	__le32 no_of_msix_vectors;
	__le32 fsrev;
	__le32 comm_header_address;
	__le32 fast_io_comm_area_address;
	__le32 adapter_fibs_physical_address;
	__le32 adapter_fibs_virtual_address;
	__le32 adapter_fibs_size;
	__le32 adapter_fib_align;
	__le32 printfbuf;
	__le32 printfbufsiz;
	__le32 host_phys_mem_pages;
	__le32 host_elapsed_seconds;
	__le32 init_flags;
	__le32 max_io_commands;
	__le32 max_io_size;
	__le32 max_fib_size;
	__le32 max_num_aif;
	__le32 host_rrq_addr_low;
	__le32 host_rrq_addr_high;
};

struct _rrq {
	__le32 host_addr_low;
	__le32 host_addr_high;
	__le16 msix_id;
	__le16 element_count;
	__le16 comp_thresh;
	__le16 unused;
};

struct _r8 {
	__le32 init_struct_revision;
	__le32 rr_queue_count;
	__le32 host_elapsed_seconds;
	__le32 init_flags;
	__le32 max_io_size;
	__le32 max_num_aif;
	__le32 reserved1;
	__le32 reserved2;
	struct _rrq rrq[1];
};

union aac_init {
	struct _r7 r7;
	struct _r8 r8;
};

struct aac_dev;

struct fib;

struct adapter_ops {
	void (*adapter_interrupt)(struct aac_dev *);
	void (*adapter_notify)(struct aac_dev *, u32);
	void (*adapter_disable_int)(struct aac_dev *);
	void (*adapter_enable_int)(struct aac_dev *);
	int (*adapter_sync_cmd)(struct aac_dev *, u32, u32, u32, u32, u32, u32, u32, u32 *, u32 *, u32 *, u32 *, u32 *);
	int (*adapter_check_health)(struct aac_dev *);
	int (*adapter_restart)(struct aac_dev *, int, u8);
	void (*adapter_start)(struct aac_dev *);
	int (*adapter_ioremap)(struct aac_dev *, u32);
	irq_handler_t adapter_intr;
	int (*adapter_deliver)(struct fib *);
	int (*adapter_bounds)(struct aac_dev *, struct scsi_cmnd *, u64);
	int (*adapter_read)(struct fib *, struct scsi_cmnd *, u64, u32);
	int (*adapter_write)(struct fib *, struct scsi_cmnd *, u64, u32, int);
	int (*adapter_scsi)(struct fib *, struct scsi_cmnd *);
	int (*adapter_comm)(struct aac_dev *, int);
};

struct aac_adapter_info {
	__le32 platform;
	__le32 cpu;
	__le32 subcpu;
	__le32 clock;
	__le32 execmem;
	__le32 buffermem;
	__le32 totalmem;
	__le32 kernelrev;
	__le32 kernelbuild;
	__le32 monitorrev;
	__le32 monitorbuild;
	__le32 hwrev;
	__le32 hwbuild;
	__le32 biosrev;
	__le32 biosbuild;
	__le32 cluster;
	__le32 clusterchannelmask;
	__le32 serial[2];
	__le32 battery;
	__le32 options;
	__le32 OEM;
};

struct aac_supplement_adapter_info {
	u8 adapter_type_text[18];
	u8 pad[2];
	__le32 flash_memory_byte_size;
	__le32 flash_image_id;
	__le32 max_number_ports;
	__le32 version;
	__le32 feature_bits;
	u8 slot_number;
	u8 reserved_pad0[3];
	u8 build_date[12];
	__le32 current_number_ports;
	struct {
		u8 assembly_pn[8];
		u8 fru_pn[8];
		u8 battery_fru_pn[8];
		u8 ec_version_string[8];
		u8 tsid[12];
	} vpd_info;
	__le32 flash_firmware_revision;
	__le32 flash_firmware_build;
	__le32 raid_type_morph_options;
	__le32 flash_firmware_boot_revision;
	__le32 flash_firmware_boot_build;
	u8 mfg_pcba_serial_no[12];
	u8 mfg_wwn_name[8];
	__le32 supported_options2;
	__le32 struct_expansion;
	__le32 feature_bits3;
	__le32 supported_performance_modes;
	u8 host_bus_type;
	u8 host_bus_width;
	u16 host_bus_speed;
	u8 max_rrc_drives;
	u8 max_disk_xtasks;
	u8 cpld_ver_loaded;
	u8 cpld_ver_in_flash;
	__le64 max_rrc_capacity;
	__le32 compiled_max_hist_log_level;
	u8 custom_board_name[12];
	u16 supported_cntlr_mode;
	u16 reserved_for_future16;
	__le32 supported_options3;
	__le16 virt_device_bus;
	__le16 virt_device_target;
	__le16 virt_device_lun;
	__le16 unused;
	__le32 reserved_for_future_growth[68];
};

struct aac_msix_ctx {
	int vector_no;
	struct aac_dev *dev;
};

struct aac_hba_map_info {
	__le32 rmw_nexus;
	u8 devtype;
	s8 reset_state;
	u16 qd_limit;
	u32 scan_counter;
	struct aac_ciss_identify_pd *safw_identify_resp;
};

struct aac_queue_block;

struct fsa_dev_info;

struct sa_registers;

struct rx_registers;

struct rkt_registers;

struct src_registers;

struct rx_inbound;

struct aac_dev {
	struct list_head entry;
	const char *name;
	int id;
	unsigned int max_fib_size;
	unsigned int sg_tablesize;
	unsigned int max_num_aif;
	unsigned int max_cmd_size;
	dma_addr_t hw_fib_pa;
	struct hw_fib *hw_fib_va;
	struct hw_fib *aif_base_va;
	struct fib *fibs;
	struct fib *free_fib;
	spinlock_t fib_lock;
	struct mutex ioctl_mutex;
	struct mutex scan_mutex;
	struct aac_queue_block *queues;
	struct list_head fib_list;
	struct adapter_ops a_ops;
	long unsigned int fsrev;
	resource_size_t base_start;
	resource_size_t dbg_base;
	resource_size_t base_size;
	resource_size_t dbg_size;
	union aac_init *init;
	dma_addr_t init_pa;
	__le32 *host_rrq;
	dma_addr_t host_rrq_pa;
	u32 host_rrq_idx[32];
	atomic_t rrq_outstanding[32];
	u32 fibs_pushed_no;
	struct pci_dev *pdev;
	void *printfbuf;
	void *comm_addr;
	dma_addr_t comm_phys;
	size_t comm_size;
	struct Scsi_Host *scsi_host_ptr;
	int maximum_num_containers;
	int maximum_num_physicals;
	int maximum_num_channels;
	struct fsa_dev_info *fsa_dev;
	struct task_struct *thread;
	struct delayed_work safw_rescan_work;
	int cardtype;
	spinlock_t iq_lock;
	union {
		struct sa_registers *sa;
		struct rx_registers *rx;
		struct rkt_registers *rkt;
		struct {
			struct src_registers *bar0;
			char *bar1;
		} src;
	} regs;
	volatile void *base;
	volatile void *dbg_base_mapped;
	volatile struct rx_inbound *IndexRegs;
	u32 OIMR;
	u32 aif_thread;
	struct aac_adapter_info adapter_info;
	struct aac_supplement_adapter_info supplement_adapter_info;
	u8 nondasd_support;
	u8 jbod;
	u8 cache_protected;
	u8 dac_support;
	u8 needs_dac;
	u8 raid_scsi_mode;
	u8 comm_interface;
	u8 raw_io_interface;
	u8 raw_io_64;
	u8 printf_enabled;
	u8 in_reset;
	u8 in_soft_reset;
	u8 msi;
	u8 sa_firmware;
	int management_fib_count;
	spinlock_t manage_lock;
	spinlock_t sync_lock;
	int sync_mode;
	struct fib *sync_fib;
	struct list_head sync_fib_list;
	u32 doorbell_mask;
	u32 max_msix;
	u32 vector_cap;
	int msi_enabled;
	atomic_t msix_counter;
	u32 scan_counter;
	struct msix_entry msixentry[32];
	struct aac_msix_ctx aac_msix[32];
	struct aac_hba_map_info hba_map[1280];
	struct aac_ciss_phys_luns_resp *safw_phys_luns;
	u8 adapter_shutdown;
	u32 handle_pci_error;
	bool init_reset;
};

typedef void (*fib_callback)(void *, struct fib *);

struct fib {
	void *next;
	s16 type;
	s16 size;
	struct aac_dev *dev;
	struct completion event_wait;
	spinlock_t event_lock;
	u32 done;
	fib_callback callback;
	void *callback_data;
	u32 flags;
	struct list_head fiblink;
	void *data;
	u32 vector_no;
	struct hw_fib *hw_fib_va;
	dma_addr_t hw_fib_pa;
	dma_addr_t hw_sgl_pa;
	dma_addr_t hw_error_pa;
	u32 hbacmd_size;
};

struct aac_driver_ident {
	int (*init)(struct aac_dev *);
	char *name;
	char *vname;
	char *model;
	u16 channels;
	int quirks;
};

struct aac_queue {
	u64 logical;
	struct aac_entry *base;
	struct aac_qhdr headers;
	u32 entries;
	wait_queue_head_t qfull;
	wait_queue_head_t cmdready;
	spinlock_t *lock;
	spinlock_t lockdata;
	struct list_head cmdq;
	atomic_t numpending;
	struct aac_dev *dev;
};

struct aac_queue_block {
	struct aac_queue queue[8];
};

struct sa_drawbridge_CSR {
	__le32 reserved[10];
	u8 LUT_Offset;
	u8 reserved1[3];
	__le32 LUT_Data;
	__le32 reserved2[26];
	__le16 PRICLEARIRQ;
	__le16 SECCLEARIRQ;
	__le16 PRISETIRQ;
	__le16 SECSETIRQ;
	__le16 PRICLEARIRQMASK;
	__le16 SECCLEARIRQMASK;
	__le16 PRISETIRQMASK;
	__le16 SECSETIRQMASK;
	__le32 MAILBOX0;
	__le32 MAILBOX1;
	__le32 MAILBOX2;
	__le32 MAILBOX3;
	__le32 MAILBOX4;
	__le32 MAILBOX5;
	__le32 MAILBOX6;
	__le32 MAILBOX7;
	__le32 ROM_Setup_Data;
	__le32 ROM_Control_Addr;
	__le32 reserved3[12];
	__le32 LUT[64];
};

struct sa_registers {
	struct sa_drawbridge_CSR SaDbCSR;
};

struct rx_mu_registers {
	__le32 ARSR;
	__le32 reserved0;
	__le32 AWR;
	__le32 reserved1;
	__le32 IMRx[2];
	__le32 OMRx[2];
	__le32 IDR;
	__le32 IISR;
	__le32 IIMR;
	__le32 ODR;
	__le32 OISR;
	__le32 OIMR;
	__le32 reserved2;
	__le32 reserved3;
	__le32 InboundQueue;
	__le32 OutboundQueue;
};

struct rx_inbound {
	__le32 Mailbox[8];
};

struct rx_registers {
	struct rx_mu_registers MUnit;
	__le32 reserved1[2];
	struct rx_inbound IndexRegs;
};

struct rkt_registers {
	struct rx_mu_registers MUnit;
	__le32 reserved1[1006];
	struct rx_inbound IndexRegs;
};

struct src_mu_registers {
	__le32 reserved0[6];
	__le32 IOAR[2];
	__le32 IDR;
	__le32 IISR;
	__le32 reserved1[3];
	__le32 OIMR;
	__le32 reserved2[25];
	__le32 ODR_R;
	__le32 ODR_C;
	__le32 reserved3[3];
	__le32 SCR0;
	__le32 reserved4[2];
	__le32 OMR;
	__le32 IQ_L;
	__le32 IQ_H;
	__le32 ODR_MSI;
	__le32 reserved5;
	__le32 IQN_L;
	__le32 IQN_H;
};

struct src_registers {
	struct src_mu_registers MUnit;
	union {
		struct {
			__le32 reserved1[130786];
			struct rx_inbound IndexRegs;
		} tupelo;
		struct {
			__le32 reserved1[970];
			struct rx_inbound IndexRegs;
		} denali;
	} u;
};

struct sense_data {
	u8 error_code;
	u8 valid: 1;
	u8 segment_number;
	u8 sense_key: 4;
	u8 reserved: 1;
	u8 ILI: 1;
	u8 EOM: 1;
	u8 filemark: 1;
	u8 information[4];
	u8 add_sense_len;
	u8 cmnd_info[4];
	u8 ASC;
	u8 ASCQ;
	u8 FRUC;
	u8 bit_ptr: 3;
	u8 BPV: 1;
	u8 reserved2: 2;
	u8 CD: 1;
	u8 SKSV: 1;
	u8 field_ptr[2];
};

struct fsa_dev_info {
	u64 last;
	u64 size;
	u32 type;
	u32 config_waiting_on;
	long unsigned int config_waiting_stamp;
	u16 queue_depth;
	u8 config_needed;
	u8 valid;
	u8 ro;
	u8 locked;
	u8 deleted;
	char devname[8];
	struct sense_data sense_data;
	u32 block_size;
	u8 identifier[16];
};

struct fib_ioctl {
	u32 fibctx;
	s32 wait;
	char *fib;
};

enum {
	HBA_RESP_STAT_IO_ERROR = 1,
	HBA_RESP_STAT_IO_ABORTED = 2,
	HBA_RESP_STAT_NO_PATH_TO_DEVICE = 3,
	HBA_RESP_STAT_INVALID_DEVICE = 4,
	HBA_RESP_STAT_HBAMODE_DISABLED = 14,
	HBA_RESP_STAT_UNDERRUN = 81,
	HBA_RESP_STAT_OVERRUN = 117,
};

struct sgentry {
	__le32 addr;
	__le32 count;
};

struct sgentry64 {
	__le32 addr[2];
	__le32 count;
};

struct sgentryraw {
	__le32 next;
	__le32 prev;
	__le32 addr[2];
	__le32 count;
	__le32 flags;
};

struct sge_ieee1212 {
	u32 addrLow;
	u32 addrHigh;
	u32 length;
	u32 flags;
};

struct sgmap {
	__le32 count;
	struct sgentry sg[1];
};

struct sgmap64 {
	__le32 count;
	struct sgentry64 sg[1];
};

struct sgmapraw {
	__le32 count;
	struct sgentryraw sg[1];
};

struct creation_info {
	u8 buildnum;
	u8 usec;
	u8 via;
	u8 year;
	__le32 date;
	__le32 serial[2];
};

struct aac_bus_info {
	__le32 Command;
	__le32 ObjType;
	__le32 MethodId;
	__le32 ObjectId;
	__le32 CtlCmd;
};

struct aac_bus_info_response {
	__le32 Status;
	__le32 ObjType;
	__le32 MethodId;
	__le32 ObjectId;
	__le32 CtlCmd;
	__le32 ProbeComplete;
	__le32 BusCount;
	__le32 TargetsPerBus;
	u8 InitiatorBusId[10];
	u8 BusValid[10];
};

struct aac_read {
	__le32 command;
	__le32 cid;
	__le32 block;
	__le32 count;
	struct sgmap sg;
};

struct aac_read64 {
	__le32 command;
	__le16 cid;
	__le16 sector_count;
	__le32 block;
	__le16 pad;
	__le16 flags;
	struct sgmap64 sg;
};

struct aac_read_reply {
	__le32 status;
	__le32 count;
};

struct aac_write {
	__le32 command;
	__le32 cid;
	__le32 block;
	__le32 count;
	__le32 stable;
	struct sgmap sg;
};

struct aac_write64 {
	__le32 command;
	__le16 cid;
	__le16 sector_count;
	__le32 block;
	__le16 pad;
	__le16 flags;
	struct sgmap64 sg;
};

struct aac_raw_io {
	__le32 block[2];
	__le32 count;
	__le16 cid;
	__le16 flags;
	__le16 bpTotal;
	__le16 bpComplete;
	struct sgmapraw sg;
};

struct aac_raw_io2 {
	__le32 blockLow;
	__le32 blockHigh;
	__le32 byteCount;
	__le16 cid;
	__le16 flags;
	__le32 sgeFirstSize;
	__le32 sgeNominalSize;
	u8 sgeCnt;
	u8 bpTotal;
	u8 bpComplete;
	u8 sgeFirstIndex;
	u8 unused[4];
	struct sge_ieee1212 sge[1];
};

struct aac_synchronize {
	__le32 command;
	__le32 type;
	__le32 cid;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 count;
};

struct aac_synchronize_reply {
	__le32 dummy0;
	__le32 dummy1;
	__le32 status;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 parm5;
	u8 data[16];
};

struct aac_power_management {
	__le32 command;
	__le32 type;
	__le32 sub;
	__le32 cid;
	__le32 parm;
};

struct aac_srb {
	__le32 function;
	__le32 channel;
	__le32 id;
	__le32 lun;
	__le32 timeout;
	__le32 flags;
	__le32 count;
	__le32 retry_limit;
	__le32 cdb_size;
	u8 cdb[16];
	struct sgmap sg;
};

struct aac_srb_reply {
	__le32 status;
	__le32 srb_status;
	__le32 scsi_status;
	__le32 data_xfer_length;
	__le32 sense_data_size;
	u8 sense_data[30];
};

struct aac_srb_unit {
	struct aac_srb srb;
	struct aac_srb_reply srb_reply;
};

struct aac_fsinfo {
	__le32 fsTotalSize;
	__le32 fsBlockSize;
	__le32 fsFragSize;
	__le32 fsMaxExtendSize;
	__le32 fsSpaceUnits;
	__le32 fsMaxNumFiles;
	__le32 fsNumFreeFiles;
	__le32 fsInodeDensity;
};

struct aac_blockdevinfo {
	__le32 block_size;
	__le32 logical_phys_map;
	u8 identifier[16];
};

union aac_contentinfo {
	struct aac_fsinfo filesys;
	struct aac_blockdevinfo bdevinfo;
};

struct aac_get_config_status {
	__le32 command;
	__le32 type;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 parm5;
	__le32 count;
};

struct aac_get_config_status_resp {
	__le32 response;
	__le32 dummy0;
	__le32 status;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 parm5;
	struct {
		__le32 action;
		__le16 flags;
		__le16 count;
	} data;
};

struct aac_commit_config {
	__le32 command;
	__le32 type;
};

struct aac_get_container_count {
	__le32 command;
	__le32 type;
};

struct aac_get_container_count_resp {
	__le32 response;
	__le32 dummy0;
	__le32 MaxContainers;
	__le32 ContainerSwitchEntries;
	__le32 MaxPartitions;
	__le32 MaxSimpleVolumes;
};

struct aac_mntent {
	__le32 oid;
	u8 name[16];
	struct creation_info create_info;
	__le32 capacity;
	__le32 vol;
	__le32 obj;
	__le32 state;
	union aac_contentinfo fileinfo;
	__le32 altoid;
	__le32 capacityhigh;
};

struct aac_query_mount {
	__le32 command;
	__le32 type;
	__le32 count;
};

struct aac_mount {
	__le32 status;
	__le32 type;
	__le32 count;
	struct aac_mntent mnt[1];
};

struct aac_get_name {
	__le32 command;
	__le32 type;
	__le32 cid;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 count;
};

struct aac_get_name_resp {
	__le32 dummy0;
	__le32 dummy1;
	__le32 status;
	__le32 parm1;
	__le32 parm2;
	__le32 parm3;
	__le32 parm4;
	__le32 parm5;
	u8 data[17];
};

struct aac_get_serial {
	__le32 command;
	__le32 type;
	__le32 cid;
};

struct aac_get_serial_resp {
	__le32 dummy0;
	__le32 dummy1;
	__le32 status;
	__le32 uid;
};

struct aac_query_disk {
	s32 cnum;
	s32 bus;
	s32 id;
	s32 lun;
	u32 valid;
	u32 locked;
	u32 deleted;
	s32 instance;
	s8 name[10];
	u32 unmapped;
};

struct aac_delete_disk {
	u32 disknum;
	u32 cnum;
};

typedef struct {
	struct {
		u8 data_length;
		u8 med_type;
		u8 dev_par;
		u8 bd_length;
	} hd;
	struct {
		u8 dens_code;
		u8 block_count[3];
		u8 reserved;
		u8 block_length[3];
	} bd;
	u8 mpc_buf[3];
} aac_modep_data;

typedef struct {
	struct {
		u8 data_length[2];
		u8 med_type;
		u8 dev_par;
		u8 rsrvd[2];
		u8 bd_length[2];
	} hd;
	struct {
		u8 dens_code;
		u8 block_count[3];
		u8 reserved;
		u8 block_length[3];
	} bd;
	u8 mpc_buf[3];
} aac_modep10_data;

struct inquiry_data {
	u8 inqd_pdt;
	u8 inqd_dtq;
	u8 inqd_ver;
	u8 inqd_rdf;
	u8 inqd_len;
	u8 inqd_pad1[2];
	u8 inqd_pad2;
	u8 inqd_vid[8];
	u8 inqd_pid[16];
	u8 inqd_prl[4];
};

struct tvpd_id_descriptor_type_1 {
	u8 codeset: 4;
	u8 reserved: 4;
	u8 identifiertype: 4;
	u8 reserved2: 4;
	u8 reserved3;
	u8 identifierlength;
	u8 venid[8];
	u8 productid[16];
	u8 serialnumber[8];
};

struct teu64id {
	u32 Serial;
	u8 reserved;
	u8 venid[3];
};

struct tvpd_id_descriptor_type_2 {
	u8 codeset: 4;
	u8 reserved: 4;
	u8 identifiertype: 4;
	u8 reserved2: 4;
	u8 reserved3;
	u8 identifierlength;
	struct teu64id eu64id;
};

struct tvpd_id_descriptor_type_3 {
	u8 codeset: 4;
	u8 reserved: 4;
	u8 identifiertype: 4;
	u8 reserved2: 4;
	u8 reserved3;
	u8 identifierlength;
	u8 Identifier[16];
};

struct tvpd_page83 {
	u8 DeviceType: 5;
	u8 DeviceTypeQualifier: 3;
	u8 PageCode;
	u8 reserved;
	u8 PageLength;
	struct tvpd_id_descriptor_type_1 type1;
	struct tvpd_id_descriptor_type_2 type2;
	struct tvpd_id_descriptor_type_3 type3;
};

struct scsi_inq {
	char vid[8];
	char pid[16];
	char prl[4];
};

struct user_sgentry {
	u32 addr;
	u32 count;
};

struct user_sgentry64 {
	u32 addr[2];
	u32 count;
};

struct user_sgmap {
	u32 count;
	struct user_sgentry sg[1];
};

struct user_sgmap64 {
	u32 count;
	struct user_sgentry64 sg[1];
};

struct aac_fib_context {
	s16 type;
	s16 size;
	u32 unique;
	ulong jiffies;
	struct list_head next;
	struct completion completion;
	int wait;
	long unsigned int count;
	struct list_head fib_list;
};

struct user_aac_srb {
	u32 function;
	u32 channel;
	u32 id;
	u32 lun;
	u32 timeout;
	u32 flags;
	u32 count;
	u32 retry_limit;
	u32 cdb_size;
	u8 cdb[16];
	struct user_sgmap sg;
};

struct revision {
	u32 compat;
	__le32 version;
	__le32 build;
};

struct aac_hba_info {
	u8 driver_name[50];
	u8 adapter_number;
	u8 system_io_bus_number;
	u8 device_number;
	u32 function_number;
	u32 vendor_id;
	u32 device_id;
	u32 sub_vendor_id;
	u32 sub_system_id;
	u32 mapped_base_address_size;
	u32 base_physical_address_high_part;
	u32 base_physical_address_low_part;
	u32 max_command_size;
	u32 max_fib_size;
	u32 max_scatter_gather_from_os;
	u32 max_scatter_gather_to_fw;
	u32 max_outstanding_fibs;
	u32 queue_start_threshold;
	u32 queue_dump_threshold;
	u32 max_io_size_queued;
	u32 outstanding_io;
	u32 firmware_build_number;
	u32 bios_build_number;
	u32 driver_build_number;
	u32 serial_number_high_part;
	u32 serial_number_low_part;
	u32 supported_options;
	u32 feature_bits;
	u32 currentnumber_ports;
	u8 new_comm_interface: 1;
	u8 new_commands_supported: 1;
	u8 disable_passthrough: 1;
	u8 expose_non_dasd: 1;
	u8 queue_allowed: 1;
	u8 bled_check_enabled: 1;
	u8 reserved1: 1;
	u8 reserted2: 1;
	u32 reserved3[10];
};

struct aac_pci_info {
	u32 bus;
	u32 slot;
};

struct aac_reset_iop {
	u8 reset_type;
};

enum aac_queue_types {
	HostNormCmdQueue = 0,
	HostHighCmdQueue = 1,
	AdapNormCmdQueue = 2,
	AdapHighCmdQueue = 3,
	HostNormRespQueue = 4,
	HostHighRespQueue = 5,
	AdapNormRespQueue = 6,
	AdapHighRespQueue = 7,
};

struct aac_close {
	__le32 command;
	__le32 cid;
};

struct aac_common {
	u32 irq_mod;
	u32 peak_fibs;
	u32 zero_fibs;
	u32 fib_timeouts;
};

enum aac_log_level {
	LOG_AAC_INIT = 10,
	LOG_AAC_INFORMATIONAL = 20,
	LOG_AAC_WARNING = 30,
	LOG_AAC_LOW_ERROR = 40,
	LOG_AAC_MEDIUM_ERROR = 50,
	LOG_AAC_HIGH_ERROR = 60,
	LOG_AAC_PANIC = 70,
	LOG_AAC_DEBUG = 80,
	LOG_AAC_WINDBG_PRINT = 90,
};

struct aac_pause {
	__le32 command;
	__le32 type;
	__le32 timeout;
	__le32 min;
	__le32 noRescan;
	__le32 parm3;
	__le32 parm4;
	__le32 count;
};

struct aac_aifcmd {
	__le32 command;
	__le32 seqnum;
	u8 data[1];
};

enum {
	NOTHING = 0,
	DELETE = 1,
	ADD = 2,
	CHANGE = 3,
};

struct POSTSTATUS {
	__le32 Post_Command;
	__le32 Post_Address;
};

typedef u32 u_int32_t;

struct aac_fib_xporthdr {
	__le64 HostAddress;
	__le32 Size;
	__le32 Handle;
	__le64 Reserved[2];
};

struct ssp_frame_hdr {
	u8 frame_type;
	u8 hashed_dest_addr[3];
	u8 _r_a;
	u8 hashed_src_addr[3];
	__be16 _r_b;
	u8 changing_data_ptr: 1;
	u8 retransmit: 1;
	u8 retry_data_frames: 1;
	u8 _r_c: 5;
	u8 num_fill_bytes: 2;
	u8 _r_d: 6;
	u32 _r_e;
	__be16 tag;
	__be16 tptt;
	__be32 data_offs;
};

struct ssp_command_iu {
	u8 lun[8];
	u8 _r_a;
	union {
		struct {
			u8 attr: 3;
			u8 prio: 4;
			u8 efb: 1;
		};
		u8 efb_prio_attr;
	};
	u8 _r_b;
	u8 _r_c: 2;
	u8 add_cdb_len: 6;
	u8 cdb[16];
	u8 add_cdb[0];
};

struct ssp_tmf_iu {
	u8 lun[8];
	u16 _r_a;
	u8 tmf;
	u8 _r_b;
	__be16 tag;
	u8 _r_c[14];
};

struct sg_el {
	__le64 bus_addr;
	__le32 size;
	__le16 _r;
	u8 next_sg_offs;
	u8 flags;
};

struct scb_header {
	__le64 next_scb;
	__le16 index;
	u8 opcode;
} __attribute__((packed));

struct initiate_ssp_task {
	u8 proto_conn_rate;
	__le32 total_xfer_len;
	struct ssp_frame_hdr ssp_frame;
	struct ssp_command_iu ssp_cmd;
	__le16 sister_scb;
	__le16 conn_handle;
	u8 data_dir;
	u8 _r_a;
	u8 retry_count;
	u8 _r_b[5];
	struct sg_el sg_element[3];
} __attribute__((packed));

struct initiate_ata_task {
	u8 proto_conn_rate;
	__le32 total_xfer_len;
	struct host_to_dev_fis___2 fis;
	__le32 data_offs;
	u8 atapi_packet[16];
	u8 _r_a[12];
	__le16 sister_scb;
	__le16 conn_handle;
	u8 ata_flags;
	u8 _r_b;
	u8 retry_count;
	u8 _r_c;
	u8 flags;
	u8 _r_d[3];
	struct sg_el sg_element[3];
} __attribute__((packed));

struct initiate_smp_task {
	u8 proto_conn_rate;
	u8 _r_a[40];
	struct sg_el smp_req;
	__le16 sister_scb;
	__le16 conn_handle;
	u8 _r_c[8];
	struct sg_el smp_resp;
	u8 _r_d[32];
} __attribute__((packed));

struct control_phy {
	u8 phy_id;
	u8 sub_func;
	u8 func_mask;
	u8 speed_mask;
	u8 hot_plug_delay;
	u8 port_type;
	u8 flags;
	__le32 timeout_override;
	u8 link_reset_retries;
	u8 _r_a[47];
	__le16 conn_handle;
	u8 _r_b[56];
} __attribute__((packed));

struct control_ata_dev {
	u8 proto_conn_rate;
	__le32 _r_a;
	struct host_to_dev_fis___2 fis;
	u8 _r_b[32];
	__le16 sister_scb;
	__le16 conn_handle;
	u8 ata_flags;
	u8 _r_c[55];
} __attribute__((packed));

struct empty_scb {
	u8 num_valid;
	__le32 _r_a;
	struct sg_el eb[7];
} __attribute__((packed));

struct initiate_link_adm {
	u8 phy_id;
	u8 sub_func;
	u8 _r_a[57];
	__le16 conn_handle;
	u8 _r_b[56];
} __attribute__((packed));

struct copy_memory {
	u8 _r_a;
	__le16 xfer_len;
	__le16 _r_b;
	__le64 src_busaddr;
	u8 src_ds;
	u8 _r_c[45];
	__le16 conn_handle;
	__le64 _r_d;
	__le64 dest_busaddr;
	u8 dest_ds;
	u8 _r_e[39];
} __attribute__((packed));

struct abort_task {
	u8 proto_conn_rate;
	__le32 _r_a;
	struct ssp_frame_hdr ssp_frame;
	struct ssp_tmf_iu ssp_task;
	__le16 sister_scb;
	__le16 conn_handle;
	u8 flags;
	u8 _r_b;
	u8 retry_count;
	u8 _r_c[5];
	__le16 index;
	__le16 itnl_to;
	u8 _r_d[44];
} __attribute__((packed));

struct clear_nexus {
	u8 nexus;
	__le32 _r_a;
	u8 flags;
	u8 _r_b[3];
	u8 conn_mask;
	u8 _r_c[19];
	struct ssp_tmf_iu ssp_task;
	__le16 _r_d;
	__le16 conn_handle;
	__le64 _r_e;
	__le16 index;
	__le16 context;
	u8 _r_f[44];
} __attribute__((packed));

struct initiate_ssp_tmf {
	u8 proto_conn_rate;
	__le32 _r_a;
	struct ssp_frame_hdr ssp_frame;
	struct ssp_tmf_iu ssp_task;
	__le16 sister_scb;
	__le16 conn_handle;
	u8 flags;
	u8 _r_b;
	u8 retry_count;
	u8 _r_c[5];
	__le16 index;
	__le16 itnl_to;
	u8 _r_d[44];
} __attribute__((packed));

struct scb___3 {
	struct scb_header header;
	union {
		struct initiate_ssp_task ssp_task;
		struct initiate_ata_task ata_task;
		struct initiate_smp_task smp_task;
		struct control_phy control_phy;
		struct control_ata_dev control_ata_dev;
		struct empty_scb escb;
		struct initiate_link_adm link_adm;
		struct copy_memory cp_mem;
		struct abort_task abort_task;
		struct clear_nexus clear_nexus;
		struct initiate_ssp_tmf ssp_tmf;
	};
} __attribute__((packed));

struct done_list_struct {
	__le16 index;
	u8 opcode;
	u8 status_block[4];
	u8 toggle;
};

struct asd_phy_desc;

struct asd_dma_tok;

struct asd_port;

struct asd_phy {
	struct asd_sas_phy sas_phy;
	struct asd_phy_desc *phy_desc;
	struct sas_identify_frame *identify_frame;
	struct asd_dma_tok *id_frm_tok;
	struct asd_port *asd_port;
	u8 frame_rcvd[1068];
};

struct asd_phy_desc {
	u8 sas_addr[8];
	u8 max_sas_lrate;
	u8 min_sas_lrate;
	u8 max_sata_lrate;
	u8 min_sata_lrate;
	u8 flags;
	u8 phy_control_0;
	u8 phy_control_1;
	u8 phy_control_2;
	u8 phy_control_3;
};

struct asd_dma_tok {
	void *vaddr;
	dma_addr_t dma_handle;
	size_t size;
};

struct asd_port {
	u8 sas_addr[8];
	u8 attached_sas_addr[8];
	u32 phy_mask;
	int num_phys;
};

struct asd_ha_addrspace {
	void *addr;
	long unsigned int start;
	long unsigned int len;
	long unsigned int flags;
	u32 swa_base;
	u32 swb_base;
	u32 swc_base;
};

struct bios_struct {
	int present;
	u8 maj;
	u8 min;
	u32 bld;
};

struct unit_element_struct {
	u16 num;
	u16 size;
	void *area;
};

struct flash_struct {
	u32 bar;
	int present;
	int wide;
	u8 manuf;
	u8 dev_id;
	u8 sec_prot;
	u8 method;
	u32 dir_offs;
};

struct hw_profile {
	struct bios_struct bios;
	struct unit_element_struct ue;
	struct flash_struct flash;
	u8 sas_addr[8];
	char pcba_sn[13];
	u8 enabled_phys;
	struct asd_phy_desc phy_desc[8];
	u32 max_scbs;
	struct asd_dma_tok *scb_ext;
	u32 max_ddbs;
	struct asd_dma_tok *ddb_ext;
	spinlock_t ddb_lock;
	void *ddb_bitmap;
	int num_phys;
	int max_phys;
	unsigned int addr_range;
	unsigned int port_name_base;
	unsigned int dev_name_base;
	unsigned int sata_name_base;
};

struct asd_ha_struct;

struct asd_ascb {
	struct list_head list;
	struct asd_ha_struct *ha;
	struct scb___3 *scb;
	struct asd_dma_tok dma_scb;
	struct asd_dma_tok *sg_arr;
	void (*tasklet_complete)(struct asd_ascb *, struct done_list_struct *);
	u8 uldd_timer: 1;
	struct timer_list timer;
	struct completion *completion;
	u8 tag_valid: 1;
	__be16 tag;
	int edb_index;
	int tc_index;
	void *uldd_task;
};

struct asd_seq_data {
	spinlock_t pend_q_lock;
	u16 scbpro;
	int pending;
	struct list_head pend_q;
	int can_queue;
	struct asd_dma_tok next_scb;
	spinlock_t tc_index_lock;
	void **tc_index_array;
	void *tc_index_bitmap;
	int tc_index_bitmap_bits;
	struct tasklet_struct dl_tasklet;
	struct done_list_struct *dl;
	struct asd_dma_tok *actual_dl;
	int dl_toggle;
	int dl_next;
	int num_edbs;
	struct asd_dma_tok **edb_arr;
	int num_escbs;
	struct asd_ascb **escb_arr;
};

struct asd_ha_struct {
	struct pci_dev *pcidev;
	const char *name;
	struct sas_ha_struct sas_ha;
	u8 revision_id;
	int iospace;
	spinlock_t iolock;
	struct asd_ha_addrspace io_handle[2];
	struct hw_profile hw_prof;
	struct asd_phy phys[8];
	spinlock_t asd_ports_lock;
	struct asd_port asd_ports[8];
	struct asd_sas_port ports[8];
	struct dma_pool *scb_pool;
	struct asd_seq_data seq;
	u32 bios_status;
	const struct firmware *bios_image;
};

struct controller_id {
	u32 vendor;
	u32 device;
	u32 sub_vendor;
	u32 sub_device;
};

struct image_info {
	u32 ImageId;
	u32 ImageOffset;
	u32 ImageLength;
	u32 ImageChecksum;
	u32 ImageVersion;
};

struct bios_file_header {
	u8 signature[32];
	u32 checksum;
	u32 antidote;
	struct controller_id contrl_id;
	u32 filelen;
	u32 chunk_num;
	u32 total_chunks;
	u32 num_images;
	u32 build_num;
	struct image_info image_header;
};

struct flash_command {
	u8 command[8];
	int code;
};

struct error_bios {
	char *reason;
	int err_code;
};

struct asd_pcidev_struct {
	const char *name;
	int (*setup)(struct asd_ha_struct *);
};

enum {
	FLASH_METHOD_UNKNOWN = 0,
	FLASH_METHOD_A = 1,
	FLASH_METHOD_B = 2,
};

struct asd_ocm_dir_ent {
	u8 type;
	u8 offs[3];
	u8 _r1;
	u8 size[3];
};

struct asd_ocm_dir {
	char sig[2];
	u8 _r1[2];
	u8 major;
	u8 minor;
	u8 _r2;
	u8 num_de;
	struct asd_ocm_dir_ent entry[15];
};

struct asd_bios_chim_struct {
	char sig[4];
	u8 major;
	u8 minor;
	u8 bios_major;
	u8 bios_minor;
	__le32 bios_build;
	u8 flags;
	u8 pci_slot;
	__le16 ue_num;
	__le16 ue_size;
	u8 _r[14];
};

struct asd_flash_de {
	__le32 type;
	__le32 offs;
	__le32 pad_size;
	__le32 image_size;
	__le32 chksum;
	u8 _r[12];
	u8 version[32];
};

struct asd_flash_dir {
	u8 cookie[32];
	__le32 rev;
	__le32 chksum;
	__le32 chksum_antidote;
	__le32 bld;
	u8 bld_id[32];
	u8 ver_data[32];
	__le32 ae_mask;
	__le32 v_mask;
	__le32 oc_mask;
	u8 _r[20];
	struct asd_flash_de dir_entry[32];
};

struct asd_manuf_sec {
	char sig[2];
	u16 offs_next;
	u8 maj;
	u8 min;
	u16 chksum;
	u16 size;
	u8 _r[6];
	u8 sas_addr[8];
	u8 pcba_sn[12];
	u8 linked_list[0];
};

struct asd_manuf_phy_desc {
	u8 state;
	u8 phy_id;
	u16 _r;
	u8 phy_control_0;
	u8 phy_control_1;
	u8 phy_control_2;
	u8 phy_control_3;
};

struct asd_manuf_phy_param {
	char sig[2];
	u16 next;
	u8 maj;
	u8 min;
	u8 num_phy_desc;
	u8 phy_desc_size;
	u8 _r[3];
	u8 usage_model_id;
	u32 _r2;
	struct asd_manuf_phy_desc phy_desc[8];
};

struct asd_ms_sb_desc {
	u8 type;
	u8 node_desc_index;
	u8 conn_desc_index;
	u8 _recvd[0];
};

struct asd_ms_conn_desc {
	u8 type;
	u8 location;
	u8 num_sideband_desc;
	u8 size_sideband_desc;
	u32 _resvd;
	u8 name[16];
	struct asd_ms_sb_desc sb_desc[0];
};

struct asd_nd_phy_desc {
	u8 vp_attch_type;
	u8 attch_specific[0];
};

struct asd_ms_node_desc {
	u8 type;
	u8 num_phy_desc;
	u8 size_phy_desc;
	u8 _resvd;
	u8 name[16];
	struct asd_nd_phy_desc phy_desc[0];
};

struct asd_ms_conn_map {
	char sig[2];
	__le16 next;
	u8 maj;
	u8 min;
	__le16 cm_size;
	u8 num_conn;
	u8 conn_size;
	u8 num_nodes;
	u8 usage_model_id;
	u32 _resvd;
	struct asd_ms_conn_desc conn_desc[0];
	struct asd_ms_node_desc node_desc[0];
};

struct asd_ctrla_phy_entry {
	u8 sas_addr[8];
	u8 sas_link_rates;
	u8 flags;
	u8 sata_link_rates;
	u8 _r[5];
};

struct asd_ctrla_phy_settings {
	u8 id0;
	u8 _r;
	u16 next;
	u8 num_phys;
	u8 _r2[3];
	struct asd_ctrla_phy_entry phy_ent[8];
};

struct asd_ll_el {
	u8 id0;
	u8 id1;
	__le16 next;
	u8 something_here[0];
};

struct sequencer_file_header {
	u32 csum;
	u32 major;
	u32 minor;
	char version[16];
	u32 cseq_table_offset;
	u32 cseq_table_size;
	u32 lseq_table_offset;
	u32 lseq_table_size;
	u32 cseq_code_offset;
	u32 cseq_code_size;
	u32 lseq_code_offset;
	u32 lseq_code_size;
	u16 mode2_task;
	u16 cseq_idle_loop;
	u16 lseq_idle_loop;
} __attribute__((packed));

struct lseq_cio_regs {
	char *name;
	u32 offs;
	u8 width;
	u32 mode;
};

struct tasklet_completion_status {
	int dl_opcode;
	int tmf_state;
	u8 tag_valid: 1;
	__be16 tag;
};

enum clear_nexus_phase {
	NEXUS_PHASE_PRE = 0,
	NEXUS_PHASE_POST = 1,
	NEXUS_PHASE_RESUME = 2,
};

struct tc_resp_sb_struct {
	__le16 index_escb;
	u8 len_lsb;
	u8 flags;
};

enum chip_flavors {
	chip_8001 = 0,
	chip_8008 = 1,
	chip_8009 = 2,
	chip_8018 = 3,
	chip_8019 = 4,
	chip_8074 = 5,
	chip_8076 = 6,
	chip_8077 = 7,
	chip_8006 = 8,
	chip_8070 = 9,
	chip_8072 = 10,
};

enum memory_region_num {
	AAP1 = 0,
	IOP = 1,
	NVMD = 2,
	DEV_MEM = 3,
	CCB_MEM = 4,
	FW_FLASH = 5,
	FORENSIC_MEM = 6,
};

enum pm8001_hba_info_flags {
	PM8001F_INIT_TIME = 1,
	PM8001F_RUN_TIME = 2,
};

struct pm8001_hba_info;

struct pm8001_ccb_info;

struct pm8001_device;

struct pm8001_tmf_task;

struct pm8001_dispatch {
	char *name;
	int (*chip_init)(struct pm8001_hba_info *);
	int (*chip_soft_rst)(struct pm8001_hba_info *);
	void (*chip_rst)(struct pm8001_hba_info *);
	int (*chip_ioremap)(struct pm8001_hba_info *);
	void (*chip_iounmap)(struct pm8001_hba_info *);
	irqreturn_t (*isr)(struct pm8001_hba_info *, u8);
	u32 (*is_our_interrupt)(struct pm8001_hba_info *);
	int (*isr_process_oq)(struct pm8001_hba_info *, u8);
	void (*interrupt_enable)(struct pm8001_hba_info *, u8);
	void (*interrupt_disable)(struct pm8001_hba_info *, u8);
	void (*make_prd)(struct scatterlist *, int, void *);
	int (*smp_req)(struct pm8001_hba_info *, struct pm8001_ccb_info *);
	int (*ssp_io_req)(struct pm8001_hba_info *, struct pm8001_ccb_info *);
	int (*sata_req)(struct pm8001_hba_info *, struct pm8001_ccb_info *);
	int (*phy_start_req)(struct pm8001_hba_info *, u8);
	int (*phy_stop_req)(struct pm8001_hba_info *, u8);
	int (*reg_dev_req)(struct pm8001_hba_info *, struct pm8001_device *, u32);
	int (*dereg_dev_req)(struct pm8001_hba_info *, u32);
	int (*phy_ctl_req)(struct pm8001_hba_info *, u32, u32);
	int (*task_abort)(struct pm8001_hba_info *, struct pm8001_device *, u8, u32, u32);
	int (*ssp_tm_req)(struct pm8001_hba_info *, struct pm8001_ccb_info *, struct pm8001_tmf_task *);
	int (*get_nvmd_req)(struct pm8001_hba_info *, void *);
	int (*set_nvmd_req)(struct pm8001_hba_info *, void *);
	int (*fw_flash_update_req)(struct pm8001_hba_info *, void *);
	int (*set_dev_state_req)(struct pm8001_hba_info *, struct pm8001_device *, u32);
	int (*sas_diag_start_end_req)(struct pm8001_hba_info *, u32);
	int (*sas_diag_execute_req)(struct pm8001_hba_info *, u32);
	int (*sas_re_init_req)(struct pm8001_hba_info *);
};

struct pm8001_tmf_task {
	u8 tmf;
	u32 tag_of_task_to_be_managed;
};

struct pm8001_ioctl_payload {
	u32 signature;
	u16 major_function;
	u16 minor_function;
	u16 length;
	u16 status;
	u16 offset;
	u16 id;
	u8 *func_specific;
};

struct forensic_data {
	u32 data_type;
	union {
		struct {
			u32 direct_len;
			u32 direct_offset;
			void *direct_data;
		} gsm_buf;
		struct {
			u16 queue_type;
			u16 queue_index;
			u32 direct_len;
			void *direct_data;
		} queue_buf;
		struct {
			u32 direct_len;
			u32 direct_offset;
			u32 read_len;
			void *direct_data;
		} data_buf;
	};
};

struct pm8001_hba_memspace {
	void *memvirtaddr;
	u64 membase;
	u32 memsize;
};

struct mpi_mem {
	void *virt_ptr;
	dma_addr_t phys_addr;
	u32 phys_addr_hi;
	u32 phys_addr_lo;
	u32 total_len;
	u32 num_elements;
	u32 element_size;
	u32 alignment;
};

struct mpi_mem_req {
	u32 count;
	struct mpi_mem region[16];
};

struct encrypt {
	u32 cipher_mode;
	u32 sec_mode;
	u32 status;
	u32 flag;
};

union main_cfg_table {
	struct {
		u32 signature;
		u32 interface_rev;
		u32 firmware_rev;
		u32 max_out_io;
		u32 max_sgl;
		u32 ctrl_cap_flag;
		u32 gst_offset;
		u32 inbound_queue_offset;
		u32 outbound_queue_offset;
		u32 inbound_q_nppd_hppd;
		u32 outbound_hw_event_pid0_3;
		u32 outbound_hw_event_pid4_7;
		u32 outbound_ncq_event_pid0_3;
		u32 outbound_ncq_event_pid4_7;
		u32 outbound_tgt_ITNexus_event_pid0_3;
		u32 outbound_tgt_ITNexus_event_pid4_7;
		u32 outbound_tgt_ssp_event_pid0_3;
		u32 outbound_tgt_ssp_event_pid4_7;
		u32 outbound_tgt_smp_event_pid0_3;
		u32 outbound_tgt_smp_event_pid4_7;
		u32 upper_event_log_addr;
		u32 lower_event_log_addr;
		u32 event_log_size;
		u32 event_log_option;
		u32 upper_iop_event_log_addr;
		u32 lower_iop_event_log_addr;
		u32 iop_event_log_size;
		u32 iop_event_log_option;
		u32 fatal_err_interrupt;
		u32 fatal_err_dump_offset0;
		u32 fatal_err_dump_length0;
		u32 fatal_err_dump_offset1;
		u32 fatal_err_dump_length1;
		u32 hda_mode_flag;
		u32 anolog_setup_table_offset;
		u32 rsvd[4];
	} pm8001_tbl;
	struct {
		u32 signature;
		u32 interface_rev;
		u32 firmware_rev;
		u32 max_out_io;
		u32 max_sgl;
		u32 ctrl_cap_flag;
		u32 gst_offset;
		u32 inbound_queue_offset;
		u32 outbound_queue_offset;
		u32 inbound_q_nppd_hppd;
		u32 rsvd[8];
		u32 crc_core_dump;
		u32 rsvd1;
		u32 upper_event_log_addr;
		u32 lower_event_log_addr;
		u32 event_log_size;
		u32 event_log_severity;
		u32 upper_pcs_event_log_addr;
		u32 lower_pcs_event_log_addr;
		u32 pcs_event_log_size;
		u32 pcs_event_log_severity;
		u32 fatal_err_interrupt;
		u32 fatal_err_dump_offset0;
		u32 fatal_err_dump_length0;
		u32 fatal_err_dump_offset1;
		u32 fatal_err_dump_length1;
		u32 gpio_led_mapping;
		u32 analog_setup_table_offset;
		u32 int_vec_table_offset;
		u32 phy_attr_table_offset;
		u32 port_recovery_timer;
		u32 interrupt_reassertion_delay;
		u32 fatal_n_non_fatal_dump;
		u32 ila_version;
		u32 inc_fw_version;
	} pm80xx_tbl;
};

union general_status_table {
	struct {
		u32 gst_len_mpistate;
		u32 iq_freeze_state0;
		u32 iq_freeze_state1;
		u32 msgu_tcnt;
		u32 iop_tcnt;
		u32 rsvd;
		u32 phy_state[8];
		u32 gpio_input_val;
		u32 rsvd1[2];
		u32 recover_err_info[8];
	} pm8001_tbl;
	struct {
		u32 gst_len_mpistate;
		u32 iq_freeze_state0;
		u32 iq_freeze_state1;
		u32 msgu_tcnt;
		u32 iop_tcnt;
		u32 rsvd[9];
		u32 gpio_input_val;
		u32 rsvd1[2];
		u32 recover_err_info[8];
	} pm80xx_tbl;
};

struct inbound_queue_table {
	u32 element_pri_size_cnt;
	u32 upper_base_addr;
	u32 lower_base_addr;
	u32 ci_upper_base_addr;
	u32 ci_lower_base_addr;
	u32 pi_pci_bar;
	u32 pi_offset;
	u32 total_length;
	void *base_virt;
	void *ci_virt;
	u32 reserved;
	__le32 consumer_index;
	u32 producer_idx;
};

struct outbound_queue_table {
	u32 element_size_cnt;
	u32 upper_base_addr;
	u32 lower_base_addr;
	void *base_virt;
	u32 pi_upper_base_addr;
	u32 pi_lower_base_addr;
	u32 ci_pci_bar;
	u32 ci_offset;
	u32 total_length;
	void *pi_virt;
	u32 interrup_vec_cnt_delay;
	u32 dinterrup_to_pci_offset;
	__le32 producer_index;
	u32 consumer_idx;
};

struct sas_phy_attribute_table {
	u32 phystart1_16[16];
	u32 outbound_hw_event_pid1_16[16];
};

struct pm8001_port;

struct pm8001_phy {
	struct pm8001_hba_info *pm8001_ha;
	struct pm8001_port *port;
	struct asd_sas_phy sas_phy;
	struct sas_identify identify;
	struct scsi_device *sdev;
	u64 dev_sas_addr;
	u32 phy_type;
	struct completion *enable_completion;
	u32 frame_rcvd_size;
	u8 frame_rcvd[32];
	u8 phy_attached;
	u8 phy_state;
	enum sas_linkrate minimum_linkrate;
	enum sas_linkrate maximum_linkrate;
	struct completion *reset_completion;
	bool port_reset_status;
	bool reset_success;
};

struct pm8001_port {
	struct asd_sas_port sas_port;
	u8 port_attached;
	u16 wide_port_phymap;
	u8 port_state;
	struct list_head list;
};

struct isr_param {
	struct pm8001_hba_info *drv_inst;
	u32 irq_id;
};

struct pm8001_chip_info;

struct pm8001_hba_info {
	char name[32];
	struct list_head list;
	long unsigned int flags;
	spinlock_t lock;
	spinlock_t bitmap_lock;
	struct pci_dev *pdev;
	struct device *dev;
	struct pm8001_hba_memspace io_mem[6];
	struct mpi_mem_req memoryMap;
	struct encrypt encrypt_info;
	struct forensic_data forensic_info;
	u32 fatal_bar_loc;
	u32 forensic_last_offset;
	u32 fatal_forensic_shift_offset;
	u32 forensic_fatal_step;
	u32 evtlog_ib_offset;
	u32 evtlog_ob_offset;
	void *msg_unit_tbl_addr;
	void *main_cfg_tbl_addr;
	void *general_stat_tbl_addr;
	void *inbnd_q_tbl_addr;
	void *outbnd_q_tbl_addr;
	void *pspa_q_tbl_addr;
	void *ivt_tbl_addr;
	void *fatal_tbl_addr;
	union main_cfg_table main_cfg_tbl;
	union general_status_table gs_tbl;
	struct inbound_queue_table inbnd_q_tbl[1];
	struct outbound_queue_table outbnd_q_tbl[4];
	struct sas_phy_attribute_table phy_attr_table;
	u8 sas_addr[8];
	struct sas_ha_struct *sas;
	struct Scsi_Host *shost;
	u32 chip_id;
	const struct pm8001_chip_info *chip;
	struct completion *nvmd_completion;
	int tags_num;
	long unsigned int *tags;
	struct pm8001_phy phy[16];
	struct pm8001_port port[16];
	u32 id;
	u32 irq;
	u32 iomb_size;
	struct pm8001_device *devices;
	struct pm8001_ccb_info *ccb_info;
	int number_of_intr;
	struct tasklet_struct tasklet[64];
	u32 logging_level;
	u32 fw_status;
	u32 smp_exp_mode;
	bool controller_fatal_error;
	const struct firmware *fw_image;
	struct isr_param irq_vector[64];
	u32 reset_in_progress;
};

struct pm8001_prd_imt {
	__le32 len;
	__le32 e;
};

struct pm8001_prd {
	__le64 addr;
	struct pm8001_prd_imt im_len;
};

struct fw_control_ex;

struct pm8001_ccb_info {
	struct list_head entry;
	struct sas_task *task;
	u32 n_elem;
	u32 ccb_tag;
	dma_addr_t ccb_dma_handle;
	struct pm8001_device *device;
	struct pm8001_prd buf_prd[128];
	struct fw_control_ex *fw_control_context;
	u8 open_retry;
};

struct pm8001_device {
	enum sas_device_type dev_type;
	struct domain_device *sas_device;
	u32 attached_phy;
	u32 id;
	struct completion *dcompletion;
	struct completion *setds_completion;
	u32 device_id;
	u32 running_req;
};

struct pm8001_chip_info {
	u32 encrypt;
	u32 n_phy;
	const struct pm8001_dispatch *dispatch;
};

struct fw_control_info;

struct fw_control_ex {
	struct fw_control_info *fw_control;
	void *buffer;
	void *virtAddr;
	void *usrAddr;
	dma_addr_t phys_addr;
	u32 len;
	void *payload;
	u8 inProgress;
	void *param1;
	void *param2;
	void *param3;
};

struct fw_control_info {
	u32 retcode;
	u32 phase;
	u32 phaseCmplt;
	u32 version;
	u32 offset;
	u32 len;
	u32 size;
	u32 reserved;
	u8 buffer[1];
};

struct pm8001_mpi3_phy_pg_trx_config {
	u32 LaneLosCfg;
	u32 LanePgaCfg1;
	u32 LanePisoCfg1;
	u32 LanePisoCfg2;
	u32 LanePisoCfg3;
	u32 LanePisoCfg4;
	u32 LanePisoCfg5;
	u32 LanePisoCfg6;
	u32 LaneBctCtrl;
};

typedef char *__kernel_caddr_t;

typedef __kernel_caddr_t caddr_t;

enum phy_control_type {
	PHY_LINK_RESET = 1,
	PHY_HARD_RESET = 2,
	PHY_NOTIFY_ENABLE_SPINUP = 16,
};

struct pm8001_fw_image_header {
	u8 vender_id[8];
	u8 product_id;
	u8 hardware_rev;
	u8 dest_partition;
	u8 reserved;
	u8 fw_rev[4];
	__be32 image_length;
	__be32 image_crc;
	__be32 startup_entry;
};

struct error_fw {
	char *reason;
	int err_code;
};

enum phy_speed {
	PHY_SPEED_15 = 1,
	PHY_SPEED_30 = 2,
	PHY_SPEED_60 = 4,
	PHY_SPEED_120 = 8,
};

enum data_direction {
	DATA_DIR_NONE = 0,
	DATA_DIR_IN = 1,
	DATA_DIR_OUT = 2,
	DATA_DIR_BYRECIPIENT = 4,
};

enum port_type {
	PORT_TYPE_SAS = 2,
	PORT_TYPE_SATA = 1,
};

enum mpi_err {
	MPI_IO_STATUS_SUCCESS = 0,
	MPI_IO_STATUS_BUSY = 1,
	MPI_IO_STATUS_FAIL = 2,
};

struct pm8001_work {
	struct work_struct work;
	struct pm8001_hba_info *pm8001_ha;
	void *data;
	int handler;
};

struct fw_flash_updata_info {
	u32 cur_image_offset;
	u32 cur_image_len;
	u32 total_image_len;
	struct pm8001_prd sgl;
} __attribute__((packed));

struct mpi_msg_hdr {
	__le32 header;
};

struct phy_start_req {
	__le32 tag;
	__le32 ase_sh_lm_slr_phyid;
	struct sas_identify_frame sas_identify;
	u32 reserved[5];
};

struct phy_stop_req {
	__le32 tag;
	__le32 phy_id;
	u32 reserved[13];
};

struct sata_completion_resp {
	__le32 tag;
	__le32 status;
	__le32 param;
	u32 sata_resp[12];
};

struct hw_event_resp {
	__le32 lr_evt_status_phyid_portid;
	__le32 evt_param;
	__le32 npip_portstate;
	struct sas_identify_frame sas_identify;
	struct dev_to_host_fis sata_fis;
};

struct reg_dev_req {
	__le32 tag;
	__le32 phyid_portid;
	__le32 dtype_dlr_retry;
	__le32 firstburstsize_ITNexustimeout;
	u8 sas_addr[8];
	__le32 upper_device_id;
	u32 reserved[8];
};

struct dereg_dev_req {
	__le32 tag;
	__le32 device_id;
	u32 reserved[13];
};

struct dev_reg_resp {
	__le32 tag;
	__le32 status;
	__le32 device_id;
	u32 reserved[12];
};

struct local_phy_ctl_req {
	__le32 tag;
	__le32 phyop_phyid;
	u32 reserved1[13];
};

struct local_phy_ctl_resp {
	__le32 tag;
	__le32 phyop_phyid;
	__le32 status;
	u32 reserved[12];
};

struct hw_event_ack_req {
	__le32 tag;
	__le32 sea_phyid_portid;
	__le32 param0;
	__le32 param1;
	u32 reserved1[11];
};

struct ssp_completion_resp {
	__le32 tag;
	__le32 status;
	__le32 param;
	__le32 ssptag_rescv_rescpad;
	struct ssp_response_iu ssp_resp_iu;
	__le32 residual_count;
};

struct sata_event_resp {
	__le32 tag;
	__le32 event;
	__le32 port_id;
	__le32 device_id;
	u32 reserved[11];
};

struct ssp_event_resp {
	__le32 tag;
	__le32 event;
	__le32 port_id;
	__le32 device_id;
	u32 reserved[11];
};

struct general_event_resp {
	__le32 status;
	__le32 inb_IOMB_payload[14];
};

struct smp_req {
	__le32 tag;
	__le32 device_id;
	__le32 len_ip_ir;
	u8 smp_req16[16];
	union {
		u8 smp_req[32];
		struct {
			__le64 long_req_addr;
			__le32 long_req_size;
			u32 _r_a;
			__le64 long_resp_addr;
			__le32 long_resp_size;
			u32 _r_b;
		} long_smp_req;
	};
} __attribute__((packed));

struct smp_completion_resp {
	__le32 tag;
	__le32 status;
	__le32 param;
	__le32 _r_a[12];
};

struct task_abort_req {
	__le32 tag;
	__le32 device_id;
	__le32 tag_to_abort;
	__le32 abort_all;
	u32 reserved[11];
};

struct task_abort_resp {
	__le32 tag;
	__le32 status;
	__le32 scp;
	u32 reserved[12];
};

struct set_dev_state_req {
	__le32 tag;
	__le32 device_id;
	__le32 nds;
	u32 reserved[12];
};

struct sas_re_initialization_req {
	__le32 tag;
	__le32 SSAHOLT;
	__le32 reserved_maxPorts;
	__le32 open_reject_cmdretries_data_retries;
	__le32 sata_hol_tmo;
	u32 reserved1[10];
};

struct sata_start_req {
	__le32 tag;
	__le32 device_id;
	__le32 data_len;
	__le32 ncqtag_atap_dir_m;
	struct host_to_dev_fis___2 sata_fis;
	u32 reserved1;
	u32 reserved2;
	u32 addr_low;
	u32 addr_high;
	__le32 len;
	__le32 esgl;
};

struct ssp_ini_tm_start_req {
	__le32 tag;
	__le32 device_id;
	__le32 relate_tag;
	__le32 tmf;
	u8 lun[8];
	__le32 ds_ads_m;
	u32 reserved[8];
};

struct ssp_info_unit {
	u8 lun[8];
	u8 reserved1;
	u8 efb_prio_attr;
	u8 reserved2;
	u8 additional_cdb_len;
	u8 cdb[16];
};

struct ssp_ini_io_start_req {
	__le32 tag;
	__le32 device_id;
	__le32 data_len;
	__le32 dir_m_tlr;
	struct ssp_info_unit ssp_iu;
	__le32 addr_low;
	__le32 addr_high;
	__le32 len;
	__le32 esgl;
};

struct fw_flash_Update_req {
	__le32 tag;
	__le32 cur_image_offset;
	__le32 cur_image_len;
	__le32 total_image_len;
	u32 reserved0[7];
	__le32 sgl_addr_lo;
	__le32 sgl_addr_hi;
	__le32 len;
	__le32 ext_reserved;
};

struct fw_flash_Update_resp {
	__le32 tag;
	__le32 status;
	u32 reserved[13];
};

struct get_nvm_data_req {
	__le32 tag;
	__le32 len_ir_vpdd;
	__le32 vpd_offset;
	u32 reserved[8];
	__le32 resp_addr_lo;
	__le32 resp_addr_hi;
	__le32 resp_len;
	u32 reserved1;
};

struct set_nvm_data_req {
	__le32 tag;
	__le32 len_ir_vpdd;
	__le32 vpd_offset;
	__le32 reserved[8];
	__le32 resp_addr_lo;
	__le32 resp_addr_hi;
	__le32 resp_len;
	u32 reserved1;
};

struct get_nvm_data_resp {
	__le32 tag;
	__le32 ir_tda_bn_dps_das_nvm;
	__le32 dlen_status;
	__le32 nvm_data[12];
};

struct set_dev_state_resp {
	__le32 tag;
	__le32 status;
	__le32 device_id;
	__le32 pds_nds;
	u32 reserved[11];
};

struct sas_identify_frame_local {
	u8 frame_type: 4;
	u8 dev_type: 3;
	u8 _un0: 1;
	u8 _un1;
	union {
		struct {
			u8 _un20: 1;
			u8 smp_iport: 1;
			u8 stp_iport: 1;
			u8 ssp_iport: 1;
			u8 _un247: 4;
		};
		u8 initiator_bits;
	};
	union {
		struct {
			u8 _un30: 1;
			u8 smp_tport: 1;
			u8 stp_tport: 1;
			u8 ssp_tport: 1;
			u8 _un347: 4;
		};
		u8 target_bits;
	};
	u8 _un4_11[8];
	u8 sas_addr[8];
	u8 phy_id;
	u8 _un21_27[7];
};

struct phy_start_req___2 {
	__le32 tag;
	__le32 ase_sh_lm_slr_phyid;
	struct sas_identify_frame_local sas_identify;
	__le32 spasti;
	u32 reserved[21];
};

struct phy_stop_req___2 {
	__le32 tag;
	__le32 phy_id;
	u32 reserved[29];
};

struct hw_event_resp___2 {
	__le32 lr_status_evt_portid;
	__le32 evt_param;
	__le32 phyid_npip_portstate;
	struct sas_identify_frame sas_identify;
	struct dev_to_host_fis sata_fis;
};

struct thermal_hw_event {
	__le32 thermal_event;
	__le32 rht_lht;
};

struct reg_dev_req___2 {
	__le32 tag;
	__le32 phyid_portid;
	__le32 dtype_dlr_mcn_ir_retry;
	__le32 firstburstsize_ITNexustimeout;
	u8 sas_addr[8];
	__le32 upper_device_id;
	u32 reserved[24];
};

struct local_phy_ctl_req___2 {
	__le32 tag;
	__le32 phyop_phyid;
	u32 reserved1[29];
};

struct hw_event_ack_req___2 {
	__le32 tag;
	__le32 phyid_sea_portid;
	__le32 param0;
	__le32 param1;
	u32 reserved1[27];
};

struct phy_start_resp {
	__le32 tag;
	__le32 status;
	__le32 phyid;
	u32 reserved[12];
};

struct phy_stop_resp {
	__le32 tag;
	__le32 status;
	__le32 phyid;
	u32 reserved[12];
};

struct sata_event_resp___2 {
	__le32 tag;
	__le32 event;
	__le32 port_id;
	__le32 device_id;
	u32 reserved;
	__le32 event_param0;
	__le32 event_param1;
	__le32 sata_addr_h32;
	__le32 sata_addr_l32;
	__le32 e_udt1_udt0_crc;
	__le32 e_udt5_udt4_udt3_udt2;
	__le32 a_udt1_udt0_crc;
	__le32 a_udt5_udt4_udt3_udt2;
	__le32 hwdevid_diferr;
	__le32 err_framelen_byteoffset;
	__le32 err_dataframe;
};

struct ssp_event_resp___2 {
	__le32 tag;
	__le32 event;
	__le32 port_id;
	__le32 device_id;
	__le32 ssp_tag;
	__le32 event_param0;
	__le32 event_param1;
	__le32 sas_addr_h32;
	__le32 sas_addr_l32;
	__le32 e_udt1_udt0_crc;
	__le32 e_udt5_udt4_udt3_udt2;
	__le32 a_udt1_udt0_crc;
	__le32 a_udt5_udt4_udt3_udt2;
	__le32 hwdevid_diferr;
	__le32 err_framelen_byteoffset;
	__le32 err_dataframe;
};

struct smp_req___2 {
	__le32 tag;
	__le32 device_id;
	__le32 len_ip_ir;
	u8 smp_req16[16];
	union {
		u8 smp_req[32];
		struct {
			__le64 long_req_addr;
			__le32 long_req_size;
			u32 _r_a;
			__le64 long_resp_addr;
			__le32 long_resp_size;
			u32 _r_b;
		} long_smp_req;
	};
	__le32 rsvd[16];
} __attribute__((packed));

struct smp_completion_resp___2 {
	__le32 tag;
	__le32 status;
	__le32 param;
	u8 _r_a[252];
};

struct task_abort_req___2 {
	__le32 tag;
	__le32 device_id;
	__le32 tag_to_abort;
	__le32 abort_all;
	u32 reserved[27];
};

struct sata_start_req___2 {
	__le32 tag;
	__le32 device_id;
	__le32 data_len;
	__le32 ncqtag_atap_dir_m_dad;
	struct host_to_dev_fis___2 sata_fis;
	u32 reserved1;
	u32 reserved2;
	u32 addr_low;
	u32 addr_high;
	__le32 len;
	__le32 esgl;
	__le32 atapi_scsi_cdb[4];
	__le32 key_index_mode;
	__le32 sector_cnt_enss;
	__le32 keytagl;
	__le32 keytagh;
	__le32 twk_val0;
	__le32 twk_val1;
	__le32 twk_val2;
	__le32 twk_val3;
	__le32 enc_addr_low;
	__le32 enc_addr_high;
	__le32 enc_len;
	__le32 enc_esgl;
};

struct ssp_ini_io_start_req___2 {
	__le32 tag;
	__le32 device_id;
	__le32 data_len;
	__le32 dad_dir_m_tlr;
	struct ssp_info_unit ssp_iu;
	__le32 addr_low;
	__le32 addr_high;
	__le32 len;
	__le32 esgl;
	u8 udt[12];
	__le32 sectcnt_ios;
	__le32 key_cmode;
	__le32 ks_enss;
	__le32 keytagl;
	__le32 keytagh;
	__le32 twk_val0;
	__le32 twk_val1;
	__le32 twk_val2;
	__le32 twk_val3;
	__le32 enc_addr_low;
	__le32 enc_addr_high;
	__le32 enc_len;
	__le32 enc_esgl;
};

struct set_ctrl_cfg_req {
	__le32 tag;
	__le32 cfg_pg[14];
	u32 reserved[16];
};

struct kek_mgmt_req {
	__le32 tag;
	__le32 new_curidx_ksop;
	u32 reserved;
	__le32 kblob[12];
	u32 reserved1[16];
};

struct set_phy_profile_req {
	__le32 tag;
	__le32 ppc_phyid;
	u32 reserved[29];
};

struct set_ctrl_cfg_resp {
	__le32 tag;
	__le32 status;
	__le32 err_qlfr_pgcd;
	u32 reserved[12];
};

struct kek_mgmt_resp {
	__le32 tag;
	__le32 status;
	__le32 kidx_new_curr_ksop;
	__le32 err_qlfr;
	u32 reserved[11];
};

struct set_phy_profile_resp {
	__le32 tag;
	__le32 status;
	__le32 ppc_phyid;
	__le32 ppc_specific_rsp[12];
};

struct SASProtocolTimerConfig {
	__le32 pageCode;
	__le32 MST_MSI;
	__le32 STP_SSP_MCT_TMO;
	__le32 STP_FRM_TMO;
	__le32 STP_IDLE_TMO;
	__le32 OPNRJT_RTRY_INTVL;
	__le32 Data_Cmd_OPNRJT_RTRY_TMO;
	__le32 Data_Cmd_OPNRJT_RTRY_THR;
	__le32 MAX_AIP;
};

typedef struct SASProtocolTimerConfig SASProtocolTimerConfig_t;

enum scsi_host_guard_type {
	SHOST_DIX_GUARD_CRC = 1,
	SHOST_DIX_GUARD_IP = 2,
};

struct ssp_remote_node_context {
	u32 remote_node_index: 12;
	u32 reserved0_1: 4;
	u32 remote_node_port_width: 4;
	u32 logical_port_index: 3;
	u32 reserved0_2: 5;
	u32 nexus_loss_timer_enable: 1;
	u32 check_bit: 1;
	u32 is_valid: 1;
	u32 is_remote_node_context: 1;
	u32 remote_sas_address_lo;
	u32 remote_sas_address_hi;
	u32 function_number: 8;
	u32 reserved3_1: 8;
	u32 arbitration_wait_time: 16;
	u32 connection_occupancy_timeout: 16;
	u32 connection_inactivity_timeout: 16;
	u32 initial_arbitration_wait_time: 16;
	u32 oaf_connection_rate: 4;
	u32 oaf_features: 4;
	u32 oaf_source_zone_group: 8;
	u32 oaf_more_compatibility_features;
	u32 reserved7;
};

struct stp_remote_node_context {
	u32 data[8];
};

union scu_remote_node_context {
	struct ssp_remote_node_context ssp;
	struct stp_remote_node_context stp;
};

enum sci_status {
	SCI_SUCCESS = 0,
	SCI_SUCCESS_IO_COMPLETE_BEFORE_START = 1,
	SCI_SUCCESS_IO_DONE_EARLY = 2,
	SCI_WARNING_ALREADY_IN_STATE = 3,
	SCI_WARNING_TIMER_CONFLICT = 4,
	SCI_WARNING_SEQUENCE_INCOMPLETE = 5,
	SCI_FAILURE = 6,
	SCI_FATAL_ERROR = 7,
	SCI_FAILURE_INVALID_STATE = 8,
	SCI_FAILURE_INSUFFICIENT_RESOURCES = 9,
	SCI_FAILURE_CONTROLLER_NOT_FOUND = 10,
	SCI_FAILURE_UNSUPPORTED_CONTROLLER_TYPE = 11,
	SCI_FAILURE_UNSUPPORTED_INIT_DATA_VERSION = 12,
	SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION = 13,
	SCI_FAILURE_UNSUPPORTED_PROTOCOL = 14,
	SCI_FAILURE_UNSUPPORTED_INFORMATION_TYPE = 15,
	SCI_FAILURE_DEVICE_EXISTS = 16,
	SCI_FAILURE_ADDING_PHY_UNSUPPORTED = 17,
	SCI_FAILURE_UNSUPPORTED_INFORMATION_FIELD = 18,
	SCI_FAILURE_UNSUPPORTED_TIME_LIMIT = 19,
	SCI_FAILURE_INVALID_PHY = 20,
	SCI_FAILURE_INVALID_PORT = 21,
	SCI_FAILURE_RESET_PORT_PARTIAL_SUCCESS = 22,
	SCI_FAILURE_RESET_PORT_FAILURE = 23,
	SCI_FAILURE_INVALID_REMOTE_DEVICE = 24,
	SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED = 25,
	SCI_FAILURE_INVALID_IO_TAG = 26,
	SCI_FAILURE_IO_RESPONSE_VALID = 27,
	SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR = 28,
	SCI_FAILURE_IO_TERMINATED = 29,
	SCI_FAILURE_IO_REQUIRES_SCSI_ABORT = 30,
	SCI_FAILURE_DEVICE_NOT_FOUND = 31,
	SCI_FAILURE_INVALID_ASSOCIATION = 32,
	SCI_FAILURE_TIMEOUT = 33,
	SCI_FAILURE_INVALID_PARAMETER_VALUE = 34,
	SCI_FAILURE_UNSUPPORTED_MESSAGE_COUNT = 35,
	SCI_FAILURE_NO_NCQ_TAG_AVAILABLE = 36,
	SCI_FAILURE_PROTOCOL_VIOLATION = 37,
	SCI_FAILURE_RETRY_REQUIRED = 38,
	SCI_FAILURE_RETRY_LIMIT_REACHED = 39,
	SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS = 40,
	SCI_FAILURE_ILLEGAL_ROUTING_ATTRIBUTE_CONFIGURATION = 41,
	SCI_FAILURE_EXCEED_MAX_ROUTE_INDEX = 42,
	SCI_FAILURE_UNSUPPORTED_PCI_DEVICE_ID = 43,
};

struct sci_timer {
	struct timer_list timer;
	bool cancel;
};

struct sci_base_state;

struct sci_base_state_machine {
	const struct sci_base_state *state_table;
	u32 initial_state_id;
	u32 current_state_id;
	u32 previous_state_id;
};

typedef void (*sci_state_transition_t)(struct sci_base_state_machine *);

struct sci_base_state {
	sci_state_transition_t enter_state;
	sci_state_transition_t exit_state;
};

enum sci_remote_node_suspension_reasons {
	SCI_HW_SUSPEND = 0,
	SCI_SW_SUSPEND_NORMAL = 1,
	SCI_SW_SUSPEND_LINKHANG_DETECT = 2,
};

typedef void (*scics_sds_remote_node_context_callback)(void *);

enum sci_remote_node_context_destination_state {
	RNC_DEST_UNSPECIFIED = 0,
	RNC_DEST_READY = 1,
	RNC_DEST_FINAL = 2,
	RNC_DEST_SUSPENDED = 3,
	RNC_DEST_SUSPENDED_RESUME = 4,
};

struct sci_remote_node_context {
	u16 remote_node_index;
	u32 suspend_type;
	enum sci_remote_node_suspension_reasons suspend_reason;
	u32 suspend_count;
	enum sci_remote_node_context_destination_state destination_state;
	scics_sds_remote_node_context_callback user_callback;
	void *user_cookie;
	struct sci_base_state_machine sm;
};

struct isci_port;

struct scu_transport_layer_registers;

struct scu_link_layer_registers;

struct isci_phy {
	struct sci_base_state_machine sm;
	struct isci_port *owning_port;
	enum sas_linkrate max_negotiated_speed;
	enum sas_protocol protocol;
	u8 phy_index;
	bool bcn_received_while_port_unassigned;
	bool is_in_link_training;
	struct sci_timer sata_timer;
	struct scu_transport_layer_registers *transport_layer_registers;
	struct scu_link_layer_registers *link_layer_registers;
	struct asd_sas_phy sas_phy;
	u8 sas_addr[8];
	union {
		struct sas_identify_frame iaf;
		struct dev_to_host_fis fis;
	} frame_rcvd;
};

struct isci_host;

struct scu_port_task_scheduler_registers;

struct scu_viit_entry;

struct isci_port {
	struct isci_host *isci_host;
	struct list_head remote_dev_list;
	long unsigned int state;
	enum sci_status hard_reset_status;
	struct sci_base_state_machine sm;
	bool ready_exit;
	u8 logical_port_index;
	u8 physical_port_index;
	u8 active_phy_mask;
	u8 enabled_phy_mask;
	u8 last_active_phy;
	u16 reserved_rni;
	u16 reserved_tag;
	u32 started_request_count;
	u32 assigned_device_count;
	u32 hang_detect_users;
	u32 not_ready_reason;
	struct isci_phy *phy_table[4];
	struct isci_host *owning_controller;
	struct sci_timer timer;
	struct scu_port_task_scheduler_registers *port_task_scheduler_registers;
	u32 *port_pe_configuration_register;
	struct scu_viit_entry *viit_registers;
};

struct scu_transport_layer_registers {
	u32 control;
	u32 arbitration_delay_timer;
	u32 timer_test_mode;
	u32 reserved_0C;
	u32 stp_rni;
	u32 tlfe_wpo_read_control;
	u32 tlfe_wpo_read_data;
	u32 rxtl_single_step_control_status_1;
	u32 rxtl_single_step_control_status_2;
	u32 tlfe_awt_retry_delay_debug_control;
	u32 reserved_0028_007F[22];
};

struct scu_link_layer_registers {
	u32 speed_negotiation_timers;
	u32 link_layer_status;
	u32 port_selector_timeout;
	u32 reserved0C;
	u32 timeout_unit_value;
	u32 rcd_timeout;
	u32 link_timer_timeouts;
	u32 sas_phy_timeouts;
	u32 received_address_frame_error_counter;
	u32 invalid_dword_counter;
	u32 transmit_identification;
	u32 sas_device_name_high;
	u32 sas_device_name_low;
	u32 source_sas_address_high;
	u32 source_sas_address_low;
	u32 identify_frame_phy_id;
	u32 identify_frame_reserved;
	u32 received_address_frame;
	u32 maximum_arbitration_wait_timer_timeout;
	u32 transmit_primitive;
	u32 error_counter_event_notification_control;
	u32 frxq_payload_fill_threshold;
	u32 link_layer_hang_detection_timeout;
	u32 reserved_5C;
	u32 received_frame_count;
	u32 transmit_frame_count;
	u32 received_dword_count;
	u32 transmit_dword_count;
	u32 loss_of_sync_error_count;
	u32 running_disparity_error_count;
	u32 received_frame_crc_error_count;
	u32 stp_control;
	u32 phy_configuration;
	u32 clock_skew_management;
	u32 transmit_comwake_signal;
	u32 transmit_cominit_signal;
	u32 transmit_comsas_signal;
	u32 cominit_control;
	u32 comwake_control;
	u32 comsas_control;
	u32 received_short_frame_count;
	u32 received_frame_without_credit_count;
	u32 received_frame_after_done_count;
	u32 phy_reset_problem_count;
	u32 counter_control;
	u32 ssp_timer_timeout_values;
	u32 ftx_control;
	u32 frx_control;
	u32 ftx_watermark;
	u32 notify_enable_spinup_control;
	u32 sas_training_sequence_timer_values;
	u32 phy_capabilities;
	u32 phy_control;
	u32 reserved_d4;
	u32 link_layer_control;
	u32 afe_xcvr_control;
	u32 afe_lookup_table_control;
	u32 phy_source_zone_group_control;
	u32 receive_phycap;
	u32 reserved_ec;
	u32 speed_negotiation_afe_rx_reset_control;
	u32 power_management_control;
	u32 sas_pm_partial_request_primitive;
	u32 sas_pm_slumber_request_primitive;
	u32 sas_pm_ack_primitive_register;
	u32 sas_pm_nak_primitive_register;
	u32 sas_primitive_timeout;
	u32 reserved_10c;
	u32 pla_product_control[4];
	u32 pla_product_sum;
	u32 pla_control;
	u32 reserved_0128_037f[150];
};

struct sci_phy_user_params {
	u32 notify_enable_spin_up_insertion_frequency;
	u16 align_insertion_frequency;
	u16 in_connection_align_insertion_frequency;
	u8 max_speed_generation;
};

struct sci_user_parameters {
	struct sci_phy_user_params phys[4];
	u8 max_concurr_spinup;
	u8 phy_spin_up_delay_interval;
	u16 stp_inactivity_timeout;
	u16 ssp_inactivity_timeout;
	u16 stp_max_occupancy_timeout;
	u16 ssp_max_occupancy_timeout;
	u8 no_outbound_task_timeout;
};

struct sci_phy_oem_params {
	struct {
		uint32_t high;
		uint32_t low;
	} sas_address;
	uint32_t afe_tx_amp_control0;
	uint32_t afe_tx_amp_control1;
	uint32_t afe_tx_amp_control2;
	uint32_t afe_tx_amp_control3;
};

struct sci_oem_params {
	struct {
		uint8_t mode_type;
		uint8_t max_concurr_spin_up;
		union {
			struct {
				uint8_t ssc_sata_tx_spread_level: 4;
				uint8_t ssc_sas_tx_spread_level: 3;
				uint8_t ssc_sas_tx_type: 1;
			};
			uint8_t do_enable_ssc;
		};
		uint8_t cable_selection_mask;
	} controller;
	struct {
		uint8_t phy_mask;
	} ports[4];
	struct sci_phy_oem_params phys[4];
};

struct sci_port_configuration_agent;

typedef void (*port_config_fn)(struct isci_host *, struct sci_port_configuration_agent *, struct isci_port *, struct isci_phy *);

struct sci_port_configuration_agent {
	u16 phy_configured_mask;
	u16 phy_ready_mask;
	struct {
		u8 min_index;
		u8 max_index;
	} phy_valid_port_range[4];
	bool timer_pending;
	port_config_fn link_up_handler;
	port_config_fn link_down_handler;
	struct sci_timer timer;
};

struct sci_remote_node_table {
	u16 available_nodes_array_size;
	u16 group_array_size;
	u32 available_remote_nodes[11];
	u32 remote_node_groups[9];
};

struct sci_power_control {
	bool timer_started;
	struct sci_timer timer;
	u8 phys_waiting;
	u8 phys_granted_power;
	struct isci_phy *requesters[4];
};

struct scu_unsolicited_frame_header;

struct sci_uf_header_array {
	struct scu_unsolicited_frame_header *array;
	dma_addr_t physical_address;
};

enum unsolicited_frame_state {
	UNSOLICITED_FRAME_EMPTY = 0,
	UNSOLICITED_FRAME_IN_USE = 1,
	UNSOLICITED_FRAME_RELEASED = 2,
	UNSOLICITED_FRAME_MAX_STATES = 3,
};

struct sci_unsolicited_frame {
	enum unsolicited_frame_state state;
	struct scu_unsolicited_frame_header *header;
	void *buffer;
};

struct sci_uf_buffer_array {
	struct sci_unsolicited_frame array[128];
	dma_addr_t physical_address;
};

struct sci_uf_address_table_array {
	u64 *array;
	dma_addr_t physical_address;
};

struct sci_unsolicited_frame_control {
	u32 get;
	struct sci_uf_header_array headers;
	struct sci_uf_buffer_array buffers;
	struct sci_uf_address_table_array address_table;
};

struct isci_request;

struct isci_remote_device {
	long unsigned int flags;
	struct kref kref;
	struct isci_port *isci_port;
	struct domain_device *domain_dev;
	struct list_head node;
	struct sci_base_state_machine sm;
	u32 device_port_width;
	enum sas_linkrate connection_rate;
	struct isci_port *owning_port;
	struct sci_remote_node_context rnc;
	u32 started_request_count;
	struct isci_request *working_request;
	u32 not_ready_reason;
	scics_sds_remote_node_context_callback abort_resume_cb;
	void *abort_resume_cbparam;
};

struct scu_task_context;

struct smu_registers;

struct scu_registers;

struct isci_host {
	struct sci_base_state_machine sm;
	struct sci_timer timer;
	struct sci_user_parameters user_parameters;
	struct sci_oem_params oem_parameters;
	struct sci_port_configuration_agent port_agent;
	struct isci_remote_device *device_table[256];
	struct sci_remote_node_table available_remote_nodes;
	struct sci_power_control power_control;
	u8 io_request_sequence[256];
	struct scu_task_context *task_context_table;
	dma_addr_t tc_dma;
	union scu_remote_node_context *remote_node_context_table;
	dma_addr_t rnc_dma;
	u32 *completion_queue;
	dma_addr_t cq_dma;
	u32 completion_queue_get;
	u32 logical_port_entries;
	u32 remote_node_entries;
	u32 task_context_entries;
	void *ufi_buf;
	dma_addr_t ufi_dma;
	struct sci_unsolicited_frame_control uf_control;
	struct sci_timer phy_timer;
	bool phy_startup_timer_pending;
	u32 next_phy_to_start;
	u8 invalid_phy_mask;
	u16 interrupt_coalesce_number;
	u32 interrupt_coalesce_timeout;
	struct smu_registers *smu_registers;
	struct scu_registers *scu_registers;
	u16 tci_head;
	u16 tci_tail;
	u16 tci_pool[256];
	int id;
	struct isci_phy phys[4];
	struct isci_port ports[5];
	struct asd_sas_port sas_ports[4];
	struct sas_ha_struct sas_ha;
	struct pci_dev *pdev;
	long unsigned int flags;
	wait_queue_head_t eventq;
	struct tasklet_struct completion_tasklet;
	spinlock_t scic_lock;
	struct isci_request *reqs[256];
	struct isci_remote_device devices[256];
};

struct scu_port_task_scheduler_registers {
	u32 control;
	u32 status;
};

struct scu_viit_entry {
	u32 status;
	u32 initiator_sas_address_hi;
	u32 initiator_sas_address_lo;
	u32 reserved;
};

struct smu_registers {
	u32 post_context_port;
	u32 address_modifier;
	u32 reserved_08;
	u32 reserved_0C;
	u32 interrupt_status;
	u32 interrupt_mask;
	u32 interrupt_coalesce_control;
	u32 reserved_1C;
	u32 host_task_table_lower;
	u32 host_task_table_upper;
	u32 task_context_range;
	u32 reserved_2C;
	u32 completion_queue_lower;
	u32 completion_queue_upper;
	u32 reserved_38;
	u32 reserved_3C;
	u32 completion_queue_put;
	u32 completion_queue_get;
	u32 completion_queue_control;
	u32 reserved_4C;
	u32 reserved_5x[4];
	u32 reserved_6x[4];
	u32 reserved_7x[4];
	u32 remote_node_context_lower;
	u32 remote_node_context_upper;
	u32 reserved_88;
	u32 reserved_8C;
	u32 device_context_capacity;
	u32 device_function_capacity;
	u32 control_status;
	u32 soft_reset_control;
	u32 mmr_address_window;
	u32 mmr_data_window;
	u32 clock_gating_control;
	u32 clock_gating_performance;
	u32 reserved_Bx[4];
	u32 reserved_Cx[4];
	u32 reserved_Dx[4];
	u32 reserved_Ex[4];
	u32 reserved_Fx[4];
	u32 reserved_1xx[64];
	u32 reserved_2xx[64];
	u32 reserved_3xx[64];
	u32 task_context_assignment[256];
};

struct scu_sdma_registers {
	u32 uf_address_table_lower;
	u32 uf_address_table_upper;
	u32 uf_header_base_address_lower;
	u32 uf_header_base_address_upper;
	u32 unsolicited_frame_queue_control;
	u32 unsolicited_frame_put_pointer;
	u32 unsolicited_frame_get_pointer;
	u32 pdma_configuration;
	u32 reserved_0020_007C[24];
	u32 cdma_configuration;
	u32 reserved_0084_0400[223];
};

struct scu_sgpio_registers {
	u32 interface_control;
	u32 blink_rate;
	u32 start_drive_lower;
	u32 start_drive_upper;
	u32 serial_input_lower;
	u32 serial_input_upper;
	u32 vendor_specific_code;
	u32 reserved_001c;
	u32 output_data_select[8];
	u32 reserved_1444_14ff[48];
};

struct scu_port_task_scheduler_group_registers {
	u32 control;
	u32 real_time_clock;
	u32 real_time_clock_control;
	u32 reserved_0C;
	struct scu_port_task_scheduler_registers port[4];
	u32 protocol_engine[4];
	u32 tc_scanning_interval_control;
	u32 rnc_scanning_interval_control;
	u32 reserved_1048_107f[14];
};

struct scu_afe_transceiver {
	u32 afe_xcvr_control0;
	u32 afe_xcvr_control1;
	u32 reserved_0008;
	u32 afe_dfx_rx_control0;
	u32 afe_dfx_rx_control1;
	u32 reserved_0014;
	u32 afe_dfx_rx_status0;
	u32 afe_dfx_rx_status1;
	u32 reserved_0020;
	u32 afe_tx_control;
	u32 afe_tx_amp_control0;
	u32 afe_tx_amp_control1;
	u32 afe_tx_amp_control2;
	u32 afe_tx_amp_control3;
	u32 afe_tx_ssc_control;
	u32 reserved_003c;
	u32 afe_rx_ssc_control0;
	u32 afe_rx_ssc_control1;
	u32 afe_rx_ssc_control2;
	u32 afe_rx_eq_status0;
	u32 afe_rx_eq_status1;
	u32 afe_rx_cdr_status;
	u32 reserved_0058;
	u32 afe_channel_control;
	u32 reserved_0060_006c[4];
	u32 afe_xcvr_error_capture_status0;
	u32 afe_xcvr_error_capture_status1;
	u32 afe_xcvr_error_capture_status2;
	u32 afe_xcvr_error_capture_status3;
	u32 afe_xcvr_error_capture_status4;
	u32 afe_xcvr_error_capture_status5;
	u32 reserved_008c_00fc[30];
};

struct scu_afe_registers {
	u32 afe_bias_control;
	u32 reserved_0004;
	u32 afe_pll_control0;
	u32 afe_pll_control1;
	u32 afe_pll_control2;
	u32 afe_common_block_status;
	u32 reserved_18_7c[26];
	u32 afe_pmsn_master_control0;
	u32 afe_pmsn_master_control1;
	u32 afe_pmsn_master_control2;
	u32 reserved_008c_00fc[29];
	u32 afe_dfx_master_control0;
	u32 afe_dfx_master_control1;
	u32 afe_dfx_dcl_control;
	u32 afe_dfx_digital_monitor_control;
	u32 afe_dfx_analog_p_monitor_control;
	u32 afe_dfx_analog_n_monitor_control;
	u32 afe_dfx_ntl_status;
	u32 afe_dfx_fifo_status0;
	u32 afe_dfx_fifo_status1;
	u32 afe_dfx_master_pattern_control;
	u32 afe_dfx_p0_control;
	u32 afe_dfx_p0_data[32];
	u32 reserved_01ac;
	u32 afe_dfx_p0_instruction[24];
	u32 reserved_0210;
	u32 afe_dfx_p1_control;
	u32 afe_dfx_p1_data[16];
	u32 reserved_0258_029c[18];
	u32 afe_dfx_p1_instruction[8];
	u32 reserved_02c0_02fc[16];
	u32 afe_dfx_tx_pmsn_control;
	u32 afe_dfx_rx_pmsn_control;
	u32 reserved_0308;
	u32 afe_dfx_noa_control0;
	u32 afe_dfx_noa_control1;
	u32 afe_dfx_noa_control2;
	u32 afe_dfx_noa_control3;
	u32 afe_dfx_noa_control4;
	u32 afe_dfx_noa_control5;
	u32 afe_dfx_noa_control6;
	u32 afe_dfx_noa_control7;
	u32 reserved_032c_07fc[309];
	struct scu_afe_transceiver scu_afe_xcvr[4];
	u32 reserved_0c00_0ffc[256];
};

struct scu_protocol_engine_group_registers {
	u32 table[224];
};

struct scu_zone_partition_table {
	u32 table[2048];
};

struct scu_completion_ram {
	u32 ram[128];
};

struct scu_frame_buffer_ram {
	u32 ram[128];
};

struct scu_scratch_ram {
	u32 ram[256];
};

struct noa_protocol_engine_partition {
	u32 reserved[64];
};

struct noa_hub_partition {
	u32 reserved[64];
};

struct noa_host_interface_partition {
	u32 reserved[64];
};

struct transport_link_layer_pair {
	struct scu_transport_layer_registers tl;
	struct scu_link_layer_registers ll;
};

struct scu_peg_registers {
	struct transport_link_layer_pair pe[4];
	struct scu_port_task_scheduler_group_registers ptsg;
	struct scu_protocol_engine_group_registers peg;
	struct scu_sgpio_registers sgpio;
	u32 reserved_01500_1BFF[448];
	struct scu_viit_entry viit[64];
	struct scu_zone_partition_table zpt0;
	struct scu_zone_partition_table zpt1;
};

struct scu_registers {
	struct scu_peg_registers peg0;
	struct scu_sdma_registers sdma;
	struct scu_completion_ram cram;
	struct scu_frame_buffer_ram fbram;
	u32 reserved_6800_69FF[128];
	struct noa_protocol_engine_partition noa_pe;
	struct noa_hub_partition noa_hub;
	struct noa_host_interface_partition noa_if;
	u32 reserved_6d00_7fff[1216];
	struct scu_peg_registers peg1;
	struct scu_afe_registers afe;
	u32 reserved_f000_211fff[527360];
	struct scu_scratch_ram scratch_ram;
};

struct scu_unsolicited_frame_header {
	u32 iit_exists: 1;
	u32 protocol_type: 3;
	u32 is_address_frame: 1;
	u32 connection_rate: 4;
	u32 reserved: 23;
	u32 data[15];
};

enum sci_port_configuration_mode {
	SCIC_PORT_MANUAL_CONFIGURATION_MODE = 0,
	SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE = 1,
};

struct sci_bios_oem_param_block_hdr {
	uint8_t signature[8];
	uint16_t total_block_length;
	uint8_t hdr_length;
	uint8_t version;
	uint8_t preboot_source;
	uint8_t num_elements;
	uint16_t element_length;
	uint8_t reserved[8];
};

struct isci_orom {
	struct sci_bios_oem_param_block_hdr hdr;
	struct sci_oem_params ctrl[2];
};

struct isci_pci_info {
	struct isci_host *hosts[2];
	struct isci_orom *orom;
};

enum cable_selections {
	short_cable = 0,
	long_cable = 1,
	medium_cable = 2,
	undefined_cable = 3,
};

struct sci_sas_address {
	u32 high;
	u32 low;
};

struct sci_phy_cap {
	union {
		struct {
			u8 start: 1;
			u8 tx_ssc_type: 1;
			u8 res1: 2;
			u8 req_logical_linkrate: 4;
			u32 gen1_no_ssc: 1;
			u32 gen1_ssc: 1;
			u32 gen2_no_ssc: 1;
			u32 gen2_ssc: 1;
			u32 gen3_no_ssc: 1;
			u32 gen3_ssc: 1;
			u32 res2: 17;
			u32 parity: 1;
		};
		u32 all;
	};
};

struct sci_phy_proto {
	union {
		struct {
			u16 _r_a: 1;
			u16 smp_iport: 1;
			u16 stp_iport: 1;
			u16 ssp_iport: 1;
			u16 _r_b: 4;
			u16 _r_c: 1;
			u16 smp_tport: 1;
			u16 stp_tport: 1;
			u16 ssp_tport: 1;
			u16 _r_d: 4;
		};
		u16 all;
	};
};

enum sci_phy_states {
	SCI_PHY_INITIAL = 0,
	SCI_PHY_STOPPED = 1,
	SCI_PHY_STARTING = 2,
	SCI_PHY_SUB_INITIAL = 3,
	SCI_PHY_SUB_AWAIT_OSSP_EN = 4,
	SCI_PHY_SUB_AWAIT_SAS_SPEED_EN = 5,
	SCI_PHY_SUB_AWAIT_IAF_UF = 6,
	SCI_PHY_SUB_AWAIT_SAS_POWER = 7,
	SCI_PHY_SUB_AWAIT_SATA_POWER = 8,
	SCI_PHY_SUB_AWAIT_SATA_PHY_EN = 9,
	SCI_PHY_SUB_AWAIT_SATA_SPEED_EN = 10,
	SCI_PHY_SUB_AWAIT_SIG_FIS_UF = 11,
	SCI_PHY_SUB_FINAL = 12,
	SCI_PHY_READY = 13,
	SCI_PHY_RESETTING = 14,
	SCI_PHY_FINAL = 15,
};

enum scsi_prot_target_type {
	SCSI_PROT_DIF_TYPE0 = 0,
	SCSI_PROT_DIF_TYPE1 = 1,
	SCSI_PROT_DIF_TYPE2 = 2,
	SCSI_PROT_DIF_TYPE3 = 3,
};

enum sci_io_status {
	SCI_IO_SUCCESS = 0,
	SCI_IO_FAILURE = 6,
	SCI_IO_SUCCESS_COMPLETE_BEFORE_START = 1,
	SCI_IO_SUCCESS_IO_DONE_EARLY = 2,
	SCI_IO_FAILURE_INVALID_STATE = 8,
	SCI_IO_FAILURE_INSUFFICIENT_RESOURCES = 9,
	SCI_IO_FAILURE_UNSUPPORTED_PROTOCOL = 14,
	SCI_IO_FAILURE_RESPONSE_VALID = 27,
	SCI_IO_FAILURE_CONTROLLER_SPECIFIC_ERR = 28,
	SCI_IO_FAILURE_TERMINATED = 29,
	SCI_IO_FAILURE_REQUIRES_SCSI_ABORT = 30,
	SCI_IO_FAILURE_INVALID_PARAMETER_VALUE = 34,
	SCI_IO_FAILURE_NO_NCQ_TAG_AVAILABLE = 36,
	SCI_IO_FAILURE_PROTOCOL_VIOLATION = 37,
	SCI_IO_FAILURE_REMOTE_DEVICE_RESET_REQUIRED = 25,
	SCI_IO_FAILURE_RETRY_REQUIRED = 38,
	SCI_IO_FAILURE_RETRY_LIMIT_REACHED = 39,
	SCI_IO_FAILURE_INVALID_REMOTE_DEVICE = 24,
};

enum sci_task_status {
	SCI_TASK_SUCCESS = 0,
	SCI_TASK_FAILURE = 6,
	SCI_TASK_FAILURE_INVALID_STATE = 8,
	SCI_TASK_FAILURE_INSUFFICIENT_RESOURCES = 9,
	SCI_TASK_FAILURE_UNSUPPORTED_PROTOCOL = 14,
	SCI_TASK_FAILURE_INVALID_TAG = 26,
	SCI_TASK_FAILURE_RESPONSE_VALID = 27,
	SCI_TASK_FAILURE_CONTROLLER_SPECIFIC_ERR = 28,
	SCI_TASK_FAILURE_TERMINATED = 29,
	SCI_TASK_FAILURE_INVALID_PARAMETER_VALUE = 34,
	SCI_TASK_FAILURE_REMOTE_DEVICE_RESET_REQUIRED = 25,
	SCI_TASK_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS = 40,
};

struct ssp_cmd_iu {
	u8 LUN[8];
	u8 add_cdb_len: 6;
	u8 _r_a: 2;
	u8 _r_b;
	u8 en_fburst: 1;
	u8 task_prio: 4;
	u8 task_attr: 3;
	u8 _r_c;
	u8 cdb[16];
};

struct ssp_task_iu {
	u8 LUN[8];
	u8 _r_a;
	u8 task_func;
	u8 _r_b[4];
	u16 task_tag;
	u8 _r_c[12];
};

struct smp_req___3 {
	u8 type;
	u8 func;
	u8 alloc_resp_len;
	u8 req_len;
	u8 req_data[0];
};

struct isci_tmf;

union ttype_ptr_union {
	struct sas_task *io_task_ptr;
	struct isci_tmf *tmf_task_ptr;
};

struct scu_sgl_element {
	u32 address_upper;
	u32 address_lower;
	u32 length: 24;
	u32 address_modifier: 8;
};

struct scu_sgl_element_pair {
	struct scu_sgl_element A;
	struct scu_sgl_element B;
	u32 next_pair_upper;
	u32 next_pair_lower;
};

struct isci_stp_pio_sgl {
	int index;
	u8 set;
	u32 offset;
};

struct isci_stp_request {
	u32 pio_len;
	u8 status;
	struct isci_stp_pio_sgl sgl;
};

struct isci_request {
	long unsigned int flags;
	union ttype_ptr_union ttype_ptr;
	struct isci_host *isci_host;
	dma_addr_t request_daddr;
	dma_addr_t zero_scatter_daddr;
	unsigned int num_sg_entries;
	struct completion *io_request_completion;
	struct sci_base_state_machine sm;
	struct isci_host *owning_controller;
	struct isci_remote_device *target_device;
	u16 io_tag;
	enum sas_protocol protocol;
	u32 scu_status;
	u32 sci_status;
	u32 post_context;
	struct scu_task_context *tc;
	struct scu_sgl_element_pair sg_table[65];
	u32 saved_rx_frame_index;
	union {
		struct {
			union {
				struct ssp_cmd_iu cmd;
				struct ssp_task_iu tmf;
			};
			union {
				struct ssp_response_iu rsp;
				u8 rsp_buf[280];
			};
		} ssp;
		struct {
			struct isci_stp_request req;
			struct host_to_dev_fis___2 cmd;
			struct dev_to_host_fis rsp;
		} stp;
	};
	long: 64;
};

enum sci_remote_device_states {
	SCI_DEV_INITIAL = 0,
	SCI_DEV_STOPPED = 1,
	SCI_DEV_STARTING = 2,
	SCI_DEV_READY = 3,
	SCI_STP_DEV_IDLE = 4,
	SCI_STP_DEV_CMD = 5,
	SCI_STP_DEV_NCQ = 6,
	SCI_STP_DEV_NCQ_ERROR = 7,
	SCI_STP_DEV_ATAPI_ERROR = 8,
	SCI_STP_DEV_AWAIT_RESET = 9,
	SCI_SMP_DEV_IDLE = 10,
	SCI_SMP_DEV_CMD = 11,
	SCI_DEV_STOPPING = 12,
	SCI_DEV_FAILED = 13,
	SCI_DEV_RESETTING = 14,
	SCI_DEV_FINAL = 15,
};

struct ssp_task_context {
	u32 reserved00: 24;
	u32 frame_type: 8;
	u32 reserved01;
	u32 fill_bytes: 2;
	u32 reserved02: 6;
	u32 changing_data_pointer: 1;
	u32 retransmit: 1;
	u32 retry_data_frame: 1;
	u32 tlr_control: 2;
	u32 reserved03: 19;
	u32 uiRsvd4;
	u32 target_port_transfer_tag: 16;
	u32 tag: 16;
	u32 data_offset;
};

struct stp_task_context {
	u32 fis_type: 8;
	u32 pm_port: 4;
	u32 reserved0: 3;
	u32 control: 1;
	u32 command: 8;
	u32 features: 8;
	u32 reserved1;
	u32 reserved2;
	u32 reserved3;
	u32 ncq_tag: 5;
	u32 reserved4: 27;
	u32 data_offset;
};

struct smp_task_context {
	u32 response_length: 8;
	u32 function_result: 8;
	u32 function: 8;
	u32 frame_type: 8;
	u32 smp_response_ufi: 12;
	u32 reserved1: 20;
	u32 reserved2;
	u32 reserved3;
	u32 reserved4;
	u32 reserved5;
};

struct primitive_task_context {
	u32 control;
	u32 sequence;
	u32 reserved0;
	u32 reserved1;
	u32 reserved2;
	u32 reserved3;
};

union protocol_context {
	struct ssp_task_context ssp;
	struct stp_task_context stp;
	struct smp_task_context smp;
	struct primitive_task_context primitive;
	u32 words[6];
};

struct transport_snapshot {
	u32 xfer_rdy_write_data_length;
	u32 data_offset;
	u32 data_transfer_size: 24;
	u32 reserved_50_0: 8;
	u32 next_initiator_write_data_offset;
	u32 next_initiator_write_data_xfer_size: 24;
	u32 reserved_58_0: 8;
};

struct scu_task_context {
	u32 priority: 2;
	u32 initiator_request: 1;
	u32 connection_rate: 4;
	u32 protocol_engine_index: 3;
	u32 logical_port_index: 3;
	u32 protocol_type: 3;
	u32 task_index: 12;
	u32 reserved_00_0: 1;
	u32 abort: 1;
	u32 valid: 1;
	u32 context_type: 1;
	u32 remote_node_index: 12;
	u32 mirrored_node_index: 12;
	u32 sata_direction: 1;
	u32 command_code: 2;
	u32 suspend_node: 1;
	u32 task_type: 4;
	u32 link_layer_control: 8;
	u32 ssp_tlr_enable: 1;
	u32 dma_ssp_target_good_response: 1;
	u32 do_not_dma_ssp_good_response: 1;
	u32 strict_ordering: 1;
	u32 control_frame: 1;
	u32 tl_control_reserved: 3;
	u32 timeout_enable: 1;
	u32 pts_control_reserved: 7;
	u32 block_guard_enable: 1;
	u32 sdma_control_reserved: 7;
	u32 address_modifier: 16;
	u32 mirrored_protocol_engine: 3;
	u32 mirrored_logical_port: 4;
	u32 reserved_0C_0: 8;
	u32 mirror_request_enable: 1;
	u32 ssp_command_iu_length: 8;
	u32 xfer_ready_tlr_enable: 1;
	u32 reserved_10_0: 7;
	u32 ssp_max_burst_size: 16;
	u32 transfer_length_bytes: 24;
	u32 reserved_14_0: 8;
	union protocol_context type;
	u32 command_iu_upper;
	u32 command_iu_lower;
	u32 response_iu_upper;
	u32 response_iu_lower;
	u32 task_phase: 8;
	u32 task_status: 8;
	u32 previous_extended_tag: 4;
	u32 stp_retry_count: 2;
	u32 reserved_40_1: 2;
	u32 ssp_tlr_threshold: 4;
	u32 reserved_40_2: 4;
	u32 write_data_length;
	struct transport_snapshot snapshot;
	u32 blk_prot_en: 1;
	u32 blk_sz: 2;
	u32 blk_prot_func: 2;
	u32 reserved_5C_0: 9;
	u32 active_sgl_element: 2;
	u32 sgl_exhausted: 1;
	u32 payload_data_transfer_error: 4;
	u32 frame_buffer_offset: 11;
	struct scu_sgl_element_pair sgl_pair_ab;
	struct scu_sgl_element_pair sgl_pair_cd;
	struct scu_sgl_element_pair sgl_snapshot_ac;
	u32 active_sgl_element_pair;
	u32 reserved_C4_CC[3];
	u32 interm_crc_val: 16;
	u32 init_crc_seed: 16;
	u32 app_tag_verify: 16;
	u32 app_tag_gen: 16;
	u32 ref_tag_seed_verify;
	u32 UD_bytes_immed_val: 13;
	u32 reserved_DC_0: 3;
	u32 DIF_bytes_immed_val: 4;
	u32 reserved_DC_1: 12;
	u32 bgc_blk_sz: 13;
	u32 reserved_E0_0: 3;
	u32 app_tag_gen_mask: 16;
	union {
		u16 bgctl;
		struct {
			u16 crc_verify: 1;
			u16 app_tag_chk: 1;
			u16 ref_tag_chk: 1;
			u16 op: 2;
			u16 legacy: 1;
			u16 invert_crc_seed: 1;
			u16 ref_tag_gen: 1;
			u16 fixed_ref_tag: 1;
			u16 invert_crc: 1;
			u16 app_ref_f_detect: 1;
			u16 uninit_dif_check_err: 1;
			u16 uninit_dif_bypass: 1;
			u16 app_f_detect: 1;
			u16 reserved_0: 2;
		} bgctl_f;
	};
	u16 app_tag_verify_mask;
	u32 blk_guard_err: 8;
	u32 reserved_E8_0: 24;
	u32 ref_tag_seed_gen;
	u32 intermediate_crc_valid_snapshot: 16;
	u32 reserved_F0_0: 16;
	u32 reference_tag_seed_for_verify_function_snapshot;
	u32 snapshot_of_reserved_dword_DC_of_tc;
	u32 reference_tag_seed_for_generate_function_snapshot;
};

enum isci_tmf_function_codes {
	isci_tmf_func_none = 0,
	isci_tmf_ssp_task_abort = 1,
	isci_tmf_ssp_lun_reset = 8,
};

struct isci_tmf {
	struct completion *complete;
	enum sas_protocol proto;
	union {
		struct ssp_response_iu resp_iu;
		struct dev_to_host_fis d2h_fis;
		u8 rsp_buf[280];
	} resp;
	unsigned char lun[8];
	u16 io_tag;
	enum isci_tmf_function_codes tmf_code;
	int status;
};

enum {
	SCU_TASK_TYPE_IOREAD = 0,
	SCU_TASK_TYPE_IOWRITE = 1,
	SCU_TASK_TYPE_SMP_REQUEST = 2,
	SCU_TASK_TYPE_RESPONSE = 3,
	SCU_TASK_TYPE_RAW_FRAME = 4,
	SCU_TASK_TYPE_PRIMITIVE = 5,
};

enum {
	SCU_TASK_TYPE_DMA_IN = 0,
	SCU_TASK_TYPE_FPDMAQ_READ = 1,
	SCU_TASK_TYPE_PACKET_DMA_IN = 2,
	SCU_TASK_TYPE_SATA_RAW_FRAME = 3,
	RESERVED_4 = 4,
	RESERVED_5 = 5,
	RESERVED_6 = 6,
	RESERVED_7 = 7,
	SCU_TASK_TYPE_DMA_OUT = 8,
	SCU_TASK_TYPE_FPDMAQ_WRITE = 9,
	SCU_TASK_TYPE_PACKET_DMA_OUT = 10,
};

enum sci_base_request_states {
	SCI_REQ_INIT = 0,
	SCI_REQ_CONSTRUCTED = 1,
	SCI_REQ_STARTED = 2,
	SCI_REQ_STP_UDMA_WAIT_TC_COMP = 3,
	SCI_REQ_STP_UDMA_WAIT_D2H = 4,
	SCI_REQ_STP_NON_DATA_WAIT_H2D = 5,
	SCI_REQ_STP_NON_DATA_WAIT_D2H = 6,
	SCI_REQ_STP_PIO_WAIT_H2D = 7,
	SCI_REQ_STP_PIO_WAIT_FRAME = 8,
	SCI_REQ_STP_PIO_DATA_IN = 9,
	SCI_REQ_STP_PIO_DATA_OUT = 10,
	SCI_REQ_ATAPI_WAIT_H2D = 11,
	SCI_REQ_ATAPI_WAIT_PIO_SETUP = 12,
	SCI_REQ_ATAPI_WAIT_D2H = 13,
	SCI_REQ_ATAPI_WAIT_TC_COMP = 14,
	SCI_REQ_TASK_WAIT_TC_COMP = 15,
	SCI_REQ_TASK_WAIT_TC_RESP = 16,
	SCI_REQ_SMP_WAIT_RESP = 17,
	SCI_REQ_SMP_WAIT_TC_COMP = 18,
	SCI_REQ_COMPLETED = 19,
	SCI_REQ_ABORTING = 20,
	SCI_REQ_FINAL = 21,
};

struct sata_fis_data;

struct sci_port_end_point_properties {
	struct sci_sas_address sas_address;
	struct sci_phy_proto protocols;
};

struct sci_port_properties {
	u32 index;
	struct sci_port_end_point_properties local;
	struct sci_port_end_point_properties remote;
	u32 phy_mask;
};

enum scis_sds_remote_node_context_states {
	SCI_RNC_INITIAL = 0,
	SCI_RNC_POSTING = 1,
	SCI_RNC_INVALIDATING = 2,
	SCI_RNC_RESUMING = 3,
	SCI_RNC_READY = 4,
	SCI_RNC_TX_SUSPENDED = 5,
	SCI_RNC_TX_RX_SUSPENDED = 6,
	SCI_RNC_AWAIT_SUSPENSION = 7,
};

enum sci_remote_device_not_ready_reason_code {
	SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED = 0,
	SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED = 1,
	SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED = 2,
	SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED = 3,
	SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED = 4,
	SCIC_REMOTE_DEVICE_NOT_READY_REASON_CODE_MAX = 5,
};

enum sci_port_not_ready_reason_code {
	SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS = 0,
	SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED = 1,
	SCIC_PORT_NOT_READY_INVALID_PORT_CONFIGURATION = 2,
	SCIC_PORT_NOT_READY_RECONFIGURING = 3,
	SCIC_PORT_NOT_READY_REASON_CODE_MAX = 4,
};

enum sci_port_states {
	SCI_PORT_STOPPED = 0,
	SCI_PORT_STOPPING = 1,
	SCI_PORT_READY = 2,
	SCI_PORT_SUB_WAITING = 3,
	SCI_PORT_SUB_OPERATIONAL = 4,
	SCI_PORT_SUB_CONFIGURING = 5,
	SCI_PORT_RESETTING = 6,
	SCI_PORT_FAILED = 7,
};

enum sas_gpio_reg_type {
	SAS_GPIO_REG_CFG = 0,
	SAS_GPIO_REG_RX = 1,
	SAS_GPIO_REG_RX_GP = 2,
	SAS_GPIO_REG_TX = 3,
	SAS_GPIO_REG_TX_GP = 4,
};

enum sci_controller_states {
	SCIC_INITIAL = 0,
	SCIC_RESET = 1,
	SCIC_INITIALIZING = 2,
	SCIC_INITIALIZED = 3,
	SCIC_STARTING = 4,
	SCIC_READY = 5,
	SCIC_RESETTING = 6,
	SCIC_STOPPING = 7,
	SCIC_FAILED = 8,
};

struct isci_oem_hdr {
	u8 sig[4];
	u8 rev_major;
	u8 rev_minor;
	u16 len;
	u8 checksum;
	u8 reserved1;
	u16 reserved2;
};

enum SCIC_SDS_APC_ACTIVITY {
	SCIC_SDS_APC_SKIP_PHY = 0,
	SCIC_SDS_APC_ADD_PHY = 1,
	SCIC_SDS_APC_START_TIMER = 2,
	SCIC_SDS_APC_ACTIVITY_MAX = 3,
};

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t log_drv;
	uint8_t sg_count;
	uint32_t lba;
	uint32_t sg_addr;
	uint16_t sector_count;
	uint8_t segment_4G;
	uint8_t enhanced_sg;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_IO_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint16_t reserved;
	uint32_t reserved2;
	uint32_t buffer_addr;
	uint32_t reserved3;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_LD_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t reserved;
	uint8_t reserved2;
	uint32_t reserved3;
	uint32_t buffer_addr;
	uint32_t reserved4;
} IPS_IOCTL_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t channel;
	uint8_t reserved3;
	uint8_t reserved4;
	uint8_t reserved5;
	uint8_t reserved6;
	uint8_t reserved7;
	uint8_t reserved8;
	uint8_t reserved9;
	uint8_t reserved10;
	uint8_t reserved11;
	uint8_t reserved12;
	uint8_t reserved13;
	uint8_t reserved14;
	uint8_t adapter_flag;
} IPS_RESET_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint16_t reserved;
	uint32_t reserved2;
	uint32_t dcdb_address;
	uint16_t reserved3;
	uint8_t segment_4G;
	uint8_t enhanced_sg;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_DCDB_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t channel;
	uint8_t source_target;
	uint32_t reserved;
	uint32_t reserved2;
	uint32_t reserved3;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_CS_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t log_drv;
	uint8_t control;
	uint32_t reserved;
	uint32_t reserved2;
	uint32_t reserved3;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_US_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t reserved;
	uint8_t state;
	uint32_t reserved2;
	uint32_t reserved3;
	uint32_t reserved4;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_FC_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t reserved;
	uint8_t desc;
	uint32_t reserved2;
	uint32_t buffer_addr;
	uint32_t reserved3;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_STATUS_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t page;
	uint8_t write;
	uint32_t reserved;
	uint32_t buffer_addr;
	uint32_t reserved2;
	uint32_t ccsar;
	uint32_t cccr;
} IPS_NVRAM_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint16_t reserved;
	uint32_t count;
	uint32_t buffer_addr;
	uint32_t reserved2;
} IPS_VERSION_INFO;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t reset_count;
	uint8_t reset_type;
	uint8_t second;
	uint8_t minute;
	uint8_t hour;
	uint8_t day;
	uint8_t reserved1[4];
	uint8_t month;
	uint8_t yearH;
	uint8_t yearL;
	uint8_t reserved2;
} IPS_FFDC_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t type;
	uint8_t direction;
	uint32_t count;
	uint32_t buffer_addr;
	uint8_t total_packets;
	uint8_t packet_num;
	uint16_t reserved;
} IPS_FLASHFW_CMD;

typedef struct {
	uint8_t op_code;
	uint8_t command_id;
	uint8_t type;
	uint8_t direction;
	uint32_t count;
	uint32_t buffer_addr;
	uint32_t offset;
} IPS_FLASHBIOS_CMD;

typedef union {
	IPS_IO_CMD basic_io;
	IPS_LD_CMD logical_info;
	IPS_IOCTL_CMD ioctl_info;
	IPS_DCDB_CMD dcdb;
	IPS_CS_CMD config_sync;
	IPS_US_CMD unlock_stripe;
	IPS_FC_CMD flush_cache;
	IPS_STATUS_CMD status;
	IPS_NVRAM_CMD nvram;
	IPS_FFDC_CMD ffdc;
	IPS_FLASHFW_CMD flashfw;
	IPS_FLASHBIOS_CMD flashbios;
	IPS_VERSION_INFO version_info;
	IPS_RESET_CMD reset;
} IPS_HOST_COMMAND;

typedef struct {
	uint8_t logical_id;
	uint8_t reserved;
	uint8_t raid_level;
	uint8_t state;
	uint32_t sector_count;
} IPS_DRIVE_INFO;

typedef struct {
	uint8_t no_of_log_drive;
	uint8_t reserved[3];
	IPS_DRIVE_INFO drive_info[8];
} IPS_LD_INFO;

typedef struct {
	uint8_t device_address;
	uint8_t cmd_attribute;
	uint16_t transfer_length;
	uint32_t buffer_pointer;
	uint8_t cdb_length;
	uint8_t sense_length;
	uint8_t sg_count;
	uint8_t reserved;
	uint8_t scsi_cdb[12];
	uint8_t sense_info[64];
	uint8_t scsi_status;
	uint8_t reserved2[3];
} IPS_DCDB_TABLE;

typedef struct {
	uint8_t device_address;
	uint8_t cmd_attribute;
	uint8_t cdb_length;
	uint8_t reserved_for_LUN;
	uint32_t transfer_length;
	uint32_t buffer_pointer;
	uint16_t sg_count;
	uint8_t sense_length;
	uint8_t scsi_status;
	uint32_t reserved;
	uint8_t scsi_cdb[16];
	uint8_t sense_info[56];
} IPS_DCDB_TABLE_TAPE;

typedef union {
	struct {
		volatile uint8_t reserved;
		volatile uint8_t command_id;
		volatile uint8_t basic_status;
		volatile uint8_t extended_status;
	} fields;
	volatile uint32_t value;
} IPS_STATUS;

typedef union {
	struct {
		volatile uint8_t reserved;
		volatile uint8_t command_id;
		volatile uint8_t basic_status;
		volatile uint8_t extended_status;
	} fields;
	volatile uint32_t value;
} *PIPS_STATUS;

typedef struct {
	IPS_STATUS status[129];
	volatile PIPS_STATUS p_status_start;
	volatile PIPS_STATUS p_status_end;
	volatile PIPS_STATUS p_status_tail;
	volatile uint32_t hw_status_start;
	volatile uint32_t hw_status_tail;
} IPS_ADAPTER;

typedef struct {
	uint8_t ucLogDriveCount;
	uint8_t ucMiscFlag;
	uint8_t ucSLTFlag;
	uint8_t ucBSTFlag;
	uint8_t ucPwrChgCnt;
	uint8_t ucWrongAdrCnt;
	uint8_t ucUnidentCnt;
	uint8_t ucNVramDevChgCnt;
	uint8_t CodeBlkVersion[8];
	uint8_t BootBlkVersion[8];
	uint32_t ulDriveSize[8];
	uint8_t ucConcurrentCmdCount;
	uint8_t ucMaxPhysicalDevices;
	uint16_t usFlashRepgmCount;
	uint8_t ucDefunctDiskCount;
	uint8_t ucRebuildFlag;
	uint8_t ucOfflineLogDrvCount;
	uint8_t ucCriticalDrvCount;
	uint16_t usConfigUpdateCount;
	uint8_t ucBlkFlag;
	uint8_t reserved;
	uint16_t usAddrDeadDisk[64];
} IPS_ENQ;

typedef struct {
	uint8_t ucInitiator;
	uint8_t ucParameters;
	uint8_t ucMiscFlag;
	uint8_t ucState;
	uint32_t ulBlockCount;
	uint8_t ucDeviceId[28];
} IPS_DEVSTATE;

typedef struct {
	uint8_t ucChn;
	uint8_t ucTgt;
	uint16_t ucReserved;
	uint32_t ulStartSect;
	uint32_t ulNoOfSects;
} IPS_CHUNK;

typedef struct {
	uint16_t ucUserField;
	uint8_t ucState;
	uint8_t ucRaidCacheParam;
	uint8_t ucNoOfChunkUnits;
	uint8_t ucStripeSize;
	uint8_t ucParams;
	uint8_t ucReserved;
	uint32_t ulLogDrvSize;
	IPS_CHUNK chunk[16];
} IPS_LD;

typedef struct {
	uint8_t board_disc[8];
	uint8_t processor[8];
	uint8_t ucNoChanType;
	uint8_t ucNoHostIntType;
	uint8_t ucCompression;
	uint8_t ucNvramType;
	uint32_t ulNvramSize;
} IPS_HARDWARE;

typedef struct {
	uint8_t ucLogDriveCount;
	uint8_t ucDateD;
	uint8_t ucDateM;
	uint8_t ucDateY;
	uint8_t init_id[4];
	uint8_t host_id[12];
	uint8_t time_sign[8];
	uint32_t UserOpt;
	uint16_t user_field;
	uint8_t ucRebuildRate;
	uint8_t ucReserve;
	IPS_HARDWARE hardware_disc;
	IPS_LD logical_drive[8];
	IPS_DEVSTATE dev[64];
	uint8_t reserved[512];
} IPS_CONF;

typedef struct {
	uint32_t signature;
	uint8_t reserved1;
	uint8_t adapter_slot;
	uint16_t adapter_type;
	uint8_t ctrl_bios[8];
	uint8_t versioning;
	uint8_t version_mismatch;
	uint8_t reserved2;
	uint8_t operating_system;
	uint8_t driver_high[4];
	uint8_t driver_low[4];
	uint8_t BiosCompatibilityID[8];
	uint8_t ReservedForOS2[8];
	uint8_t bios_high[4];
	uint8_t bios_low[4];
	uint8_t adapter_order[16];
	uint8_t Filler[60];
} IPS_NVRAM_P5;

struct _IPS_SUBSYS {
	uint32_t param[128];
};

typedef struct _IPS_SUBSYS IPS_SUBSYS;

typedef struct {
	uint8_t DeviceType;
	uint8_t DeviceTypeQualifier;
	uint8_t Version;
	uint8_t ResponseDataFormat;
	uint8_t AdditionalLength;
	uint8_t Reserved;
	uint8_t Flags[2];
	uint8_t VendorId[8];
	uint8_t ProductId[16];
	uint8_t ProductRevisionLevel[4];
	uint8_t Reserved2;
} IPS_SCSI_INQ_DATA;

typedef struct {
	uint32_t lba;
	uint32_t len;
} IPS_SCSI_CAPACITY;

typedef struct {
	uint8_t ResponseCode;
	uint8_t SegmentNumber;
	uint8_t Flags;
	uint8_t Information[4];
	uint8_t AdditionalLength;
	uint8_t CommandSpecific[4];
	uint8_t AdditionalSenseCode;
	uint8_t AdditionalSenseCodeQual;
	uint8_t FRUCode;
	uint8_t SenseKeySpecific[3];
} IPS_SCSI_REQSEN;

typedef struct {
	uint8_t PageCode;
	uint8_t PageLength;
	uint16_t TracksPerZone;
	uint16_t AltSectorsPerZone;
	uint16_t AltTracksPerZone;
	uint16_t AltTracksPerVolume;
	uint16_t SectorsPerTrack;
	uint16_t BytesPerSector;
	uint16_t Interleave;
	uint16_t TrackSkew;
	uint16_t CylinderSkew;
	uint8_t flags;
	uint8_t reserved[3];
} IPS_SCSI_MODE_PAGE3;

typedef struct {
	uint8_t PageCode;
	uint8_t PageLength;
	uint16_t CylindersHigh;
	uint8_t CylindersLow;
	uint8_t Heads;
	uint16_t WritePrecompHigh;
	uint8_t WritePrecompLow;
	uint16_t ReducedWriteCurrentHigh;
	uint8_t ReducedWriteCurrentLow;
	uint16_t StepRate;
	uint16_t LandingZoneHigh;
	uint8_t LandingZoneLow;
	uint8_t flags;
	uint8_t RotationalOffset;
	uint8_t Reserved;
	uint16_t MediumRotationRate;
	uint8_t Reserved2[2];
} IPS_SCSI_MODE_PAGE4;

typedef struct {
	uint8_t PageCode;
	uint8_t PageLength;
	uint8_t flags;
	uint8_t RetentPrio;
	uint16_t DisPrefetchLen;
	uint16_t MinPrefetchLen;
	uint16_t MaxPrefetchLen;
	uint16_t MaxPrefetchCeiling;
} IPS_SCSI_MODE_PAGE8;

typedef struct {
	uint32_t NumberOfBlocks;
	uint8_t DensityCode;
	uint16_t BlockLengthHigh;
	uint8_t BlockLengthLow;
} IPS_SCSI_MODE_PAGE_BLKDESC;

typedef struct {
	uint8_t DataLength;
	uint8_t MediumType;
	uint8_t Reserved;
	uint8_t BlockDescLength;
} IPS_SCSI_MODE_PAGE_HEADER;

typedef struct {
	IPS_SCSI_MODE_PAGE_HEADER hdr;
	IPS_SCSI_MODE_PAGE_BLKDESC blkdesc;
	union {
		IPS_SCSI_MODE_PAGE3 pg3;
		IPS_SCSI_MODE_PAGE4 pg4;
		IPS_SCSI_MODE_PAGE8 pg8;
	} pdata;
} IPS_SCSI_MODE_PAGE_DATA;

struct ips_sglist {
	uint32_t address;
	uint32_t length;
};

typedef struct ips_sglist IPS_STD_SG_LIST;

struct ips_enh_sglist {
	uint32_t address_lo;
	uint32_t address_hi;
	uint32_t length;
	uint32_t reserved;
};

typedef struct ips_enh_sglist IPS_ENH_SG_LIST;

typedef union {
	void *list;
	IPS_STD_SG_LIST *std_list;
	IPS_ENH_SG_LIST *enh_list;
} IPS_SG_LIST;

typedef struct {
	char *option_name;
	int *option_flag;
	int option_value;
} IPS_OPTION;

struct ips_stat {
	uint32_t residue_len;
	void *scb_addr;
	uint8_t padding[4];
};

typedef struct ips_stat ips_stat_t;

struct ips_scb;

struct ips_scb_queue {
	struct ips_scb *head;
	struct ips_scb *tail;
	int count;
};

struct ips_ha;

typedef struct ips_ha ips_ha_t;

typedef void (*ips_scb_callback)(ips_ha_t *, struct ips_scb *);

struct ips_scb {
	IPS_HOST_COMMAND cmd;
	IPS_DCDB_TABLE dcdb;
	uint8_t target_id;
	uint8_t bus;
	uint8_t lun;
	uint8_t cdb[12];
	uint32_t scb_busaddr;
	uint32_t old_data_busaddr;
	uint32_t timeout;
	uint8_t basic_status;
	uint8_t extended_status;
	uint8_t breakup;
	uint8_t sg_break;
	uint32_t data_len;
	uint32_t sg_len;
	uint32_t flags;
	uint32_t op_code;
	IPS_SG_LIST sg_list;
	struct scsi_cmnd *scsi_cmd;
	struct ips_scb *q_next;
	ips_scb_callback callback;
	uint32_t sg_busaddr;
	int sg_count;
	dma_addr_t data_busaddr;
};

typedef struct ips_scb_queue ips_scb_queue_t;

struct ips_wait_queue {
	struct scsi_cmnd *head;
	struct scsi_cmnd *tail;
	int count;
};

typedef struct ips_wait_queue ips_wait_queue_entry_t;

struct ips_copp_wait_item {
	struct scsi_cmnd *scsi_cmd;
	struct ips_copp_wait_item *next;
};

typedef struct ips_copp_wait_item ips_copp_wait_item_t;

struct ips_copp_queue {
	struct ips_copp_wait_item *head;
	struct ips_copp_wait_item *tail;
	int count;
};

typedef struct ips_copp_queue ips_copp_queue_t;

typedef struct {
	int (*reset)(struct ips_ha *);
	int (*issue)(struct ips_ha *, struct ips_scb *);
	int (*isinit)(struct ips_ha *);
	int (*isintr)(struct ips_ha *);
	int (*init)(struct ips_ha *);
	int (*erasebios)(struct ips_ha *);
	int (*programbios)(struct ips_ha *, char *, uint32_t, uint32_t);
	int (*verifybios)(struct ips_ha *, char *, uint32_t, uint32_t);
	void (*statinit)(struct ips_ha *);
	int (*intr)(struct ips_ha *);
	void (*enableint)(struct ips_ha *);
	uint32_t (*statupd)(struct ips_ha *);
} ips_hw_func_t;

struct ips_ha {
	uint8_t ha_id[5];
	uint32_t dcdb_active[4];
	uint32_t io_addr;
	uint8_t ntargets;
	uint8_t nbus;
	uint8_t nlun;
	uint16_t ad_type;
	uint16_t host_num;
	uint32_t max_xfer;
	uint32_t max_cmds;
	uint32_t num_ioctl;
	ips_stat_t sp;
	struct ips_scb *scbs;
	struct ips_scb *scb_freelist;
	ips_wait_queue_entry_t scb_waitlist;
	ips_copp_queue_t copp_waitlist;
	ips_scb_queue_t scb_activelist;
	IPS_IO_CMD *dummy;
	IPS_ADAPTER *adapt;
	IPS_LD_INFO *logical_drive_info;
	dma_addr_t logical_drive_info_dma_addr;
	IPS_ENQ *enq;
	IPS_CONF *conf;
	IPS_NVRAM_P5 *nvram;
	IPS_SUBSYS *subsys;
	char *ioctl_data;
	uint32_t ioctl_datasize;
	uint32_t cmd_in_progress;
	int flags;
	uint8_t waitflag;
	uint8_t active;
	int ioctl_reset;
	uint16_t reset_count;
	time64_t last_ffdc;
	uint8_t slot_num;
	int ioctl_len;
	dma_addr_t ioctl_busaddr;
	uint8_t bios_version[8];
	uint32_t mem_addr;
	uint32_t io_len;
	uint32_t mem_len;
	char *mem_ptr;
	char *ioremap_ptr;
	ips_hw_func_t func;
	struct pci_dev *pcidev;
	char *flash_data;
	int flash_len;
	u32 flash_datasize;
	dma_addr_t flash_busaddr;
	dma_addr_t enq_busaddr;
	uint8_t requires_esl;
};

typedef struct ips_scb ips_scb_t;

struct ips_scb_pt {
	IPS_HOST_COMMAND cmd;
	IPS_DCDB_TABLE dcdb;
	uint8_t target_id;
	uint8_t bus;
	uint8_t lun;
	uint8_t cdb[12];
	uint32_t scb_busaddr;
	uint32_t data_busaddr;
	uint32_t timeout;
	uint8_t basic_status;
	uint8_t extended_status;
	uint16_t breakup;
	uint32_t data_len;
	uint32_t sg_len;
	uint32_t flags;
	uint32_t op_code;
	IPS_SG_LIST *sg_list;
	struct scsi_cmnd *scsi_cmd;
	struct ips_scb *q_next;
	ips_scb_callback callback;
};

typedef struct ips_scb_pt ips_scb_pt_t;

typedef struct {
	uint8_t CoppID[4];
	uint32_t CoppCmd;
	uint32_t PtBuffer;
	uint8_t *CmdBuffer;
	uint32_t CmdBSize;
	ips_scb_pt_t CoppCP;
	uint32_t TimeOut;
	uint8_t BasicStatus;
	uint8_t ExtendedStatus;
	uint8_t AdapterType;
	uint8_t reserved;
} ips_passthru_t;

struct btree_head32 {
	struct btree_head h;
};

struct btree_head64 {
	struct btree_head h;
};

typedef struct {
	uint8_t domain;
	uint8_t area;
	uint8_t al_pa;
} be_id_t;

typedef struct {
	uint8_t al_pa;
	uint8_t area;
	uint8_t domain;
} le_id_t;

struct dsd32 {
	__le32 address;
	__le32 length;
};

struct dsd64 {
	__le64 address;
	__le32 length;
} __attribute__((packed));

struct qla82xx_legacy_intr_set {
	uint32_t int_vec_bit;
	uint32_t tgt_status_reg;
	uint32_t tgt_mask_reg;
	uint32_t pci_int_reg;
};

struct device_reg_82xx {
	uint32_t req_q_out[64];
	uint32_t rsp_q_in[64];
	uint32_t rsp_q_out[64];
	uint16_t mailbox_in[32];
	uint16_t unused_1[32];
	uint32_t hint;
	uint16_t unused_2[62];
	uint16_t mailbox_out[32];
	uint32_t unused_3[48];
	uint32_t host_status;
	uint32_t host_int;
};

struct fcp_cmnd___2 {
	struct scsi_lun lun;
	uint8_t crn;
	uint8_t task_attribute;
	uint8_t task_management;
	uint8_t additional_cdb_len;
	uint8_t cdb[260];
};

struct dsd_dma {
	struct list_head list;
	dma_addr_t dsd_list_dma;
	void *dsd_addr;
};

struct ct6_dsd {
	uint16_t fcp_cmnd_len;
	dma_addr_t fcp_cmnd_dma;
	struct fcp_cmnd___2 *fcp_cmnd;
	int dsd_use_cnt;
	struct list_head dsd_list;
};

struct qla8044_reset_template_hdr {
	uint16_t version;
	uint16_t signature;
	uint16_t size;
	uint16_t entries;
	uint16_t hdr_size;
	uint16_t checksum;
	uint16_t init_seq_offset;
	uint16_t start_seq_offset;
};

struct qla8044_reset_template {
	int seq_index;
	int seq_error;
	int array_index;
	uint32_t array[16];
	uint8_t *buff;
	uint8_t *stop_offset;
	uint8_t *start_offset;
	uint8_t *init_offset;
	struct qla8044_reset_template_hdr *hdr;
	uint8_t seq_end;
	uint8_t template_end;
};

enum qla_regs {
	QLA8044_PEG_HALT_STATUS1_INDEX = 0,
	QLA8044_PEG_HALT_STATUS2_INDEX = 1,
	QLA8044_PEG_ALIVE_COUNTER_INDEX = 2,
	QLA8044_CRB_DRV_ACTIVE_INDEX = 3,
	QLA8044_CRB_DEV_STATE_INDEX = 4,
	QLA8044_CRB_DRV_STATE_INDEX = 5,
	QLA8044_CRB_DRV_SCRATCH_INDEX = 6,
	QLA8044_CRB_DEV_PART_INFO_INDEX = 7,
	QLA8044_CRB_DRV_IDC_VERSION_INDEX = 8,
	QLA8044_FW_VERSION_MAJOR_INDEX = 9,
	QLA8044_FW_VERSION_MINOR_INDEX = 10,
	QLA8044_FW_VERSION_SUB_INDEX = 11,
	QLA8044_CRB_CMDPEG_STATE_INDEX = 12,
	QLA8044_CRB_TEMP_STATE_INDEX = 13,
};

enum nvmefc_fcp_datadir {
	NVMEFC_FCP_NODATA = 0,
	NVMEFC_FCP_WRITE = 1,
	NVMEFC_FCP_READ = 2,
};

enum nvme_fc_obj_state {
	FC_OBJSTATE_UNKNOWN = 0,
	FC_OBJSTATE_NOTPRESENT = 1,
	FC_OBJSTATE_ONLINE = 2,
	FC_OBJSTATE_OFFLINE = 3,
	FC_OBJSTATE_BLOCKED = 4,
	FC_OBJSTATE_BYPASSED = 5,
	FC_OBJSTATE_DIAGNOSTICS = 6,
	FC_OBJSTATE_LINKDOWN = 7,
	FC_OBJSTATE_ERROR = 8,
	FC_OBJSTATE_LOOPBACK = 9,
	FC_OBJSTATE_DELETED = 10,
};

struct nvme_fc_local_port {
	u32 port_num;
	u32 port_role;
	u64 node_name;
	u64 port_name;
	void *private;
	u32 port_id;
	enum nvme_fc_obj_state port_state;
};

struct nvme_fc_remote_port {
	u32 port_num;
	u32 port_role;
	u64 node_name;
	u64 port_name;
	struct nvme_fc_local_port *localport;
	void *private;
	u32 dev_loss_tmo;
	u32 port_id;
	enum nvme_fc_obj_state port_state;
};

struct els_plogi_payload;

struct els_plogi {
	uint32_t flags;
	uint32_t els_cmd;
	struct completion comp;
	struct els_plogi_payload *els_plogi_pyld;
	struct els_plogi_payload *els_resp_pyld;
	u32 tx_size;
	u32 rx_size;
	dma_addr_t els_plogi_pyld_dma;
	dma_addr_t els_resp_pyld_dma;
	uint32_t fw_status[3];
	__le16 comp_status;
	__le16 len;
};

typedef union {
	uint32_t b24: 24;
	struct {
		uint8_t al_pa;
		uint8_t area;
		uint8_t domain;
		uint8_t rsvd_1;
	} b;
} port_id_t;

struct ct_arg {
	void *iocb;
	u16 nport_handle;
	dma_addr_t req_dma;
	dma_addr_t rsp_dma;
	u32 req_size;
	u32 rsp_size;
	u32 req_allocated_size;
	u32 rsp_allocated_size;
	void *req;
	void *rsp;
	port_id_t id;
};

struct els_logo_payload;

struct imm_ntfy_from_isp;

struct srb_iocb {
	union {
		struct {
			uint16_t flags;
			uint16_t data[2];
			u32 iop[2];
		} logio;
		struct {
			uint32_t flags;
			uint32_t els_cmd;
			struct completion comp;
			struct els_logo_payload *els_logo_pyld;
			dma_addr_t els_logo_pyld_dma;
		} els_logo;
		struct els_plogi els_plogi;
		struct {
			uint64_t lun;
			uint32_t flags;
			uint32_t data;
			struct completion comp;
			__le16 comp_status;
		} tmf;
		struct {
			uint8_t flags;
			uint32_t req_len;
			uint32_t rsp_len;
			void *req_addr;
			void *rsp_addr;
			dma_addr_t req_dma_handle;
			dma_addr_t rsp_dma_handle;
			__le32 adapter_id;
			__le32 adapter_id_hi;
			__le16 req_func_type;
			__le32 req_data;
			__le32 req_data_extra;
			__le32 result;
			__le32 seq_number;
			__le16 fw_flags;
			struct completion fxiocb_comp;
			__le32 reserved_0;
			uint8_t reserved_1;
		} fxiocb;
		struct {
			uint32_t cmd_hndl;
			__le16 comp_status;
			__le16 req_que_no;
			struct completion comp;
		} abt;
		struct ct_arg ctarg;
		struct {
			__le16 in_mb[28];
			__le16 out_mb[28];
			void *out;
			void *in;
			dma_addr_t out_dma;
			dma_addr_t in_dma;
			struct completion comp;
			int rc;
		} mbx;
		struct {
			struct imm_ntfy_from_isp *ntfy;
		} nack;
		struct {
			__le16 comp_status;
			uint16_t rsp_pyld_len;
			uint8_t aen_op;
			void *desc;
			int cmd_len;
			int rsp_len;
			dma_addr_t cmd_dma;
			dma_addr_t rsp_dma;
			enum nvmefc_fcp_datadir dir;
			uint32_t dl;
			uint32_t timeout_sec;
			struct list_head entry;
		} nvme;
		struct {
			u16 cmd;
			u16 vp_index;
		} ctrlvp;
	} u;
	struct timer_list timer;
	void (*timeout)(void *);
};

struct crc_context;

struct srb_cmd {
	struct scsi_cmnd *cmd;
	uint32_t request_sense_length;
	uint32_t fw_sense_length;
	uint8_t *request_sense_ptr;
	struct ct6_dsd *ct6_ctx;
	struct crc_context *crc_ctx;
};

struct fc_port;

struct scsi_qla_host;

struct qla_qpair;

struct srb {
	uint8_t cmd_type;
	uint8_t pad[3];
	struct kref cmd_kref;
	void *priv;
	wait_queue_head_t nvme_ls_waitq;
	struct fc_port *fcport;
	struct scsi_qla_host *vha;
	unsigned int start_timer: 1;
	unsigned int abort: 1;
	unsigned int aborted: 1;
	unsigned int completed: 1;
	uint32_t handle;
	uint16_t flags;
	uint16_t type;
	const char *name;
	int iocbs;
	struct qla_qpair *qpair;
	struct srb *cmd_sp;
	struct list_head elem;
	u32 gen1;
	u32 gen2;
	int rc;
	int retry_count;
	struct completion *comp;
	union {
		struct srb_iocb iocb_cmd;
		struct bsg_job *bsg_job;
		struct srb_cmd scmd;
	} u;
	void (*done)(struct srb *, int);
	void (*free)(struct srb *);
	void (*put_fn)(struct kref *);
};

typedef enum {
	FCT_UNKNOWN = 0,
	FCT_RSCN = 1,
	FCT_SWITCH = 2,
	FCT_BROADCAST = 3,
	FCT_INITIATOR = 4,
	FCT_TARGET = 5,
	FCT_NVME_INITIATOR = 16,
	FCT_NVME_TARGET = 32,
	FCT_NVME_DISCOVERY = 64,
	FCT_NVME = 240,
} fc_port_type_t;

struct qla_tgt_sess;

struct ct_sns_pkt;

struct ct_sns_desc {
	struct ct_sns_pkt *ct_sns;
	dma_addr_t ct_sns_dma;
};

enum discovery_state {
	DSC_DELETED = 0,
	DSC_GNN_ID = 1,
	DSC_GNL = 2,
	DSC_LOGIN_PEND = 3,
	DSC_LOGIN_FAILED = 4,
	DSC_GPDB = 5,
	DSC_UPD_FCPORT = 6,
	DSC_LOGIN_COMPLETE = 7,
	DSC_ADISC = 8,
	DSC_DELETE_PEND = 9,
};

enum login_state {
	DSC_LS_LLIOCB_SENT = 2,
	DSC_LS_PLOGI_PEND = 3,
	DSC_LS_PLOGI_COMP = 4,
	DSC_LS_PRLI_PEND = 5,
	DSC_LS_PRLI_COMP = 6,
	DSC_LS_PORT_UNAVAIL = 7,
	DSC_LS_PRLO_PEND = 9,
	DSC_LS_LOGO_PEND = 10,
};

struct se_session;

struct qla_tgt;

struct qlt_plogi_ack_t;

struct fc_port {
	struct list_head list;
	struct scsi_qla_host *vha;
	uint8_t node_name[8];
	uint8_t port_name[8];
	port_id_t d_id;
	uint16_t loop_id;
	uint16_t old_loop_id;
	unsigned int conf_compl_supported: 1;
	unsigned int deleted: 2;
	unsigned int free_pending: 1;
	unsigned int local: 1;
	unsigned int logout_on_delete: 1;
	unsigned int logo_ack_needed: 1;
	unsigned int keep_nport_handle: 1;
	unsigned int send_els_logo: 1;
	unsigned int login_pause: 1;
	unsigned int login_succ: 1;
	unsigned int query: 1;
	unsigned int id_changed: 1;
	unsigned int scan_needed: 1;
	unsigned int n2n_flag: 1;
	unsigned int explicit_logout: 1;
	unsigned int prli_pend_timer: 1;
	struct completion nvme_del_done;
	uint32_t nvme_prli_service_param;
	uint8_t nvme_flag;
	uint32_t nvme_first_burst_size;
	struct fc_port *conflict;
	unsigned char logout_completed;
	int generation;
	struct se_session *se_sess;
	struct kref sess_kref;
	struct qla_tgt *tgt;
	long unsigned int expires;
	struct list_head del_list_entry;
	struct work_struct free_work;
	struct work_struct reg_work;
	uint64_t jiffies_at_registration;
	long unsigned int prli_expired;
	struct qlt_plogi_ack_t *plogi_link[2];
	uint16_t tgt_id;
	uint16_t old_tgt_id;
	uint16_t sec_since_registration;
	uint8_t fcp_prio;
	uint8_t fabric_port_name[8];
	uint16_t fp_speed;
	fc_port_type_t port_type;
	atomic_t state;
	uint32_t flags;
	int login_retry;
	struct fc_rport *rport;
	struct fc_rport *drport;
	u32 supported_classes;
	uint8_t fc4_type;
	uint8_t fc4_features;
	uint8_t scan_state;
	long unsigned int last_queue_full;
	long unsigned int last_ramp_up;
	uint16_t port_id;
	struct nvme_fc_remote_port *nvme_remote_port;
	long unsigned int retry_delay_timestamp;
	struct qla_tgt_sess *tgt_session;
	struct ct_sns_desc ct_desc;
	enum discovery_state disc_state;
	atomic_t shadow_disc_state;
	enum discovery_state next_disc_state;
	enum login_state fw_login_state;
	long unsigned int dm_login_expire;
	long unsigned int plogi_nack_done_deadline;
	u32 login_gen;
	u32 last_login_gen;
	u32 rscn_gen;
	u32 last_rscn_gen;
	u32 chip_reset;
	struct list_head gnl_entry;
	struct work_struct del_work;
	u8 iocb[64];
	u8 current_login_state;
	u8 last_login_state;
	u16 n2n_link_reset_cnt;
	u16 n2n_chip_reset;
};

struct get_name_list_extended {
	__le16 flags;
	u8 current_login_state;
	u8 last_login_state;
	u8 hard_address[3];
	u8 reserved_1;
	u8 port_id[3];
	u8 sequence_id;
	__le16 port_timer;
	__le16 nport_handle;
	__le16 receive_data_size;
	__le16 reserved_2;
	u8 prli_svc_param_word_0[2];
	u8 prli_svc_param_word_3[2];
	u8 port_name[8];
	u8 node_name[8];
};

struct device_reg_24xx {
	uint32_t flash_addr;
	uint32_t flash_data;
	uint32_t ctrl_status;
	uint32_t ictrl;
	uint32_t istatus;
	uint32_t unused_1[2];
	uint32_t req_q_in;
	uint32_t req_q_out;
	uint32_t rsp_q_in;
	uint32_t rsp_q_out;
	uint32_t preq_q_in;
	uint32_t preq_q_out;
	uint32_t unused_2[2];
	uint32_t atio_q_in;
	uint32_t atio_q_out;
	uint32_t host_status;
	uint32_t hccr;
	uint32_t gpiod;
	uint32_t gpioe;
	uint32_t iobase_addr;
	uint32_t unused_3[10];
	uint16_t mailbox0;
	uint16_t mailbox1;
	uint16_t mailbox2;
	uint16_t mailbox3;
	uint16_t mailbox4;
	uint16_t mailbox5;
	uint16_t mailbox6;
	uint16_t mailbox7;
	uint16_t mailbox8;
	uint16_t mailbox9;
	uint16_t mailbox10;
	uint16_t mailbox11;
	uint16_t mailbox12;
	uint16_t mailbox13;
	uint16_t mailbox14;
	uint16_t mailbox15;
	uint16_t mailbox16;
	uint16_t mailbox17;
	uint16_t mailbox18;
	uint16_t mailbox19;
	uint16_t mailbox20;
	uint16_t mailbox21;
	uint16_t mailbox22;
	uint16_t mailbox23;
	uint16_t mailbox24;
	uint16_t mailbox25;
	uint16_t mailbox26;
	uint16_t mailbox27;
	uint16_t mailbox28;
	uint16_t mailbox29;
	uint16_t mailbox30;
	uint16_t mailbox31;
	uint32_t iobase_window;
	uint32_t iobase_c4;
	uint32_t iobase_c8;
	uint32_t unused_4_1[6];
	uint32_t iobase_q;
	uint32_t unused_5[2];
	uint32_t iobase_select;
	uint32_t unused_6[2];
	uint32_t iobase_sdata;
};

struct qla_npiv_entry {
	uint16_t flags;
	uint16_t vf_id;
	uint8_t q_qos;
	uint8_t f_qos;
	uint16_t unused1;
	uint8_t port_name[8];
	uint8_t node_name[8];
};

struct init_cb_81xx {
	uint16_t version;
	uint16_t reserved_1;
	uint16_t frame_payload_size;
	uint16_t execution_throttle;
	uint16_t exchange_count;
	uint16_t reserved_2;
	uint8_t port_name[8];
	uint8_t node_name[8];
	uint16_t response_q_inpointer;
	uint16_t request_q_outpointer;
	uint16_t login_retry_count;
	uint16_t prio_request_q_outpointer;
	uint16_t response_q_length;
	uint16_t request_q_length;
	uint16_t reserved_3;
	uint16_t prio_request_q_length;
	__le64 request_q_address;
	__le64 response_q_address;
	__le64 prio_request_q_address;
	uint8_t reserved_4[8];
	uint16_t atio_q_inpointer;
	uint16_t atio_q_length;
	__le64 atio_q_address;
	uint16_t interrupt_delay_timer;
	uint16_t login_timeout;
	uint32_t firmware_options_1;
	uint32_t firmware_options_2;
	uint32_t firmware_options_3;
	uint8_t reserved_5[8];
	uint8_t enode_mac[6];
	uint8_t reserved_6[10];
} __attribute__((packed));

struct ex_init_cb_81xx {
	uint16_t ex_version;
	uint8_t prio_fcf_matching_flags;
	uint8_t reserved_1[3];
	uint16_t pri_fcf_vlan_id;
	uint8_t pri_fcf_fabric_name[8];
	uint16_t reserved_2[7];
	uint8_t spma_mac_addr[6];
	uint16_t reserved_3[14];
};

struct qla_fcp_prio_entry {
	uint16_t flags;
	uint8_t tag;
	uint8_t reserved;
	uint32_t src_pid;
	uint32_t dst_pid;
	uint16_t lun_beg;
	uint16_t lun_end;
	uint8_t src_wwpn[8];
	uint8_t dst_wwpn[8];
};

struct qla_fcp_prio_cfg {
	uint8_t signature[4];
	uint16_t version;
	uint16_t length;
	uint16_t checksum;
	uint16_t num_entries;
	uint16_t size_of_entry;
	uint8_t attributes;
	uint8_t reserved;
	struct qla_fcp_prio_entry entry[1];
};

struct name_list_extended {
	struct get_name_list_extended *l;
	dma_addr_t ldma;
	struct list_head fcports;
	u32 size;
	u8 sent;
};

struct crc_context {
	uint32_t handle;
	__le32 ref_tag;
	__le16 app_tag;
	uint8_t ref_tag_mask[4];
	uint8_t app_tag_mask[2];
	__le16 guard_seed;
	__le16 prot_opts;
	__le16 blk_size;
	uint16_t runt_blk_guard;
	__le32 byte_count;
	union {
		struct {
			uint32_t reserved_1;
			uint16_t reserved_2;
			uint16_t reserved_3;
			uint32_t reserved_4;
			struct dsd64 data_dsd[1];
			uint32_t reserved_5[2];
			uint32_t reserved_6;
		} __attribute__((packed)) nobundling;
		struct {
			__le32 dif_byte_count;
			uint16_t reserved_1;
			__le16 dseg_count;
			uint32_t reserved_2;
			struct dsd64 data_dsd[1];
			struct dsd64 dif_dsd;
		} __attribute__((packed)) bundling;
	} u;
	struct fcp_cmnd___2 fcp_cmnd;
	dma_addr_t crc_ctx_dma;
	struct list_head dsd_list;
	struct list_head ldif_dsd_list;
	u8 no_ldif_dsd;
	long: 56;
	struct list_head ldif_dma_hndl_list;
	u32 dif_bundl_len;
	u8 no_dif_bundl;
	int: 24;
} __attribute__((packed));

struct els_logo_payload {
	uint8_t opcode;
	uint8_t rsvd[3];
	uint8_t s_id[3];
	uint8_t rsvd1[1];
	uint8_t wwpn[8];
};

struct els_plogi_payload {
	uint8_t opcode;
	uint8_t rsvd[3];
	uint8_t data[112];
};

typedef union {
	uint16_t extended;
	struct {
		uint8_t reserved;
		uint8_t standard;
	} id;
} target_id_t;

struct imm_ntfy_from_isp {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	union {
		struct {
			uint32_t sys_define_2;
			target_id_t target;
			uint16_t lun;
			uint8_t target_id;
			uint8_t reserved_1;
			uint16_t status_modifier;
			uint16_t status;
			uint16_t task_flags;
			uint16_t seq_id;
			uint16_t srr_rx_id;
			uint32_t srr_rel_offs;
			uint16_t srr_ui;
			uint16_t srr_ox_id;
			uint8_t reserved_2[28];
		} isp2x;
		struct {
			uint32_t reserved;
			uint16_t nport_handle;
			uint16_t reserved_2;
			uint16_t flags;
			uint16_t srr_rx_id;
			uint16_t status;
			uint8_t status_subcode;
			uint8_t fw_handle;
			uint32_t exchange_address;
			uint32_t srr_rel_offs;
			uint16_t srr_ui;
			uint16_t srr_ox_id;
			union {
				struct {
					uint8_t node_name[8];
				} plogi;
				struct {
					uint16_t wd3_lo;
					uint8_t resv0[6];
				} prli;
				struct {
					uint8_t port_id[3];
					uint8_t resv1;
					uint16_t nport_handle;
					uint16_t resv2;
				} req_els;
			} u;
			uint8_t port_name[8];
			uint8_t resv3[3];
			uint8_t vp_index;
			uint32_t reserved_5;
			uint8_t port_id[3];
			uint8_t reserved_6;
		} isp24;
	} u;
	uint16_t reserved_7;
	uint16_t ox_id;
};

enum {
	TYPE_SRB = 0,
	TYPE_TGT_CMD = 1,
	TYPE_TGT_TMCMD = 2,
};

typedef struct fc_port fc_port_t;

struct scsi_qlt_host {
	void *target_lport_ptr;
	struct mutex tgt_mutex;
	struct mutex tgt_host_action_mutex;
	struct qla_tgt *qla_tgt;
};

struct qla_dif_statistics {
	uint64_t dif_input_bytes;
	uint64_t dif_output_bytes;
	uint64_t dif_input_requests;
	uint64_t dif_output_requests;
	uint32_t dif_guard_err;
	uint32_t dif_ref_tag_err;
	uint32_t dif_app_tag_err;
};

struct qla_statistics {
	uint32_t total_isp_aborts;
	uint64_t input_bytes;
	uint64_t output_bytes;
	uint64_t input_requests;
	uint64_t output_requests;
	uint32_t control_requests;
	uint64_t jiffies_at_last_reset;
	uint32_t stat_max_pend_cmds;
	uint32_t stat_max_qfull_cmds_alloc;
	uint32_t stat_max_qfull_cmds_dropped;
	struct qla_dif_statistics qla_dif_stats;
};

struct bidi_statistics {
	long long unsigned int io_count;
	long long unsigned int transfer_bytes;
};

enum scan_flags_t {
	SF_SCANNING = 1,
	SF_QUEUED = 2,
};

struct fab_scan_rp;

struct fab_scan {
	struct fab_scan_rp *l;
	u32 size;
	u16 scan_retry;
	enum scan_flags_t scan_flags;
	struct delayed_work scan_work;
};

struct qla_hw_data;

struct req_que;

struct scsi_qla_host {
	struct list_head list;
	struct list_head vp_fcports;
	struct list_head work_list;
	spinlock_t work_lock;
	struct work_struct iocb_work;
	struct Scsi_Host *host;
	long unsigned int host_no;
	uint8_t host_str[16];
	volatile struct {
		uint32_t init_done: 1;
		uint32_t online: 1;
		uint32_t reset_active: 1;
		uint32_t management_server_logged_in: 1;
		uint32_t process_response_queue: 1;
		uint32_t difdix_supported: 1;
		uint32_t delete_progress: 1;
		uint32_t fw_tgt_reported: 1;
		uint32_t bbcr_enable: 1;
		uint32_t qpairs_available: 1;
		uint32_t qpairs_req_created: 1;
		uint32_t qpairs_rsp_created: 1;
		uint32_t nvme_enabled: 1;
		uint32_t nvme_first_burst: 1;
	} flags;
	atomic_t loop_state;
	long unsigned int relogin_jif;
	long unsigned int dpc_flags;
	long unsigned int pci_flags;
	uint32_t device_flags;
	uint16_t loop_id;
	uint16_t self_login_loop_id;
	fc_port_t bidir_fcport;
	port_id_t d_id;
	uint8_t marker_needed;
	uint16_t mgmt_svr_loop_id;
	uint8_t loop_down_abort_time;
	atomic_t loop_down_timer;
	uint8_t link_down_timeout;
	uint32_t timer_active;
	struct timer_list timer;
	uint8_t node_name[8];
	uint8_t port_name[8];
	uint8_t fabric_node_name[8];
	struct nvme_fc_local_port *nvme_local_port;
	struct completion nvme_del_done;
	uint16_t fcoe_vlan_id;
	uint16_t fcoe_fcf_idx;
	uint8_t fcoe_vn_port_mac[6];
	struct list_head qla_cmd_list;
	struct list_head qla_sess_op_cmd_list;
	struct list_head unknown_atio_list;
	spinlock_t cmd_list_lock;
	struct delayed_work unknown_atio_work;
	atomic_t generation_tick;
	int total_fcport_update_gen;
	struct list_head logo_list;
	struct list_head plogi_ack_list;
	struct list_head qp_list;
	uint32_t vp_abort_cnt;
	struct fc_vport *fc_vport;
	uint16_t vp_idx;
	struct qla_qpair *qpair;
	long unsigned int vp_flags;
	atomic_t vp_state;
	uint16_t vp_err_state;
	uint16_t vp_prev_err_state;
	struct qla_hw_data *hw;
	struct scsi_qlt_host vha_tgt;
	struct req_que *req;
	int fw_heartbeat_counter;
	int seconds_since_last_heartbeat;
	struct fc_host_statistics fc_host_stat;
	struct qla_statistics qla_stats;
	struct bidi_statistics bidi_stats;
	atomic_t vref_count;
	struct qla8044_reset_template reset_tmplt;
	uint16_t bbcr;
	uint16_t u_ql2xexchoffld;
	uint16_t u_ql2xiniexchg;
	uint16_t qlini_mode;
	uint16_t ql2xexchoffld;
	uint16_t ql2xiniexchg;
	struct name_list_extended gnl;
	int fcport_count;
	wait_queue_head_t fcport_waitQ;
	wait_queue_head_t vref_waitq;
	uint8_t min_supported_speed;
	uint8_t n2n_node_name[8];
	uint8_t n2n_port_name[8];
	uint16_t n2n_id;
	struct list_head gpnid_list;
	struct fab_scan scan;
	unsigned int irq_offset;
};

struct atio_que;

struct qla_tgt_counters {
	uint64_t qla_core_sbt_cmd;
	uint64_t core_qla_que_buf;
	uint64_t qla_core_ret_ctio;
	uint64_t core_qla_snd_status;
	uint64_t qla_core_ret_sta_ctio;
	uint64_t core_qla_free_cmd;
	uint64_t num_q_full_sent;
	uint64_t num_alloc_iocb_failed;
	uint64_t num_term_xchg_sent;
};

struct rsp_que;

struct qla_msix_entry;

struct qla_qpair {
	spinlock_t qp_lock;
	atomic_t ref_count;
	uint32_t lun_cnt;
	spinlock_t *qp_lock_ptr;
	struct scsi_qla_host *vha;
	u32 chip_reset;
	uint32_t online: 1;
	uint32_t difdix_supported: 1;
	uint32_t delete_in_progress: 1;
	uint32_t fw_started: 1;
	uint32_t enable_class_2: 1;
	uint32_t enable_explicit_conf: 1;
	uint32_t use_shadow_reg: 1;
	uint16_t id;
	uint16_t vp_idx;
	mempool_t *srb_mempool;
	struct pci_dev *pdev;
	void (*reqq_start_iocbs)(struct qla_qpair *);
	struct req_que *req;
	struct rsp_que *rsp;
	struct atio_que *atio;
	struct qla_msix_entry *msix;
	struct qla_hw_data *hw;
	struct work_struct q_work;
	struct list_head qp_list_elem;
	struct list_head hints_list;
	uint16_t cpuid;
	uint16_t retry_term_cnt;
	uint32_t retry_term_exchg_addr;
	uint64_t retry_term_jiff;
	struct qla_tgt_counters tgt_counters;
};

typedef struct srb srb_t;

struct device_reg_2xxx {
	uint16_t flash_address;
	uint16_t flash_data;
	uint16_t unused_1[1];
	uint16_t ctrl_status;
	uint16_t ictrl;
	uint16_t istatus;
	uint16_t semaphore;
	uint16_t nvram;
	union {
		struct {
			uint16_t mailbox0;
			uint16_t mailbox1;
			uint16_t mailbox2;
			uint16_t mailbox3;
			uint16_t mailbox4;
			uint16_t mailbox5;
			uint16_t mailbox6;
			uint16_t mailbox7;
			uint16_t unused_2[59];
		} isp2100;
		struct {
			uint16_t req_q_in;
			uint16_t req_q_out;
			uint16_t rsp_q_in;
			uint16_t rsp_q_out;
			uint32_t host_status;
			uint16_t host_semaphore;
			uint16_t unused_3[17];
			uint16_t mailbox0;
			uint16_t mailbox1;
			uint16_t mailbox2;
			uint16_t mailbox3;
			uint16_t mailbox4;
			uint16_t mailbox5;
			uint16_t mailbox6;
			uint16_t mailbox7;
			uint16_t mailbox8;
			uint16_t mailbox9;
			uint16_t mailbox10;
			uint16_t mailbox11;
			uint16_t mailbox12;
			uint16_t mailbox13;
			uint16_t mailbox14;
			uint16_t mailbox15;
			uint16_t mailbox16;
			uint16_t mailbox17;
			uint16_t mailbox18;
			uint16_t mailbox19;
			uint16_t mailbox20;
			uint16_t mailbox21;
			uint16_t mailbox22;
			uint16_t mailbox23;
			uint16_t mailbox24;
			uint16_t mailbox25;
			uint16_t mailbox26;
			uint16_t mailbox27;
			uint16_t mailbox28;
			uint16_t mailbox29;
			uint16_t mailbox30;
			uint16_t mailbox31;
			uint16_t fb_cmd;
			uint16_t unused_4[10];
		} __attribute__((packed)) isp2300;
	} u;
	uint16_t fpm_diag_config;
	uint16_t unused_5[4];
	uint16_t risc_hw;
	uint16_t unused_5_1;
	uint16_t pcr;
	uint16_t unused_6[5];
	uint16_t mctr;
	uint16_t unused_7[3];
	uint16_t fb_cmd_2100;
	uint16_t unused_8[3];
	uint16_t hccr;
	uint16_t unused_9[5];
	uint16_t gpiod;
	uint16_t gpioe;
	union {
		struct {
			uint16_t unused_10[8];
			uint16_t mailbox8;
			uint16_t mailbox9;
			uint16_t mailbox10;
			uint16_t mailbox11;
			uint16_t mailbox12;
			uint16_t mailbox13;
			uint16_t mailbox14;
			uint16_t mailbox15;
			uint16_t mailbox16;
			uint16_t mailbox17;
			uint16_t mailbox18;
			uint16_t mailbox19;
			uint16_t mailbox20;
			uint16_t mailbox21;
			uint16_t mailbox22;
			uint16_t mailbox23;
		} isp2200;
	} u_end;
};

struct device_reg_25xxmq {
	uint32_t req_q_in;
	uint32_t req_q_out;
	uint32_t rsp_q_in;
	uint32_t rsp_q_out;
	uint32_t atio_q_in;
	uint32_t atio_q_out;
};

struct device_reg_fx00 {
	uint32_t mailbox0;
	uint32_t mailbox1;
	uint32_t mailbox2;
	uint32_t mailbox3;
	uint32_t mailbox4;
	uint32_t mailbox5;
	uint32_t mailbox6;
	uint32_t mailbox7;
	uint32_t mailbox8;
	uint32_t mailbox9;
	uint32_t mailbox10;
	uint32_t mailbox11;
	uint32_t mailbox12;
	uint32_t mailbox13;
	uint32_t mailbox14;
	uint32_t mailbox15;
	uint32_t mailbox16;
	uint32_t mailbox17;
	uint32_t mailbox18;
	uint32_t mailbox19;
	uint32_t mailbox20;
	uint32_t mailbox21;
	uint32_t mailbox22;
	uint32_t mailbox23;
	uint32_t mailbox24;
	uint32_t mailbox25;
	uint32_t mailbox26;
	uint32_t mailbox27;
	uint32_t mailbox28;
	uint32_t mailbox29;
	uint32_t mailbox30;
	uint32_t mailbox31;
	uint32_t aenmailbox0;
	uint32_t aenmailbox1;
	uint32_t aenmailbox2;
	uint32_t aenmailbox3;
	uint32_t aenmailbox4;
	uint32_t aenmailbox5;
	uint32_t aenmailbox6;
	uint32_t aenmailbox7;
	uint32_t req_q_in;
	uint32_t req_q_out;
	uint32_t rsp_q_in;
	uint32_t rsp_q_out;
	uint32_t initval0;
	uint32_t initval1;
	uint32_t initval2;
	uint32_t initval3;
	uint32_t initval4;
	uint32_t initval5;
	uint32_t initval6;
	uint32_t initval7;
	uint32_t fwheartbeat;
	uint32_t pseudoaen;
};

typedef union {
	struct device_reg_2xxx isp;
	struct device_reg_24xx isp24;
	struct device_reg_25xxmq isp25mq;
	struct device_reg_82xx isp82;
	struct device_reg_fx00 ispfx00;
} device_reg_t;

typedef struct {
	uint32_t out_mb;
	uint32_t in_mb;
	uint16_t mb[32];
	long int buf_size;
	void *bufp;
	uint32_t tov;
	uint8_t flags;
} mbx_cmd_t;

struct mbx_cmd_32 {
	uint32_t out_mb;
	uint32_t in_mb;
	uint32_t mb[32];
	long int buf_size;
	void *bufp;
	uint32_t tov;
	uint8_t flags;
};

typedef struct {
	uint8_t version;
	uint8_t reserved_1;
	uint8_t firmware_options[2];
	uint16_t frame_payload_size;
	uint16_t max_iocb_allocation;
	uint16_t execution_throttle;
	uint8_t retry_count;
	uint8_t retry_delay;
	uint8_t port_name[8];
	uint16_t hard_address;
	uint8_t inquiry_data;
	uint8_t login_timeout;
	uint8_t node_name[8];
	uint16_t request_q_outpointer;
	uint16_t response_q_inpointer;
	uint16_t request_q_length;
	uint16_t response_q_length;
	__le64 request_q_address;
	__le64 response_q_address;
	uint16_t lun_enables;
	uint8_t command_resource_count;
	uint8_t immediate_notify_resource_count;
	uint16_t timeout;
	uint8_t reserved_2[2];
	uint8_t add_firmware_options[2];
	uint8_t response_accumulation_timer;
	uint8_t interrupt_delay_timer;
	uint8_t special_options[2];
	uint8_t reserved_3[26];
} init_cb_t;

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint8_t data[52];
	uint32_t signature;
} response_t;

struct atio {
	uint8_t entry_type;
	uint8_t entry_count;
	__le16 attr_n_length;
	uint8_t data[56];
	uint32_t signature;
};

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	target_id_t target;
	uint16_t lun;
	uint16_t control_flags;
	uint16_t reserved_1;
	uint16_t timeout;
	uint16_t dseg_count;
	uint8_t scsi_cdb[16];
	uint32_t byte_count;
	union {
		struct dsd32 dsd32[3];
		struct dsd64 dsd64[2];
	};
} cmd_entry_t;

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	target_id_t target;
	uint16_t lun;
	uint16_t control_flags;
	uint16_t reserved_1;
	uint16_t timeout;
	uint16_t dseg_count;
	uint8_t scsi_cdb[16];
	uint32_t byte_count;
	struct dsd64 dsd[2];
} request_t;

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t handle_count;
	uint8_t entry_status;
	uint32_t handle1;
	target_id_t loop_id;
	uint16_t status;
	uint16_t control_flags;
	uint16_t reserved2;
	uint16_t timeout;
	uint16_t cmd_dsd_count;
	uint16_t total_dsd_count;
	uint8_t type;
	uint8_t r_ctl;
	uint16_t rx_id;
	uint16_t reserved3;
	uint32_t handle2;
	uint32_t rsp_bytecount;
	uint32_t req_bytecount;
	struct dsd64 req_dsd;
	struct dsd64 rsp_dsd;
} __attribute__((packed)) ms_iocb_entry_t;

enum qlt_plogi_link_t {
	QLT_PLOGI_LINK_SAME_WWN = 0,
	QLT_PLOGI_LINK_CONFLICT = 1,
	QLT_PLOGI_LINK_MAX = 2,
};

struct qlt_plogi_ack_t {
	struct list_head list;
	struct imm_ntfy_from_isp iocb;
	port_id_t id;
	int ref_count;
	void *fcport;
};

struct ct_cmd_hdr {
	uint8_t revision;
	uint8_t in_id[3];
	uint8_t gs_type;
	uint8_t gs_subtype;
	uint8_t options;
	uint8_t reserved;
};

struct ct_fdmi_hba_attr {
	uint16_t type;
	uint16_t len;
	union {
		uint8_t node_name[8];
		uint8_t manufacturer[64];
		uint8_t serial_num[32];
		uint8_t model[17];
		uint8_t model_desc[80];
		uint8_t hw_version[32];
		uint8_t driver_version[32];
		uint8_t orom_version[16];
		uint8_t fw_version[32];
		uint8_t os_version[128];
		uint32_t max_ct_len;
	} a;
};

struct ct_fdmi_hba_attributes {
	uint32_t count;
	struct ct_fdmi_hba_attr entry[9];
};

struct ct_fdmiv2_hba_attr {
	uint16_t type;
	uint16_t len;
	union {
		uint8_t node_name[8];
		uint8_t manufacturer[64];
		uint8_t serial_num[32];
		uint8_t model[17];
		uint8_t model_desc[80];
		uint8_t hw_version[16];
		uint8_t driver_version[32];
		uint8_t orom_version[16];
		uint8_t fw_version[32];
		uint8_t os_version[128];
		uint32_t max_ct_len;
		uint8_t sym_name[256];
		uint32_t vendor_id;
		uint32_t num_ports;
		uint8_t fabric_name[8];
		uint8_t bios_name[32];
		uint8_t vendor_identifier[8];
	} a;
};

struct ct_fdmiv2_hba_attributes {
	uint32_t count;
	struct ct_fdmiv2_hba_attr entry[17];
};

struct ct_fdmi_port_attr {
	uint16_t type;
	uint16_t len;
	union {
		uint8_t fc4_types[32];
		uint32_t sup_speed;
		uint32_t cur_speed;
		uint32_t max_frame_size;
		uint8_t os_dev_name[32];
		uint8_t host_name[256];
	} a;
};

struct ct_fdmi_port_attributes {
	uint32_t count;
	struct ct_fdmi_port_attr entry[6];
};

struct ct_fdmiv2_port_attr {
	uint16_t type;
	uint16_t len;
	union {
		uint8_t fc4_types[32];
		uint32_t sup_speed;
		uint32_t cur_speed;
		uint32_t max_frame_size;
		uint8_t os_dev_name[32];
		uint8_t host_name[256];
		uint8_t node_name[8];
		uint8_t port_name[8];
		uint8_t port_sym_name[128];
		uint32_t port_type;
		uint32_t port_supported_cos;
		uint8_t fabric_name[8];
		uint8_t port_fc4_type[32];
		uint32_t port_state;
		uint32_t num_ports;
		uint32_t port_id;
	} a;
};

struct ct_fdmiv2_port_attributes {
	uint32_t count;
	struct ct_fdmiv2_port_attr entry[16];
};

struct ct_sns_req {
	struct ct_cmd_hdr header;
	uint16_t command;
	uint16_t max_rsp_size;
	uint8_t fragment_id;
	uint8_t reserved[3];
	union {
		struct {
			uint8_t reserved;
			be_id_t port_id;
		} port_id;
		struct {
			uint8_t reserved;
			uint8_t domain;
			uint8_t area;
			uint8_t port_type;
		} gpn_ft;
		struct {
			uint8_t port_type;
			uint8_t domain;
			uint8_t area;
			uint8_t reserved;
		} gid_pt;
		struct {
			uint8_t reserved;
			be_id_t port_id;
			uint8_t fc4_types[32];
		} rft_id;
		struct {
			uint8_t reserved;
			be_id_t port_id;
			uint16_t reserved2;
			uint8_t fc4_feature;
			uint8_t fc4_type;
		} rff_id;
		struct {
			uint8_t reserved;
			be_id_t port_id;
			uint8_t node_name[8];
		} rnn_id;
		struct {
			uint8_t node_name[8];
			uint8_t name_len;
			uint8_t sym_node_name[255];
		} rsnn_nn;
		struct {
			uint8_t hba_identifier[8];
		} ghat;
		struct {
			uint8_t hba_identifier[8];
			uint32_t entry_count;
			uint8_t port_name[8];
			struct ct_fdmi_hba_attributes attrs;
		} rhba;
		struct {
			uint8_t hba_identifier[8];
			uint32_t entry_count;
			uint8_t port_name[8];
			struct ct_fdmiv2_hba_attributes attrs;
		} rhba2;
		struct {
			uint8_t hba_identifier[8];
			struct ct_fdmi_hba_attributes attrs;
		} rhat;
		struct {
			uint8_t port_name[8];
			struct ct_fdmi_port_attributes attrs;
		} rpa;
		struct {
			uint8_t port_name[8];
			struct ct_fdmiv2_port_attributes attrs;
		} rpa2;
		struct {
			uint8_t port_name[8];
		} dhba;
		struct {
			uint8_t port_name[8];
		} dhat;
		struct {
			uint8_t port_name[8];
		} dprt;
		struct {
			uint8_t port_name[8];
		} dpa;
		struct {
			uint8_t port_name[8];
		} gpsc;
		struct {
			uint8_t reserved;
			uint8_t port_id[3];
		} gff_id;
		struct {
			uint8_t port_name[8];
		} gid_pn;
	} req;
};

struct ct_rsp_hdr {
	struct ct_cmd_hdr header;
	uint16_t response;
	uint16_t residual;
	uint8_t fragment_id;
	uint8_t reason_code;
	uint8_t explanation_code;
	uint8_t vendor_unique;
};

struct ct_sns_gid_pt_data {
	uint8_t control_byte;
	be_id_t port_id;
};

struct ct_sns_rsp {
	struct ct_rsp_hdr header;
	union {
		struct {
			uint8_t port_type;
			be_id_t port_id;
			uint8_t port_name[8];
			uint8_t sym_port_name_len;
			uint8_t sym_port_name[255];
			uint8_t node_name[8];
			uint8_t sym_node_name_len;
			uint8_t sym_node_name[255];
			uint8_t init_proc_assoc[8];
			uint8_t node_ip_addr[16];
			uint8_t class_of_service[4];
			uint8_t fc4_types[32];
			uint8_t ip_address[16];
			uint8_t fabric_port_name[8];
			uint8_t reserved;
			uint8_t hard_address[3];
		} ga_nxt;
		struct {
			struct ct_sns_gid_pt_data entries[2048];
		} gid_pt;
		struct {
			uint8_t port_name[8];
		} gpn_id;
		struct {
			uint8_t node_name[8];
		} gnn_id;
		struct {
			uint8_t fc4_types[32];
		} gft_id;
		struct {
			uint32_t entry_count;
			uint8_t port_name[8];
			struct ct_fdmi_hba_attributes attrs;
		} ghat;
		struct {
			uint8_t port_name[8];
		} gfpn_id;
		struct {
			uint16_t speeds;
			uint16_t speed;
		} gpsc;
		struct {
			uint8_t fc4_features[128];
		} gff_id;
		struct {
			uint8_t reserved;
			uint8_t port_id[3];
		} gid_pn;
	} rsp;
};

struct ct_sns_pkt {
	union {
		struct ct_sns_req req;
		struct ct_sns_rsp rsp;
	} p;
};

enum target_prot_op {
	TARGET_PROT_NORMAL = 0,
	TARGET_PROT_DIN_INSERT = 1,
	TARGET_PROT_DOUT_INSERT = 2,
	TARGET_PROT_DIN_STRIP = 4,
	TARGET_PROT_DOUT_STRIP = 8,
	TARGET_PROT_DIN_PASS = 16,
	TARGET_PROT_DOUT_PASS = 32,
};

enum target_prot_type {
	TARGET_DIF_TYPE0_PROT = 0,
	TARGET_DIF_TYPE1_PROT = 1,
	TARGET_DIF_TYPE2_PROT = 2,
	TARGET_DIF_TYPE3_PROT = 3,
};

struct se_node_acl;

struct se_portal_group;

struct se_session {
	unsigned int sess_tearing_down: 1;
	u64 sess_bin_isid;
	enum target_prot_op sup_prot_ops;
	enum target_prot_type sess_prot_type;
	struct se_node_acl *se_node_acl;
	struct se_portal_group *se_tpg;
	void *fabric_sess_ptr;
	struct percpu_ref cmd_count;
	struct list_head sess_list;
	struct list_head sess_acl_list;
	struct list_head sess_cmd_list;
	spinlock_t sess_cmd_lock;
	wait_queue_head_t cmd_list_wq;
	void *sess_cmd_map;
	struct sbitmap_queue sess_tag_pool;
};

struct qla_qpair_hint;

struct qla_tgt {
	struct scsi_qla_host *vha;
	struct qla_hw_data *ha;
	struct btree_head64 lun_qpair_map;
	struct qla_qpair_hint *qphints;
	int atio_irq_cmd_count;
	int sg_tablesize;
	unsigned int link_reinit_iocb_pending: 1;
	int tgt_stop;
	int tgt_stopped;
	int sess_count;
	struct list_head del_sess_list;
	spinlock_t sess_work_lock;
	struct list_head sess_works_list;
	struct work_struct sess_work;
	struct imm_ntfy_from_isp link_reinit_iocb;
	wait_queue_head_t waitQ;
	int notify_ack_expected;
	int abts_resp_expected;
	int modify_lun_expected;
	atomic_t tgt_global_resets_count;
	struct list_head tgt_list_entry;
};

struct event_arg {
	fc_port_t *fcport;
	srb_t *sp;
	port_id_t id;
	u16 data[2];
	u16 rc;
	u8 port_name[8];
	u32 iop[2];
};

struct mr_data_fx00 {
	uint8_t symbolic_name[64];
	uint8_t serial_num[32];
	uint8_t hw_version[16];
	uint8_t fw_version[16];
	uint8_t uboot_version[16];
	uint8_t fru_serial_num[32];
	fc_port_t fcport;
	uint8_t fw_hbt_en;
	uint8_t fw_hbt_cnt;
	uint8_t fw_hbt_miss_cnt;
	uint32_t old_fw_hbt_cnt;
	uint16_t fw_reset_timer_tick;
	uint8_t fw_reset_timer_exp;
	uint16_t fw_critemp_timer_tick;
	uint32_t old_aenmbx0_state;
	uint32_t critical_temperature;
	bool extended_io_enabled;
	bool host_info_resend;
	uint8_t hinfo_resend_timer_tick;
};

enum fc4type_t {
	FS_FC4TYPE_FCP = 1,
	FS_FC4TYPE_NVME = 2,
	FS_FCP_IS_N2N = 128,
};

struct fab_scan_rp {
	port_id_t id;
	enum fc4type_t fc4type;
	u8 port_name[8];
	u8 node_name[8];
};

struct sns_cmd_pkt {
	union {
		struct {
			uint16_t buffer_length;
			uint16_t reserved_1;
			__le64 buffer_address;
			uint16_t subcommand_length;
			uint16_t reserved_2;
			uint16_t subcommand;
			uint16_t size;
			uint32_t reserved_3;
			uint8_t param[36];
		} __attribute__((packed)) cmd;
		uint8_t rft_data[16];
		uint8_t rnn_data[16];
		uint8_t gan_data[636];
		uint8_t gid_data[2064];
		uint8_t gpn_data[24];
		uint8_t gnn_data[24];
	} p;
};

struct fw_blob {
	char *name;
	uint32_t segs[4];
	const struct firmware *fw;
};

struct gid_list_info {
	uint8_t al_pa;
	uint8_t area;
	uint8_t domain;
	uint8_t loop_id_2100;
	uint16_t loop_id;
	uint16_t reserved_1;
};

struct isp_operations {
	int (*pci_config)(struct scsi_qla_host *);
	int (*reset_chip)(struct scsi_qla_host *);
	int (*chip_diag)(struct scsi_qla_host *);
	void (*config_rings)(struct scsi_qla_host *);
	int (*reset_adapter)(struct scsi_qla_host *);
	int (*nvram_config)(struct scsi_qla_host *);
	void (*update_fw_options)(struct scsi_qla_host *);
	int (*load_risc)(struct scsi_qla_host *, uint32_t *);
	char * (*pci_info_str)(struct scsi_qla_host *, char *, size_t);
	char * (*fw_version_str)(struct scsi_qla_host *, char *, size_t);
	irq_handler_t intr_handler;
	void (*enable_intrs)(struct qla_hw_data *);
	void (*disable_intrs)(struct qla_hw_data *);
	int (*abort_command)(srb_t *);
	int (*target_reset)(struct fc_port *, uint64_t, int);
	int (*lun_reset)(struct fc_port *, uint64_t, int);
	int (*fabric_login)(struct scsi_qla_host *, uint16_t, uint8_t, uint8_t, uint8_t, uint16_t *, uint8_t);
	int (*fabric_logout)(struct scsi_qla_host *, uint16_t, uint8_t, uint8_t, uint8_t);
	uint16_t (*calc_req_entries)(uint16_t);
	void (*build_iocbs)(srb_t *, cmd_entry_t *, uint16_t);
	void * (*prep_ms_iocb)(struct scsi_qla_host *, struct ct_arg *);
	void * (*prep_ms_fdmi_iocb)(struct scsi_qla_host *, uint32_t, uint32_t);
	uint8_t * (*read_nvram)(struct scsi_qla_host *, void *, uint32_t, uint32_t);
	int (*write_nvram)(struct scsi_qla_host *, void *, uint32_t, uint32_t);
	void (*fw_dump)(struct scsi_qla_host *, int);
	int (*beacon_on)(struct scsi_qla_host *);
	int (*beacon_off)(struct scsi_qla_host *);
	void (*beacon_blink)(struct scsi_qla_host *);
	void * (*read_optrom)(struct scsi_qla_host *, void *, uint32_t, uint32_t);
	int (*write_optrom)(struct scsi_qla_host *, void *, uint32_t, uint32_t);
	int (*get_flash_version)(struct scsi_qla_host *, void *);
	int (*start_scsi)(srb_t *);
	int (*start_scsi_mq)(srb_t *);
	int (*abort_isp)(struct scsi_qla_host *);
	int (*iospace_config)(struct qla_hw_data *);
	int (*initialize_adapter)(struct scsi_qla_host *);
};

struct fwdt {
	void *template;
	ulong length;
	ulong dump_size;
};

struct qlfc_fw {
	void *fw_buf;
	dma_addr_t fw_dma;
	uint32_t len;
};

struct qla_tgt_func_tmpl;

struct qla_tgt_vp_map;

struct qlt_hw_data {
	uint32_t node_name_set: 1;
	dma_addr_t atio_dma;
	struct atio *atio_ring;
	struct atio *atio_ring_ptr;
	uint16_t atio_ring_index;
	uint16_t atio_q_length;
	uint32_t *atio_q_in;
	uint32_t *atio_q_out;
	struct qla_tgt_func_tmpl *tgt_ops;
	struct qla_tgt_vp_map *tgt_vp_map;
	int saved_set;
	uint16_t saved_exchange_count;
	uint32_t saved_firmware_options_1;
	uint32_t saved_firmware_options_2;
	uint32_t saved_firmware_options_3;
	uint8_t saved_firmware_options[2];
	uint8_t saved_add_firmware_options[2];
	uint8_t tgt_node_name[8];
	struct dentry *dfs_tgt_sess;
	struct dentry *dfs_tgt_port_database;
	struct dentry *dfs_naqp;
	struct list_head q_full_list;
	uint32_t num_pend_cmds;
	uint32_t num_qfull_cmds_alloc;
	uint32_t num_qfull_cmds_dropped;
	spinlock_t q_full_lock;
	uint32_t leak_exchg_thresh_hold;
	spinlock_t sess_lock;
	int num_act_qpairs;
	long: 32;
	long: 64;
	long: 64;
	spinlock_t atio_lock;
	struct btree_head32 host_map;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct qla2xxx_fw_dump;

struct qla_chip_state_84xx;

struct qla_hw_data {
	struct pci_dev *pdev;
	mempool_t *srb_mempool;
	volatile struct {
		uint32_t mbox_int: 1;
		uint32_t mbox_busy: 1;
		uint32_t disable_risc_code_load: 1;
		uint32_t enable_64bit_addressing: 1;
		uint32_t enable_lip_reset: 1;
		uint32_t enable_target_reset: 1;
		uint32_t enable_lip_full_login: 1;
		uint32_t enable_led_scheme: 1;
		uint32_t msi_enabled: 1;
		uint32_t msix_enabled: 1;
		uint32_t disable_serdes: 1;
		uint32_t gpsc_supported: 1;
		uint32_t npiv_supported: 1;
		uint32_t pci_channel_io_perm_failure: 1;
		uint32_t fce_enabled: 1;
		uint32_t fac_supported: 1;
		uint32_t chip_reset_done: 1;
		uint32_t running_gold_fw: 1;
		uint32_t eeh_busy: 1;
		uint32_t disable_msix_handshake: 1;
		uint32_t fcp_prio_enabled: 1;
		uint32_t isp82xx_fw_hung: 1;
		uint32_t nic_core_hung: 1;
		uint32_t quiesce_owner: 1;
		uint32_t nic_core_reset_hdlr_active: 1;
		uint32_t nic_core_reset_owner: 1;
		uint32_t isp82xx_no_md_cap: 1;
		uint32_t host_shutting_down: 1;
		uint32_t idc_compl_status: 1;
		uint32_t mr_reset_hdlr_active: 1;
		uint32_t mr_intr_valid: 1;
		uint32_t dport_enabled: 1;
		uint32_t fawwpn_enabled: 1;
		uint32_t exlogins_enabled: 1;
		uint32_t exchoffld_enabled: 1;
		uint32_t lip_ae: 1;
		uint32_t n2n_ae: 1;
		uint32_t fw_started: 1;
		uint32_t fw_init_done: 1;
		uint32_t detected_lr_sfp: 1;
		uint32_t using_lr_setting: 1;
		uint32_t rida_fmt2: 1;
		uint32_t purge_mbox: 1;
		uint32_t n2n_bigger: 1;
		uint32_t secure_adapter: 1;
		uint32_t secure_fw: 1;
	} flags;
	uint16_t max_exchg;
	uint16_t long_range_distance;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t hardware_lock;
	int bars;
	int mem_only;
	device_reg_t *iobase;
	resource_size_t pio_address;
	dma_addr_t bar0_hdl;
	void *cregbase;
	dma_addr_t bar2_hdl;
	uint32_t rqstq_intr_code;
	uint32_t mbx_intr_code;
	uint32_t req_que_len;
	uint32_t rsp_que_len;
	uint32_t req_que_off;
	uint32_t rsp_que_off;
	device_reg_t *mqiobase;
	device_reg_t *msixbase;
	uint16_t msix_count;
	uint8_t mqenable;
	struct req_que **req_q_map;
	struct rsp_que **rsp_q_map;
	struct qla_qpair **queue_pair_map;
	long unsigned int req_qid_map[4];
	long unsigned int rsp_qid_map[4];
	long unsigned int qpair_qid_map[4];
	uint8_t max_req_queues;
	uint8_t max_rsp_queues;
	uint8_t max_qpairs;
	uint8_t num_qpairs;
	struct qla_qpair *base_qpair;
	struct qla_npiv_entry *npiv_info;
	uint16_t nvram_npiv_size;
	uint16_t switch_cap;
	uint8_t port_no;
	uint8_t exch_starvation;
	uint8_t loop_down_abort_time;
	atomic_t loop_down_timer;
	uint8_t link_down_timeout;
	uint16_t max_loop_id;
	uint16_t max_fibre_devices;
	uint16_t fb_rev;
	uint16_t min_external_loopid;
	uint16_t link_data_rate;
	uint16_t set_data_rate;
	uint8_t current_topology;
	uint8_t prev_topology;
	uint8_t operating_mode;
	uint8_t interrupts_on;
	uint32_t isp_abort_cnt;
	uint32_t isp_type;
	uint32_t device_type;
	uint8_t serial0;
	uint8_t serial1;
	uint8_t serial2;
	uint16_t nvram_size;
	uint16_t nvram_base;
	void *nvram;
	uint16_t vpd_size;
	uint16_t vpd_base;
	void *vpd;
	uint16_t loop_reset_delay;
	uint8_t retry_count;
	uint8_t login_timeout;
	uint16_t r_a_tov;
	int port_down_retry_count;
	uint8_t mbx_count;
	uint8_t aen_mbx_count;
	atomic_t num_pend_mbx_stage1;
	atomic_t num_pend_mbx_stage2;
	atomic_t num_pend_mbx_stage3;
	uint16_t frame_payload_size;
	uint32_t login_retry_count;
	ms_iocb_entry_t *ms_iocb;
	dma_addr_t ms_iocb_dma;
	struct ct_sns_pkt *ct_sns;
	dma_addr_t ct_sns_dma;
	struct sns_cmd_pkt *sns_cmd;
	dma_addr_t sns_cmd_dma;
	void *sfp_data;
	dma_addr_t sfp_data_dma;
	void *flt;
	dma_addr_t flt_dma;
	void *xgmac_data;
	dma_addr_t xgmac_data_dma;
	void *dcbx_tlv;
	dma_addr_t dcbx_tlv_dma;
	struct task_struct *dpc_thread;
	uint8_t dpc_active;
	dma_addr_t gid_list_dma;
	struct gid_list_info *gid_list;
	int gid_list_info_size;
	struct dma_pool *s_dma_pool;
	dma_addr_t init_cb_dma;
	init_cb_t *init_cb;
	int init_cb_size;
	dma_addr_t ex_init_cb_dma;
	struct ex_init_cb_81xx *ex_init_cb;
	void *async_pd;
	dma_addr_t async_pd_dma;
	void *exlogin_buf;
	dma_addr_t exlogin_buf_dma;
	int exlogin_size;
	void *exchoffld_buf;
	dma_addr_t exchoffld_buf_dma;
	int exchoffld_size;
	int exchoffld_count;
	struct els_plogi_payload plogi_els_payld;
	void *swl;
	uint16_t mailbox_out[32];
	uint32_t mailbox_out32[32];
	uint32_t aenmb[8];
	mbx_cmd_t *mcp;
	struct mbx_cmd_32 *mcp32;
	long unsigned int mbx_cmd_flags;
	struct mutex vport_lock;
	spinlock_t vport_slock;
	struct mutex mq_lock;
	struct completion mbx_cmd_comp;
	struct completion mbx_intr_comp;
	struct completion dcbx_comp;
	struct completion lb_portup_comp;
	int notify_dcbx_comp;
	int notify_lb_portup_comp;
	struct mutex selflogin_lock;
	uint16_t fw_major_version;
	uint16_t fw_minor_version;
	uint16_t fw_subminor_version;
	uint16_t fw_attributes;
	uint16_t fw_attributes_h;
	uint16_t fw_attributes_ext[2];
	uint32_t fw_memory_size;
	uint32_t fw_transfer_size;
	uint32_t fw_srisc_address;
	uint16_t orig_fw_tgt_xcb_count;
	uint16_t cur_fw_tgt_xcb_count;
	uint16_t orig_fw_xcb_count;
	uint16_t cur_fw_xcb_count;
	uint16_t orig_fw_iocb_count;
	uint16_t cur_fw_iocb_count;
	uint16_t fw_max_fcf_count;
	uint32_t fw_shared_ram_start;
	uint32_t fw_shared_ram_end;
	uint32_t fw_ddr_ram_start;
	uint32_t fw_ddr_ram_end;
	uint16_t fw_options[16];
	uint8_t fw_seriallink_options[4];
	uint16_t fw_seriallink_options24[4];
	uint8_t serdes_version[3];
	uint8_t mpi_version[3];
	uint32_t mpi_capabilities;
	uint8_t phy_version[3];
	uint8_t pep_version[3];
	struct fwdt fwdt[2];
	struct qla2xxx_fw_dump *fw_dump;
	uint32_t fw_dump_len;
	u32 fw_dump_alloc_len;
	bool fw_dumped;
	bool fw_dump_mpi;
	long unsigned int fw_dump_cap_flags;
	int fw_dump_reading;
	int prev_minidump_failed;
	dma_addr_t eft_dma;
	void *eft;
	dma_addr_t mctp_dump_dma;
	void *mctp_dump;
	int mctp_dumped;
	int mctp_dump_reading;
	uint32_t chain_offset;
	struct dentry *dfs_dir;
	struct dentry *dfs_fce;
	struct dentry *dfs_tgt_counters;
	struct dentry *dfs_fw_resource_cnt;
	dma_addr_t fce_dma;
	void *fce;
	uint32_t fce_bufs;
	uint16_t fce_mb[8];
	uint64_t fce_wr;
	uint64_t fce_rd;
	struct mutex fce_mutex;
	uint32_t pci_attr;
	uint16_t chip_revision;
	uint16_t product_id[4];
	uint8_t model_number[17];
	char model_desc[80];
	uint8_t adapter_id[17];
	char *optrom_buffer;
	uint32_t optrom_size;
	int optrom_state;
	uint32_t optrom_region_start;
	uint32_t optrom_region_size;
	struct mutex optrom_mutex;
	uint8_t bios_revision[2];
	uint8_t efi_revision[2];
	uint8_t fcode_revision[16];
	uint32_t fw_revision[4];
	uint32_t gold_fw_version[4];
	uint32_t flash_conf_off;
	uint32_t flash_data_off;
	uint32_t nvram_conf_off;
	uint32_t nvram_data_off;
	uint32_t fdt_wrt_disable;
	uint32_t fdt_wrt_enable;
	uint32_t fdt_erase_cmd;
	uint32_t fdt_block_size;
	uint32_t fdt_unprotect_sec_cmd;
	uint32_t fdt_protect_sec_cmd;
	uint32_t fdt_wrt_sts_reg_cmd;
	struct {
		uint32_t flt_region_flt;
		uint32_t flt_region_fdt;
		uint32_t flt_region_boot;
		uint32_t flt_region_boot_sec;
		uint32_t flt_region_fw;
		uint32_t flt_region_fw_sec;
		uint32_t flt_region_vpd_nvram;
		uint32_t flt_region_vpd_nvram_sec;
		uint32_t flt_region_vpd;
		uint32_t flt_region_vpd_sec;
		uint32_t flt_region_nvram;
		uint32_t flt_region_nvram_sec;
		uint32_t flt_region_npiv_conf;
		uint32_t flt_region_gold_fw;
		uint32_t flt_region_fcp_prio;
		uint32_t flt_region_bootload;
		uint32_t flt_region_img_status_pri;
		uint32_t flt_region_img_status_sec;
		uint32_t flt_region_aux_img_status_pri;
		uint32_t flt_region_aux_img_status_sec;
	};
	uint8_t active_image;
	uint16_t beacon_blink_led;
	uint8_t beacon_color_state;
	uint16_t zio_mode;
	uint16_t zio_timer;
	struct qla_msix_entry *msix_entries;
	struct list_head vp_list;
	long unsigned int vp_idx_map[4];
	uint16_t num_vhosts;
	uint16_t num_vsans;
	uint16_t max_npiv_vports;
	int cur_vport_count;
	struct qla_chip_state_84xx *cs84xx;
	struct isp_operations *isp_ops;
	struct workqueue_struct *wq;
	struct qlfc_fw fw_buf;
	struct qla_fcp_prio_cfg *fcp_prio_cfg;
	struct dma_pool *dl_dma_pool;
	struct dma_pool *fcp_cmnd_dma_pool;
	mempool_t *ctx_mempool;
	void *nx_pcibase;
	void *nxdb_rd_ptr;
	void *nxdb_wr_ptr;
	uint32_t crb_win;
	uint32_t curr_window;
	uint32_t ddr_mn_window;
	long unsigned int mn_win_crb;
	long unsigned int ms_win_crb;
	int qdr_sn_window;
	uint32_t fcoe_dev_init_timeout;
	uint32_t fcoe_reset_timeout;
	rwlock_t hw_lock;
	uint16_t portnum;
	int link_width;
	struct fw_blob *hablob;
	struct qla82xx_legacy_intr_set nx_legacy_intr;
	uint16_t gbl_dsd_inuse;
	uint16_t gbl_dsd_avail;
	struct list_head gbl_dsd_list;
	uint8_t fw_type;
	__le32 file_prd_off;
	uint32_t md_template_size;
	void *md_tmplt_hdr;
	dma_addr_t md_tmplt_hdr_dma;
	void *md_dump;
	uint32_t md_dump_size;
	void *loop_id_map;
	uint32_t idc_audit_ts;
	uint32_t idc_extend_tmo;
	struct workqueue_struct *dpc_lp_wq;
	struct work_struct idc_aen;
	struct workqueue_struct *dpc_hp_wq;
	struct work_struct nic_core_reset;
	struct work_struct idc_state_handler;
	struct work_struct nic_core_unrecoverable;
	struct work_struct board_disable;
	struct mr_data_fx00 mr;
	uint32_t chip_reset;
	long: 32;
	long: 64;
	struct qlt_hw_data tgt;
	int allow_cna_fw_dump;
	uint32_t fw_ability_mask;
	uint16_t min_supported_speed;
	uint16_t max_supported_speed;
	struct dma_pool *dif_bundl_pool;
	struct {
		struct {
			struct list_head head;
			uint count;
		} good;
		struct {
			struct list_head head;
			uint count;
		} unusable;
	} pool;
	long long unsigned int dif_bundle_crossed_pages;
	long long unsigned int dif_bundle_reads;
	long long unsigned int dif_bundle_writes;
	long long unsigned int dif_bundle_kallocs;
	long long unsigned int dif_bundle_dma_allocs;
	atomic_t nvme_active_aen_cnt;
	uint16_t nvme_last_rptd_aen;
	uint8_t fc4_type_priority;
	atomic_t zio_threshold;
	uint16_t last_zio_threshold;
};

struct qla_msix_entry {
	int have_irq;
	int in_use;
	uint32_t vector;
	uint16_t entry;
	char name[30];
	void *handle;
	int cpuid;
};

enum qla_work_type {
	QLA_EVT_AEN = 0,
	QLA_EVT_IDC_ACK = 1,
	QLA_EVT_ASYNC_LOGIN = 2,
	QLA_EVT_ASYNC_LOGOUT = 3,
	QLA_EVT_ASYNC_LOGOUT_DONE = 4,
	QLA_EVT_ASYNC_ADISC = 5,
	QLA_EVT_UEVENT = 6,
	QLA_EVT_AENFX = 7,
	QLA_EVT_GPNID = 8,
	QLA_EVT_UNMAP = 9,
	QLA_EVT_NEW_SESS = 10,
	QLA_EVT_GPDB = 11,
	QLA_EVT_PRLI = 12,
	QLA_EVT_GPSC = 13,
	QLA_EVT_GNL = 14,
	QLA_EVT_NACK = 15,
	QLA_EVT_RELOGIN = 16,
	QLA_EVT_ASYNC_PRLO = 17,
	QLA_EVT_ASYNC_PRLO_DONE = 18,
	QLA_EVT_GPNFT = 19,
	QLA_EVT_GPNFT_DONE = 20,
	QLA_EVT_GNNFT_DONE = 21,
	QLA_EVT_GNNID = 22,
	QLA_EVT_GFPNID = 23,
	QLA_EVT_SP_RETRY = 24,
	QLA_EVT_IIDMA = 25,
	QLA_EVT_ELS_PLOGI = 26,
};

struct qla_work_evt {
	struct list_head list;
	enum qla_work_type type;
	u32 flags;
	union {
		struct {
			enum fc_host_event_code code;
			u32 data;
		} aen;
		struct {
			uint16_t mb[7];
		} idc_ack;
		struct {
			struct fc_port *fcport;
			u16 data[2];
		} logio;
		struct {
			u32 code;
		} uevent;
		struct {
			uint32_t evtcode;
			uint32_t mbx[8];
			uint32_t count;
		} aenfx;
		struct {
			srb_t *sp;
		} iosb;
		struct {
			port_id_t id;
		} gpnid;
		struct {
			port_id_t id;
			u8 port_name[8];
			u8 node_name[8];
			void *pla;
			u8 fc4_type;
		} new_sess;
		struct {
			fc_port_t *fcport;
			u8 opt;
		} fcport;
		struct {
			fc_port_t *fcport;
			u8 iocb[64];
			int type;
		} nack;
		struct {
			u8 fc4_type;
			srb_t *sp;
		} gpnft;
	} u;
};

struct qla_chip_state_84xx {
	struct list_head list;
	struct kref kref;
	void *bus;
	spinlock_t access_lock;
	struct mutex fw_update_mutex;
	uint32_t fw_update;
	uint32_t op_fw_version;
	uint32_t op_fw_size;
	uint32_t op_fw_seq_size;
	uint32_t diag_fw_version;
	uint32_t gold_fw_version;
};

struct rsp_que {
	dma_addr_t dma;
	response_t *ring;
	response_t *ring_ptr;
	uint32_t *rsp_q_in;
	uint32_t *rsp_q_out;
	uint16_t ring_index;
	uint16_t out_ptr;
	uint16_t *in_ptr;
	uint16_t length;
	uint16_t options;
	uint16_t rid;
	uint16_t id;
	uint16_t vp_idx;
	struct qla_hw_data *hw;
	struct qla_msix_entry *msix;
	struct req_que *req;
	srb_t *status_srb;
	struct qla_qpair *qpair;
	dma_addr_t dma_fx00;
	response_t *ring_fx00;
	uint16_t length_fx00;
	uint8_t rsp_pkt[64];
};

struct req_que {
	dma_addr_t dma;
	request_t *ring;
	request_t *ring_ptr;
	uint32_t *req_q_in;
	uint32_t *req_q_out;
	uint16_t ring_index;
	uint16_t in_ptr;
	uint16_t *out_ptr;
	uint16_t cnt;
	uint16_t length;
	uint16_t options;
	uint16_t rid;
	uint16_t id;
	uint16_t qos;
	uint16_t vp_idx;
	struct rsp_que *rsp;
	srb_t **outstanding_cmds;
	uint32_t current_outstanding_cmd;
	uint16_t num_outstanding_cmds;
	int max_q_depth;
	dma_addr_t dma_fx00;
	request_t *ring_fx00;
	uint16_t length_fx00;
	uint8_t req_pkt[64];
};

struct qla_tgt_cmd;

struct qla_tgt_mgmt_cmd;

struct qla_tgt_func_tmpl {
	struct qla_tgt_cmd * (*find_cmd_by_tag)(struct fc_port *, uint64_t);
	int (*handle_cmd)(struct scsi_qla_host *, struct qla_tgt_cmd *, unsigned char *, uint32_t, int, int, int);
	void (*handle_data)(struct qla_tgt_cmd *);
	int (*handle_tmr)(struct qla_tgt_mgmt_cmd *, u64, uint16_t, uint32_t);
	void (*free_cmd)(struct qla_tgt_cmd *);
	void (*free_mcmd)(struct qla_tgt_mgmt_cmd *);
	void (*free_session)(struct fc_port *);
	int (*check_initiator_node_acl)(struct scsi_qla_host *, unsigned char *, struct fc_port *);
	void (*update_sess)(struct fc_port *, port_id_t, uint16_t, bool);
	struct fc_port * (*find_sess_by_loop_id)(struct scsi_qla_host *, const uint16_t);
	struct fc_port * (*find_sess_by_s_id)(struct scsi_qla_host *, const be_id_t);
	void (*clear_nacl_from_fcport_map)(struct fc_port *);
	void (*put_sess)(struct fc_port *);
	void (*shutdown_sess)(struct fc_port *);
	int (*get_dif_tags)(struct qla_tgt_cmd *, uint16_t *);
	int (*chk_dif_tags)(uint32_t);
	void (*add_target)(struct scsi_qla_host *);
	void (*remove_target)(struct scsi_qla_host *);
};

typedef struct scsi_qla_host scsi_qla_host_t;

struct qla_tgt_vp_map {
	uint8_t idx;
	scsi_qla_host_t *vha;
};

struct qla2100_fw_dump {
	uint16_t hccr;
	uint16_t pbiu_reg[8];
	uint16_t mailbox_reg[32];
	uint16_t dma_reg[48];
	uint16_t risc_hdw_reg[16];
	uint16_t risc_gp0_reg[16];
	uint16_t risc_gp1_reg[16];
	uint16_t risc_gp2_reg[16];
	uint16_t risc_gp3_reg[16];
	uint16_t risc_gp4_reg[16];
	uint16_t risc_gp5_reg[16];
	uint16_t risc_gp6_reg[16];
	uint16_t risc_gp7_reg[16];
	uint16_t frame_buf_hdw_reg[16];
	uint16_t fpm_b0_reg[64];
	uint16_t fpm_b1_reg[64];
	uint16_t risc_ram[61440];
};

struct qla2300_fw_dump {
	uint16_t hccr;
	uint16_t pbiu_reg[8];
	uint16_t risc_host_reg[8];
	uint16_t mailbox_reg[32];
	uint16_t resp_dma_reg[32];
	uint16_t dma_reg[48];
	uint16_t risc_hdw_reg[16];
	uint16_t risc_gp0_reg[16];
	uint16_t risc_gp1_reg[16];
	uint16_t risc_gp2_reg[16];
	uint16_t risc_gp3_reg[16];
	uint16_t risc_gp4_reg[16];
	uint16_t risc_gp5_reg[16];
	uint16_t risc_gp6_reg[16];
	uint16_t risc_gp7_reg[16];
	uint16_t frame_buf_hdw_reg[64];
	uint16_t fpm_b0_reg[64];
	uint16_t fpm_b1_reg[64];
	uint16_t risc_ram[63488];
	uint16_t stack_ram[4096];
	uint16_t data_ram[1];
};

struct qla24xx_fw_dump {
	uint32_t host_status;
	uint32_t host_reg[32];
	uint32_t shadow_reg[7];
	uint16_t mailbox_reg[32];
	uint32_t xseq_gp_reg[128];
	uint32_t xseq_0_reg[16];
	uint32_t xseq_1_reg[16];
	uint32_t rseq_gp_reg[128];
	uint32_t rseq_0_reg[16];
	uint32_t rseq_1_reg[16];
	uint32_t rseq_2_reg[16];
	uint32_t cmd_dma_reg[16];
	uint32_t req0_dma_reg[15];
	uint32_t resp0_dma_reg[15];
	uint32_t req1_dma_reg[15];
	uint32_t xmt0_dma_reg[32];
	uint32_t xmt1_dma_reg[32];
	uint32_t xmt2_dma_reg[32];
	uint32_t xmt3_dma_reg[32];
	uint32_t xmt4_dma_reg[32];
	uint32_t xmt_data_dma_reg[16];
	uint32_t rcvt0_data_dma_reg[32];
	uint32_t rcvt1_data_dma_reg[32];
	uint32_t risc_gp_reg[128];
	uint32_t lmc_reg[112];
	uint32_t fpm_hdw_reg[192];
	uint32_t fb_hdw_reg[176];
	uint32_t code_ram[8192];
	uint32_t ext_mem[1];
};

struct qla25xx_fw_dump {
	uint32_t host_status;
	uint32_t host_risc_reg[32];
	uint32_t pcie_regs[4];
	uint32_t host_reg[32];
	uint32_t shadow_reg[11];
	uint32_t risc_io_reg;
	uint16_t mailbox_reg[32];
	uint32_t xseq_gp_reg[128];
	uint32_t xseq_0_reg[48];
	uint32_t xseq_1_reg[16];
	uint32_t rseq_gp_reg[128];
	uint32_t rseq_0_reg[32];
	uint32_t rseq_1_reg[16];
	uint32_t rseq_2_reg[16];
	uint32_t aseq_gp_reg[128];
	uint32_t aseq_0_reg[32];
	uint32_t aseq_1_reg[16];
	uint32_t aseq_2_reg[16];
	uint32_t cmd_dma_reg[16];
	uint32_t req0_dma_reg[15];
	uint32_t resp0_dma_reg[15];
	uint32_t req1_dma_reg[15];
	uint32_t xmt0_dma_reg[32];
	uint32_t xmt1_dma_reg[32];
	uint32_t xmt2_dma_reg[32];
	uint32_t xmt3_dma_reg[32];
	uint32_t xmt4_dma_reg[32];
	uint32_t xmt_data_dma_reg[16];
	uint32_t rcvt0_data_dma_reg[32];
	uint32_t rcvt1_data_dma_reg[32];
	uint32_t risc_gp_reg[128];
	uint32_t lmc_reg[128];
	uint32_t fpm_hdw_reg[192];
	uint32_t fb_hdw_reg[192];
	uint32_t code_ram[8192];
	uint32_t ext_mem[1];
};

struct qla81xx_fw_dump {
	uint32_t host_status;
	uint32_t host_risc_reg[32];
	uint32_t pcie_regs[4];
	uint32_t host_reg[32];
	uint32_t shadow_reg[11];
	uint32_t risc_io_reg;
	uint16_t mailbox_reg[32];
	uint32_t xseq_gp_reg[128];
	uint32_t xseq_0_reg[48];
	uint32_t xseq_1_reg[16];
	uint32_t rseq_gp_reg[128];
	uint32_t rseq_0_reg[32];
	uint32_t rseq_1_reg[16];
	uint32_t rseq_2_reg[16];
	uint32_t aseq_gp_reg[128];
	uint32_t aseq_0_reg[32];
	uint32_t aseq_1_reg[16];
	uint32_t aseq_2_reg[16];
	uint32_t cmd_dma_reg[16];
	uint32_t req0_dma_reg[15];
	uint32_t resp0_dma_reg[15];
	uint32_t req1_dma_reg[15];
	uint32_t xmt0_dma_reg[32];
	uint32_t xmt1_dma_reg[32];
	uint32_t xmt2_dma_reg[32];
	uint32_t xmt3_dma_reg[32];
	uint32_t xmt4_dma_reg[32];
	uint32_t xmt_data_dma_reg[16];
	uint32_t rcvt0_data_dma_reg[32];
	uint32_t rcvt1_data_dma_reg[32];
	uint32_t risc_gp_reg[128];
	uint32_t lmc_reg[128];
	uint32_t fpm_hdw_reg[224];
	uint32_t fb_hdw_reg[208];
	uint32_t code_ram[8192];
	uint32_t ext_mem[1];
};

struct qla83xx_fw_dump {
	uint32_t host_status;
	uint32_t host_risc_reg[48];
	uint32_t pcie_regs[4];
	uint32_t host_reg[32];
	uint32_t shadow_reg[11];
	uint32_t risc_io_reg;
	uint16_t mailbox_reg[32];
	uint32_t xseq_gp_reg[256];
	uint32_t xseq_0_reg[48];
	uint32_t xseq_1_reg[16];
	uint32_t xseq_2_reg[16];
	uint32_t rseq_gp_reg[256];
	uint32_t rseq_0_reg[32];
	uint32_t rseq_1_reg[16];
	uint32_t rseq_2_reg[16];
	uint32_t rseq_3_reg[16];
	uint32_t aseq_gp_reg[256];
	uint32_t aseq_0_reg[32];
	uint32_t aseq_1_reg[16];
	uint32_t aseq_2_reg[16];
	uint32_t aseq_3_reg[16];
	uint32_t cmd_dma_reg[64];
	uint32_t req0_dma_reg[15];
	uint32_t resp0_dma_reg[15];
	uint32_t req1_dma_reg[15];
	uint32_t xmt0_dma_reg[32];
	uint32_t xmt1_dma_reg[32];
	uint32_t xmt2_dma_reg[32];
	uint32_t xmt3_dma_reg[32];
	uint32_t xmt4_dma_reg[32];
	uint32_t xmt_data_dma_reg[16];
	uint32_t rcvt0_data_dma_reg[32];
	uint32_t rcvt1_data_dma_reg[32];
	uint32_t risc_gp_reg[128];
	uint32_t lmc_reg[128];
	uint32_t fpm_hdw_reg[256];
	uint32_t rq0_array_reg[256];
	uint32_t rq1_array_reg[256];
	uint32_t rp0_array_reg[256];
	uint32_t rp1_array_reg[256];
	uint32_t queue_control_reg[16];
	uint32_t fb_hdw_reg[432];
	uint32_t at0_array_reg[128];
	uint32_t code_ram[9216];
	uint32_t ext_mem[1];
};

struct qla2xxx_fw_dump {
	uint8_t signature[4];
	uint32_t version;
	uint32_t fw_major_version;
	uint32_t fw_minor_version;
	uint32_t fw_subminor_version;
	uint32_t fw_attributes;
	uint32_t vendor;
	uint32_t device;
	uint32_t subsystem_vendor;
	uint32_t subsystem_device;
	uint32_t fixed_size;
	uint32_t mem_size;
	uint32_t req_q_size;
	uint32_t rsp_q_size;
	uint32_t eft_size;
	uint32_t eft_addr_l;
	uint32_t eft_addr_h;
	uint32_t header_size;
	union {
		struct qla2100_fw_dump isp21;
		struct qla2300_fw_dump isp23;
		struct qla24xx_fw_dump isp24;
		struct qla25xx_fw_dump isp25;
		struct qla81xx_fw_dump isp81;
		struct qla83xx_fw_dump isp83;
	} isp;
};

enum nexus_wait_type {
	WAIT_HOST = 0,
	WAIT_TARGET = 1,
	WAIT_LUN = 2,
};

struct fcp_hdr {
	uint8_t r_ctl;
	be_id_t d_id;
	uint8_t cs_ctl;
	be_id_t s_id;
	uint8_t type;
	uint8_t f_ctl[3];
	uint8_t seq_id;
	uint8_t df_ctl;
	uint16_t seq_cnt;
	__be16 ox_id;
	uint16_t rx_id;
	uint32_t parameter;
};

struct fcp_hdr_le {
	le_id_t d_id;
	uint8_t r_ctl;
	le_id_t s_id;
	uint8_t cs_ctl;
	uint8_t f_ctl[3];
	uint8_t type;
	uint16_t seq_cnt;
	uint8_t df_ctl;
	uint8_t seq_id;
	uint16_t rx_id;
	uint16_t ox_id;
	uint32_t parameter;
};

struct atio7_fcp_cmnd {
	uint64_t lun;
	uint8_t cmnd_ref;
	uint8_t task_attr: 3;
	uint8_t reserved: 5;
	uint8_t task_mgmt_flags;
	uint8_t wrdata: 1;
	uint8_t rddata: 1;
	uint8_t add_cdb_len: 6;
	uint8_t cdb[16];
	uint8_t add_cdb[4];
};

struct atio_from_isp {
	union {
		struct {
			uint16_t entry_hdr;
			uint8_t sys_define;
			uint8_t entry_status;
			uint32_t sys_define_2;
			target_id_t target;
			uint16_t rx_id;
			uint16_t flags;
			uint16_t status;
			uint8_t command_ref;
			uint8_t task_codes;
			uint8_t task_flags;
			uint8_t execution_codes;
			uint8_t cdb[16];
			uint32_t data_length;
			uint16_t lun;
			uint8_t initiator_port_name[8];
			uint16_t reserved_32[6];
			uint16_t ox_id;
		} isp2x;
		struct {
			uint16_t entry_hdr;
			uint8_t fcp_cmnd_len_low;
			uint8_t fcp_cmnd_len_high: 4;
			uint8_t attr: 4;
			uint32_t exchange_addr;
			struct fcp_hdr fcp_hdr;
			struct atio7_fcp_cmnd fcp_cmnd;
		} isp24;
		struct {
			uint8_t entry_type;
			uint8_t entry_count;
			__le16 attr_n_length;
			uint8_t data[56];
			uint32_t signature;
		} raw;
	} u;
};

struct abts_recv_from_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint8_t reserved_1[6];
	uint16_t nport_handle;
	uint8_t reserved_2[2];
	uint8_t vp_index;
	uint8_t reserved_3: 4;
	uint8_t sof_type: 4;
	uint32_t exchange_address;
	struct fcp_hdr_le fcp_hdr_le;
	uint8_t reserved_4[16];
	uint32_t exchange_addr_to_abort;
};

enum transport_state_table {
	TRANSPORT_NO_STATE = 0,
	TRANSPORT_NEW_CMD = 1,
	TRANSPORT_WRITE_PENDING = 3,
	TRANSPORT_PROCESSING = 5,
	TRANSPORT_COMPLETE = 6,
	TRANSPORT_ISTATE_PROCESSING = 11,
	TRANSPORT_COMPLETE_QF_WP = 18,
	TRANSPORT_COMPLETE_QF_OK = 19,
	TRANSPORT_COMPLETE_QF_ERR = 20,
};

typedef unsigned int sense_reason_t;

struct se_device;

struct se_lun;

struct se_tmr_req;

struct target_core_fabric_ops;

struct se_cmd {
	u8 scsi_status;
	u8 scsi_asc;
	u8 scsi_ascq;
	u16 scsi_sense_length;
	unsigned int unknown_data_length: 1;
	bool state_active: 1;
	u64 tag;
	int alua_nonop_delay;
	enum dma_data_direction data_direction;
	int sam_task_attr;
	unsigned int map_tag;
	int map_cpu;
	enum transport_state_table t_state;
	u32 se_cmd_flags;
	u32 data_length;
	u32 residual_count;
	u64 orig_fe_lun;
	u64 pr_res_key;
	void *sense_buffer;
	struct list_head se_delayed_node;
	struct list_head se_qf_node;
	struct se_device *se_dev;
	struct se_lun *se_lun;
	struct se_session *se_sess;
	struct se_tmr_req *se_tmr_req;
	struct list_head se_cmd_list;
	struct completion *free_compl;
	struct completion *abrt_compl;
	const struct target_core_fabric_ops *se_tfo;
	sense_reason_t (*execute_cmd)(struct se_cmd *);
	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool, int *);
	void *protocol_data;
	unsigned char *t_task_cdb;
	unsigned char __t_task_cdb[32];
	long long unsigned int t_task_lba;
	unsigned int t_task_nolb;
	unsigned int transport_state;
	spinlock_t t_state_lock;
	struct kref cmd_kref;
	struct completion t_transport_stop_comp;
	struct work_struct work;
	struct scatterlist *t_data_sg;
	struct scatterlist *t_data_sg_orig;
	unsigned int t_data_nents;
	unsigned int t_data_nents_orig;
	void *t_data_vmap;
	struct scatterlist *t_bidi_data_sg;
	unsigned int t_bidi_data_nents;
	int lun_ref_active;
	struct list_head state_list;
	void *priv;
	enum target_prot_op prot_op;
	enum target_prot_type prot_type;
	u8 prot_checks;
	bool prot_pto;
	u32 prot_length;
	u32 reftag_seed;
	struct scatterlist *t_prot_sg;
	unsigned int t_prot_nents;
	sense_reason_t pi_err;
	sector_t bad_sector;
	int cpuid;
};

enum trace_flags {
	TRC_NEW_CMD = 1,
	TRC_DO_WORK = 2,
	TRC_DO_WORK_ERR = 4,
	TRC_XFR_RDY = 8,
	TRC_XMIT_DATA = 16,
	TRC_XMIT_STATUS = 32,
	TRC_SRR_RSP = 64,
	TRC_SRR_XRDY = 128,
	TRC_SRR_TERM = 256,
	TRC_SRR_CTIO = 512,
	TRC_FLUSH = 1024,
	TRC_CTIO_ERR = 2048,
	TRC_CTIO_DONE = 4096,
	TRC_CTIO_ABORTED = 8192,
	TRC_CTIO_STRANGE = 16384,
	TRC_CMD_DONE = 32768,
	TRC_CMD_CHK_STOP = 65536,
	TRC_CMD_FREE = 131072,
	TRC_DATA_IN = 262144,
	TRC_ABORT = 524288,
	TRC_DIF_ERR = 1048576,
};

struct qla_tgt_cmd {
	uint8_t cmd_type;
	uint8_t pad[7];
	struct se_cmd se_cmd;
	struct fc_port *sess;
	struct qla_qpair *qpair;
	uint32_t reset_count;
	int state;
	struct work_struct work;
	unsigned char sense_buffer[96];
	spinlock_t cmd_lock;
	unsigned int conf_compl_supported: 1;
	unsigned int sg_mapped: 1;
	unsigned int free_sg: 1;
	unsigned int write_data_transferred: 1;
	unsigned int q_full: 1;
	unsigned int term_exchg: 1;
	unsigned int cmd_sent_to_fw: 1;
	unsigned int cmd_in_wq: 1;
	unsigned int aborted;
	struct scatterlist *sg;
	int sg_cnt;
	int bufflen;
	int offset;
	u64 unpacked_lun;
	enum dma_data_direction dma_data_direction;
	uint16_t ctio_flags;
	uint16_t vp_idx;
	uint16_t loop_id;
	struct qla_tgt *tgt;
	struct scsi_qla_host *vha;
	struct list_head cmd_list;
	struct atio_from_isp atio;
	uint8_t ctx_dsd_alloced;
	int8_t dif_err_code;
	struct scatterlist *prot_sg;
	uint32_t prot_sg_cnt;
	uint32_t blk_sz;
	uint32_t num_blks;
	uint8_t scsi_status;
	uint8_t sense_key;
	uint8_t asc;
	uint8_t ascq;
	struct crc_context *ctx;
	const uint8_t *cdb;
	uint64_t lba;
	uint16_t a_guard;
	uint16_t e_guard;
	uint16_t a_app_tag;
	uint16_t e_app_tag;
	uint32_t a_ref_tag;
	uint32_t e_ref_tag;
	uint16_t prot_flags;
	uint64_t jiffies_at_alloc;
	uint64_t jiffies_at_free;
	enum trace_flags trc_flags;
};

struct qla_tgt_mgmt_cmd {
	uint8_t cmd_type;
	uint8_t pad[3];
	uint16_t tmr_func;
	uint8_t fc_tm_rsp;
	uint8_t abort_io_attr;
	struct fc_port *sess;
	struct qla_qpair *qpair;
	struct scsi_qla_host *vha;
	struct se_cmd se_cmd;
	struct work_struct free_work;
	unsigned int flags;
	uint32_t reset_count;
	struct work_struct work;
	uint64_t unpacked_lun;
	union {
		struct atio_from_isp atio;
		struct imm_ntfy_from_isp imm_ntfy;
		struct abts_recv_from_24xx abts;
	} orig_iocb;
};

struct t10_alua_tg_pt_gp;

struct t10_alua {
	u16 alua_tg_pt_gps_counter;
	u32 alua_tg_pt_gps_count;
	spinlock_t lba_map_lock;
	u32 lba_map_segment_size;
	u32 lba_map_segment_multiplier;
	struct list_head lba_map_list;
	spinlock_t tg_pt_gps_lock;
	struct se_device *t10_dev;
	struct t10_alua_tg_pt_gp *default_tg_pt_gp;
	struct config_group alua_tg_pt_gps_group;
	struct list_head tg_pt_gps_list;
};

struct t10_wwn {
	char vendor[9];
	char model[17];
	char revision[5];
	char unit_serial[254];
	spinlock_t t10_vpd_lock;
	struct se_device *t10_dev;
	struct config_group t10_wwn_group;
	struct list_head t10_vpd_list;
};

struct t10_reservation {
	int pr_all_tg_pt;
	int pr_aptpl_active;
	u32 pr_generation;
	spinlock_t registration_lock;
	spinlock_t aptpl_reg_lock;
	struct se_node_acl *pr_res_holder;
	struct list_head registration_list;
	struct list_head aptpl_reg_list;
};

struct se_dev_attrib {
	int emulate_model_alias;
	int emulate_dpo;
	int emulate_fua_write;
	int emulate_fua_read;
	int emulate_write_cache;
	int emulate_ua_intlck_ctrl;
	int emulate_tas;
	int emulate_tpu;
	int emulate_tpws;
	int emulate_caw;
	int emulate_3pc;
	int emulate_pr;
	enum target_prot_type pi_prot_type;
	enum target_prot_type hw_pi_prot_type;
	int pi_prot_verify;
	int enforce_pr_isids;
	int force_pr_aptpl;
	int is_nonrot;
	int emulate_rest_reord;
	int unmap_zeroes_data;
	u32 hw_block_size;
	u32 block_size;
	u32 hw_max_sectors;
	u32 optimal_sectors;
	u32 hw_queue_depth;
	u32 queue_depth;
	u32 max_unmap_lba_count;
	u32 max_unmap_block_desc_count;
	u32 unmap_granularity;
	u32 unmap_granularity_alignment;
	u32 max_write_same_len;
	u32 max_bytes_per_io;
	struct se_device *da_dev;
	struct config_group da_group;
};

struct se_dev_stat_grps {
	struct config_group stat_group;
	struct config_group scsi_dev_group;
	struct config_group scsi_tgt_dev_group;
	struct config_group scsi_lu_group;
};

struct target_backend_ops;

struct scsi_port_stats {
	atomic_long_t cmd_pdus;
	atomic_long_t tx_data_octets;
	atomic_long_t rx_data_octets;
};

struct se_port_stat_grps {
	struct config_group stat_group;
	struct config_group scsi_port_group;
	struct config_group scsi_tgt_port_group;
	struct config_group scsi_transport_group;
};

struct se_lun {
	u64 unpacked_lun;
	bool lun_shutdown;
	bool lun_access_ro;
	u32 lun_index;
	u16 lun_rtpi;
	atomic_t lun_acl_count;
	struct se_device *lun_se_dev;
	struct list_head lun_deve_list;
	spinlock_t lun_deve_lock;
	int lun_tg_pt_secondary_stat;
	int lun_tg_pt_secondary_write_md;
	atomic_t lun_tg_pt_secondary_offline;
	struct mutex lun_tg_pt_md_mutex;
	struct list_head lun_tg_pt_gp_link;
	struct t10_alua_tg_pt_gp *lun_tg_pt_gp;
	spinlock_t lun_tg_pt_gp_lock;
	struct se_portal_group *lun_tpg;
	struct scsi_port_stats lun_stats;
	struct config_group lun_group;
	struct se_port_stat_grps port_stat_grps;
	struct completion lun_shutdown_comp;
	struct percpu_ref lun_ref;
	struct list_head lun_dev_link;
	struct hlist_node link;
	struct callback_head callback_head;
};

struct t10_alua_lu_gp_member;

struct t10_pr_registration;

struct se_hba;

struct se_device {
	u16 dev_rpti_counter;
	u32 dev_cur_ordered_id;
	u32 dev_flags;
	u32 queue_depth;
	u64 dev_res_bin_isid;
	u32 dev_index;
	u64 creation_time;
	atomic_long_t num_resets;
	atomic_long_t aborts_complete;
	atomic_long_t aborts_no_task;
	atomic_long_t num_cmds;
	atomic_long_t read_bytes;
	atomic_long_t write_bytes;
	atomic_t simple_cmds;
	atomic_t dev_ordered_sync;
	atomic_t dev_qf_count;
	u32 export_count;
	spinlock_t delayed_cmd_lock;
	spinlock_t execute_task_lock;
	spinlock_t dev_reservation_lock;
	unsigned int dev_reservation_flags;
	spinlock_t se_port_lock;
	spinlock_t se_tmr_lock;
	spinlock_t qf_cmd_lock;
	struct semaphore caw_sem;
	struct se_session *reservation_holder;
	struct t10_alua_lu_gp_member *dev_alua_lu_gp_mem;
	struct t10_pr_registration *dev_pr_res_holder;
	struct list_head dev_sep_list;
	struct list_head dev_tmr_list;
	struct work_struct qf_work_queue;
	struct list_head delayed_cmd_list;
	struct list_head state_list;
	struct list_head qf_cmd_list;
	struct se_hba *se_hba;
	struct t10_wwn t10_wwn;
	struct t10_alua t10_alua;
	struct t10_reservation t10_pr;
	struct se_dev_attrib dev_attrib;
	struct config_group dev_action_group;
	struct config_group dev_group;
	struct config_group dev_pr_group;
	struct se_dev_stat_grps dev_stat_grps;
	unsigned char dev_alias[512];
	unsigned char udev_path[512];
	const struct target_backend_ops *transport;
	struct se_lun xcopy_lun;
	int prot_length;
	u32 hba_index;
	struct callback_head callback_head;
};

struct t10_alua_tg_pt_gp {
	u16 tg_pt_gp_id;
	int tg_pt_gp_valid_id;
	int tg_pt_gp_alua_supported_states;
	int tg_pt_gp_alua_access_status;
	int tg_pt_gp_alua_access_type;
	int tg_pt_gp_nonop_delay_msecs;
	int tg_pt_gp_trans_delay_msecs;
	int tg_pt_gp_implicit_trans_secs;
	int tg_pt_gp_pref;
	int tg_pt_gp_write_metadata;
	u32 tg_pt_gp_members;
	int tg_pt_gp_alua_access_state;
	atomic_t tg_pt_gp_ref_cnt;
	spinlock_t tg_pt_gp_lock;
	struct mutex tg_pt_gp_transition_mutex;
	struct se_device *tg_pt_gp_dev;
	struct config_group tg_pt_gp_group;
	struct list_head tg_pt_gp_list;
	struct list_head tg_pt_gp_lun_list;
	struct se_lun *tg_pt_gp_alua_lun;
	struct se_node_acl *tg_pt_gp_alua_nacl;
};

struct t10_alua_lu_gp {
	u16 lu_gp_id;
	int lu_gp_valid_id;
	u32 lu_gp_members;
	atomic_t lu_gp_ref_cnt;
	spinlock_t lu_gp_lock;
	struct config_group lu_gp_group;
	struct list_head lu_gp_node;
	struct list_head lu_gp_mem_list;
};

struct t10_alua_lu_gp_member {
	bool lu_gp_assoc;
	atomic_t lu_gp_mem_ref_cnt;
	spinlock_t lu_gp_mem_lock;
	struct t10_alua_lu_gp *lu_gp;
	struct se_device *lu_gp_mem_dev;
	struct list_head lu_gp_mem_list;
};

struct se_node_acl {
	char initiatorname[224];
	bool dynamic_node_acl;
	bool dynamic_stop;
	u32 queue_depth;
	u32 acl_index;
	enum target_prot_type saved_prot_type;
	char acl_tag[64];
	atomic_t acl_pr_ref_count;
	struct hlist_head lun_entry_hlist;
	struct se_session *nacl_sess;
	struct se_portal_group *se_tpg;
	struct mutex lun_entry_mutex;
	spinlock_t nacl_sess_lock;
	struct config_group acl_group;
	struct config_group acl_attrib_group;
	struct config_group acl_auth_group;
	struct config_group acl_param_group;
	struct config_group acl_fabric_stat_group;
	struct list_head acl_list;
	struct list_head acl_sess_list;
	struct completion acl_free_comp;
	struct kref acl_kref;
};

struct se_dev_entry;

struct t10_pr_registration {
	char pr_reg_isid[16];
	unsigned char pr_iport[256];
	unsigned char pr_tport[256];
	u16 pr_aptpl_rpti;
	u16 pr_reg_tpgt;
	int pr_reg_all_tg_pt;
	int pr_reg_aptpl;
	int pr_res_holder;
	int pr_res_type;
	int pr_res_scope;
	bool isid_present_at_reg;
	u64 pr_res_mapped_lun;
	u64 pr_aptpl_target_lun;
	u16 tg_pt_sep_rtpi;
	u32 pr_res_generation;
	u64 pr_reg_bin_isid;
	u64 pr_res_key;
	atomic_t pr_res_holders;
	struct se_node_acl *pr_reg_nacl;
	struct se_dev_entry *pr_reg_deve;
	struct list_head pr_reg_list;
	struct list_head pr_reg_abort_list;
	struct list_head pr_reg_aptpl_list;
	struct list_head pr_reg_atp_list;
	struct list_head pr_reg_atp_mem_list;
};

struct se_lun_acl;

struct se_dev_entry {
	u64 mapped_lun;
	u64 pr_res_key;
	u64 creation_time;
	bool lun_access_ro;
	u32 attach_count;
	atomic_long_t total_cmds;
	atomic_long_t read_bytes;
	atomic_long_t write_bytes;
	struct kref pr_kref;
	struct completion pr_comp;
	struct se_lun_acl *se_lun_acl;
	spinlock_t ua_lock;
	struct se_lun *se_lun;
	long unsigned int deve_flags;
	struct list_head alua_port_list;
	struct list_head lun_link;
	struct list_head ua_list;
	struct hlist_node link;
	struct callback_head callback_head;
};

struct se_tmr_req {
	u8 function;
	u8 response;
	int call_transport;
	u64 ref_task_tag;
	void *fabric_tmr_ptr;
	struct se_cmd *task_cmd;
	struct se_device *tmr_dev;
	struct list_head tmr_list;
};

struct target_fabric_configfs;

struct se_wwn;

struct se_tpg_np;

struct target_core_fabric_ops {
	struct module *module;
	const char *fabric_alias;
	const char *fabric_name;
	size_t node_acl_size;
	u32 max_data_sg_nents;
	char * (*tpg_get_wwn)(struct se_portal_group *);
	u16 (*tpg_get_tag)(struct se_portal_group *);
	u32 (*tpg_get_default_depth)(struct se_portal_group *);
	int (*tpg_check_demo_mode)(struct se_portal_group *);
	int (*tpg_check_demo_mode_cache)(struct se_portal_group *);
	int (*tpg_check_demo_mode_write_protect)(struct se_portal_group *);
	int (*tpg_check_prod_mode_write_protect)(struct se_portal_group *);
	int (*tpg_check_demo_mode_login_only)(struct se_portal_group *);
	int (*tpg_check_prot_fabric_only)(struct se_portal_group *);
	u32 (*tpg_get_inst_index)(struct se_portal_group *);
	int (*check_stop_free)(struct se_cmd *);
	void (*release_cmd)(struct se_cmd *);
	void (*close_session)(struct se_session *);
	u32 (*sess_get_index)(struct se_session *);
	u32 (*sess_get_initiator_sid)(struct se_session *, unsigned char *, u32);
	int (*write_pending)(struct se_cmd *);
	void (*set_default_node_attributes)(struct se_node_acl *);
	int (*get_cmd_state)(struct se_cmd *);
	int (*queue_data_in)(struct se_cmd *);
	int (*queue_status)(struct se_cmd *);
	void (*queue_tm_rsp)(struct se_cmd *);
	void (*aborted_task)(struct se_cmd *);
	struct se_wwn * (*fabric_make_wwn)(struct target_fabric_configfs *, struct config_group *, const char *);
	void (*fabric_drop_wwn)(struct se_wwn *);
	void (*add_wwn_groups)(struct se_wwn *);
	struct se_portal_group * (*fabric_make_tpg)(struct se_wwn *, const char *);
	void (*fabric_drop_tpg)(struct se_portal_group *);
	int (*fabric_post_link)(struct se_portal_group *, struct se_lun *);
	void (*fabric_pre_unlink)(struct se_portal_group *, struct se_lun *);
	struct se_tpg_np * (*fabric_make_np)(struct se_portal_group *, struct config_group *, const char *);
	void (*fabric_drop_np)(struct se_tpg_np *);
	int (*fabric_init_nodeacl)(struct se_node_acl *, const char *);
	struct configfs_attribute **tfc_discovery_attrs;
	struct configfs_attribute **tfc_wwn_attrs;
	struct configfs_attribute **tfc_tpg_base_attrs;
	struct configfs_attribute **tfc_tpg_np_base_attrs;
	struct configfs_attribute **tfc_tpg_attrib_attrs;
	struct configfs_attribute **tfc_tpg_auth_attrs;
	struct configfs_attribute **tfc_tpg_param_attrs;
	struct configfs_attribute **tfc_tpg_nacl_base_attrs;
	struct configfs_attribute **tfc_tpg_nacl_attrib_attrs;
	struct configfs_attribute **tfc_tpg_nacl_auth_attrs;
	struct configfs_attribute **tfc_tpg_nacl_param_attrs;
	bool write_pending_must_be_called;
};

struct se_portal_group {
	int proto_id;
	atomic_t tpg_pr_ref_count;
	struct mutex acl_node_mutex;
	spinlock_t session_lock;
	struct mutex tpg_lun_mutex;
	struct list_head se_tpg_node;
	struct list_head acl_node_list;
	struct hlist_head tpg_lun_hlist;
	struct se_lun *tpg_virt_lun0;
	struct list_head tpg_sess_list;
	const struct target_core_fabric_ops *se_tpg_tfo;
	struct se_wwn *se_tpg_wwn;
	struct config_group tpg_group;
	struct config_group tpg_lun_group;
	struct config_group tpg_np_group;
	struct config_group tpg_acl_group;
	struct config_group tpg_attrib_group;
	struct config_group tpg_auth_group;
	struct config_group tpg_param_group;
};

struct se_ml_stat_grps {
	struct config_group stat_group;
	struct config_group scsi_auth_intr_group;
	struct config_group scsi_att_intr_port_group;
};

struct se_lun_acl {
	u64 mapped_lun;
	struct se_node_acl *se_lun_nacl;
	struct se_lun *se_lun;
	struct config_group se_lun_group;
	struct se_ml_stat_grps ml_stat_grps;
};

struct target_backend;

struct se_hba {
	u16 hba_tpgt;
	u32 hba_id;
	u32 hba_flags;
	u32 dev_count;
	u32 hba_index;
	void *hba_ptr;
	struct list_head hba_node;
	spinlock_t device_lock;
	struct config_group hba_group;
	struct mutex hba_access_mutex;
	struct target_backend *backend;
};

struct se_wwn {
	struct target_fabric_configfs *wwn_tf;
	void *priv;
	struct config_group wwn_group;
	struct config_group fabric_stat_group;
};

struct qla_qpair_hint {
	struct list_head hint_elem;
	struct qla_qpair *qpair;
	u16 cpuid;
	uint8_t cmd_cnt;
};

struct port_database_24xx {
	uint16_t flags;
	uint8_t current_login_state;
	uint8_t last_login_state;
	uint8_t hard_address[3];
	uint8_t reserved_1;
	uint8_t port_id[3];
	uint8_t sequence_id;
	uint16_t port_timer;
	uint16_t nport_handle;
	uint16_t receive_data_size;
	uint16_t reserved_2;
	uint8_t prli_svc_param_word_0[2];
	uint8_t prli_svc_param_word_3[2];
	uint8_t port_name[8];
	uint8_t node_name[8];
	uint8_t reserved_3[4];
	uint16_t prli_nvme_svc_param_word_0;
	uint16_t prli_nvme_svc_param_word_3;
	uint16_t nvme_first_burst_size;
	uint8_t reserved_4[14];
};

struct nvram_24xx {
	uint8_t id[4];
	uint16_t nvram_version;
	uint16_t reserved_0;
	uint16_t version;
	uint16_t reserved_1;
	__le16 frame_payload_size;
	uint16_t execution_throttle;
	uint16_t exchange_count;
	uint16_t hard_address;
	uint8_t port_name[8];
	uint8_t node_name[8];
	uint16_t login_retry_count;
	uint16_t link_down_on_nos;
	uint16_t interrupt_delay_timer;
	uint16_t login_timeout;
	uint32_t firmware_options_1;
	uint32_t firmware_options_2;
	uint32_t firmware_options_3;
	uint16_t seriallink_options[4];
	uint16_t reserved_2[16];
	uint16_t reserved_3[16];
	uint16_t reserved_4[16];
	uint16_t reserved_5[16];
	uint16_t reserved_6[16];
	uint16_t reserved_7[16];
	uint32_t host_p;
	uint8_t alternate_port_name[8];
	uint8_t alternate_node_name[8];
	uint8_t boot_port_name[8];
	uint16_t boot_lun_number;
	uint16_t reserved_8;
	uint8_t alt1_boot_port_name[8];
	uint16_t alt1_boot_lun_number;
	uint16_t reserved_9;
	uint8_t alt2_boot_port_name[8];
	uint16_t alt2_boot_lun_number;
	uint16_t reserved_10;
	uint8_t alt3_boot_port_name[8];
	uint16_t alt3_boot_lun_number;
	uint16_t reserved_11;
	uint32_t efi_parameters;
	uint8_t reset_delay;
	uint8_t reserved_12;
	uint16_t reserved_13;
	uint16_t boot_id_number;
	uint16_t reserved_14;
	uint16_t max_luns_per_target;
	uint16_t reserved_15;
	uint16_t port_down_retry_count;
	uint16_t link_down_timeout;
	uint16_t fcode_parameter;
	uint16_t reserved_16[3];
	uint8_t prev_drv_ver_major;
	uint8_t prev_drv_ver_submajob;
	uint8_t prev_drv_ver_minor;
	uint8_t prev_drv_ver_subminor;
	uint16_t prev_bios_ver_major;
	uint16_t prev_bios_ver_minor;
	uint16_t prev_efi_ver_major;
	uint16_t prev_efi_ver_minor;
	uint16_t prev_fw_ver_major;
	uint8_t prev_fw_ver_minor;
	uint8_t prev_fw_ver_subminor;
	uint16_t reserved_17[8];
	uint16_t reserved_18[16];
	uint16_t reserved_19[16];
	uint16_t reserved_20[16];
	uint8_t model_name[16];
	uint16_t reserved_21[2];
	uint16_t pcie_table_sig;
	uint16_t pcie_table_offset;
	uint16_t subsystem_vendor_id;
	uint16_t subsystem_device_id;
	uint32_t checksum;
};

struct init_cb_24xx {
	uint16_t version;
	uint16_t reserved_1;
	uint16_t frame_payload_size;
	uint16_t execution_throttle;
	uint16_t exchange_count;
	uint16_t hard_address;
	uint8_t port_name[8];
	uint8_t node_name[8];
	uint16_t response_q_inpointer;
	uint16_t request_q_outpointer;
	uint16_t login_retry_count;
	uint16_t prio_request_q_outpointer;
	uint16_t response_q_length;
	uint16_t request_q_length;
	uint16_t link_down_on_nos;
	uint16_t prio_request_q_length;
	__le64 request_q_address;
	__le64 response_q_address;
	__le64 prio_request_q_address;
	uint16_t msix;
	uint16_t msix_atio;
	uint8_t reserved_2[4];
	uint16_t atio_q_inpointer;
	uint16_t atio_q_length;
	__le64 atio_q_address;
	uint16_t interrupt_delay_timer;
	uint16_t login_timeout;
	uint32_t firmware_options_1;
	uint32_t firmware_options_2;
	uint32_t firmware_options_3;
	uint16_t qos;
	uint16_t rid;
	uint8_t reserved_3[20];
} __attribute__((packed));

struct mid_conf_entry_24xx {
	uint16_t reserved_1;
	uint8_t options;
	uint8_t hard_address;
	uint8_t port_name[8];
	uint8_t node_name[8];
};

struct mid_init_cb_24xx {
	struct init_cb_24xx init_cb;
	uint16_t count;
	uint16_t options;
	struct mid_conf_entry_24xx entries[256];
} __attribute__((packed));

struct nvram_81xx {
	uint8_t id[4];
	uint16_t nvram_version;
	uint16_t reserved_0;
	uint16_t version;
	uint16_t reserved_1;
	uint16_t frame_payload_size;
	uint16_t execution_throttle;
	uint16_t exchange_count;
	uint16_t reserved_2;
	uint8_t port_name[8];
	uint8_t node_name[8];
	uint16_t login_retry_count;
	uint16_t reserved_3;
	uint16_t interrupt_delay_timer;
	uint16_t login_timeout;
	uint32_t firmware_options_1;
	uint32_t firmware_options_2;
	uint32_t firmware_options_3;
	uint16_t reserved_4[4];
	uint8_t enode_mac[6];
	uint16_t reserved_5[5];
	uint16_t reserved_6[24];
	uint16_t ex_version;
	uint8_t prio_fcf_matching_flags;
	uint8_t reserved_6_1[3];
	uint16_t pri_fcf_vlan_id;
	uint8_t pri_fcf_fabric_name[8];
	uint16_t reserved_6_2[7];
	uint8_t spma_mac_addr[6];
	uint16_t reserved_6_3[14];
	uint8_t min_supported_speed;
	uint8_t reserved_7_0;
	uint16_t reserved_7[31];
	uint32_t host_p;
	uint8_t alternate_port_name[8];
	uint8_t alternate_node_name[8];
	uint8_t boot_port_name[8];
	uint16_t boot_lun_number;
	uint16_t reserved_8;
	uint8_t alt1_boot_port_name[8];
	uint16_t alt1_boot_lun_number;
	uint16_t reserved_9;
	uint8_t alt2_boot_port_name[8];
	uint16_t alt2_boot_lun_number;
	uint16_t reserved_10;
	uint8_t alt3_boot_port_name[8];
	uint16_t alt3_boot_lun_number;
	uint16_t reserved_11;
	uint32_t efi_parameters;
	uint8_t reset_delay;
	uint8_t reserved_12;
	uint16_t reserved_13;
	uint16_t boot_id_number;
	uint16_t reserved_14;
	uint16_t max_luns_per_target;
	uint16_t reserved_15;
	uint16_t port_down_retry_count;
	uint16_t link_down_timeout;
	uint16_t fcode_parameter;
	uint16_t reserved_16[3];
	uint8_t reserved_17[4];
	uint16_t reserved_18[5];
	uint8_t reserved_19[2];
	uint16_t reserved_20[8];
	uint8_t reserved_21[16];
	uint16_t reserved_22[3];
	uint16_t enhanced_features;
	uint16_t reserved_24[4];
	uint16_t reserved_25[32];
	uint8_t model_name[16];
	uint16_t feature_mask_l;
	uint16_t feature_mask_h;
	uint16_t reserved_26[2];
	uint16_t subsystem_vendor_id;
	uint16_t subsystem_device_id;
	uint32_t checksum;
};

typedef struct {
	uint8_t id[4];
	uint8_t nvram_version;
	uint8_t reserved_0;
	uint8_t parameter_block_version;
	uint8_t reserved_1;
	uint8_t firmware_options[2];
	uint16_t frame_payload_size;
	uint16_t max_iocb_allocation;
	uint16_t execution_throttle;
	uint8_t retry_count;
	uint8_t retry_delay;
	uint8_t port_name[8];
	uint16_t hard_address;
	uint8_t inquiry_data;
	uint8_t login_timeout;
	uint8_t node_name[8];
	uint8_t add_firmware_options[2];
	uint8_t response_accumulation_timer;
	uint8_t interrupt_delay_timer;
	uint8_t special_options[2];
	uint8_t reserved_2[22];
	uint8_t seriallink_options[4];
	uint8_t host_p[2];
	uint8_t boot_node_name[8];
	uint8_t boot_lun_number;
	uint8_t reset_delay;
	uint8_t port_down_retry_count;
	uint8_t boot_id_number;
	uint16_t max_luns_per_target;
	uint8_t fcode_boot_port_name[8];
	uint8_t alternate_port_name[8];
	uint8_t alternate_node_name[8];
	uint8_t efi_parameters;
	uint8_t link_down_timeout;
	uint8_t adapter_id[16];
	uint8_t alt1_boot_node_name[8];
	uint16_t alt1_boot_lun_number;
	uint8_t alt2_boot_node_name[8];
	uint16_t alt2_boot_lun_number;
	uint8_t alt3_boot_node_name[8];
	uint16_t alt3_boot_lun_number;
	uint8_t alt4_boot_node_name[8];
	uint16_t alt4_boot_lun_number;
	uint8_t alt5_boot_node_name[8];
	uint16_t alt5_boot_lun_number;
	uint8_t alt6_boot_node_name[8];
	uint16_t alt6_boot_lun_number;
	uint8_t alt7_boot_node_name[8];
	uint16_t alt7_boot_lun_number;
	uint8_t reserved_3[2];
	uint8_t model_number[16];
	uint8_t oem_specific[16];
	uint8_t adapter_features[2];
	uint8_t reserved_4[16];
	uint16_t subsystem_vendor_id_2200;
	uint16_t subsystem_device_id_2200;
	uint8_t reserved_5;
	uint8_t checksum;
} nvram_t;

typedef struct {
	port_id_t d_id;
	uint8_t node_name[8];
	uint8_t port_name[8];
	uint8_t fabric_port_name[8];
	uint16_t fp_speed;
	uint8_t fc4_type;
	uint8_t fc4_features;
} sw_info_t;

enum qla_sess_deletion {
	QLA_SESS_DELETION_NONE = 0,
	QLA_SESS_DELETION_IN_PROGRESS = 1,
	QLA_SESS_DELETED = 2,
};

enum rscn_addr_format {
	RSCN_PORT_ADDR = 0,
	RSCN_AREA_ADDR = 1,
	RSCN_DOM_ADDR = 2,
	RSCN_FAB_ADDR = 3,
};

struct active_regions {
	uint8_t global;
	struct {
		uint8_t board_config;
		uint8_t vpd_nvram;
		uint8_t npiv_config_0_1;
		uint8_t npiv_config_2_3;
	} aux;
};

struct qla27xx_image_status {
	uint8_t image_status_mask;
	uint16_t generation;
	uint8_t ver_major;
	uint8_t ver_minor;
	uint8_t bitmap;
	uint8_t reserved[2];
	uint32_t checksum;
	uint32_t signature;
} __attribute__((packed));

struct sff_8247_a0 {
	u8 txid;
	u8 ext_txid;
	u8 connector;
	u8 eth_infi_cc3;
	u8 sonet_cc4[2];
	u8 eth_cc6;
	u8 fc_ll_cc7;
	u8 fc_tec_cc8;
	u8 fc_med_cc9;
	u8 fc_sp_cc10;
	u8 encode;
	u8 bitrate;
	u8 rate_id;
	u8 length_km;
	u8 length_100m;
	u8 length_50um_10m;
	u8 length_62um_10m;
	u8 length_om4_10m;
	u8 length_om3_10m;
	u8 vendor_name[16];
	u8 tx_compat;
	u8 vendor_oui[3];
	u8 vendor_pn[16];
	u8 vendor_rev[4];
	u8 wavelength[2];
	u8 resv;
	u8 cc_base;
	u8 options[2];
	u8 br_max;
	u8 br_min;
	u8 vendor_sn[16];
	u8 date_code[8];
	u8 diag;
	u8 enh_options;
	u8 sff_revision;
	u8 cc_ext;
	u8 vendor_specific[32];
	u8 resv2[128];
};

struct nvme_fc_ersp_iu {
	__u8 status_code;
	__u8 rsvd1;
	__be16 iu_len;
	__be32 rsn;
	__be32 xfrd_len;
	__be32 rsvd12;
	struct nvme_completion cqe;
};

struct sts_entry_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t comp_status;
	uint16_t ox_id;
	uint32_t residual_len;
	union {
		uint16_t reserved_1;
		uint16_t nvme_rsp_pyld_len;
	};
	uint16_t state_flags;
	uint16_t retry_delay;
	uint16_t scsi_status;
	uint32_t rsp_residual_count;
	uint32_t sense_len;
	union {
		struct {
			uint32_t rsp_data_len;
			uint8_t data[28];
		};
		struct nvme_fc_ersp_iu nvme_ersp;
		uint8_t nvme_ersp_data[32];
	};
};

struct logio_entry_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t comp_status;
	uint16_t nport_handle;
	uint16_t control_flags;
	uint8_t vp_index;
	uint8_t reserved_1;
	uint8_t port_id[3];
	uint8_t rsp_size;
	uint32_t io_parameter[11];
};

struct tsk_mgmt_entry {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t handle_count;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t nport_handle;
	uint16_t reserved_1;
	uint16_t delay;
	uint16_t timeout;
	struct scsi_lun lun;
	uint32_t control_flags;
	uint8_t reserved_2[20];
	uint8_t port_id[3];
	uint8_t vp_index;
	uint8_t reserved_3[12];
};

struct abort_entry_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t handle_count;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t nport_handle;
	uint16_t options;
	uint32_t handle_to_abort;
	uint16_t req_que_no;
	uint8_t reserved_1[30];
	uint8_t port_id[3];
	uint8_t vp_index;
	uint8_t reserved_2[12];
};

struct vp_config_entry_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t handle_count;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t flags;
	uint16_t comp_status;
	uint8_t command;
	uint8_t vp_count;
	uint8_t vp_index1;
	uint8_t vp_index2;
	uint8_t options_idx1;
	uint8_t hard_address_idx1;
	uint16_t reserved_vp1;
	uint8_t port_name_idx1[8];
	uint8_t node_name_idx1[8];
	uint8_t options_idx2;
	uint8_t hard_address_idx2;
	uint16_t reserved_vp2;
	uint8_t port_name_idx2[8];
	uint8_t node_name_idx2[8];
	uint16_t id;
	uint16_t reserved_4;
	uint16_t hopct;
	uint8_t reserved_5[2];
};

enum VP_STATUS {
	VP_STAT_COMPL = 0,
	VP_STAT_FAIL = 1,
	VP_STAT_ID_CHG = 2,
	VP_STAT_SNS_TO = 3,
	VP_STAT_SNS_RJT = 4,
	VP_STAT_SCR_TO = 5,
	VP_STAT_SCR_RJT = 6,
};

struct vp_rpt_id_entry_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t resv1;
	uint8_t vp_acquired;
	uint8_t vp_setup;
	uint8_t vp_idx;
	uint8_t vp_status;
	uint8_t port_id[3];
	uint8_t format;
	union {
		struct {
			uint8_t vp_idx_map[16];
			uint8_t reserved_4[32];
		} f0;
		struct {
			uint8_t vpstat1_subcode;
			uint8_t flags;
			uint16_t fip_flags;
			uint8_t rsv2[12];
			uint8_t ls_rjt_vendor;
			uint8_t ls_rjt_explanation;
			uint8_t ls_rjt_reason;
			uint8_t rsv3[5];
			uint8_t port_name[8];
			uint8_t node_name[8];
			uint16_t bbcr;
			uint8_t reserved_5[6];
		} f1;
		struct {
			uint8_t vpstat1_subcode;
			uint8_t flags;
			uint16_t rsv6;
			uint8_t rsv2[12];
			uint8_t ls_rjt_vendor;
			uint8_t ls_rjt_explanation;
			uint8_t ls_rjt_reason;
			uint8_t rsv3[5];
			uint8_t port_name[8];
			uint8_t node_name[8];
			uint8_t remote_nport_id[4];
			uint32_t reserved_5;
		} f2;
	} u;
};

struct verify_chip_entry_84xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_defined;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t options;
	uint16_t reserved_1;
	uint16_t data_seg_cnt;
	uint16_t reserved_2[3];
	uint32_t fw_ver;
	uint32_t exchange_address;
	uint32_t reserved_3[3];
	uint32_t fw_size;
	uint32_t fw_seq_size;
	uint32_t relative_offset;
	struct dsd64 dsd;
} __attribute__((packed));

struct verify_chip_rsp_84xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_defined;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t comp_status;
	uint16_t failure_code;
	uint16_t reserved_1[4];
	uint32_t fw_ver;
	uint32_t exchange_address;
	uint32_t reserved_2[6];
};

struct msg_echo_lb {
	dma_addr_t send_dma;
	dma_addr_t rcv_dma;
	uint16_t req_sg_cnt;
	uint16_t rsp_sg_cnt;
	uint16_t options;
	uint32_t transfer_size;
	uint32_t iteration_count;
};

typedef struct {
	uint8_t options;
	uint8_t control;
	uint8_t master_state;
	uint8_t slave_state;
	uint8_t reserved[2];
	uint8_t hard_address;
	uint8_t reserved_1;
	uint8_t port_id[4];
	uint8_t node_name[8];
	uint8_t port_name[8];
	uint16_t execution_throttle;
	uint16_t execution_count;
	uint8_t reset_count;
	uint8_t reserved_2;
	uint16_t resource_allocation;
	uint16_t current_allocation;
	uint16_t queue_head;
	uint16_t queue_tail;
	uint16_t transmit_execution_list_next;
	uint16_t transmit_execution_list_previous;
	uint16_t common_features;
	uint16_t total_concurrent_sequences;
	uint16_t RO_by_information_category;
	uint8_t recipient;
	uint8_t initiator;
	uint16_t receive_data_size;
	uint16_t concurrent_sequences;
	uint16_t open_sequences_per_exchange;
	uint16_t lun_abort_flags;
	uint16_t lun_stop_flags;
	uint16_t stop_queue_head;
	uint16_t stop_queue_tail;
	uint16_t port_retry_timer;
	uint16_t next_sequence_id;
	uint16_t frame_count;
	uint16_t PRLI_payload_length;
	uint8_t prli_svc_param_word_0[2];
	uint8_t prli_svc_param_word_3[2];
	uint16_t loop_id;
	uint16_t extended_lun_info_list_pointer;
	uint16_t extended_lun_stop_list_pointer;
} port_database_t;

struct link_statistics {
	uint32_t link_fail_cnt;
	uint32_t loss_sync_cnt;
	uint32_t loss_sig_cnt;
	uint32_t prim_seq_err_cnt;
	uint32_t inval_xmit_word_cnt;
	uint32_t inval_crc_cnt;
	uint32_t lip_cnt;
	uint32_t link_up_cnt;
	uint32_t link_down_loop_init_tmo;
	uint32_t link_down_los;
	uint32_t link_down_loss_rcv_clk;
	uint32_t reserved0[5];
	uint32_t port_cfg_chg;
	uint32_t reserved1[11];
	uint32_t rsp_q_full;
	uint32_t atio_q_full;
	uint32_t drop_ae;
	uint32_t els_proto_err;
	uint32_t reserved2;
	uint32_t tx_frames;
	uint32_t rx_frames;
	uint32_t discarded_frames;
	uint32_t dropped_frames;
	uint32_t reserved3;
	uint32_t nos_rcvd;
	uint32_t reserved4[4];
	uint32_t tx_prjt;
	uint32_t rcv_exfail;
	uint32_t rcv_abts;
	uint32_t seq_frm_miss;
	uint32_t corr_err;
	uint32_t mb_rqst;
	uint32_t nport_full;
	uint32_t eofa;
	uint32_t reserved5;
	uint32_t fpm_recv_word_cnt_lo;
	uint32_t fpm_recv_word_cnt_hi;
	uint32_t fpm_disc_word_cnt_lo;
	uint32_t fpm_disc_word_cnt_hi;
	uint32_t fpm_xmit_word_cnt_lo;
	uint32_t fpm_xmit_word_cnt_hi;
	uint32_t reserved6[70];
};

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t scsi_status;
	uint16_t comp_status;
	uint16_t state_flags;
	uint16_t status_flags;
	uint16_t rsp_info_len;
	uint16_t req_sense_length;
	uint32_t residual_length;
	uint8_t rsp_info[8];
	uint8_t req_sense_data[32];
} sts_entry_t;

struct mb_cmd_name {
	uint16_t cmd;
	const char *str;
};

struct rom_cmd {
	uint16_t cmd;
};

struct tsk_mgmt_cmd {
	union {
		struct tsk_mgmt_entry tsk;
		struct sts_entry_24xx sts;
	} p;
};

struct cs84xx_mgmt_cmd {
	union {
		struct verify_chip_entry_84xx req;
		struct verify_chip_rsp_84xx rsp;
	} p;
};

struct pt_ls4_request {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t status;
	uint16_t nport_handle;
	uint16_t tx_dseg_count;
	uint8_t vp_index;
	uint8_t rsvd;
	uint16_t timeout;
	uint16_t control_flags;
	uint16_t rx_dseg_count;
	uint16_t rsvd2;
	uint32_t exchange_address;
	uint32_t rsvd3;
	uint32_t rx_byte_count;
	uint32_t tx_byte_count;
	struct dsd64 dsd[2];
};

struct cmd_bidir {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t nport_handle;
	uint16_t timeout;
	uint16_t wr_dseg_count;
	uint16_t rd_dseg_count;
	struct scsi_lun lun;
	uint16_t control_flags;
	uint16_t fcp_cmnd_dseg_len;
	__le64 fcp_cmnd_dseg_address;
	uint16_t reserved[2];
	uint32_t rd_byte_count;
	uint32_t wr_byte_count;
	uint8_t port_id[3];
	uint8_t vp_index;
	struct dsd64 fcp_dsd;
} __attribute__((packed));

struct cmd_type_6 {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t nport_handle;
	uint16_t timeout;
	uint16_t dseg_count;
	uint16_t fcp_rsp_dsd_len;
	struct scsi_lun lun;
	uint16_t control_flags;
	uint16_t fcp_cmnd_dseg_len;
	__le64 fcp_cmnd_dseg_address;
	__le64 fcp_rsp_dseg_address;
	uint32_t byte_count;
	uint8_t port_id[3];
	uint8_t vp_index;
	struct dsd64 fcp_dsd;
} __attribute__((packed));

struct cmd_type_7 {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t nport_handle;
	uint16_t timeout;
	uint16_t dseg_count;
	uint16_t reserved_1;
	struct scsi_lun lun;
	uint16_t task_mgmt_flags;
	uint8_t task;
	uint8_t crn;
	uint8_t fcp_cdb[16];
	uint32_t byte_count;
	uint8_t port_id[3];
	uint8_t vp_index;
	struct dsd64 dsd;
} __attribute__((packed));

struct cmd_type_crc_2 {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t nport_handle;
	uint16_t timeout;
	uint16_t dseg_count;
	uint16_t fcp_rsp_dseg_len;
	struct scsi_lun lun;
	uint16_t control_flags;
	uint16_t fcp_cmnd_dseg_len;
	__le64 fcp_cmnd_dseg_address;
	__le64 fcp_rsp_dseg_address;
	uint32_t byte_count;
	uint8_t port_id[3];
	uint8_t vp_index;
	__le64 crc_context_address;
	uint16_t crc_context_len;
	uint16_t reserved_1;
} __attribute__((packed));

struct mrk_entry_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t handle_count;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t nport_handle;
	uint8_t modifier;
	uint8_t reserved_1;
	uint8_t reserved_2;
	uint8_t vp_index;
	uint16_t reserved_3;
	uint8_t lun[8];
	uint8_t reserved_4[40];
};

struct ct_entry_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t comp_status;
	uint16_t nport_handle;
	uint16_t cmd_dsd_count;
	uint8_t vp_index;
	uint8_t reserved_1;
	uint16_t timeout;
	uint16_t reserved_2;
	uint16_t rsp_dsd_count;
	uint8_t reserved_3[10];
	uint32_t rsp_byte_count;
	uint32_t cmd_byte_count;
	struct dsd64 dsd[2];
};

struct els_entry_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t reserved_1;
	uint16_t nport_handle;
	uint16_t tx_dsd_count;
	uint8_t vp_index;
	uint8_t sof_type;
	uint32_t rx_xchg_address;
	uint16_t rx_dsd_count;
	uint8_t opcode;
	uint8_t reserved_2;
	uint8_t port_id[3];
	uint8_t s_id[3];
	uint16_t control_flags;
	__le32 rx_byte_count;
	__le32 tx_byte_count;
	__le64 tx_address;
	__le32 tx_len;
	__le64 rx_address;
	__le32 rx_len;
} __attribute__((packed));

struct vp_ctrl_entry_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t vp_idx_failed;
	uint16_t comp_status;
	uint16_t command;
	uint16_t vp_count;
	uint8_t vp_idx_map[16];
	uint16_t flags;
	uint16_t id;
	uint16_t reserved_4;
	uint16_t hopct;
	uint8_t reserved_5[24];
};

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t reserved;
	struct dsd32 dsd[7];
} cont_entry_t;

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	struct dsd64 dsd[5];
} __attribute__((packed)) cont_a64_entry_t;

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t handle_count;
	uint8_t entry_status;
	uint32_t sys_define_2;
	target_id_t target;
	uint8_t modifier;
	uint8_t reserved_1;
	uint16_t sequence_number;
	uint16_t lun;
	uint8_t reserved_2[48];
} mrk_entry_t;

struct mbx_entry {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define1;
	uint8_t entry_status;
	uint32_t handle;
	target_id_t loop_id;
	uint16_t status;
	uint16_t state_flags;
	uint16_t status_flags;
	uint32_t sys_define2[2];
	uint16_t mb0;
	uint16_t mb1;
	uint16_t mb2;
	uint16_t mb3;
	uint16_t mb6;
	uint16_t mb7;
	uint16_t mb9;
	uint16_t mb10;
	uint32_t reserved_2[2];
	uint8_t node_name[8];
	uint8_t port_name[8];
};

struct mbx_24xx_entry {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define1;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t mb[28];
};

struct tsk_mgmt_entry_fx00 {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	__le32 handle;
	uint32_t reserved_0;
	__le16 tgt_id;
	uint16_t reserved_1;
	uint16_t reserved_3;
	uint16_t reserved_4;
	struct scsi_lun lun;
	__le32 control_flags;
	uint8_t reserved_2[32];
};

struct abort_iocb_entry_fx00 {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	__le32 handle;
	__le32 reserved_0;
	__le16 tgt_id_sts;
	__le16 options;
	__le32 abort_handle;
	__le32 reserved_2;
	__le16 req_que_no;
	uint8_t reserved_1[38];
};

struct fxdisc_entry_fx00 {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	__le32 handle;
	__le32 reserved_0;
	__le16 func_num;
	__le16 req_xfrcnt;
	__le16 req_dsdcnt;
	__le16 rsp_xfrcnt;
	__le16 rsp_dsdcnt;
	uint8_t flags;
	uint8_t reserved_1;
	struct dsd64 dseg_rq;
	struct dsd64 dseg_rsp;
	__le32 dataword;
	__le32 adapid;
	__le32 adapid_hi;
	__le32 dataword_extra;
} __attribute__((packed));

struct qla_tc_param {
	struct scsi_qla_host *vha;
	uint32_t blk_sz;
	uint32_t bufflen;
	struct scatterlist *sg;
	struct scatterlist *prot_sg;
	struct crc_context *ctx;
	uint8_t *ctx_dsd_alloced;
};

struct qla2_sgx {
	dma_addr_t dma_addr;
	uint32_t dma_len;
	uint32_t tot_bytes;
	struct scatterlist *cur_sg;
	uint32_t bytes_consumed;
	uint32_t num_bytes;
	uint32_t tot_partial;
	uint32_t num_sg;
	srb_t *sp;
};

struct nack_to_isp {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	union {
		struct {
			uint32_t sys_define_2;
			target_id_t target;
			uint8_t target_id;
			uint8_t reserved_1;
			uint16_t flags;
			uint16_t resp_code;
			uint16_t status;
			uint16_t task_flags;
			uint16_t seq_id;
			uint16_t srr_rx_id;
			uint32_t srr_rel_offs;
			uint16_t srr_ui;
			uint16_t srr_flags;
			uint16_t srr_reject_code;
			uint8_t srr_reject_vendor_uniq;
			uint8_t srr_reject_code_expl;
			uint8_t reserved_2[24];
		} isp2x;
		struct {
			uint32_t handle;
			uint16_t nport_handle;
			uint16_t reserved_1;
			uint16_t flags;
			uint16_t srr_rx_id;
			uint16_t status;
			uint8_t status_subcode;
			uint8_t fw_handle;
			uint32_t exchange_address;
			uint32_t srr_rel_offs;
			uint16_t srr_ui;
			uint16_t srr_flags;
			uint8_t reserved_4[19];
			uint8_t vp_index;
			uint8_t srr_reject_vendor_uniq;
			uint8_t srr_reject_code_expl;
			uint8_t srr_reject_code;
			uint8_t reserved_5[5];
		} isp24;
	} u;
	uint8_t reserved[2];
	uint16_t ox_id;
};

struct fw_dif_context {
	uint32_t ref_tag;
	uint16_t app_tag;
	uint8_t ref_tag_mask[4];
	uint8_t app_tag_mask[2];
};

struct nvmefc_fcp_req {
	void *cmdaddr;
	void *rspaddr;
	dma_addr_t cmddma;
	dma_addr_t rspdma;
	u16 cmdlen;
	u16 rsplen;
	u32 payload_length;
	struct sg_table sg_table;
	struct scatterlist *first_sgl;
	int sg_cnt;
	enum nvmefc_fcp_datadir io_dir;
	__le16 sqid;
	void (*done)(struct nvmefc_fcp_req *);
	void *private;
	u32 transferred_length;
	u16 rcv_rsplen;
	u32 status;
};

struct els_sts_entry_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t comp_status;
	uint16_t nport_handle;
	uint16_t reserved_1;
	uint8_t vp_index;
	uint8_t sof_type;
	uint32_t rx_xchg_address;
	uint16_t reserved_2;
	uint8_t opcode;
	uint8_t reserved_3;
	uint8_t port_id[3];
	uint8_t reserved_4;
	uint16_t reserved_5;
	uint16_t control_flags;
	uint32_t total_byte_count;
	uint32_t error_subcode_1;
	uint32_t error_subcode_2;
};

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint8_t data[60];
} sts_cont_entry_t;

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t handle_count;
	uint8_t entry_status;
	uint32_t handle[15];
} sts21_entry_t;

typedef struct {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t handle_count;
	uint8_t entry_status;
	uint16_t handle[30];
} sts22_entry_t;

struct qla_init_msix_entry {
	const char *name;
	irq_handler_t handler;
};

struct ct_sns_gpn_ft_data {
	u8 control_byte;
	u8 port_id[3];
	u32 reserved;
	u8 port_name[8];
};

struct ct_sns_gpnft_rsp {
	struct {
		struct ct_cmd_hdr header;
		uint16_t response;
		uint16_t residual;
		uint8_t fragment_id;
		uint8_t reason_code;
		uint8_t explanation_code;
		uint8_t vendor_unique;
	};
	struct ct_sns_gpn_ft_data entries[1];
};

struct qla2xxx_fce_chain {
	uint32_t type;
	uint32_t chain_size;
	uint32_t size;
	uint32_t addr_l;
	uint32_t addr_h;
	uint32_t eregs[8];
};

struct qla2xxx_offld_chain {
	uint32_t type;
	uint32_t chain_size;
	uint32_t size;
	u64 addr;
};

struct qla2xxx_mq_chain {
	uint32_t type;
	uint32_t chain_size;
	uint32_t count;
	uint32_t qregs[128];
};

struct qla2xxx_mqueue_header {
	uint32_t queue;
	uint32_t number;
	uint32_t size;
};

struct qla2xxx_mqueue_chain {
	uint32_t type;
	uint32_t chain_size;
};

struct qla_fdt_layout {
	uint8_t sig[4];
	uint16_t version;
	uint16_t len;
	uint16_t checksum;
	uint8_t unused1[2];
	uint8_t model[16];
	uint16_t man_id;
	uint16_t id;
	uint8_t flags;
	uint8_t erase_cmd;
	uint8_t alt_erase_cmd;
	uint8_t wrt_enable_cmd;
	uint8_t wrt_enable_bits;
	uint8_t wrt_sts_reg_cmd;
	uint8_t unprotect_sec_cmd;
	uint8_t read_man_id_cmd;
	uint32_t block_size;
	uint32_t alt_block_size;
	uint32_t flash_size;
	uint32_t wrt_enable_data;
	uint8_t read_id_addr_len;
	uint8_t wrt_disable_bits;
	uint8_t read_dev_id_len;
	uint8_t chip_erase_cmd;
	uint16_t read_timeout;
	uint8_t protect_sec_cmd;
	uint8_t unused2[65];
};

struct qla_flt_location {
	uint8_t sig[4];
	uint16_t start_lo;
	uint16_t start_hi;
	uint8_t version;
	uint8_t unused[5];
	uint16_t checksum;
};

struct qla_flt_header {
	uint16_t version;
	uint16_t length;
	uint16_t checksum;
	uint16_t unused;
};

struct qla_flt_region {
	uint16_t code;
	uint8_t attribute;
	uint8_t reserved;
	uint32_t size;
	uint32_t start;
	uint32_t end;
};

struct qla_npiv_header {
	uint8_t sig[2];
	uint16_t version;
	uint16_t entries;
	uint16_t unused[4];
	uint16_t checksum;
};

struct secure_flash_update_block {
	uint32_t block_info;
	uint32_t signature_lo;
	uint32_t signature_hi;
	uint32_t signature_upper[62];
};

struct sysfs_entry {
	char *name;
	struct bin_attribute *attr;
	int type;
};

enum {
	NO_ACTION___2 = 0,
	MODE_CHANGE_ACCEPT = 1,
	MODE_CHANGE_NO_ACTION = 2,
	TARGET_STILL_ACTIVE = 3,
};

struct qla84_mgmt_param {
	union {
		struct {
			uint32_t start_addr;
		} mem;
		struct {
			uint32_t id;
			uint32_t param0;
			uint32_t param1;
		} config;
		struct {
			uint32_t type;
			uint32_t context;
		} info;
	} u;
};

struct qla84_msg_mgmt {
	uint16_t cmd;
	uint16_t rsrvd;
	struct qla84_mgmt_param mgmtp;
	uint32_t len;
	uint8_t payload[0];
};

struct qla_bsg_a84_mgmt {
	struct qla84_msg_mgmt mgmt;
};

struct qla_scsi_addr {
	uint16_t bus;
	uint16_t target;
};

struct qla_ext_dest_addr {
	union {
		uint8_t wwnn[8];
		uint8_t wwpn[8];
		uint8_t id[4];
		struct qla_scsi_addr scsi_addr;
	} dest_addr;
	uint16_t dest_type;
	uint16_t lun;
	uint16_t padding[2];
};

struct qla_port_param {
	struct qla_ext_dest_addr fc_scsi_addr;
	uint16_t mode;
	uint16_t speed;
};

struct qla_field_address {
	uint16_t offset;
	uint16_t device;
	uint16_t option;
};

struct qla_field_info {
	uint8_t version[36];
};

struct qla_image_version {
	struct qla_field_address field_address;
	struct qla_field_info field_info;
};

struct qla_image_version_list {
	uint32_t count;
	struct qla_image_version version[0];
};

struct qla_status_reg {
	struct qla_field_address field_address;
	uint8_t status_reg;
	uint8_t reserved[7];
};

struct qla_i2c_access {
	uint16_t device;
	uint16_t offset;
	uint16_t option;
	uint16_t length;
	uint8_t buffer[64];
};

struct qla_serdes_reg {
	uint16_t cmd;
	uint16_t addr;
	uint16_t val;
};

struct qla_serdes_reg_ex {
	uint16_t cmd;
	uint32_t addr;
	uint32_t val;
} __attribute__((packed));

struct qla_flash_update_caps {
	uint64_t capabilities;
	uint32_t outage_duration;
	uint8_t reserved[20];
};

struct qla_bbcr_data {
	uint8_t status;
	uint8_t state;
	uint8_t configured_bbscn;
	uint8_t negotiated_bbscn;
	uint8_t offline_reason_code;
	uint16_t mbx1;
	uint8_t reserved[9];
} __attribute__((packed));

struct qla_dport_diag {
	uint16_t options;
	uint32_t buf[16];
	uint8_t unused[62];
} __attribute__((packed));

struct qla_active_regions {
	uint8_t global_image;
	uint8_t board_config;
	uint8_t vpd_nvram;
	uint8_t npiv_config_0_1;
	uint8_t npiv_config_2_3;
	uint8_t reserved[32];
};

struct access_chip_84xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_defined;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t options;
	uint16_t reserved1;
	uint16_t dseg_count;
	uint16_t reserved2[3];
	uint32_t parameter1;
	uint32_t parameter2;
	uint32_t parameter3;
	uint32_t reserved3[3];
	uint32_t total_byte_cnt;
	uint32_t reserved4;
	struct dsd64 dsd;
} __attribute__((packed));

struct qla_mt_iocb_rqst_fx00 {
	__le32 reserved_0;
	__le16 func_type;
	uint8_t flags;
	uint8_t reserved_1;
	__le32 dataword;
	__le32 adapid;
	__le32 adapid_hi;
	__le32 dataword_extra;
	__le16 req_len;
	__le16 reserved_2;
	__le16 rsp_len;
	__le16 reserved_3;
};

struct crb_128M_2M_sub_block_map {
	unsigned int valid;
	unsigned int start_128M;
	unsigned int end_128M;
	unsigned int start_2M;
};

struct crb_128M_2M_block_map {
	struct crb_128M_2M_sub_block_map sub_block[16];
};

struct crb_addr_pair {
	long int addr;
	long int data;
};

struct qla82xx_uri_table_desc {
	uint32_t findex;
	uint32_t num_entries;
	uint32_t entry_size;
	uint32_t reserved[5];
};

struct qla82xx_uri_data_desc {
	uint32_t findex;
	uint32_t size;
	uint32_t reserved[5];
};

struct qla82xx_md_template_hdr {
	uint32_t entry_type;
	uint32_t first_entry_offset;
	uint32_t size_of_template;
	uint32_t capture_debug_level;
	uint32_t num_of_entries;
	uint32_t version;
	uint32_t driver_timestamp;
	uint32_t template_checksum;
	uint32_t driver_capture_mask;
	uint32_t driver_info[3];
	uint32_t saved_state_array[16];
	uint32_t capture_size_array[8];
	uint32_t markers_array[8];
	uint32_t num_of_free_entries;
	uint32_t free_entry_offset;
	uint32_t total_table_size;
	uint32_t bkup_table_offset;
};

struct qla82xx_md_entry_hdr {
	uint32_t entry_type;
	uint32_t entry_size;
	uint32_t entry_capture_size;
	struct {
		uint8_t entry_capture_mask;
		uint8_t entry_code;
		uint8_t driver_code;
		uint8_t driver_flags;
	} d_ctrl;
};

typedef struct qla82xx_md_entry_hdr qla82xx_md_entry_hdr_t;

struct qla82xx_md_entry_crb {
	qla82xx_md_entry_hdr_t h;
	uint32_t addr;
	struct {
		uint8_t addr_stride;
		uint8_t state_index_a;
		uint16_t poll_timeout;
	} crb_strd;
	uint32_t data_size;
	uint32_t op_count;
	struct {
		uint8_t opcode;
		uint8_t state_index_v;
		uint8_t shl;
		uint8_t shr;
	} crb_ctrl;
	uint32_t value_1;
	uint32_t value_2;
	uint32_t value_3;
};

struct qla82xx_md_entry_cache {
	qla82xx_md_entry_hdr_t h;
	uint32_t tag_reg_addr;
	struct {
		uint16_t tag_value_stride;
		uint16_t init_tag_value;
	} addr_ctrl;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t control_addr;
	struct {
		uint16_t write_value;
		uint8_t poll_mask;
		uint8_t poll_wait;
	} cache_ctrl;
	uint32_t read_addr;
	struct {
		uint8_t read_addr_stride;
		uint8_t read_addr_cnt;
		uint16_t rsvd_1;
	} read_ctrl;
};

struct qla82xx_md_entry_rdocm {
	qla82xx_md_entry_hdr_t h;
	uint32_t rsvd_0;
	uint32_t rsvd_1;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t rsvd_2;
	uint32_t rsvd_3;
	uint32_t read_addr;
	uint32_t read_addr_stride;
	uint32_t read_addr_cntrl;
};

struct qla82xx_md_entry_rdmem {
	qla82xx_md_entry_hdr_t h;
	uint32_t rsvd[6];
	uint32_t read_addr;
	uint32_t read_data_size;
};

struct qla82xx_md_entry_rdrom {
	qla82xx_md_entry_hdr_t h;
	uint32_t rsvd[6];
	uint32_t read_addr;
	uint32_t read_data_size;
};

struct qla82xx_md_entry_mux {
	qla82xx_md_entry_hdr_t h;
	uint32_t select_addr;
	uint32_t rsvd_0;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t select_value;
	uint32_t select_value_stride;
	uint32_t read_addr;
	uint32_t rsvd_1;
};

struct qla82xx_md_entry_queue {
	qla82xx_md_entry_hdr_t h;
	uint32_t select_addr;
	struct {
		uint16_t queue_id_stride;
		uint16_t rsvd_0;
	} q_strd;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t rsvd_1;
	uint32_t rsvd_2;
	uint32_t read_addr;
	struct {
		uint8_t read_addr_stride;
		uint8_t read_addr_cnt;
		uint16_t rsvd_3;
	} rd_strd;
};

enum {
	QLA82XX_TEMP_NORMAL = 1,
	QLA82XX_TEMP_WARN = 2,
	QLA82XX_TEMP_PANIC = 3,
};

struct cmd_type_7_fx00 {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint8_t reserved_0;
	uint8_t port_path_ctrl;
	uint16_t reserved_1;
	__le16 tgt_idx;
	uint16_t timeout;
	__le16 dseg_count;
	uint8_t scsi_rsp_dsd_len;
	uint8_t reserved_2;
	struct scsi_lun lun;
	uint8_t cntrl_flags;
	uint8_t task_mgmt_flags;
	uint8_t task;
	uint8_t crn;
	uint8_t fcp_cdb[16];
	__le32 byte_count;
	struct dsd64 dsd;
} __attribute__((packed));

struct sts_entry_fx00 {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint32_t reserved_3;
	__le16 comp_status;
	uint16_t reserved_0;
	__le32 residual_len;
	uint16_t reserved_1;
	uint16_t state_flags;
	uint16_t reserved_2;
	__le16 scsi_status;
	uint32_t sense_len;
	uint8_t data[32];
};

struct multi_sts_entry_fx00 {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t handle_count;
	uint8_t entry_status;
	__le32 handles[15];
};

struct ioctl_iocb_entry_fx00 {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint32_t reserved_0;
	uint16_t comp_func_num;
	__le16 fw_iotcl_flags;
	__le32 dataword_r;
	uint32_t adapid;
	uint32_t dataword_r_extra;
	__le32 seq_no;
	uint8_t reserved_2[20];
	uint32_t residuallen;
	__le32 status;
};

struct qlafx00_tgt_node_info {
	uint8_t tgt_node_wwpn[8];
	uint8_t tgt_node_wwnn[8];
	uint32_t tgt_node_state;
	uint8_t reserved[128];
	uint32_t reserved_1[8];
	uint64_t reserved_2[4];
} __attribute__((packed));

struct port_info_data {
	uint8_t port_state;
	uint8_t port_type;
	uint16_t port_identifier;
	uint32_t up_port_state;
	uint8_t fw_ver_num[32];
	uint8_t portal_attrib;
	uint16_t host_option;
	uint8_t reset_delay;
	uint8_t pdwn_retry_cnt;
	uint16_t max_luns2tgt;
	uint8_t risc_ver;
	uint8_t pconn_option;
	uint16_t risc_option;
	uint16_t max_frame_len;
	uint16_t max_iocb_alloc;
	uint16_t exec_throttle;
	uint8_t retry_cnt;
	uint8_t retry_delay;
	uint8_t port_name[8];
	uint8_t port_id[3];
	uint8_t link_status;
	uint8_t plink_rate;
	uint32_t link_config;
	uint16_t adap_haddr;
	uint8_t tgt_disc;
	uint8_t log_tout;
	uint8_t node_name[8];
	uint16_t erisc_opt1;
	uint8_t resp_acc_tmr;
	uint8_t intr_del_tmr;
	uint8_t erisc_opt2;
	uint8_t alt_port_name[8];
	uint8_t alt_node_name[8];
	uint8_t link_down_tout;
	uint8_t conn_type;
	uint8_t fc_fw_mode;
	uint32_t uiReserved[48];
} __attribute__((packed));

struct host_system_info {
	uint32_t os_type;
	char sysname[128];
	char nodename[64];
	char release[64];
	char version[64];
	char machine[64];
	char domainname[64];
	char hostdriver[64];
	uint32_t reserved[64];
};

struct register_host_info {
	struct host_system_info hsi;
	uint64_t utc;
	uint32_t reserved[64];
} __attribute__((packed));

struct config_info_data {
	uint8_t model_num[16];
	uint8_t model_description[80];
	uint8_t reserved0[160];
	uint8_t symbolic_name[64];
	uint8_t serial_num[32];
	uint8_t hw_version[16];
	uint8_t fw_version[16];
	uint8_t uboot_version[16];
	uint8_t fru_serial_num[32];
	uint8_t fc_port_count;
	uint8_t iscsi_port_count;
	uint8_t reserved1[2];
	uint8_t mode;
	uint8_t log_level;
	uint8_t reserved2[2];
	uint32_t log_size;
	uint8_t tgt_pres_mode;
	uint8_t iqn_flags;
	uint8_t lun_mapping;
	uint64_t adapter_id;
	uint32_t cluster_key_len;
	uint8_t cluster_key[16];
	uint64_t cluster_master_id;
	uint64_t cluster_slave_id;
	uint8_t cluster_flags;
	uint32_t enabled_capabilities;
	uint32_t nominal_temp_value;
} __attribute__((packed));

struct qla_mt_iocb_rsp_fx00 {
	uint32_t reserved_1;
	uint16_t func_type;
	__le16 ioctl_flags;
	__le32 ioctl_data;
	uint32_t adapid;
	uint32_t adapid_hi;
	uint32_t reserved_2;
	__le32 seq_number;
	uint8_t reserved_3[20];
	int32_t res_count;
	__le32 status;
};

struct qla8044_reset_entry_hdr {
	uint16_t cmd;
	uint16_t size;
	uint16_t count;
	uint16_t delay;
};

struct qla8044_poll {
	uint32_t test_mask;
	uint32_t test_value;
};

struct qla8044_rmw {
	uint32_t test_mask;
	uint32_t xor_value;
	uint32_t or_value;
	uint8_t shl;
	uint8_t shr;
	uint8_t index_a;
	uint8_t rsvd;
};

struct qla8044_entry {
	uint32_t arg1;
	uint32_t arg2;
};

struct qla8044_quad_entry {
	uint32_t dr_addr;
	uint32_t dr_value;
	uint32_t ar_addr;
	uint32_t ar_value;
};

struct qla8044_minidump_entry_hdr {
	uint32_t entry_type;
	uint32_t entry_size;
	uint32_t entry_capture_size;
	struct {
		uint8_t entry_capture_mask;
		uint8_t entry_code;
		uint8_t driver_code;
		uint8_t driver_flags;
	} d_ctrl;
};

struct qla8044_minidump_entry_crb {
	struct qla8044_minidump_entry_hdr h;
	uint32_t addr;
	struct {
		uint8_t addr_stride;
		uint8_t state_index_a;
		uint16_t poll_timeout;
	} crb_strd;
	uint32_t data_size;
	uint32_t op_count;
	struct {
		uint8_t opcode;
		uint8_t state_index_v;
		uint8_t shl;
		uint8_t shr;
	} crb_ctrl;
	uint32_t value_1;
	uint32_t value_2;
	uint32_t value_3;
};

struct qla8044_minidump_entry_cache {
	struct qla8044_minidump_entry_hdr h;
	uint32_t tag_reg_addr;
	struct {
		uint16_t tag_value_stride;
		uint16_t init_tag_value;
	} addr_ctrl;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t control_addr;
	struct {
		uint16_t write_value;
		uint8_t poll_mask;
		uint8_t poll_wait;
	} cache_ctrl;
	uint32_t read_addr;
	struct {
		uint8_t read_addr_stride;
		uint8_t read_addr_cnt;
		uint16_t rsvd_1;
	} read_ctrl;
};

struct qla8044_minidump_entry_rdocm {
	struct qla8044_minidump_entry_hdr h;
	uint32_t rsvd_0;
	uint32_t rsvd_1;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t rsvd_2;
	uint32_t rsvd_3;
	uint32_t read_addr;
	uint32_t read_addr_stride;
};

struct qla8044_minidump_entry_rdmem {
	struct qla8044_minidump_entry_hdr h;
	uint32_t rsvd[6];
	uint32_t read_addr;
	uint32_t read_data_size;
};

struct qla8044_minidump_entry_rdmem_pex_dma {
	struct qla8044_minidump_entry_hdr h;
	uint32_t desc_card_addr;
	uint16_t dma_desc_cmd;
	uint8_t rsvd[2];
	uint32_t start_dma_cmd;
	uint8_t rsvd2[12];
	uint32_t read_addr;
	uint32_t read_data_size;
};

struct qla8044_minidump_entry_rdrom {
	struct qla8044_minidump_entry_hdr h;
	uint32_t rsvd[6];
	uint32_t read_addr;
	uint32_t read_data_size;
};

struct qla8044_minidump_entry_mux {
	struct qla8044_minidump_entry_hdr h;
	uint32_t select_addr;
	uint32_t rsvd_0;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t select_value;
	uint32_t select_value_stride;
	uint32_t read_addr;
	uint32_t rsvd_1;
};

struct qla8044_minidump_entry_queue {
	struct qla8044_minidump_entry_hdr h;
	uint32_t select_addr;
	struct {
		uint16_t queue_id_stride;
		uint16_t rsvd_0;
	} q_strd;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t rsvd_1;
	uint32_t rsvd_2;
	uint32_t read_addr;
	struct {
		uint8_t read_addr_stride;
		uint8_t read_addr_cnt;
		uint16_t rsvd_3;
	} rd_strd;
};

struct qla8044_minidump_entry_pollrd {
	struct qla8044_minidump_entry_hdr h;
	uint32_t select_addr;
	uint32_t read_addr;
	uint32_t select_value;
	uint16_t select_value_stride;
	uint16_t op_count;
	uint32_t poll_wait;
	uint32_t poll_mask;
	uint32_t data_size;
	uint32_t rsvd_1;
};

struct qla8044_minidump_entry_rddfe {
	struct qla8044_minidump_entry_hdr h;
	uint32_t addr_1;
	uint32_t value;
	uint8_t stride;
	uint8_t stride2;
	uint16_t count;
	uint32_t poll;
	uint32_t mask;
	uint32_t modify_mask;
	uint32_t data_size;
	uint32_t rsvd;
};

struct qla8044_minidump_entry_rdmdio {
	struct qla8044_minidump_entry_hdr h;
	uint32_t addr_1;
	uint32_t addr_2;
	uint32_t value_1;
	uint8_t stride_1;
	uint8_t stride_2;
	uint16_t count;
	uint32_t poll;
	uint32_t mask;
	uint32_t value_2;
	uint32_t data_size;
};

struct qla8044_minidump_entry_pollwr {
	struct qla8044_minidump_entry_hdr h;
	uint32_t addr_1;
	uint32_t addr_2;
	uint32_t value_1;
	uint32_t value_2;
	uint32_t poll;
	uint32_t mask;
	uint32_t data_size;
	uint32_t rsvd;
};

struct qla8044_minidump_entry_rdmux2 {
	struct qla8044_minidump_entry_hdr h;
	uint32_t select_addr_1;
	uint32_t select_addr_2;
	uint32_t select_value_1;
	uint32_t select_value_2;
	uint32_t op_count;
	uint32_t select_value_mask;
	uint32_t read_addr;
	uint8_t select_value_stride;
	uint8_t data_size;
	uint8_t rsvd[2];
};

struct qla8044_minidump_entry_pollrdmwr {
	struct qla8044_minidump_entry_hdr h;
	uint32_t addr_1;
	uint32_t addr_2;
	uint32_t value_1;
	uint32_t value_2;
	uint32_t poll_wait;
	uint32_t poll_mask;
	uint32_t modify_mask;
	uint32_t data_size;
};

struct qla8044_minidump_template_hdr {
	uint32_t entry_type;
	uint32_t first_entry_offset;
	uint32_t size_of_template;
	uint32_t capture_debug_level;
	uint32_t num_of_entries;
	uint32_t version;
	uint32_t driver_timestamp;
	uint32_t checksum;
	uint32_t driver_capture_mask;
	uint32_t driver_info_word2;
	uint32_t driver_info_word3;
	uint32_t driver_info_word4;
	uint32_t saved_state_array[16];
	uint32_t capture_size_array[8];
	uint32_t ocm_window_reg[16];
};

struct qla8044_pex_dma_descriptor {
	struct {
		uint32_t read_data_size;
		uint8_t rsvd[2];
		uint16_t dma_desc_cmd;
	} cmd;
	uint64_t src_addr;
	uint64_t dma_bus_addr;
	uint8_t rsvd[24];
};

enum se_cmd_flags_table {
	SCF_SUPPORTED_SAM_OPCODE = 1,
	SCF_TRANSPORT_TASK_SENSE = 2,
	SCF_EMULATED_TASK_SENSE = 4,
	SCF_SCSI_DATA_CDB = 8,
	SCF_SCSI_TMR_CDB = 16,
	SCF_FUA = 128,
	SCF_SE_LUN_CMD = 256,
	SCF_BIDI = 1024,
	SCF_SENT_CHECK_CONDITION = 2048,
	SCF_OVERFLOW_BIT = 4096,
	SCF_UNDERFLOW_BIT = 8192,
	SCF_ALUA_NON_OPTIMIZED = 32768,
	SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC = 131072,
	SCF_COMPARE_AND_WRITE = 524288,
	SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC = 2097152,
	SCF_ACK_KREF = 4194304,
	SCF_USE_CPUID = 8388608,
	SCF_TASK_ATTR_SET = 16777216,
	SCF_TREAT_READ_AS_NORMAL = 33554432,
};

struct se_tpg_np {
	struct se_portal_group *tpg_np_parent;
	struct config_group tpg_np_group;
};

struct btree_geo;

struct ctio_to_2xxx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	target_id_t target;
	uint16_t rx_id;
	uint16_t flags;
	uint16_t status;
	uint16_t timeout;
	uint16_t dseg_count;
	uint32_t relative_offset;
	uint32_t residual;
	uint16_t reserved_1[3];
	uint16_t scsi_status;
	uint32_t transfer_length;
	struct dsd32 dsd[3];
};

struct ctio7_to_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t nport_handle;
	uint16_t timeout;
	uint16_t dseg_count;
	uint8_t vp_index;
	uint8_t add_flags;
	le_id_t initiator_id;
	uint8_t reserved;
	uint32_t exchange_addr;
	union {
		struct {
			uint16_t reserved1;
			__le16 flags;
			uint32_t residual;
			__le16 ox_id;
			uint16_t scsi_status;
			uint32_t relative_offset;
			uint32_t reserved2;
			uint32_t transfer_length;
			uint32_t reserved3;
			struct dsd64 dsd;
		} __attribute__((packed)) status0;
		struct {
			uint16_t sense_length;
			__le16 flags;
			uint32_t residual;
			__le16 ox_id;
			uint16_t scsi_status;
			uint16_t response_len;
			uint16_t reserved;
			uint8_t sense_data[24];
		} status1;
	} u;
};

struct ctio7_from_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t status;
	uint16_t timeout;
	uint16_t dseg_count;
	uint8_t vp_index;
	uint8_t reserved1[5];
	uint32_t exchange_address;
	uint16_t reserved2;
	uint16_t flags;
	uint32_t residual;
	uint16_t ox_id;
	uint16_t reserved3;
	uint32_t relative_offset;
	uint8_t reserved4[24];
};

struct ctio_crc2_to_fw {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t nport_handle;
	__le16 timeout;
	uint16_t dseg_count;
	uint8_t vp_index;
	uint8_t add_flags;
	le_id_t initiator_id;
	uint8_t reserved1;
	uint32_t exchange_addr;
	uint16_t reserved2;
	__le16 flags;
	uint32_t residual;
	__le16 ox_id;
	uint16_t scsi_status;
	__le32 relative_offset;
	uint32_t reserved5;
	__le32 transfer_length;
	uint32_t reserved6;
	__le64 crc_context_address;
	uint16_t crc_context_len;
	uint16_t reserved_1;
} __attribute__((packed));

struct ctio_crc_from_fw {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t status;
	uint16_t timeout;
	uint16_t dseg_count;
	uint32_t reserved1;
	uint16_t state_flags;
	uint32_t exchange_address;
	uint16_t reserved2;
	uint16_t flags;
	uint32_t resid_xfer_length;
	uint16_t ox_id;
	uint8_t reserved3[12];
	uint16_t runt_guard;
	uint8_t actual_dif[8];
	uint8_t expected_dif[8];
} __attribute__((packed));

struct ba_acc_le {
	uint16_t reserved;
	uint8_t seq_id_last;
	uint8_t seq_id_valid;
	uint16_t rx_id;
	uint16_t ox_id;
	uint16_t high_seq_cnt;
	uint16_t low_seq_cnt;
};

struct ba_rjt_le {
	uint8_t vendor_uniq;
	uint8_t reason_expl;
	uint8_t reason_code;
	uint8_t reserved;
};

struct abts_resp_to_24xx {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t reserved_1;
	uint16_t nport_handle;
	uint16_t control_flags;
	uint8_t vp_index;
	uint8_t reserved_3: 4;
	uint8_t sof_type: 4;
	uint32_t exchange_address;
	struct fcp_hdr_le fcp_hdr_le;
	union {
		struct ba_acc_le ba_acct;
		struct ba_rjt_le ba_rjt;
	} payload;
	uint32_t reserved_4;
	uint32_t exchange_addr_to_abort;
};

struct abts_resp_from_24xx_fw {
	uint8_t entry_type;
	uint8_t entry_count;
	uint8_t sys_define;
	uint8_t entry_status;
	uint32_t handle;
	uint16_t compl_status;
	uint16_t nport_handle;
	uint16_t reserved_1;
	uint8_t reserved_2;
	uint8_t reserved_3: 4;
	uint8_t sof_type: 4;
	uint32_t exchange_address;
	struct fcp_hdr_le fcp_hdr_le;
	uint8_t reserved_4[8];
	uint32_t error_subcode1;
	uint32_t error_subcode2;
	uint32_t exchange_addr_to_abort;
};

struct qla_tgt_sess_op {
	struct scsi_qla_host *vha;
	uint32_t chip_reset;
	struct atio_from_isp atio;
	int: 32;
	struct work_struct work;
	struct list_head cmd_list;
	bool aborted;
	long: 56;
	struct rsp_que *rsp;
} __attribute__((packed));

struct qla_tgt_sess_work_param {
	struct list_head sess_works_list_entry;
	int type;
	union {
		struct abts_recv_from_24xx abts;
		struct imm_ntfy_from_isp tm_iocb;
		struct atio_from_isp tm_iocb2;
	};
	int: 32;
} __attribute__((packed));

struct qla_tgt_prm {
	struct qla_tgt_cmd *cmd;
	struct qla_tgt *tgt;
	void *pkt;
	struct scatterlist *sg;
	unsigned char *sense_buffer;
	int seg_cnt;
	int req_cnt;
	uint16_t rq_result;
	int sense_buffer_len;
	int residual;
	int add_status_pkt;
	struct scatterlist *prot_sg;
	uint16_t prot_seg_cnt;
	uint16_t tot_dsds;
};

typedef struct {
	port_id_t id;
	int cmd_count;
	struct list_head list;
} qlt_port_logo_t;

struct qla27xx_fwdt_template {
	__le32 template_type;
	__le32 entry_offset;
	__le32 template_size;
	uint32_t count;
	__le32 entry_count;
	uint32_t template_version;
	uint32_t capture_timestamp;
	uint32_t template_checksum;
	uint32_t reserved_2;
	uint32_t driver_info[3];
	uint32_t saved_state[16];
	uint32_t reserved_3[8];
	uint32_t firmware_version[5];
};

struct qla27xx_fwdt_entry {
	struct {
		__le32 type;
		__le32 size;
		uint32_t reserved_1;
		uint8_t capture_flags;
		uint8_t reserved_2[2];
		uint8_t driver_flags;
	} hdr;
	union {
		struct {		} t0;
		struct {		} t255;
		struct {
			__le32 base_addr;
			uint8_t reg_width;
			__le16 reg_count;
			uint8_t pci_offset;
		} __attribute__((packed)) t256;
		struct {
			__le32 base_addr;
			__le32 write_data;
			uint8_t pci_offset;
			uint8_t reserved[3];
		} t257;
		struct {
			__le32 base_addr;
			uint8_t reg_width;
			__le16 reg_count;
			uint8_t pci_offset;
			uint8_t banksel_offset;
			uint8_t reserved[3];
			__le32 bank;
		} __attribute__((packed)) t258;
		struct {
			__le32 base_addr;
			__le32 write_data;
			uint8_t reserved[2];
			uint8_t pci_offset;
			uint8_t banksel_offset;
			__le32 bank;
		} t259;
		struct {
			uint8_t pci_offset;
			uint8_t reserved[3];
		} t260;
		struct {
			uint8_t pci_offset;
			uint8_t reserved[3];
			__le32 write_data;
		} t261;
		struct {
			uint8_t ram_area;
			uint8_t reserved[3];
			__le32 start_addr;
			__le32 end_addr;
		} t262;
		struct {
			uint32_t num_queues;
			uint8_t queue_type;
			uint8_t reserved[3];
		} t263;
		struct {
			uint32_t fce_trace_size;
			uint64_t write_pointer;
			uint64_t base_pointer;
			uint32_t fce_enable_mb0;
			uint32_t fce_enable_mb2;
			uint32_t fce_enable_mb3;
			uint32_t fce_enable_mb4;
			uint32_t fce_enable_mb5;
			uint32_t fce_enable_mb6;
		} __attribute__((packed)) t264;
		struct {		} t265;
		struct {		} t266;
		struct {
			uint8_t pci_offset;
			uint8_t reserved[3];
			__le32 data;
		} t267;
		struct {
			uint8_t buf_type;
			uint8_t reserved[3];
			uint32_t buf_size;
			uint64_t start_addr;
		} t268;
		struct {
			uint32_t scratch_size;
		} t269;
		struct {
			__le32 addr;
			__le32 count;
		} t270;
		struct {
			__le32 addr;
			__le32 data;
		} t271;
		struct {
			__le32 addr;
			__le32 count;
		} t272;
		struct {
			__le32 addr;
			__le32 count;
		} t273;
		struct {
			uint32_t num_queues;
			uint8_t queue_type;
			uint8_t reserved[3];
		} t274;
		struct {
			__le32 length;
			uint8_t buffer[0];
		} t275;
		struct {
			__le32 cond1;
			__le32 cond2;
		} t276;
		struct {
			__le32 cmd_addr;
			__le32 wr_cmd_data;
			__le32 data_addr;
		} t277;
		struct {
			__le32 cmd_addr;
			__le32 wr_cmd_data;
			__le32 data_addr;
			__le32 wr_data;
		} t278;
	};
} __attribute__((packed));

struct nvme_fc_port_info {
	u64 node_name;
	u64 port_name;
	u32 port_role;
	u32 port_id;
	u32 dev_loss_tmo;
};

struct nvmefc_ls_req {
	void *rqstaddr;
	dma_addr_t rqstdma;
	u32 rqstlen;
	void *rspaddr;
	dma_addr_t rspdma;
	u32 rsplen;
	u32 timeout;
	void *private;
	void (*done)(struct nvmefc_ls_req *, int);
};

struct nvme_fc_port_template {
	void (*localport_delete)(struct nvme_fc_local_port *);
	void (*remoteport_delete)(struct nvme_fc_remote_port *);
	int (*create_queue)(struct nvme_fc_local_port *, unsigned int, u16, void **);
	void (*delete_queue)(struct nvme_fc_local_port *, unsigned int, void *);
	int (*ls_req)(struct nvme_fc_local_port *, struct nvme_fc_remote_port *, struct nvmefc_ls_req *);
	int (*fcp_io)(struct nvme_fc_local_port *, struct nvme_fc_remote_port *, void *, struct nvmefc_fcp_req *);
	void (*ls_abort)(struct nvme_fc_local_port *, struct nvme_fc_remote_port *, struct nvmefc_ls_req *);
	void (*fcp_abort)(struct nvme_fc_local_port *, struct nvme_fc_remote_port *, void *, struct nvmefc_fcp_req *);
	u32 max_hw_queues;
	u16 max_sgl_segments;
	u16 max_dif_sgl_segments;
	u64 dma_boundary;
	u32 local_priv_sz;
	u32 remote_priv_sz;
	u32 lsrqst_priv_sz;
	u32 fcprqst_priv_sz;
};

struct qla_nvme_rport {
	struct fc_port *fcport;
};

struct iscsi_param_info {
	uint32_t len;
	uint16_t param;
	uint8_t value[0];
} __attribute__((packed));

struct iscsi_iface_param_info {
	uint32_t iface_num;
	uint32_t len;
	uint16_t param;
	uint8_t iface_type;
	uint8_t param_type;
	uint8_t value[0];
};

struct iscsi_flashnode_param_info {
	uint32_t len;
	uint16_t param;
	uint8_t value[0];
} __attribute__((packed));

enum iscsi_chap_param {
	ISCSI_CHAP_PARAM_INDEX = 0,
	ISCSI_CHAP_PARAM_CHAP_TYPE = 1,
	ISCSI_CHAP_PARAM_USERNAME = 2,
	ISCSI_CHAP_PARAM_PASSWORD = 3,
	ISCSI_CHAP_PARAM_PASSWORD_LEN = 4,
};

struct iscsi_host_stats_custom {
	char desc[64];
	uint64_t value;
};

struct iscsi_offload_host_stats {
	uint64_t mactx_frames;
	uint64_t mactx_bytes;
	uint64_t mactx_multicast_frames;
	uint64_t mactx_broadcast_frames;
	uint64_t mactx_pause_frames;
	uint64_t mactx_control_frames;
	uint64_t mactx_deferral;
	uint64_t mactx_excess_deferral;
	uint64_t mactx_late_collision;
	uint64_t mactx_abort;
	uint64_t mactx_single_collision;
	uint64_t mactx_multiple_collision;
	uint64_t mactx_collision;
	uint64_t mactx_frames_dropped;
	uint64_t mactx_jumbo_frames;
	uint64_t macrx_frames;
	uint64_t macrx_bytes;
	uint64_t macrx_unknown_control_frames;
	uint64_t macrx_pause_frames;
	uint64_t macrx_control_frames;
	uint64_t macrx_dribble;
	uint64_t macrx_frame_length_error;
	uint64_t macrx_jabber;
	uint64_t macrx_carrier_sense_error;
	uint64_t macrx_frame_discarded;
	uint64_t macrx_frames_dropped;
	uint64_t mac_crc_error;
	uint64_t mac_encoding_error;
	uint64_t macrx_length_error_large;
	uint64_t macrx_length_error_small;
	uint64_t macrx_multicast_frames;
	uint64_t macrx_broadcast_frames;
	uint64_t iptx_packets;
	uint64_t iptx_bytes;
	uint64_t iptx_fragments;
	uint64_t iprx_packets;
	uint64_t iprx_bytes;
	uint64_t iprx_fragments;
	uint64_t ip_datagram_reassembly;
	uint64_t ip_invalid_address_error;
	uint64_t ip_error_packets;
	uint64_t ip_fragrx_overlap;
	uint64_t ip_fragrx_outoforder;
	uint64_t ip_datagram_reassembly_timeout;
	uint64_t ipv6tx_packets;
	uint64_t ipv6tx_bytes;
	uint64_t ipv6tx_fragments;
	uint64_t ipv6rx_packets;
	uint64_t ipv6rx_bytes;
	uint64_t ipv6rx_fragments;
	uint64_t ipv6_datagram_reassembly;
	uint64_t ipv6_invalid_address_error;
	uint64_t ipv6_error_packets;
	uint64_t ipv6_fragrx_overlap;
	uint64_t ipv6_fragrx_outoforder;
	uint64_t ipv6_datagram_reassembly_timeout;
	uint64_t tcptx_segments;
	uint64_t tcptx_bytes;
	uint64_t tcprx_segments;
	uint64_t tcprx_byte;
	uint64_t tcp_duplicate_ack_retx;
	uint64_t tcp_retx_timer_expired;
	uint64_t tcprx_duplicate_ack;
	uint64_t tcprx_pure_ackr;
	uint64_t tcptx_delayed_ack;
	uint64_t tcptx_pure_ack;
	uint64_t tcprx_segment_error;
	uint64_t tcprx_segment_outoforder;
	uint64_t tcprx_window_probe;
	uint64_t tcprx_window_update;
	uint64_t tcptx_window_probe_persist;
	uint64_t ecc_error_correction;
	uint64_t iscsi_pdu_tx;
	uint64_t iscsi_data_bytes_tx;
	uint64_t iscsi_pdu_rx;
	uint64_t iscsi_data_bytes_rx;
	uint64_t iscsi_io_completed;
	uint64_t iscsi_unexpected_io_rx;
	uint64_t iscsi_format_error;
	uint64_t iscsi_hdr_digest_error;
	uint64_t iscsi_data_digest_error;
	uint64_t iscsi_sequence_error;
	uint32_t custom_length;
	struct iscsi_host_stats_custom custom[0];
};

enum qla_regs___2 {
	QLA8XXX_PEG_HALT_STATUS1 = 0,
	QLA8XXX_PEG_HALT_STATUS2 = 1,
	QLA8XXX_PEG_ALIVE_COUNTER = 2,
	QLA8XXX_CRB_DRV_ACTIVE = 3,
	QLA8XXX_CRB_DEV_STATE = 4,
	QLA8XXX_CRB_DRV_STATE = 5,
	QLA8XXX_CRB_DRV_SCRATCH = 6,
	QLA8XXX_CRB_DEV_PART_INFO = 7,
	QLA8XXX_CRB_DRV_IDC_VERSION = 8,
	QLA8XXX_FW_VERSION_MAJOR = 9,
	QLA8XXX_FW_VERSION_MINOR = 10,
	QLA8XXX_FW_VERSION_SUB = 11,
	QLA8XXX_CRB_CMDPEG_STATE = 12,
	QLA8XXX_CRB_TEMP_STATE = 13,
};

struct port_ctrl_stat_regs {
	__le32 ext_hw_conf;
	__le32 rsrvd0;
	__le32 port_ctrl;
	__le32 port_status;
	__le32 rsrvd1[32];
	__le32 gp_out;
	__le32 gp_in;
	__le32 rsrvd2[5];
	__le32 port_err_status;
};

struct host_mem_cfg_regs {
	__le32 rsrvd0[12];
	__le32 req_q_out;
	__le32 rsrvd1[31];
};

struct device_reg_82xx___2 {
	__le32 req_q_out;
	__le32 reserve1[63];
	__le32 rsp_q_in;
	__le32 reserve2[63];
	__le32 rsp_q_out;
	__le32 reserve3[63];
	__le32 mailbox_in[8];
	__le32 reserve4[24];
	__le32 hint;
	__le32 reserve5[31];
	__le32 mailbox_out[8];
	__le32 reserve6[56];
	__le32 host_status;
	__le32 host_int;
};

struct device_reg_83xx {
	__le32 mailbox_in[16];
	__le32 reserve1[496];
	__le32 mailbox_out[16];
	__le32 reserve2[496];
	__le32 mbox_int;
	__le32 reserve3[63];
	__le32 req_q_out;
	__le32 reserve4[63];
	__le32 rsp_q_in;
	__le32 reserve5[1919];
	__le32 req_q_in;
	__le32 reserve6[3];
	__le32 iocb_int_mask;
	__le32 reserve7[3];
	__le32 rsp_q_out;
	__le32 reserve8[3];
	__le32 anonymousbuff;
	__le32 mb_int_mask;
	__le32 host_intr;
	__le32 risc_intr;
	__le32 reserve9[544];
	__le32 leg_int_ptr;
	__le32 leg_int_trig;
	__le32 leg_int_mask;
};

struct isp_reg {
	__le32 mailbox[8];
	__le32 flash_address;
	__le32 flash_data;
	__le32 ctrl_status;
	union {
		struct {
			__le32 nvram;
			__le32 reserved1[2];
		} isp4010;
		struct {
			__le32 intr_mask;
			__le32 nvram;
			__le32 semaphore;
		} isp4022;
	} u1;
	__le32 req_q_in;
	__le32 rsp_q_out;
	__le32 reserved2[4];
	union {
		struct {
			__le32 ext_hw_conf;
			__le32 flow_ctrl;
			__le32 port_ctrl;
			__le32 port_status;
			__le32 reserved3[8];
			__le32 req_q_out;
			__le32 reserved4[23];
			__le32 gp_out;
			__le32 gp_in;
			__le32 reserved5[5];
			__le32 port_err_status;
		} isp4010;
		struct {
			union {
				struct port_ctrl_stat_regs p0;
				struct host_mem_cfg_regs p1;
			};
		} isp4022;
	} u2;
};

struct shadow_regs {
	__le32 req_q_out;
	__le32 rsp_q_in;
};

struct addr_ctrl_blk {
	uint8_t version;
	uint8_t control;
	uint16_t fw_options;
	uint16_t exec_throttle;
	uint8_t zio_count;
	uint8_t res0;
	uint16_t eth_mtu_size;
	uint16_t add_fw_options;
	uint8_t hb_interval;
	uint8_t inst_num;
	uint16_t res1;
	uint16_t rqq_consumer_idx;
	uint16_t compq_producer_idx;
	uint16_t rqq_len;
	uint16_t compq_len;
	uint32_t rqq_addr_lo;
	uint32_t rqq_addr_hi;
	uint32_t compq_addr_lo;
	uint32_t compq_addr_hi;
	uint32_t shdwreg_addr_lo;
	uint32_t shdwreg_addr_hi;
	uint16_t iscsi_opts;
	uint16_t ipv4_tcp_opts;
	uint16_t ipv4_ip_opts;
	uint16_t iscsi_max_pdu_size;
	uint8_t ipv4_tos;
	uint8_t ipv4_ttl;
	uint8_t acb_version;
	uint8_t res2;
	uint16_t def_timeout;
	uint16_t iscsi_fburst_len;
	uint16_t iscsi_def_time2wait;
	uint16_t iscsi_def_time2retain;
	uint16_t iscsi_max_outstnd_r2t;
	uint16_t conn_ka_timeout;
	uint16_t ipv4_port;
	uint16_t iscsi_max_burst_len;
	uint32_t res5;
	uint8_t ipv4_addr[4];
	uint16_t ipv4_vlan_tag;
	uint8_t ipv4_addr_state;
	uint8_t ipv4_cacheid;
	uint8_t res6[8];
	uint8_t ipv4_subnet[4];
	uint8_t res7[12];
	uint8_t ipv4_gw_addr[4];
	uint8_t res8[12];
	uint8_t pri_dns_srvr_ip[4];
	uint8_t sec_dns_srvr_ip[4];
	uint16_t min_eph_port;
	uint16_t max_eph_port;
	uint8_t res9[4];
	uint8_t iscsi_alias[32];
	uint8_t res9_1[22];
	uint16_t tgt_portal_grp;
	uint8_t abort_timer;
	uint8_t ipv4_tcp_wsf;
	uint8_t res10[6];
	uint8_t ipv4_sec_ip_addr[4];
	uint8_t ipv4_dhcp_vid_len;
	uint8_t ipv4_dhcp_vid[11];
	uint8_t res11[20];
	uint8_t ipv4_dhcp_alt_cid_len;
	uint8_t ipv4_dhcp_alt_cid[11];
	uint8_t iscsi_name[224];
	uint8_t res12[32];
	uint32_t cookie;
	uint16_t ipv6_port;
	uint16_t ipv6_opts;
	uint16_t ipv6_addtl_opts;
	uint16_t ipv6_tcp_opts;
	uint8_t ipv6_tcp_wsf;
	uint16_t ipv6_flow_lbl;
	uint8_t ipv6_dflt_rtr_addr[16];
	uint16_t ipv6_vlan_tag;
	uint8_t ipv6_lnk_lcl_addr_state;
	uint8_t ipv6_addr0_state;
	uint8_t ipv6_addr1_state;
	uint8_t ipv6_dflt_rtr_state;
	uint8_t ipv6_traffic_class;
	uint8_t ipv6_hop_limit;
	uint8_t ipv6_if_id[8];
	uint8_t ipv6_addr0[16];
	uint8_t ipv6_addr1[16];
	uint32_t ipv6_nd_reach_time;
	uint32_t ipv6_nd_rexmit_timer;
	uint32_t ipv6_nd_stale_timeout;
	uint8_t ipv6_dup_addr_detect_count;
	uint8_t ipv6_cache_id;
	uint8_t res13[18];
	uint32_t ipv6_gw_advrt_mtu;
	uint8_t res14[140];
};

struct addr_ctrl_blk_def {
	uint8_t reserved1[1];
	uint8_t control;
	uint8_t reserved2[11];
	uint8_t inst_num;
	uint8_t reserved3[34];
	uint16_t iscsi_opts;
	uint16_t ipv4_tcp_opts;
	uint16_t ipv4_ip_opts;
	uint16_t iscsi_max_pdu_size;
	uint8_t ipv4_tos;
	uint8_t ipv4_ttl;
	uint8_t reserved4[2];
	uint16_t def_timeout;
	uint16_t iscsi_fburst_len;
	uint8_t reserved5[4];
	uint16_t iscsi_max_outstnd_r2t;
	uint8_t reserved6[2];
	uint16_t ipv4_port;
	uint16_t iscsi_max_burst_len;
	uint8_t reserved7[4];
	uint8_t ipv4_addr[4];
	uint16_t ipv4_vlan_tag;
	uint8_t ipv4_addr_state;
	uint8_t ipv4_cacheid;
	uint8_t reserved8[8];
	uint8_t ipv4_subnet[4];
	uint8_t reserved9[12];
	uint8_t ipv4_gw_addr[4];
	uint8_t reserved10[84];
	uint8_t abort_timer;
	uint8_t ipv4_tcp_wsf;
	uint8_t reserved11[10];
	uint8_t ipv4_dhcp_vid_len;
	uint8_t ipv4_dhcp_vid[11];
	uint8_t reserved12[20];
	uint8_t ipv4_dhcp_alt_cid_len;
	uint8_t ipv4_dhcp_alt_cid[11];
	uint8_t iscsi_name[224];
	uint8_t reserved13[32];
	uint32_t cookie;
	uint16_t ipv6_port;
	uint16_t ipv6_opts;
	uint16_t ipv6_addtl_opts;
	uint16_t ipv6_tcp_opts;
	uint8_t ipv6_tcp_wsf;
	uint16_t ipv6_flow_lbl;
	uint8_t ipv6_dflt_rtr_addr[16];
	uint16_t ipv6_vlan_tag;
	uint8_t ipv6_lnk_lcl_addr_state;
	uint8_t ipv6_addr0_state;
	uint8_t ipv6_addr1_state;
	uint8_t ipv6_dflt_rtr_state;
	uint8_t ipv6_traffic_class;
	uint8_t ipv6_hop_limit;
	uint8_t ipv6_if_id[8];
	uint8_t ipv6_addr0[16];
	uint8_t ipv6_addr1[16];
	uint32_t ipv6_nd_reach_time;
	uint32_t ipv6_nd_rexmit_timer;
	uint32_t ipv6_nd_stale_timeout;
	uint8_t ipv6_dup_addr_detect_count;
	uint8_t ipv6_cache_id;
	uint8_t reserved14[18];
	uint32_t ipv6_gw_advrt_mtu;
	uint8_t reserved15[140];
};

struct ql4_chap_table {
	uint16_t link;
	uint8_t flags;
	uint8_t secret_len;
	uint8_t secret[100];
	uint8_t name[256];
	uint16_t reserved;
	uint16_t cookie;
};

struct dev_db_entry {
	uint16_t options;
	uint16_t exec_throttle;
	uint16_t exec_count;
	uint16_t res0;
	uint16_t iscsi_options;
	uint16_t tcp_options;
	uint16_t ip_options;
	uint16_t iscsi_max_rcv_data_seg_len;
	uint32_t res1;
	uint16_t iscsi_max_snd_data_seg_len;
	uint16_t iscsi_first_burst_len;
	uint16_t iscsi_def_time2wait;
	uint16_t iscsi_def_time2retain;
	uint16_t iscsi_max_outsnd_r2t;
	uint16_t ka_timeout;
	uint8_t isid[6];
	uint16_t tsid;
	uint16_t port;
	uint16_t iscsi_max_burst_len;
	uint16_t def_timeout;
	uint16_t res2;
	uint8_t ip_addr[16];
	uint8_t iscsi_alias[32];
	uint8_t tgt_addr[32];
	uint16_t mss;
	uint16_t res3;
	uint16_t lcl_port;
	uint8_t ipv4_tos;
	uint16_t ipv6_flow_lbl;
	uint8_t res4[54];
	uint8_t iscsi_name[224];
	uint8_t link_local_ipv6_addr[16];
	uint8_t res5[16];
	uint16_t ddb_link;
	uint16_t chap_tbl_idx;
	uint16_t tgt_portal_grp;
	uint8_t tcp_xmt_wsf;
	uint8_t tcp_rcv_wsf;
	uint32_t stat_sn;
	uint32_t exp_stat_sn;
	uint8_t res6[43];
	uint16_t cookie;
	uint16_t len;
};

struct about_fw_info {
	uint16_t fw_major;
	uint16_t fw_minor;
	uint16_t fw_patch;
	uint16_t fw_build;
	uint8_t fw_build_date[16];
	uint8_t fw_build_time[16];
	uint8_t fw_build_user[16];
	uint16_t fw_load_source;
	uint8_t reserved1[6];
	uint16_t iscsi_major;
	uint16_t iscsi_minor;
	uint16_t bootload_major;
	uint16_t bootload_minor;
	uint16_t bootload_patch;
	uint16_t bootload_build;
	uint8_t extended_timestamp[180];
};

struct qla4_header {
	uint8_t entryType;
	uint8_t entryStatus;
	uint8_t systemDefined;
	uint8_t entryCount;
};

struct queue_entry {
	uint8_t data[60];
	uint32_t signature;
};

struct passthru_status {
	struct qla4_header hdr;
	uint32_t handle;
	uint16_t target;
	uint16_t connectionID;
	uint8_t completionStatus;
	uint8_t residualFlags;
	uint16_t timeout;
	uint16_t portNumber;
	uint8_t res1[10];
	uint32_t outResidual;
	uint8_t res2[12];
	uint32_t inResidual;
	uint8_t res4[16];
};

struct mbox_cmd_iocb {
	struct qla4_header hdr;
	uint32_t handle;
	uint32_t in_mbox[8];
	uint32_t res1[6];
};

struct ql_iscsi_stats {
	uint64_t mac_tx_frames;
	uint64_t mac_tx_bytes;
	uint64_t mac_tx_multicast_frames;
	uint64_t mac_tx_broadcast_frames;
	uint64_t mac_tx_pause_frames;
	uint64_t mac_tx_control_frames;
	uint64_t mac_tx_deferral;
	uint64_t mac_tx_excess_deferral;
	uint64_t mac_tx_late_collision;
	uint64_t mac_tx_abort;
	uint64_t mac_tx_single_collision;
	uint64_t mac_tx_multiple_collision;
	uint64_t mac_tx_collision;
	uint64_t mac_tx_frames_dropped;
	uint64_t mac_tx_jumbo_frames;
	uint64_t mac_rx_frames;
	uint64_t mac_rx_bytes;
	uint64_t mac_rx_unknown_control_frames;
	uint64_t mac_rx_pause_frames;
	uint64_t mac_rx_control_frames;
	uint64_t mac_rx_dribble;
	uint64_t mac_rx_frame_length_error;
	uint64_t mac_rx_jabber;
	uint64_t mac_rx_carrier_sense_error;
	uint64_t mac_rx_frame_discarded;
	uint64_t mac_rx_frames_dropped;
	uint64_t mac_crc_error;
	uint64_t mac_encoding_error;
	uint64_t mac_rx_length_error_large;
	uint64_t mac_rx_length_error_small;
	uint64_t mac_rx_multicast_frames;
	uint64_t mac_rx_broadcast_frames;
	uint64_t ip_tx_packets;
	uint64_t ip_tx_bytes;
	uint64_t ip_tx_fragments;
	uint64_t ip_rx_packets;
	uint64_t ip_rx_bytes;
	uint64_t ip_rx_fragments;
	uint64_t ip_datagram_reassembly;
	uint64_t ip_invalid_address_error;
	uint64_t ip_error_packets;
	uint64_t ip_fragrx_overlap;
	uint64_t ip_fragrx_outoforder;
	uint64_t ip_datagram_reassembly_timeout;
	uint64_t ipv6_tx_packets;
	uint64_t ipv6_tx_bytes;
	uint64_t ipv6_tx_fragments;
	uint64_t ipv6_rx_packets;
	uint64_t ipv6_rx_bytes;
	uint64_t ipv6_rx_fragments;
	uint64_t ipv6_datagram_reassembly;
	uint64_t ipv6_invalid_address_error;
	uint64_t ipv6_error_packets;
	uint64_t ipv6_fragrx_overlap;
	uint64_t ipv6_fragrx_outoforder;
	uint64_t ipv6_datagram_reassembly_timeout;
	uint64_t tcp_tx_segments;
	uint64_t tcp_tx_bytes;
	uint64_t tcp_rx_segments;
	uint64_t tcp_rx_byte;
	uint64_t tcp_duplicate_ack_retx;
	uint64_t tcp_retx_timer_expired;
	uint64_t tcp_rx_duplicate_ack;
	uint64_t tcp_rx_pure_ackr;
	uint64_t tcp_tx_delayed_ack;
	uint64_t tcp_tx_pure_ack;
	uint64_t tcp_rx_segment_error;
	uint64_t tcp_rx_segment_outoforder;
	uint64_t tcp_rx_window_probe;
	uint64_t tcp_rx_window_update;
	uint64_t tcp_tx_window_probe_persist;
	uint64_t ecc_error_correction;
	uint64_t iscsi_pdu_tx;
	uint64_t iscsi_data_bytes_tx;
	uint64_t iscsi_pdu_rx;
	uint64_t iscsi_data_bytes_rx;
	uint64_t iscsi_io_completed;
	uint64_t iscsi_unexpected_io_rx;
	uint64_t iscsi_format_error;
	uint64_t iscsi_hdr_digest_error;
	uint64_t iscsi_data_digest_error;
	uint64_t iscsi_sequence_error;
	uint32_t tx_cmd_pdu;
	uint32_t tx_resp_pdu;
	uint32_t rx_cmd_pdu;
	uint32_t rx_resp_pdu;
	uint64_t tx_data_octets;
	uint64_t rx_data_octets;
	uint32_t hdr_digest_err;
	uint32_t data_digest_err;
	uint32_t conn_timeout_err;
	uint32_t framing_err;
	uint32_t tx_nopout_pdus;
	uint32_t tx_scsi_cmd_pdus;
	uint32_t tx_tmf_cmd_pdus;
	uint32_t tx_login_cmd_pdus;
	uint32_t tx_text_cmd_pdus;
	uint32_t tx_scsi_write_pdus;
	uint32_t tx_logout_cmd_pdus;
	uint32_t tx_snack_req_pdus;
	uint32_t rx_nopin_pdus;
	uint32_t rx_scsi_resp_pdus;
	uint32_t rx_tmf_resp_pdus;
	uint32_t rx_login_resp_pdus;
	uint32_t rx_text_resp_pdus;
	uint32_t rx_scsi_read_pdus;
	uint32_t rx_logout_resp_pdus;
	uint32_t rx_r2t_pdus;
	uint32_t rx_async_pdus;
	uint32_t rx_reject_pdus;
	uint8_t reserved2[264];
};

struct bios_params {
	uint16_t SpinUpDelay: 1;
	uint16_t BIOSDisable: 1;
	uint16_t MMAPEnable: 1;
	uint16_t BootEnable: 1;
	uint16_t Reserved0: 12;
	uint8_t bootID0: 7;
	uint8_t bootID0Valid: 1;
	uint8_t bootLUN0[8];
	uint8_t bootID1: 7;
	uint8_t bootID1Valid: 1;
	uint8_t bootLUN1[8];
	uint16_t MaxLunsPerTarget;
	uint8_t Reserved1[10];
};

struct eeprom_port_cfg {
	u16 etherMtu_mac;
	u16 pauseThreshold_mac;
	u16 resumeThreshold_mac;
	u16 reserved[13];
};

struct eeprom_function_cfg {
	u8 reserved[30];
	u8 macAddress[6];
	u8 macAddressSecondary[6];
	u16 subsysVendorId;
	u16 subsysDeviceId;
};

struct eeprom_data {
	union {
		struct {
			u8 asic_id[4];
			u8 version;
			u8 reserved;
			u16 board_id;
			u8 serial_number[16];
			u16 ext_hw_conf;
			u8 mac0[6];
			u8 mac1[6];
			u8 mac2[6];
			u8 mac3[6];
			u16 etherMtu;
			u16 macConfig;
			u16 phyConfig;
			u16 reserved_56;
			u8 unused_1[2];
			u16 bufletSize;
			u16 bufletCount;
			u16 bufletPauseThreshold;
			u16 tcpWindowThreshold50;
			u16 tcpWindowThreshold25;
			u16 tcpWindowThreshold0;
			u16 ipHashTableBaseHi;
			u16 ipHashTableBaseLo;
			u16 ipHashTableSize;
			u16 tcpHashTableBaseHi;
			u16 tcpHashTableBaseLo;
			u16 tcpHashTableSize;
			u16 ncbTableBaseHi;
			u16 ncbTableBaseLo;
			u16 ncbTableSize;
			u16 drbTableBaseHi;
			u16 drbTableBaseLo;
			u16 drbTableSize;
			u8 unused_2[4];
			u16 ipReassemblyTimeout;
			u16 tcpMaxWindowSizeHi;
			u16 tcpMaxWindowSizeLo;
			u32 net_ip_addr0;
			u32 net_ip_addr1;
			u32 scsi_ip_addr0;
			u32 scsi_ip_addr1;
			u8 unused_3[128];
			u16 subsysVendorId_f0;
			u16 subsysDeviceId_f0;
			u16 signature;
			u8 unused_4[250];
			u16 subsysVendorId_f1;
			u16 subsysDeviceId_f1;
			u16 checksum;
		} __attribute__((packed)) isp4010;
		struct {
			u8 asicId[4];
			u8 version;
			u8 reserved_5;
			u16 boardId;
			u8 boardIdStr[16];
			u8 serialNumber[16];
			u16 ext_hw_conf;
			struct eeprom_port_cfg macCfg_port0;
			struct eeprom_port_cfg macCfg_port1;
			u16 bufletSize;
			u16 bufletCount;
			u16 tcpWindowThreshold50;
			u16 tcpWindowThreshold25;
			u16 tcpWindowThreshold0;
			u16 ipHashTableBaseHi;
			u16 ipHashTableBaseLo;
			u16 ipHashTableSize;
			u16 tcpHashTableBaseHi;
			u16 tcpHashTableBaseLo;
			u16 tcpHashTableSize;
			u16 ncbTableBaseHi;
			u16 ncbTableBaseLo;
			u16 ncbTableSize;
			u16 drbTableBaseHi;
			u16 drbTableBaseLo;
			u16 drbTableSize;
			u16 reserved_142[4];
			u16 ipReassemblyTimeout;
			u16 tcpMaxWindowSize;
			u16 ipSecurity;
			u8 reserved_156[294];
			u16 qDebug[8];
			struct eeprom_function_cfg funcCfg_fn0;
			u16 reserved_510;
			u8 oemSpace[432];
			struct bios_params sBIOSParams_fn1;
			struct eeprom_function_cfg funcCfg_fn1;
			u16 reserved_1022;
			u8 reserved_1024[464];
			struct eeprom_function_cfg funcCfg_fn2;
			u16 reserved_1534;
			u8 reserved_1536[432];
			struct bios_params sBIOSParams_fn3;
			struct eeprom_function_cfg funcCfg_fn3;
			u16 checksum;
		} isp4022;
	};
};

struct qla4_83xx_reset_template_hdr {
	__le16 version;
	__le16 signature;
	__le16 size;
	__le16 entries;
	__le16 hdr_size;
	__le16 checksum;
	__le16 init_seq_offset;
	__le16 start_seq_offset;
};

struct qla4_83xx_reset_template {
	int seq_index;
	int seq_error;
	int array_index;
	uint32_t array[16];
	uint8_t *buff;
	uint8_t *stop_offset;
	uint8_t *start_offset;
	uint8_t *init_offset;
	struct qla4_83xx_reset_template_hdr *hdr;
	uint8_t seq_end;
	uint8_t template_end;
};

struct qla4_83xx_idc_information {
	uint32_t request_desc;
	uint32_t info1;
	uint32_t info2;
	uint32_t info3;
};

struct scsi_qla_host___2;

struct ddb_entry;

struct srb___2 {
	struct list_head list;
	struct scsi_qla_host___2 *ha;
	struct ddb_entry *ddb;
	uint16_t flags;
	uint8_t state;
	struct scsi_cmnd *cmd;
	dma_addr_t dma_handle;
	struct kref srb_ref;
	uint8_t err_id;
	uint16_t reserved;
	uint16_t iocb_tov;
	uint16_t iocb_cnt;
	uint16_t cc_stat;
	uint8_t *req_sense_ptr;
	uint16_t req_sense_len;
	uint16_t reserved2;
};

struct aen {
	uint32_t mbox_sts[8];
};

struct ql4_aen_log {
	int count;
	struct aen entry[512];
};

struct qla4_8xxx_legacy_intr_set {
	uint32_t int_vec_bit;
	uint32_t tgt_status_reg;
	uint32_t tgt_mask_reg;
	uint32_t pci_int_reg;
};

struct ql82xx_hw_data {
	uint32_t flash_conf_off;
	uint32_t flash_data_off;
	uint32_t fdt_wrt_disable;
	uint32_t fdt_erase_cmd;
	uint32_t fdt_block_size;
	uint32_t fdt_unprotect_sec_cmd;
	uint32_t fdt_protect_sec_cmd;
	uint32_t flt_region_flt;
	uint32_t flt_region_fdt;
	uint32_t flt_region_boot;
	uint32_t flt_region_bootload;
	uint32_t flt_region_fw;
	uint32_t flt_iscsi_param;
	uint32_t flt_region_chap;
	uint32_t flt_chap_size;
	uint32_t flt_region_ddb;
	uint32_t flt_ddb_size;
};

struct ipaddress_config {
	uint16_t ipv4_options;
	uint16_t tcp_options;
	uint16_t ipv4_vlan_tag;
	uint8_t ipv4_addr_state;
	uint8_t ip_address[4];
	uint8_t subnet_mask[4];
	uint8_t gateway[4];
	uint32_t ipv6_options;
	uint32_t ipv6_addl_options;
	uint8_t ipv6_link_local_state;
	uint8_t ipv6_addr0_state;
	uint8_t ipv6_addr1_state;
	uint8_t ipv6_default_router_state;
	uint16_t ipv6_vlan_tag;
	struct in6_addr ipv6_link_local_addr;
	struct in6_addr ipv6_addr0;
	struct in6_addr ipv6_addr1;
	struct in6_addr ipv6_default_router_addr;
	uint16_t eth_mtu_size;
	uint16_t ipv4_port;
	uint16_t ipv6_port;
	uint8_t control;
	uint16_t ipv6_tcp_options;
	uint8_t tcp_wsf;
	uint8_t ipv6_tcp_wsf;
	uint8_t ipv4_tos;
	uint8_t ipv4_cache_id;
	uint8_t ipv6_cache_id;
	uint8_t ipv4_alt_cid_len;
	uint8_t ipv4_alt_cid[11];
	uint8_t ipv4_vid_len;
	uint8_t ipv4_vid[11];
	uint8_t ipv4_ttl;
	uint16_t ipv6_flow_lbl;
	uint8_t ipv6_traffic_class;
	uint8_t ipv6_hop_limit;
	uint32_t ipv6_nd_reach_time;
	uint32_t ipv6_nd_rexmit_timer;
	uint32_t ipv6_nd_stale_timeout;
	uint8_t ipv6_dup_addr_detect_count;
	uint32_t ipv6_gw_advrt_mtu;
	uint16_t def_timeout;
	uint8_t abort_timer;
	uint16_t iscsi_options;
	uint16_t iscsi_max_pdu_size;
	uint16_t iscsi_first_burst_len;
	uint16_t iscsi_max_outstnd_r2t;
	uint16_t iscsi_max_burst_len;
	uint8_t iscsi_name[224];
};

struct ip_address_format {
	u8 ip_type;
	u8 ip_address[16];
};

struct ql4_chap_format {
	u8 intr_chap_name[256];
	u8 intr_secret[100];
	u8 target_chap_name[256];
	u8 target_secret[100];
	u16 intr_chap_name_length;
	u16 intr_secret_length;
	u16 target_chap_name_length;
	u16 target_secret_length;
};

struct ql4_conn_info {
	u16 dest_port;
	struct ip_address_format dest_ipaddr;
	struct ql4_chap_format chap;
};

struct ql4_boot_session_info {
	u8 target_name[224];
	struct ql4_conn_info conn_list[1];
};

struct ql4_boot_tgt_info {
	struct ql4_boot_session_info boot_pri_sess;
	struct ql4_boot_session_info boot_sec_sess;
};

struct isp_operations___2;

struct mrb;

struct scsi_qla_host___2 {
	long unsigned int flags;
	long unsigned int dpc_flags;
	struct Scsi_Host *host;
	uint32_t tot_ddbs;
	uint16_t iocb_cnt;
	uint16_t iocb_hiwat;
	mempool_t *srb_mempool;
	struct pci_dev *pdev;
	struct isp_reg *reg;
	long unsigned int pio_address;
	long unsigned int pio_length;
	uint16_t req_q_count;
	long unsigned int host_no;
	struct eeprom_data *nvram;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t hardware_lock;
	uint32_t eeprom_cmd_data;
	uint64_t isr_count;
	uint64_t adapter_error_count;
	uint64_t device_error_count;
	uint64_t total_io_count;
	uint64_t total_mbytes_xferred;
	uint64_t link_failure_count;
	uint64_t invalid_crc_count;
	uint32_t bytes_xfered;
	uint32_t spurious_int_count;
	uint32_t aborted_io_count;
	uint32_t io_timeout_count;
	uint32_t mailbox_timeout_count;
	uint32_t seconds_since_last_intr;
	uint32_t seconds_since_last_heartbeat;
	uint32_t mac_index;
	uint32_t firmware_version[2];
	uint32_t patch_number;
	uint32_t build_number;
	uint32_t board_id;
	uint16_t firmware_options;
	uint8_t alias[32];
	uint8_t name_string[256];
	uint8_t heartbeat_interval;
	uint8_t my_mac[6];
	uint8_t serial_number[16];
	uint16_t port_num;
	uint32_t firmware_state;
	uint32_t addl_fw_state;
	struct workqueue_struct *dpc_thread;
	struct work_struct dpc_work;
	struct timer_list timer;
	uint32_t timer_active;
	atomic_t check_relogin_timeouts;
	uint32_t retry_reset_ha_cnt;
	uint32_t isp_reset_timer;
	uint32_t nic_reset_timer;
	int eh_start;
	struct list_head free_srb_q;
	uint16_t free_srb_q_count;
	uint16_t num_srbs_allocated;
	void *queues;
	dma_addr_t queues_dma;
	long unsigned int queues_len;
	dma_addr_t request_dma;
	struct queue_entry *request_ring;
	struct queue_entry *request_ptr;
	dma_addr_t response_dma;
	struct queue_entry *response_ring;
	struct queue_entry *response_ptr;
	dma_addr_t shadow_regs_dma;
	struct shadow_regs *shadow_regs;
	uint16_t request_in;
	uint16_t request_out;
	uint16_t response_in;
	uint16_t response_out;
	uint16_t aen_q_count;
	uint16_t aen_in;
	uint16_t aen_out;
	struct aen aen_q[512];
	struct ql4_aen_log aen_log;
	struct mutex mbox_sem;
	volatile uint8_t mbox_status_count;
	volatile uint32_t mbox_status[8];
	struct ddb_entry *fw_ddb_index_map[512];
	struct srb___2 *status_srb;
	uint8_t acb_version;
	struct device_reg_82xx___2 *qla4_82xx_reg;
	long unsigned int nx_pcibase;
	uint8_t *nx_db_rd_ptr;
	long unsigned int nx_db_wr_ptr;
	long unsigned int first_page_group_start;
	long unsigned int first_page_group_end;
	uint32_t crb_win;
	uint32_t curr_window;
	uint32_t ddr_mn_window;
	long unsigned int mn_win_crb;
	long unsigned int ms_win_crb;
	int qdr_sn_window;
	rwlock_t hw_lock;
	uint16_t func_num;
	int link_width;
	struct qla4_8xxx_legacy_intr_set nx_legacy_intr;
	u32 nx_crb_mask;
	uint8_t revision_id;
	uint32_t fw_heartbeat_counter;
	struct isp_operations___2 *isp_ops;
	struct ql82xx_hw_data hw;
	uint32_t nx_dev_init_timeout;
	uint32_t nx_reset_timeout;
	void *fw_dump;
	uint32_t fw_dump_size;
	uint32_t fw_dump_capture_mask;
	void *fw_dump_tmplt_hdr;
	uint32_t fw_dump_tmplt_size;
	uint32_t fw_dump_skip_size;
	struct completion mbx_intr_comp;
	struct ipaddress_config ip_config;
	struct iscsi_iface *iface_ipv4;
	struct iscsi_iface *iface_ipv6_0;
	struct iscsi_iface *iface_ipv6_1;
	struct about_fw_info fw_info;
	uint32_t fw_uptime_secs;
	uint32_t fw_uptime_msecs;
	uint16_t def_timeout;
	uint32_t flash_state;
	struct dma_pool *chap_dma_pool;
	uint8_t *chap_list;
	struct mutex chap_sem;
	struct workqueue_struct *task_wq;
	long unsigned int ddb_idx_map[8];
	struct iscsi_boot_kset *boot_kset;
	struct ql4_boot_tgt_info boot_tgt;
	uint16_t phy_port_num;
	uint16_t phy_port_cnt;
	uint16_t iscsi_pci_func_cnt;
	uint8_t model_name[16];
	struct completion disable_acb_comp;
	struct dma_pool *fw_ddb_dma_pool;
	uint16_t pri_ddb_idx;
	uint16_t sec_ddb_idx;
	int is_reset;
	uint16_t temperature;
	struct list_head work_list;
	spinlock_t work_lock;
	struct mrb *active_mrb_array[128];
	uint32_t mrb_index;
	uint32_t *reg_tbl;
	struct qla4_83xx_reset_template reset_tmplt;
	struct device_reg_83xx *qla4_83xx_reg;
	uint32_t pf_bit;
	struct qla4_83xx_idc_information idc_info;
	struct addr_ctrl_blk *saved_acb;
	int notify_idc_comp;
	int notify_link_up_comp;
	int idc_extend_tmo;
	struct completion idc_comp;
	struct completion link_up_comp;
	long: 64;
};

struct ddb_entry {
	struct scsi_qla_host___2 *ha;
	struct iscsi_cls_session *sess;
	struct iscsi_cls_conn *conn;
	uint16_t fw_ddb_index;
	uint32_t fw_ddb_device_state;
	uint16_t ddb_type;
	struct dev_db_entry fw_ddb_entry;
	int (*unblock_sess)(struct iscsi_cls_session *);
	int (*ddb_change)(struct scsi_qla_host___2 *, uint32_t, struct ddb_entry *, uint32_t);
	long unsigned int flags;
	uint16_t default_relogin_timeout;
	atomic_t retry_relogin_timer;
	atomic_t relogin_timer;
	atomic_t relogin_retry_count;
	uint32_t default_time2wait;
	uint16_t chap_tbl_idx;
};

struct mrb {
	struct scsi_qla_host___2 *ha;
	struct mbox_cmd_iocb *mbox;
	uint32_t mbox_cmd;
	uint16_t iocb_cnt;
	uint32_t pid;
};

struct qla_ddb_index {
	struct list_head list;
	uint16_t fw_ddb_idx;
	uint16_t flash_ddb_idx;
	struct dev_db_entry fw_ddb;
	uint8_t flash_isid[6];
};

struct ql4_tuple_ddb {
	int port;
	int tpgt;
	char ip_addr[64];
	char iscsi_name[224];
	uint16_t options;
	uint8_t isid[6];
};

enum qla4_work_type {
	QLA4_EVENT_AEN = 0,
	QLA4_EVENT_PING_STATUS = 1,
};

struct qla4_work_evt {
	struct list_head list;
	enum qla4_work_type type;
	union {
		struct {
			enum iscsi_host_event_code code;
			uint32_t data_size;
			uint8_t data[0];
		} aen;
		struct {
			uint32_t status;
			uint32_t pid;
			uint32_t data_size;
			uint8_t data[0];
		} ping;
	} u;
};

struct isp_operations___2 {
	int (*iospace_config)(struct scsi_qla_host___2 *);
	void (*pci_config)(struct scsi_qla_host___2 *);
	void (*disable_intrs)(struct scsi_qla_host___2 *);
	void (*enable_intrs)(struct scsi_qla_host___2 *);
	int (*start_firmware)(struct scsi_qla_host___2 *);
	int (*restart_firmware)(struct scsi_qla_host___2 *);
	irqreturn_t (*intr_handler)(int, void *);
	void (*interrupt_service_routine)(struct scsi_qla_host___2 *, uint32_t);
	int (*need_reset)(struct scsi_qla_host___2 *);
	int (*reset_chip)(struct scsi_qla_host___2 *);
	int (*reset_firmware)(struct scsi_qla_host___2 *);
	void (*queue_iocb)(struct scsi_qla_host___2 *);
	void (*complete_iocb)(struct scsi_qla_host___2 *);
	uint16_t (*rd_shdw_req_q_out)(struct scsi_qla_host___2 *);
	uint16_t (*rd_shdw_rsp_q_in)(struct scsi_qla_host___2 *);
	int (*get_sys_info)(struct scsi_qla_host___2 *);
	uint32_t (*rd_reg_direct)(struct scsi_qla_host___2 *, ulong);
	void (*wr_reg_direct)(struct scsi_qla_host___2 *, ulong, uint32_t);
	int (*rd_reg_indirect)(struct scsi_qla_host___2 *, uint32_t, uint32_t *);
	int (*wr_reg_indirect)(struct scsi_qla_host___2 *, uint32_t, uint32_t);
	int (*idc_lock)(struct scsi_qla_host___2 *);
	void (*idc_unlock)(struct scsi_qla_host___2 *);
	void (*rom_lock_recovery)(struct scsi_qla_host___2 *);
	void (*queue_mailbox_command)(struct scsi_qla_host___2 *, uint32_t *, int);
	void (*process_mailbox_interrupt)(struct scsi_qla_host___2 *, int);
};

struct ql4_task_data {
	struct scsi_qla_host___2 *ha;
	uint8_t iocb_req_cnt;
	dma_addr_t data_dma;
	void *req_buffer;
	dma_addr_t req_dma;
	uint32_t req_len;
	void *resp_buffer;
	dma_addr_t resp_dma;
	uint32_t resp_len;
	struct iscsi_task *task;
	struct passthru_status sts;
	struct work_struct task_work;
};

struct qla_endpoint {
	struct Scsi_Host *host;
	struct __kernel_sockaddr_storage dst_addr;
};

struct qla_conn {
	struct qla_endpoint *qla_ep;
};

union external_hw_config_reg {
	struct {
		__le32 bReserved0: 1;
		__le32 bSDRAMProtectionMethod: 2;
		__le32 bSDRAMBanks: 1;
		__le32 bSDRAMChipWidth: 1;
		__le32 bSDRAMChipSize: 2;
		__le32 bParityDisable: 1;
		__le32 bExternalMemoryType: 1;
		__le32 bFlashBIOSWriteEnable: 1;
		__le32 bFlashUpperBankSelect: 1;
		__le32 bWriteBurst: 2;
		__le32 bReserved1: 3;
		__le32 bMask: 16;
	};
	uint32_t Asuint32_t;
};

struct sys_info_phys_addr {
	uint8_t address[6];
	uint8_t filler[2];
};

struct flash_sys_info {
	uint32_t cookie;
	uint32_t physAddrCount;
	struct sys_info_phys_addr physAddr[4];
	uint8_t vendorId[128];
	uint8_t productId[128];
	uint32_t serialNumber;
	uint32_t pciDeviceVendor;
	uint32_t pciDeviceId;
	uint32_t pciSubsysVendor;
	uint32_t pciSubsysId;
	uint32_t crumbs;
	uint32_t enterpriseNumber;
	uint32_t mtu;
	uint32_t reserved0;
	uint32_t crumbs2;
	uint8_t acSerialNumber[16];
	uint32_t crumbs3;
	uint32_t reserved1[39];
};

struct response {
	uint8_t data[60];
	uint32_t signature;
};

struct qla4_8xxx_minidump_template_hdr {
	uint32_t entry_type;
	uint32_t first_entry_offset;
	uint32_t size_of_template;
	uint32_t capture_debug_level;
	uint32_t num_of_entries;
	uint32_t version;
	uint32_t driver_timestamp;
	uint32_t checksum;
	uint32_t driver_capture_mask;
	uint32_t driver_info_word2;
	uint32_t driver_info_word3;
	uint32_t driver_info_word4;
	uint32_t saved_state_array[16];
	uint32_t capture_size_array[8];
	uint32_t ocm_window_reg[16];
	uint32_t capabilities[16];
};

struct crash_record {
	uint16_t fw_major_version;
	uint16_t fw_minor_version;
	uint16_t fw_patch_version;
	uint16_t fw_build_version;
	uint8_t build_date[16];
	uint8_t build_time[16];
	uint8_t build_user[16];
	uint8_t card_serial_num[16];
	uint32_t time_of_crash_in_secs;
	uint32_t time_of_crash_in_ms;
	uint16_t out_RISC_sd_num_frames;
	uint16_t OAP_sd_num_words;
	uint16_t IAP_sd_num_frames;
	uint16_t in_RISC_sd_num_words;
	uint8_t reserved1[28];
	uint8_t out_RISC_reg_dump[256];
	uint8_t in_RISC_reg_dump[256];
	uint8_t in_out_RISC_stack_dump[0];
};

struct conn_event_log_entry {
	uint32_t timestamp_sec;
	uint32_t timestamp_ms;
	uint16_t device_index;
	uint16_t fw_conn_state;
	uint8_t event_type;
	uint8_t error_code;
	uint16_t error_code_detail;
	uint8_t num_consecutive_events;
	uint8_t rsvd[3];
};

struct data_seg_a64 {
	struct {
		uint32_t addrLow;
		uint32_t addrHigh;
	} base;
	uint32_t count;
};

struct command_t3_entry {
	struct qla4_header hdr;
	uint32_t handle;
	uint16_t target;
	uint16_t connection_id;
	uint8_t control_flags;
	uint8_t state_flags;
	uint8_t cmdRefNum;
	uint8_t reserved1;
	uint8_t cdb[16];
	struct scsi_lun lun;
	uint32_t cmdSeqNum;
	uint16_t timeout;
	uint16_t dataSegCnt;
	uint32_t ttlByteCnt;
	struct data_seg_a64 dataseg[1];
};

struct continuation_t1_entry {
	struct qla4_header hdr;
	struct data_seg_a64 dataseg[5];
};

struct qla4_marker_entry {
	struct qla4_header hdr;
	uint32_t system_defined;
	uint16_t target;
	uint16_t modifier;
	uint16_t flags;
	uint16_t reserved1;
	struct scsi_lun lun;
	uint64_t reserved2;
	uint64_t reserved3;
	uint64_t reserved4;
	uint64_t reserved5;
	uint64_t reserved6;
};

struct passthru0 {
	struct qla4_header hdr;
	uint32_t handle;
	uint16_t target;
	uint16_t connection_id;
	uint16_t control_flags;
	uint16_t timeout;
	struct data_seg_a64 out_dsd;
	uint32_t res1;
	struct data_seg_a64 in_dsd;
	uint8_t res2[20];
};

enum iscsi_ping_status_code {
	ISCSI_PING_SUCCESS = 0,
	ISCSI_PING_FW_DISABLED = 1,
	ISCSI_PING_IPADDR_INVALID = 2,
	ISCSI_PING_LINKLOCAL_IPV6_ADDR_INVALID = 3,
	ISCSI_PING_TIMEOUT = 4,
	ISCSI_PING_INVALID_DEST_ADDR = 5,
	ISCSI_PING_OVERSIZE_PACKET = 6,
	ISCSI_PING_ICMP_ERROR = 7,
	ISCSI_PING_MAX_REQ_EXCEEDED = 8,
	ISCSI_PING_NO_ARP_RECEIVED = 9,
};

struct status_entry {
	struct qla4_header hdr;
	uint32_t handle;
	uint8_t scsiStatus;
	uint8_t iscsiFlags;
	uint8_t iscsiResponse;
	uint8_t completionStatus;
	uint8_t reserved1;
	uint8_t state_flags;
	uint16_t senseDataByteCnt;
	uint32_t residualByteCnt;
	uint32_t bidiResidualByteCnt;
	uint32_t expSeqNum;
	uint32_t maxCmdSeqNum;
	uint8_t senseData[32];
};

struct status_cont_entry {
	struct qla4_header hdr;
	uint8_t ext_sense_data[60];
};

struct mbox_status_iocb {
	struct qla4_header hdr;
	uint32_t handle;
	uint32_t out_mbox[8];
	uint32_t res1[6];
};

struct qla8xxx_minidump_entry_hdr {
	uint32_t entry_type;
	uint32_t entry_size;
	uint32_t entry_capture_size;
	struct {
		uint8_t entry_capture_mask;
		uint8_t entry_code;
		uint8_t driver_code;
		uint8_t driver_flags;
	} d_ctrl;
};

struct qla8xxx_minidump_entry_crb {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t addr;
	struct {
		uint8_t addr_stride;
		uint8_t state_index_a;
		uint16_t poll_timeout;
	} crb_strd;
	uint32_t data_size;
	uint32_t op_count;
	struct {
		uint8_t opcode;
		uint8_t state_index_v;
		uint8_t shl;
		uint8_t shr;
	} crb_ctrl;
	uint32_t value_1;
	uint32_t value_2;
	uint32_t value_3;
};

struct qla8xxx_minidump_entry_cache {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t tag_reg_addr;
	struct {
		uint16_t tag_value_stride;
		uint16_t init_tag_value;
	} addr_ctrl;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t control_addr;
	struct {
		uint16_t write_value;
		uint8_t poll_mask;
		uint8_t poll_wait;
	} cache_ctrl;
	uint32_t read_addr;
	struct {
		uint8_t read_addr_stride;
		uint8_t read_addr_cnt;
		uint16_t rsvd_1;
	} read_ctrl;
};

struct qla8xxx_minidump_entry_rdocm {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t rsvd_0;
	uint32_t rsvd_1;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t rsvd_2;
	uint32_t rsvd_3;
	uint32_t read_addr;
	uint32_t read_addr_stride;
};

struct qla8xxx_minidump_entry_rdmem {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t rsvd[6];
	uint32_t read_addr;
	uint32_t read_data_size;
};

struct qla8xxx_minidump_entry_rdrom {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t rsvd[6];
	uint32_t read_addr;
	uint32_t read_data_size;
};

struct qla8xxx_minidump_entry_mux {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t select_addr;
	uint32_t rsvd_0;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t select_value;
	uint32_t select_value_stride;
	uint32_t read_addr;
	uint32_t rsvd_1;
};

struct qla8xxx_minidump_entry_queue {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t select_addr;
	struct {
		uint16_t queue_id_stride;
		uint16_t rsvd_0;
	} q_strd;
	uint32_t data_size;
	uint32_t op_count;
	uint32_t rsvd_1;
	uint32_t rsvd_2;
	uint32_t read_addr;
	struct {
		uint8_t read_addr_stride;
		uint8_t read_addr_cnt;
		uint16_t rsvd_3;
	} rd_strd;
};

struct qla_flt_region___2 {
	uint32_t code;
	uint32_t size;
	uint32_t start;
	uint32_t end;
};

struct mbx_sys_info {
	uint8_t board_id_str[16];
	uint16_t board_id;
	uint16_t phys_port_cnt;
	uint16_t port_num;
	uint8_t mac_addr[6];
	uint32_t iscsi_pci_func_cnt;
	uint32_t pci_func;
	unsigned char serial_number[16];
	uint8_t reserved[12];
};

struct qla83xx_minidump_entry_pollrd {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t select_addr;
	uint32_t read_addr;
	uint32_t select_value;
	uint16_t select_value_stride;
	uint16_t op_count;
	uint32_t poll_wait;
	uint32_t poll_mask;
	uint32_t data_size;
	uint32_t rsvd_1;
};

struct qla8044_minidump_entry_rddfe___2 {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t addr_1;
	uint32_t value;
	uint8_t stride;
	uint8_t stride2;
	uint16_t count;
	uint32_t poll;
	uint32_t mask;
	uint32_t modify_mask;
	uint32_t data_size;
	uint32_t rsvd;
};

struct qla8044_minidump_entry_rdmdio___2 {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t addr_1;
	uint32_t addr_2;
	uint32_t value_1;
	uint8_t stride_1;
	uint8_t stride_2;
	uint16_t count;
	uint32_t poll;
	uint32_t mask;
	uint32_t value_2;
	uint32_t data_size;
};

struct qla8044_minidump_entry_pollwr___2 {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t addr_1;
	uint32_t addr_2;
	uint32_t value_1;
	uint32_t value_2;
	uint32_t poll;
	uint32_t mask;
	uint32_t data_size;
	uint32_t rsvd;
};

struct qla83xx_minidump_entry_rdmux2 {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t select_addr_1;
	uint32_t select_addr_2;
	uint32_t select_value_1;
	uint32_t select_value_2;
	uint32_t op_count;
	uint32_t select_value_mask;
	uint32_t read_addr;
	uint8_t select_value_stride;
	uint8_t data_size;
	uint8_t rsvd[2];
};

struct qla83xx_minidump_entry_pollrdmwr {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t addr_1;
	uint32_t addr_2;
	uint32_t value_1;
	uint32_t value_2;
	uint32_t poll_wait;
	uint32_t poll_mask;
	uint32_t modify_mask;
	uint32_t data_size;
};

struct qla4_83xx_minidump_entry_rdmem_pex_dma {
	struct qla8xxx_minidump_entry_hdr h;
	uint32_t desc_card_addr;
	uint16_t dma_desc_cmd;
	uint8_t rsvd[2];
	uint32_t start_dma_cmd;
	uint8_t rsvd2[12];
	uint32_t read_addr;
	uint32_t read_data_size;
};

struct qla4_83xx_pex_dma_descriptor {
	struct {
		uint32_t read_data_size;
		uint8_t rsvd[2];
		uint16_t dma_desc_cmd;
	} cmd;
	uint64_t src_addr;
	uint64_t dma_bus_addr;
	uint8_t rsvd[24];
};

struct sysfs_entry___2 {
	char *name;
	struct bin_attribute *attr;
};

struct qla4_83xx_reset_entry_hdr {
	__le16 cmd;
	__le16 size;
	__le16 count;
	__le16 delay;
};

struct qla4_83xx_poll {
	__le32 test_mask;
	__le32 test_value;
};

struct qla4_83xx_rmw {
	__le32 test_mask;
	__le32 xor_value;
	__le32 or_value;
	uint8_t shl;
	uint8_t shr;
	uint8_t index_a;
	uint8_t rsvd;
};

struct qla4_83xx_entry {
	__le32 arg1;
	__le32 arg2;
};

struct qla4_83xx_quad_entry {
	__le32 dr_addr;
	__le32 dr_value;
	__le32 ar_addr;
	__le32 ar_value;
};

enum {
	UNKNOWN_CLASS = 0,
	NIC_CLASS = 1,
	FCOE_CLASS = 2,
	ISCSI_CLASS = 3,
};

struct device_info {
	int func_num;
	int device_type;
	int port_num;
};

struct bfa_trc_s {
	u16 line;
	u16 fileno;
	u32 timestamp;
	union {
		struct {
			u32 rsvd;
			u32 u32;
		} u32;
		u64 u64;
	} data;
};

struct bfa_trc_mod_s {
	u32 head;
	u32 tail;
	u32 ntrc;
	u32 stopped;
	u32 ticks;
	u32 rsvd[3];
	struct bfa_trc_s trc[4096];
};

enum {
	BFA_TRC_HAL = 1,
	BFA_TRC_FCS = 2,
	BFA_TRC_LDRV = 3,
	BFA_TRC_CNA = 4,
};

typedef void (*bfa_sm_t)(void *, int);

typedef void (*bfa_fsm_t)(void *, int);

typedef void (*bfa_wc_resume_t)(void *);

struct bfa_wc_s {
	bfa_wc_resume_t wc_resume;
	void *wc_cbarg;
	int wc_count;
};

typedef u64 wwn_t;

struct mac_s {
	u8 mac[6];
};

struct fchs_s {
	u32 cat_info: 4;
	u32 routing: 4;
	u32 d_id: 24;
	u32 cs_ctl: 8;
	u32 s_id: 24;
	u32 type: 8;
	u32 f_ctl: 24;
	u8 seq_id;
	u8 df_ctl;
	u16 seq_cnt;
	__be16 ox_id;
	u16 rx_id;
	u32 ro;
};

enum fc_cos {
	FC_CLASS_2___2 = 4,
	FC_CLASS_3___2 = 8,
	FC_CLASS_2_3 = 12,
};

struct fc_alpabm_s {
	u8 alpa_bm[16];
};

enum fcp_tm_cmnd {
	FCP_TM_ABORT_TASK_SET = 2,
	FCP_TM_CLEAR_TASK_SET = 4,
	FCP_TM_LUN_RESET = 16,
	FCP_TM_TARGET_RESET = 32,
	FCP_TM_CLEAR_ACA = 64,
};

struct bfa_mfg_vpd_s {
	u8 version;
	u8 vpd_sig[3];
	u8 chksum;
	u8 vendor;
	u8 len;
	u8 rsv;
	u8 data[512];
};

enum bfa_status {
	BFA_STATUS_OK = 0,
	BFA_STATUS_FAILED = 1,
	BFA_STATUS_EINVAL = 2,
	BFA_STATUS_ENOMEM = 3,
	BFA_STATUS_ETIMER = 5,
	BFA_STATUS_EPROTOCOL = 6,
	BFA_STATUS_BADFLASH = 9,
	BFA_STATUS_SFP_UNSUPP = 10,
	BFA_STATUS_UNKNOWN_VFID = 11,
	BFA_STATUS_DATACORRUPTED = 12,
	BFA_STATUS_DEVBUSY = 13,
	BFA_STATUS_HDMA_FAILED = 16,
	BFA_STATUS_FLASH_BAD_LEN = 17,
	BFA_STATUS_UNKNOWN_LWWN = 18,
	BFA_STATUS_UNKNOWN_RWWN = 19,
	BFA_STATUS_VPORT_EXISTS = 21,
	BFA_STATUS_VPORT_MAX = 22,
	BFA_STATUS_UNSUPP_SPEED = 23,
	BFA_STATUS_INVLD_DFSZ = 24,
	BFA_STATUS_CMD_NOTSUPP = 26,
	BFA_STATUS_FABRIC_RJT = 29,
	BFA_STATUS_UNKNOWN_VWWN = 30,
	BFA_STATUS_PORT_OFFLINE = 34,
	BFA_STATUS_VPORT_WWN_BP = 46,
	BFA_STATUS_PORT_NOT_DISABLED = 47,
	BFA_STATUS_NO_FCPIM_NEXUS = 52,
	BFA_STATUS_IOC_FAILURE = 56,
	BFA_STATUS_INVALID_WWN = 57,
	BFA_STATUS_ADAPTER_ENABLED = 60,
	BFA_STATUS_IOC_NON_OP = 61,
	BFA_STATUS_VERSION_FAIL = 70,
	BFA_STATUS_DIAG_BUSY = 71,
	BFA_STATUS_BEACON_ON = 72,
	BFA_STATUS_ENOFSAVE = 78,
	BFA_STATUS_IOC_DISABLED = 82,
	BFA_STATUS_ERROR_TRL_ENABLED = 87,
	BFA_STATUS_ERROR_QOS_ENABLED = 88,
	BFA_STATUS_NO_SFP_DEV = 89,
	BFA_STATUS_MEMTEST_FAILED = 90,
	BFA_STATUS_LEDTEST_OP = 109,
	BFA_STATUS_INVALID_MAC = 134,
	BFA_STATUS_CMD_NOTSUPP_CNA = 146,
	BFA_STATUS_PBC = 154,
	BFA_STATUS_BAD_FWCFG = 156,
	BFA_STATUS_INVALID_VENDOR = 158,
	BFA_STATUS_SFP_NOT_READY = 159,
	BFA_STATUS_TRUNK_ENABLED = 164,
	BFA_STATUS_TRUNK_DISABLED = 165,
	BFA_STATUS_IOPROFILE_OFF = 175,
	BFA_STATUS_PHY_NOT_PRESENT = 183,
	BFA_STATUS_FEATURE_NOT_SUPPORTED = 192,
	BFA_STATUS_ENTRY_EXISTS = 193,
	BFA_STATUS_ENTRY_NOT_EXISTS = 194,
	BFA_STATUS_NO_CHANGE = 195,
	BFA_STATUS_FAA_ENABLED = 197,
	BFA_STATUS_FAA_DISABLED = 198,
	BFA_STATUS_FAA_ACQUIRED = 199,
	BFA_STATUS_FAA_ACQ_ADDR = 200,
	BFA_STATUS_BBCR_FC_ONLY = 201,
	BFA_STATUS_ERROR_TRUNK_ENABLED = 203,
	BFA_STATUS_MAX_ENTRY_REACHED = 212,
	BFA_STATUS_TOPOLOGY_LOOP = 230,
	BFA_STATUS_LOOP_UNSUPP_MEZZ = 231,
	BFA_STATUS_INVALID_BW = 233,
	BFA_STATUS_QOS_BW_INVALID = 234,
	BFA_STATUS_DPORT_ENABLED = 235,
	BFA_STATUS_DPORT_DISABLED = 236,
	BFA_STATUS_CMD_NOTSUPP_MEZZ = 239,
	BFA_STATUS_FRU_NOT_PRESENT = 240,
	BFA_STATUS_DPORT_NO_SFP = 243,
	BFA_STATUS_DPORT_ERR = 245,
	BFA_STATUS_DPORT_ENOSYS = 254,
	BFA_STATUS_DPORT_CANT_PERF = 255,
	BFA_STATUS_DPORT_LOGICALERR = 256,
	BFA_STATUS_DPORT_SWBUSY = 257,
	BFA_STATUS_ERR_BBCR_SPEED_UNSUPPORT = 258,
	BFA_STATUS_ERROR_BBCR_ENABLED = 259,
	BFA_STATUS_INVALID_BBSCN = 260,
	BFA_STATUS_DDPORT_ERR = 261,
	BFA_STATUS_DPORT_SFPWRAP_ERR = 262,
	BFA_STATUS_BBCR_CFG_NO_CHANGE = 265,
	BFA_STATUS_DPORT_SW_NOTREADY = 268,
	BFA_STATUS_DPORT_INV_SFP = 271,
	BFA_STATUS_DPORT_CMD_NOTSUPP = 273,
	BFA_STATUS_MAX_VAL = 274,
};

enum bfa_eproto_status {
	BFA_EPROTO_BAD_ACCEPT = 0,
	BFA_EPROTO_UNKNOWN_RSP = 1,
};

enum bfa_boolean {
	BFA_FALSE = 0,
	BFA_TRUE = 1,
};

enum {
	BFA_ADAPTER_SERIAL_NUM_LEN = 12,
	BFA_ADAPTER_MODEL_NAME_LEN = 16,
	BFA_ADAPTER_MODEL_DESCR_LEN = 128,
	BFA_ADAPTER_MFG_NAME_LEN = 8,
	BFA_ADAPTER_SYM_NAME_LEN = 64,
	BFA_ADAPTER_OS_TYPE_LEN = 64,
	BFA_ADAPTER_UUID_LEN = 16,
};

enum {
	BFA_IOC_DRIVER_LEN = 16,
	BFA_IOC_CHIP_REV_LEN = 8,
};

struct bfa_ioc_pci_attr_s {
	u16 vendor_id;
	u16 device_id;
	u16 ssid;
	u16 ssvid;
	u32 pcifn;
	u32 rsvd;
	char chip_rev[8];
};

struct bfa_ioc_drv_stats_s {
	u32 ioc_isrs;
	u32 ioc_enables;
	u32 ioc_disables;
	u32 ioc_hbfails;
	u32 ioc_boots;
	u32 stats_tmos;
	u32 hb_count;
	u32 disable_reqs;
	u32 enable_reqs;
	u32 disable_replies;
	u32 enable_replies;
	u32 rsvd;
};

enum bfa_aen_category {
	BFA_AEN_CAT_ADAPTER = 1,
	BFA_AEN_CAT_PORT = 2,
	BFA_AEN_CAT_LPORT = 3,
	BFA_AEN_CAT_RPORT = 4,
	BFA_AEN_CAT_ITNIM = 5,
	BFA_AEN_CAT_AUDIT = 8,
	BFA_AEN_CAT_IOC = 9,
};

struct bfa_adapter_aen_data_s {
	char serial_num[12];
	u32 nports;
	wwn_t pwwn;
};

struct bfa_port_aen_data_s {
	wwn_t pwwn;
	wwn_t fwwn;
	u32 phy_port_num;
	u16 ioc_type;
	u16 level;
	struct mac_s mac;
	u16 rsvd;
};

struct bfa_lport_aen_data_s {
	u16 vf_id;
	u16 roles;
	u32 rsvd;
	wwn_t ppwwn;
	wwn_t lpwwn;
};

struct bfa_itnim_aen_data_s {
	u16 vf_id;
	u16 rsvd[3];
	wwn_t ppwwn;
	wwn_t lpwwn;
	wwn_t rpwwn;
};

struct bfa_audit_aen_data_s {
	wwn_t pwwn;
	int partition_inst;
	int partition_type;
};

struct bfa_ioc_aen_data_s {
	wwn_t pwwn;
	u16 ioc_type;
	struct mac_s mac;
};

enum {
	BFA_PCI_VENDOR_ID_BROCADE = 5719,
	BFA_PCI_DEVICE_ID_FC_8G2P = 19,
	BFA_PCI_DEVICE_ID_FC_8G1P = 23,
	BFA_PCI_DEVICE_ID_CT = 20,
	BFA_PCI_DEVICE_ID_CT_FC = 33,
	BFA_PCI_DEVICE_ID_CT2 = 34,
	BFA_PCI_DEVICE_ID_CT2_QUAD = 35,
};

enum bfa_port_speed {
	BFA_PORT_SPEED_UNKNOWN = 0,
	BFA_PORT_SPEED_1GBPS = 1,
	BFA_PORT_SPEED_2GBPS = 2,
	BFA_PORT_SPEED_4GBPS = 4,
	BFA_PORT_SPEED_8GBPS = 8,
	BFA_PORT_SPEED_10GBPS = 10,
	BFA_PORT_SPEED_16GBPS = 16,
	BFA_PORT_SPEED_AUTO = 15,
};

enum {
	BFA_BOOT_BOOTLUN_MAX = 4,
	BFA_PREBOOT_BOOTLUN_MAX = 8,
};

enum bfa_mode_s {
	BFA_MODE_HBA = 1,
	BFA_MODE_CNA = 2,
	BFA_MODE_NIC = 3,
};

struct bfa_ablk_cfg_pf_s {
	u16 pers;
	u8 port_id;
	u8 optrom;
	u8 valid;
	u8 sriov;
	u8 max_vfs;
	u8 rsvd[1];
	u16 num_qpairs;
	u16 num_vectors;
	u16 bw_min;
	u16 bw_max;
};

struct bfa_ablk_cfg_port_s {
	u8 mode;
	u8 type;
	u8 max_pfs;
	u8 rsvd[5];
};

struct bfa_ablk_cfg_inst_s {
	u8 nports;
	u8 max_pfs;
	u8 rsvd[6];
	struct bfa_ablk_cfg_pf_s pf_cfg[16];
	struct bfa_ablk_cfg_port_s port_cfg[2];
};

struct bfa_ablk_cfg_s {
	struct bfa_ablk_cfg_inst_s inst[2];
};

enum bfa_defs_sfp_media_e {
	BFA_SFP_MEDIA_UNKNOWN = 0,
	BFA_SFP_MEDIA_CU = 1,
	BFA_SFP_MEDIA_LW = 2,
	BFA_SFP_MEDIA_SW = 3,
	BFA_SFP_MEDIA_EL = 4,
	BFA_SFP_MEDIA_UNSUPPORT = 5,
};

struct sfp_srlid_base_s {
	u8 id;
	u8 extid;
	u8 connector;
	u8 xcvr[8];
	u8 encoding;
	u8 br_norm;
	u8 rate_id;
	u8 len_km;
	u8 len_100m;
	u8 len_om2;
	u8 len_om1;
	u8 len_cu;
	u8 len_om3;
	u8 vendor_name[16];
	u8 unalloc1;
	u8 vendor_oui[3];
	u8 vendor_pn[16];
	u8 vendor_rev[4];
	u8 wavelen[2];
	u8 unalloc2;
	u8 cc_base;
};

struct sfp_srlid_ext_s {
	u8 options[2];
	u8 br_max;
	u8 br_min;
	u8 vendor_sn[16];
	u8 date_code[8];
	u8 diag_mon_type;
	u8 en_options;
	u8 sff_8472;
	u8 cc_ext;
};

struct sfp_diag_base_s {
	u8 temp_high_alarm[2];
	u8 temp_low_alarm[2];
	u8 temp_high_warning[2];
	u8 temp_low_warning[2];
	u8 volt_high_alarm[2];
	u8 volt_low_alarm[2];
	u8 volt_high_warning[2];
	u8 volt_low_warning[2];
	u8 bias_high_alarm[2];
	u8 bias_low_alarm[2];
	u8 bias_high_warning[2];
	u8 bias_low_warning[2];
	u8 tx_pwr_high_alarm[2];
	u8 tx_pwr_low_alarm[2];
	u8 tx_pwr_high_warning[2];
	u8 tx_pwr_low_warning[2];
	u8 rx_pwr_high_alarm[2];
	u8 rx_pwr_low_alarm[2];
	u8 rx_pwr_high_warning[2];
	u8 rx_pwr_low_warning[2];
	u8 unallocate_1[16];
	u8 rx_pwr[20];
	u8 tx_i[4];
	u8 tx_pwr[4];
	u8 temp[4];
	u8 volt[4];
	u8 unallocate_2[3];
	u8 cc_dmi;
};

struct sfp_diag_ext_s {
	u8 diag[10];
	u8 unalloc1[4];
	u8 status_ctl;
	u8 rsvd;
	u8 alarm_flags[2];
	u8 unalloc2[2];
	u8 warning_flags[2];
	u8 ext_status_ctl[2];
};

struct sfp_usr_eeprom_s {
	u8 rsvd1[2];
	u8 ewrap;
	u8 rsvd2[2];
	u8 owrap;
	u8 rsvd3[2];
	u8 prbs;
	u8 rsvd4[2];
	u8 tx_eqz_16;
	u8 tx_eqz_8;
	u8 rsvd5[2];
	u8 rx_emp_16;
	u8 rx_emp_8;
	u8 rsvd6[2];
	u8 tx_eye_adj;
	u8 rsvd7[3];
	u8 tx_eye_qctl;
	u8 tx_eye_qres;
	u8 rsvd8[2];
	u8 poh[3];
	u8 rsvd9[2];
};

struct sfp_mem_s {
	struct sfp_srlid_base_s srlid_base;
	struct sfp_srlid_ext_s srlid_ext;
	struct sfp_diag_base_s diag_base;
	struct sfp_diag_ext_s diag_ext;
	struct sfp_usr_eeprom_s usr_eeprom;
};

enum bfa_diag_dport_test_type {
	DPORT_TEST_ELOOP = 0,
	DPORT_TEST_OLOOP = 1,
	DPORT_TEST_ROLOOP = 2,
	DPORT_TEST_LINK = 3,
	DPORT_TEST_MAX = 4,
};

struct bfa_diag_dport_subtest_result_s {
	u8 status;
	u8 rsvd[7];
	u64 start_time;
};

struct bfa_diag_dport_result_s {
	wwn_t rp_pwwn;
	wwn_t rp_nwwn;
	u64 start_time;
	u64 end_time;
	u8 status;
	u8 mode;
	u8 rsvd;
	u8 speed;
	u16 buffer_required;
	u16 frmsz;
	u32 lpcnt;
	u32 pat;
	u32 roundtrip_latency;
	u32 est_cable_distance;
	struct bfa_diag_dport_subtest_result_s subtest[4];
};

struct bfa_plog_rec_s {
	u64 tv;
	u8 port;
	u8 mid;
	u8 eid;
	u8 log_type;
	u8 log_num_ints;
	u8 rsvd;
	u16 misc;
	union {
		char string_log[32];
		u32 int_log[8];
	} log_entry;
};

enum bfa_plog_mid {
	BFA_PL_MID_INVALID = 0,
	BFA_PL_MID_DEBUG = 1,
	BFA_PL_MID_DRVR = 2,
	BFA_PL_MID_HAL = 3,
	BFA_PL_MID_HAL_FCXP = 4,
	BFA_PL_MID_HAL_UF = 5,
	BFA_PL_MID_FCS = 6,
	BFA_PL_MID_LPS = 7,
	BFA_PL_MID_MAX = 8,
};

enum bfa_plog_eid {
	BFA_PL_EID_INVALID = 0,
	BFA_PL_EID_IOC_DISABLE = 1,
	BFA_PL_EID_IOC_ENABLE = 2,
	BFA_PL_EID_PORT_DISABLE = 3,
	BFA_PL_EID_PORT_ENABLE = 4,
	BFA_PL_EID_PORT_ST_CHANGE = 5,
	BFA_PL_EID_TX = 6,
	BFA_PL_EID_TX_ACK1 = 7,
	BFA_PL_EID_TX_RJT = 8,
	BFA_PL_EID_TX_BSY = 9,
	BFA_PL_EID_RX = 10,
	BFA_PL_EID_RX_ACK1 = 11,
	BFA_PL_EID_RX_RJT = 12,
	BFA_PL_EID_RX_BSY = 13,
	BFA_PL_EID_CT_IN = 14,
	BFA_PL_EID_CT_OUT = 15,
	BFA_PL_EID_DRIVER_START = 16,
	BFA_PL_EID_RSCN = 17,
	BFA_PL_EID_DEBUG = 18,
	BFA_PL_EID_MISC = 19,
	BFA_PL_EID_FIP_FCF_DISC = 20,
	BFA_PL_EID_FIP_FCF_CVL = 21,
	BFA_PL_EID_LOGIN = 22,
	BFA_PL_EID_LOGO = 23,
	BFA_PL_EID_TRUNK_SCN = 24,
	BFA_PL_EID_MAX = 25,
};

struct bfa_plog_s {
	char plog_sig[8];
	u8 plog_enabled;
	u8 rsvd[7];
	u32 ticks;
	u16 head;
	u16 tail;
	struct bfa_plog_rec_s plog_recs[256];
};

struct bfi_mhdr_s {
	u8 msg_class;
	u8 msg_id;
	union {
		struct {
			u8 qid;
			u8 fn_lpu;
		} h2i;
		u16 i2htok;
	} mtag;
};

union bfi_addr_u {
	struct {
		__be32 addr_lo;
		__be32 addr_hi;
	} a32;
};

struct bfi_sge_s {
	u32 sg_len: 28;
	u32 rsvd: 2;
	u32 flags: 2;
	union bfi_addr_u sga;
};

struct bfi_alen_s {
	union bfi_addr_u al_addr;
	u32 al_len;
};

struct bfi_sgpg_s {
	struct bfi_sge_s sges[8];
	u32 rsvd[8];
};

struct bfi_msg_s {
	struct bfi_mhdr_s mhdr;
	u32 pl[31];
};

struct bfi_mbmsg_s {
	struct bfi_mhdr_s mh;
	u32 pl[7];
};

enum bfi_pcifn_class {
	BFI_PCIFN_CLASS_FC = 3076,
	BFI_PCIFN_CLASS_ETH = 512,
};

enum bfi_mclass {
	BFI_MC_IOC = 1,
	BFI_MC_DIAG = 2,
	BFI_MC_FLASH = 3,
	BFI_MC_CEE = 4,
	BFI_MC_FCPORT = 5,
	BFI_MC_IOCFC = 6,
	BFI_MC_ABLK = 7,
	BFI_MC_UF = 8,
	BFI_MC_FCXP = 9,
	BFI_MC_LPS = 10,
	BFI_MC_RPORT = 11,
	BFI_MC_ITN = 12,
	BFI_MC_IOIM_READ = 13,
	BFI_MC_IOIM_WRITE = 14,
	BFI_MC_IOIM_IO = 15,
	BFI_MC_IOIM = 16,
	BFI_MC_IOIM_IOCOM = 17,
	BFI_MC_TSKIM = 18,
	BFI_MC_PORT = 21,
	BFI_MC_SFP = 22,
	BFI_MC_PHY = 25,
	BFI_MC_FRU = 34,
	BFI_MC_MAX = 35,
};

enum bfi_asic_gen {
	BFI_ASIC_GEN_CB = 1,
	BFI_ASIC_GEN_CT = 2,
	BFI_ASIC_GEN_CT2 = 3,
};

enum bfi_asic_mode {
	BFI_ASIC_MODE_FC = 1,
	BFI_ASIC_MODE_FC16 = 2,
	BFI_ASIC_MODE_ETH = 3,
	BFI_ASIC_MODE_COMBO = 4,
};

struct bfi_ioc_attr_s {
	wwn_t mfg_pwwn;
	wwn_t mfg_nwwn;
	struct mac_s mfg_mac;
	u8 port_mode;
	u8 rsvd_a;
	wwn_t pwwn;
	wwn_t nwwn;
	struct mac_s mac;
	u16 rsvd_b;
	struct mac_s fcoe_mac;
	u16 rsvd_c;
	char brcd_serialnum[12];
	u8 pcie_gen;
	u8 pcie_lanes_orig;
	u8 pcie_lanes;
	u8 rx_bbcredit;
	u32 adapter_prop;
	u16 maxfrsize;
	char asic_rev;
	u8 rsvd_d;
	char fw_version[64];
	char optrom_version[64];
	struct bfa_mfg_vpd_s vpd;
	u32 card_type;
	u8 mfg_day;
	u8 mfg_month;
	u16 mfg_year;
	u8 uuid[16];
};

enum bfi_port_mode {
	BFI_PORT_MODE_FC = 1,
	BFI_PORT_MODE_ETH = 2,
};

enum bfi_ioc_state {
	BFI_IOC_UNINIT = 0,
	BFI_IOC_INITING = 1,
	BFI_IOC_HWINIT = 2,
	BFI_IOC_CFG = 3,
	BFI_IOC_OP = 4,
	BFI_IOC_DISABLING = 5,
	BFI_IOC_DISABLED = 6,
	BFI_IOC_CFG_DISABLED = 7,
	BFI_IOC_FAIL = 8,
	BFI_IOC_MEMTEST = 9,
};

struct bfi_pbc_blun_s {
	wwn_t tgt_pwwn;
	struct scsi_lun tgt_lun;
};

struct bfi_pbc_vport_s {
	wwn_t vp_pwwn;
	wwn_t vp_nwwn;
};

struct bfi_pbc_s {
	u8 port_enabled;
	u8 boot_enabled;
	u8 nbluns;
	u8 nvports;
	u8 port_speed;
	u8 rsvd_a;
	u16 hss;
	wwn_t pbc_pwwn;
	wwn_t pbc_nwwn;
	struct bfi_pbc_blun_s blun[8];
	struct bfi_pbc_vport_s vport[16];
};

enum bfi_ablk_h2i_msgs_e {
	BFI_ABLK_H2I_QUERY = 1,
	BFI_ABLK_H2I_ADPT_CONFIG = 2,
	BFI_ABLK_H2I_PORT_CONFIG = 3,
	BFI_ABLK_H2I_PF_CREATE = 4,
	BFI_ABLK_H2I_PF_DELETE = 5,
	BFI_ABLK_H2I_PF_UPDATE = 6,
	BFI_ABLK_H2I_OPTROM_ENABLE = 7,
	BFI_ABLK_H2I_OPTROM_DISABLE = 8,
};

enum bfi_sfp_h2i_e {
	BFI_SFP_H2I_SHOW = 1,
	BFI_SFP_H2I_SCN = 2,
};

enum bfi_sfp_mem_e {
	BFI_SFP_MEM_ALL = 1,
	BFI_SFP_MEM_DIAGEXT = 2,
};

enum bfi_diag_h2i {
	BFI_DIAG_H2I_PORTBEACON = 1,
	BFI_DIAG_H2I_LOOPBACK = 2,
	BFI_DIAG_H2I_FWPING = 3,
	BFI_DIAG_H2I_TEMPSENSOR = 4,
	BFI_DIAG_H2I_LEDTEST = 5,
	BFI_DIAG_H2I_QTEST = 6,
	BFI_DIAG_H2I_DPORT = 7,
};

struct bfi_diag_dport_req_s {
	struct bfi_mhdr_s mh;
	u8 req;
	u8 rsvd[3];
	u32 lpcnt;
	u32 payload;
};

struct bfi_diag_dport_rsp_s {
	struct bfi_mhdr_s mh;
	enum bfa_status status;
	wwn_t pwwn;
	wwn_t nwwn;
};

struct bfi_diag_dport_scn_teststart_s {
	wwn_t pwwn;
	wwn_t nwwn;
	u8 type;
	u8 mode;
	u8 rsvd[2];
	u32 numfrm;
};

struct bfi_diag_dport_scn_testcomp_s {
	u8 status;
	u8 speed;
	u16 numbuffer;
	u8 subtest_status[4];
	u32 latency;
	u32 distance;
	u16 frm_sz;
	u8 rsvd[2];
};

struct bfi_diag_dport_scn_s {
	struct bfi_mhdr_s mh;
	u8 state;
	u8 rsvd[3];
	union {
		struct bfi_diag_dport_scn_teststart_s teststart;
		struct bfi_diag_dport_scn_testcomp_s testcomp;
	} info;
};

union bfi_diag_dport_msg_u {
	struct bfi_diag_dport_req_s req;
	struct bfi_diag_dport_rsp_s rsp;
	struct bfi_diag_dport_scn_s scn;
};

struct bfa_iocfc_intr_attr_s {
	u8 coalesce;
	u8 rsvd[3];
	__be16 latency;
	__be16 delay;
};

struct bfa_iocfc_fwcfg_s {
	u16 num_fabrics;
	u16 num_lports;
	u16 num_rports;
	u16 num_ioim_reqs;
	u16 num_tskim_reqs;
	u16 num_fwtio_reqs;
	u16 num_fcxp_reqs;
	u16 num_uf_bufs;
	u8 num_cqs;
	u8 fw_tick_res;
	u8 rsvd[6];
};

struct bfa_iocfc_drvcfg_s {
	u16 num_reqq_elems;
	u16 num_rspq_elems;
	u16 num_sgpgs;
	u16 num_sboot_tgts;
	u16 num_sboot_luns;
	u16 ioc_recover;
	u16 min_cfg;
	u16 path_tov;
	u16 num_tio_reqs;
	u8 port_mode;
	u8 rsvd_a;
	enum bfa_boolean delay_comp;
	u16 num_ttsk_reqs;
	u32 rsvd;
};

struct bfa_iocfc_cfg_s {
	struct bfa_iocfc_fwcfg_s fwcfg;
	struct bfa_iocfc_drvcfg_s drvcfg;
};

struct bfa_qos_bw_s {
	u8 qos_bw_set;
	u8 high;
	u8 med;
	u8 low;
};

struct bfa_qos_attr_s {
	u8 state;
	u8 rsvd1[3];
	u32 total_bb_cr;
	struct bfa_qos_bw_s qos_bw;
	struct bfa_qos_bw_s qos_bw_op;
};

struct bfa_bbcr_attr_s {
	u8 state;
	u8 peer_bb_scn;
	u8 reason;
	u8 rsvd;
};

struct bfa_qos_vc_info_s {
	u8 vc_credit;
	u8 borrow_credit;
	u8 priority;
	u8 resvd;
};

struct bfa_qos_vc_attr_s {
	u16 total_vc_count;
	u16 shared_credit;
	u32 elp_opmode_flags;
	struct bfa_qos_vc_info_s vc_info[16];
};

struct bfa_qos_stats_s {
	u32 flogi_sent;
	u32 flogi_acc_recvd;
	u32 flogi_rjt_recvd;
	u32 flogi_retries;
	u32 elp_recvd;
	u32 elp_accepted;
	u32 elp_rejected;
	u32 elp_dropped;
	u32 qos_rscn_recvd;
	u32 rsvd;
};

struct bfa_fcoe_stats_s {
	u64 secs_reset;
	u64 cee_linkups;
	u64 cee_linkdns;
	u64 fip_linkups;
	u64 fip_linkdns;
	u64 fip_fails;
	u64 mac_invalids;
	u64 vlan_req;
	u64 vlan_notify;
	u64 vlan_err;
	u64 vlan_timeouts;
	u64 vlan_invalids;
	u64 disc_req;
	u64 disc_rsp;
	u64 disc_err;
	u64 disc_unsol;
	u64 disc_timeouts;
	u64 disc_fcf_unavail;
	u64 linksvc_unsupp;
	u64 linksvc_err;
	u64 logo_req;
	u64 clrvlink_req;
	u64 op_unsupp;
	u64 untagged;
	u64 txf_ucast;
	u64 txf_ucast_vlan;
	u64 txf_ucast_octets;
	u64 txf_mcast;
	u64 txf_mcast_vlan;
	u64 txf_mcast_octets;
	u64 txf_bcast;
	u64 txf_bcast_vlan;
	u64 txf_bcast_octets;
	u64 txf_timeout;
	u64 txf_parity_errors;
	u64 txf_fid_parity_errors;
	u64 rxf_ucast_octets;
	u64 rxf_ucast;
	u64 rxf_ucast_vlan;
	u64 rxf_mcast_octets;
	u64 rxf_mcast;
	u64 rxf_mcast_vlan;
	u64 rxf_bcast_octets;
	u64 rxf_bcast;
	u64 rxf_bcast_vlan;
};

union bfa_fcport_stats_u {
	struct bfa_qos_stats_s fcqos;
	struct bfa_fcoe_stats_s fcoe;
};

struct bfa_fcpim_del_itn_stats_s {
	u32 del_itn_iocomp_aborted;
	u32 del_itn_iocomp_timedout;
	u32 del_itn_iocom_sqer_needed;
	u32 del_itn_iocom_res_free;
	u32 del_itn_iocom_hostabrts;
	u32 del_itn_total_ios;
	u32 del_io_iocdowns;
	u32 del_tm_iocdowns;
};

struct bfa_itnim_iostats_s {
	u32 total_ios;
	u32 input_reqs;
	u32 output_reqs;
	u32 io_comps;
	u32 wr_throughput;
	u32 rd_throughput;
	u32 iocomp_ok;
	u32 iocomp_underrun;
	u32 iocomp_overrun;
	u32 qwait;
	u32 qresumes;
	u32 no_iotags;
	u32 iocomp_timedout;
	u32 iocom_nexus_abort;
	u32 iocom_proto_err;
	u32 iocom_dif_err;
	u32 iocom_sqer_needed;
	u32 iocom_res_free;
	u32 io_aborts;
	u32 iocom_hostabrts;
	u32 io_cleanups;
	u32 path_tov_expired;
	u32 iocomp_aborted;
	u32 io_iocdowns;
	u32 iocom_utags;
	u32 io_tmaborts;
	u32 tm_io_comps;
	u32 creates;
	u32 fw_create;
	u32 create_comps;
	u32 onlines;
	u32 offlines;
	u32 fw_delete;
	u32 delete_comps;
	u32 deletes;
	u32 sler_events;
	u32 ioc_disabled;
	u32 cleanup_comps;
	u32 tm_cmnds;
	u32 tm_fw_rsps;
	u32 tm_success;
	u32 tm_failures;
	u32 no_tskims;
	u32 tm_qwait;
	u32 tm_qresumes;
	u32 tm_iocdowns;
	u32 tm_cleanups;
	u32 tm_cleanup_comps;
	u32 rsvd[6];
};

enum bfa_port_type {
	BFA_PORT_TYPE_UNKNOWN = 1,
	BFA_PORT_TYPE_NPORT = 5,
	BFA_PORT_TYPE_NLPORT = 6,
	BFA_PORT_TYPE_LPORT = 20,
	BFA_PORT_TYPE_P2P = 21,
	BFA_PORT_TYPE_VPORT = 22,
};

enum bfa_port_topology {
	BFA_PORT_TOPOLOGY_NONE = 0,
	BFA_PORT_TOPOLOGY_P2P_OLD_VER = 1,
	BFA_PORT_TOPOLOGY_LOOP = 2,
	BFA_PORT_TOPOLOGY_AUTO_OLD_VER = 3,
	BFA_PORT_TOPOLOGY_AUTO = 4,
	BFA_PORT_TOPOLOGY_P2P = 5,
};

enum bfa_port_linkstate {
	BFA_PORT_LINKUP = 1,
	BFA_PORT_LINKDOWN = 2,
};

enum bfa_fec_state_s {
	BFA_FEC_ONLINE = 1,
	BFA_FEC_OFFLINE = 2,
	BFA_FEC_OFFLINE_NOT_16G = 3,
};

struct bfa_lun_mask_s {
	wwn_t lp_wwn;
	wwn_t rp_wwn;
	struct scsi_lun lun;
	u8 ua;
	u8 rsvd[3];
	u16 rp_tag;
	u8 lp_tag;
	u8 state;
};

struct bfa_lunmask_cfg_s {
	u32 status;
	u32 rsvd;
	struct bfa_lun_mask_s lun_list[16];
};

struct bfa_throttle_cfg_s {
	u16 is_valid;
	u16 value;
	u32 rsvd;
};

struct bfa_port_cfg_s {
	u8 topology;
	u8 speed;
	u8 trunked;
	u8 qos_enabled;
	u8 cfg_hardalpa;
	u8 hardalpa;
	__be16 maxfrsize;
	u8 rx_bbcredit;
	u8 tx_bbcredit;
	u8 ratelimit;
	u8 trl_def_speed;
	u8 bb_cr_enabled;
	u8 bb_scn;
	u8 faa_state;
	u8 rsvd1;
	u16 path_tov;
	u16 q_depth;
	struct bfa_qos_bw_s qos_bw;
};

struct bfa_fcport_fcf_s {
	wwn_t name;
	wwn_t fabric_name;
	u8 fipenabled;
	u8 fipfailed;
	u8 resv[2];
	u8 pri;
	u8 version;
	u8 available;
	u8 fka_disabled;
	u8 maxsz_verified;
	u8 fc_map[3];
	__be16 vlan;
	u32 fka_adv_per;
	struct mac_s mac;
} __attribute__((packed));

enum bfa_trunk_state {
	BFA_TRUNK_DISABLED = 0,
	BFA_TRUNK_ONLINE = 1,
	BFA_TRUNK_OFFLINE = 2,
};

struct bfa_trunk_vc_attr_s {
	u32 bb_credit;
	u32 elp_opmode_flags;
	u32 req_credit;
	u16 vc_credits[8];
};

struct bfa_fcport_loop_info_s {
	u8 myalpa;
	u8 alpabm_val;
	u8 resvd[6];
	struct fc_alpabm_s alpabm;
};

struct bfa_port_link_s {
	u8 linkstate;
	u8 linkstate_rsn;
	u8 topology;
	u8 speed;
	u32 linkstate_opt;
	u8 trunked;
	u8 fec_state;
	u8 resvd[6];
	struct bfa_qos_attr_s qos_attr;
	union {
		struct bfa_fcport_loop_info_s loop_info;
		struct bfa_bbcr_attr_s bbcr_attr;
		union {
			struct bfa_qos_vc_attr_s qos_vc_attr;
			struct bfa_trunk_vc_attr_s trunk_vc_attr;
			struct bfa_fcport_fcf_s fcf;
		} vc_fcf;
	} attr;
};

enum bfa_trunk_link_fctl {
	BFA_TRUNK_LINK_FCTL_NORMAL = 0,
	BFA_TRUNK_LINK_FCTL_VC = 1,
	BFA_TRUNK_LINK_FCTL_VC_QOS = 2,
};

enum bfa_trunk_link_state {
	BFA_TRUNK_LINK_STATE_UP = 1,
	BFA_TRUNK_LINK_STATE_DN_LINKDN = 2,
	BFA_TRUNK_LINK_STATE_DN_GRP_MIS = 3,
	BFA_TRUNK_LINK_STATE_DN_SPD_MIS = 4,
	BFA_TRUNK_LINK_STATE_DN_MODE_MIS = 5,
};

struct bfa_trunk_link_attr_s {
	wwn_t trunk_wwn;
	enum bfa_trunk_link_fctl fctl;
	enum bfa_trunk_link_state link_state;
	enum bfa_port_speed speed;
	u32 deskew;
};

struct bfa_trunk_attr_s {
	enum bfa_trunk_state state;
	enum bfa_port_speed speed;
	u32 port_id;
	u32 rsvd;
	struct bfa_trunk_link_attr_s link_attr[2];
};

struct bfa_rport_hal_stats_s {
	u32 sm_un_cr;
	u32 sm_un_unexp;
	u32 sm_cr_on;
	u32 sm_cr_del;
	u32 sm_cr_hwf;
	u32 sm_cr_unexp;
	u32 sm_fwc_rsp;
	u32 sm_fwc_del;
	u32 sm_fwc_off;
	u32 sm_fwc_hwf;
	u32 sm_fwc_unexp;
	u32 sm_on_off;
	u32 sm_on_del;
	u32 sm_on_hwf;
	u32 sm_on_unexp;
	u32 sm_fwd_rsp;
	u32 sm_fwd_del;
	u32 sm_fwd_hwf;
	u32 sm_fwd_unexp;
	u32 sm_off_del;
	u32 sm_off_on;
	u32 sm_off_hwf;
	u32 sm_off_unexp;
	u32 sm_del_fwrsp;
	u32 sm_del_hwf;
	u32 sm_del_unexp;
	u32 sm_delp_fwrsp;
	u32 sm_delp_hwf;
	u32 sm_delp_unexp;
	u32 sm_offp_fwrsp;
	u32 sm_offp_del;
	u32 sm_offp_hwf;
	u32 sm_offp_unexp;
	u32 sm_iocd_off;
	u32 sm_iocd_del;
	u32 sm_iocd_on;
	u32 sm_iocd_unexp;
	u32 rsvd;
};

struct bfa_rport_qos_attr_s {
	u8 qos_priority;
	u8 rsvd[3];
	u32 qos_flow_id;
};

struct bfa_itnim_latency_s {
	u32 min[14];
	u32 max[14];
	u32 count[14];
	u32 avg[14];
};

struct bfa_itnim_ioprofile_s {
	u32 clock_res_mul;
	u32 clock_res_div;
	u32 index;
	u32 io_profile_start_time;
	u32 iocomps[14];
	struct bfa_itnim_latency_s io_latency;
};

struct bfa_port_fc_stats_s {
	u64 secs_reset;
	u64 tx_frames;
	u64 tx_words;
	u64 tx_lip;
	u64 tx_lip_f7f7;
	u64 tx_lip_f8f7;
	u64 tx_arbf0;
	u64 tx_nos;
	u64 tx_ols;
	u64 tx_lr;
	u64 tx_lrr;
	u64 rx_frames;
	u64 rx_words;
	u64 lip_count;
	u64 rx_lip_f7f7;
	u64 rx_lip_f8f7;
	u64 rx_arbf0;
	u64 nos_count;
	u64 ols_count;
	u64 lr_count;
	u64 lrr_count;
	u64 invalid_crcs;
	u64 invalid_crc_gd_eof;
	u64 undersized_frm;
	u64 oversized_frm;
	u64 bad_eof_frm;
	u64 error_frames;
	u64 dropped_frames;
	u64 link_failures;
	u64 loss_of_syncs;
	u64 loss_of_signals;
	u64 primseq_errs;
	u64 bad_os_count;
	u64 err_enc_out;
	u64 err_enc;
	u64 bbcr_frames_lost;
	u64 bbcr_rrdys_lost;
	u64 bbcr_link_resets;
	u64 bbcr_frame_lost_intrs;
	u64 bbcr_rrdy_lost_intrs;
	u64 loop_timeouts;
};

struct bfa_port_eth_stats_s {
	u64 secs_reset;
	u64 frame_64;
	u64 frame_65_127;
	u64 frame_128_255;
	u64 frame_256_511;
	u64 frame_512_1023;
	u64 frame_1024_1518;
	u64 frame_1519_1522;
	u64 tx_bytes;
	u64 tx_packets;
	u64 tx_mcast_packets;
	u64 tx_bcast_packets;
	u64 tx_control_frame;
	u64 tx_drop;
	u64 tx_jabber;
	u64 tx_fcs_error;
	u64 tx_fragments;
	u64 rx_bytes;
	u64 rx_packets;
	u64 rx_mcast_packets;
	u64 rx_bcast_packets;
	u64 rx_control_frames;
	u64 rx_unknown_opcode;
	u64 rx_drop;
	u64 rx_jabber;
	u64 rx_fcs_error;
	u64 rx_alignment_error;
	u64 rx_frame_length_error;
	u64 rx_code_error;
	u64 rx_fragments;
	u64 rx_pause;
	u64 rx_zero_pause;
	u64 tx_pause;
	u64 tx_zero_pause;
	u64 rx_fcoe_pause;
	u64 rx_fcoe_zero_pause;
	u64 tx_fcoe_pause;
	u64 tx_fcoe_zero_pause;
	u64 rx_iscsi_pause;
	u64 rx_iscsi_zero_pause;
	u64 tx_iscsi_pause;
	u64 tx_iscsi_zero_pause;
};

union bfa_port_stats_u {
	struct bfa_port_fc_stats_s fc;
	struct bfa_port_eth_stats_s eth;
};

struct bfa_cee_lldp_str_s {
	u8 sub_type;
	u8 len;
	u8 rsvd[2];
	u8 value[128];
};

struct bfa_cee_lldp_cfg_s {
	struct bfa_cee_lldp_str_s chassis_id;
	struct bfa_cee_lldp_str_s port_id;
	struct bfa_cee_lldp_str_s port_desc;
	struct bfa_cee_lldp_str_s sys_name;
	struct bfa_cee_lldp_str_s sys_desc;
	struct bfa_cee_lldp_str_s mgmt_addr;
	u16 time_to_live;
	u16 enabled_system_cap;
};

struct bfa_cee_dcbx_cfg_s {
	u8 pgid[8];
	u8 pg_percentage[8];
	u8 pfc_primap;
	u8 fcoe_primap;
	u8 iscsi_primap;
	u8 dcbx_version;
	u8 lls_fcoe;
	u8 lls_lan;
	u8 rsvd[2];
};

struct bfa_cee_attr_s {
	u8 cee_status;
	u8 error_reason;
	struct bfa_cee_lldp_cfg_s lldp_remote;
	struct bfa_cee_dcbx_cfg_s dcbx_remote;
	struct mac_s src_mac;
	u8 link_speed;
	u8 nw_priority;
	u8 filler[2];
};

struct bfa_cee_stats_s {
	u32 lldp_tx_frames;
	u32 lldp_rx_frames;
	u32 lldp_rx_frames_invalid;
	u32 lldp_rx_frames_new;
	u32 lldp_tlvs_unrecognized;
	u32 lldp_rx_shutdown_tlvs;
	u32 lldp_info_aged_out;
	u32 dcbx_phylink_ups;
	u32 dcbx_phylink_downs;
	u32 dcbx_rx_tlvs;
	u32 dcbx_rx_tlvs_invalid;
	u32 dcbx_control_tlv_error;
	u32 dcbx_feature_tlv_error;
	u32 dcbx_cee_cfg_new;
	u32 cee_status_down;
	u32 cee_status_up;
	u32 cee_hw_cfg_changed;
	u32 cee_rx_invalid_cfg;
};

struct bfa_rport_aen_data_s {
	u16 vf_id;
	u16 rsvd[3];
	wwn_t ppwwn;
	wwn_t lpwwn;
	wwn_t rpwwn;
	union {
		struct bfa_rport_qos_attr_s qos;
	} priv;
};

union bfa_aen_data_u {
	struct bfa_adapter_aen_data_s adapter;
	struct bfa_port_aen_data_s port;
	struct bfa_lport_aen_data_s lport;
	struct bfa_rport_aen_data_s rport;
	struct bfa_itnim_aen_data_s itnim;
	struct bfa_audit_aen_data_s audit;
	struct bfa_ioc_aen_data_s ioc;
};

struct bfa_aen_entry_s {
	struct list_head qe;
	enum bfa_aen_category aen_category;
	int aen_type;
	union bfa_aen_data_u aen_data;
	u64 aen_tv_sec;
	u64 aen_tv_usec;
	u32 seq_num;
	u32 bfad_num;
};

typedef void (*bfa_timer_cbfn_t)(void *);

struct bfa_timer_s {
	struct list_head qe;
	bfa_timer_cbfn_t timercb;
	void *arg;
	int timeout;
};

struct bfa_timer_mod_s {
	struct list_head timer_q;
};

struct bfa_sge_s {
	u32 sg_len;
	void *sg_addr;
};

struct bfa_mem_dma_s {
	struct list_head qe;
	u32 mem_len;
	u8 *kva;
	u64 dma;
	u8 *kva_curp;
	u64 dma_curp;
};

struct bfa_mem_kva_s {
	struct list_head qe;
	u32 mem_len;
	u8 *kva;
	u8 *kva_curp;
};

struct bfa_meminfo_s {
	struct bfa_mem_dma_s dma_info;
	struct bfa_mem_kva_s kva_info;
};

struct bfa_pcidev_s {
	int pci_slot;
	u8 pci_func;
	u16 device_id;
	u16 ssid;
	void *pci_bar_kva;
};

struct bfa_dma_s {
	void *kva;
	u64 pa;
};

struct bfa_ioc_regs_s {
	void *hfn_mbox_cmd;
	void *hfn_mbox;
	void *lpu_mbox_cmd;
	void *lpu_mbox;
	void *lpu_read_stat;
	void *pss_ctl_reg;
	void *pss_err_status_reg;
	void *app_pll_fast_ctl_reg;
	void *app_pll_slow_ctl_reg;
	void *ioc_sem_reg;
	void *ioc_usage_sem_reg;
	void *ioc_init_sem_reg;
	void *ioc_usage_reg;
	void *host_page_num_fn;
	void *heartbeat;
	void *ioc_fwstate;
	void *alt_ioc_fwstate;
	void *ll_halt;
	void *alt_ll_halt;
	void *err_set;
	void *ioc_fail_sync;
	void *shirq_isr_next;
	void *shirq_msk_next;
	void *smem_page_start;
	u32 smem_pg0;
};

struct bfa_mbox_cmd_s {
	struct list_head qe;
	u32 msg[8];
};

typedef void (*bfa_ioc_mbox_mcfunc_t)(void *, struct bfi_mbmsg_s *);

struct bfa_ioc_mbox_mod_s {
	struct list_head cmd_q;
	int nmclass;
	struct {
		bfa_ioc_mbox_mcfunc_t cbfn;
		void *cbarg;
	} mbhdlr[35];
};

typedef void (*bfa_ioc_enable_cbfn_t)(void *, enum bfa_status);

typedef void (*bfa_ioc_disable_cbfn_t)(void *);

typedef void (*bfa_ioc_hbfail_cbfn_t)(void *);

typedef void (*bfa_ioc_reset_cbfn_t)(void *);

struct bfa_ioc_cbfn_s {
	bfa_ioc_enable_cbfn_t enable_cbfn;
	bfa_ioc_disable_cbfn_t disable_cbfn;
	bfa_ioc_hbfail_cbfn_t hbfail_cbfn;
	bfa_ioc_reset_cbfn_t reset_cbfn;
};

enum bfa_ioc_event_e {
	BFA_IOC_E_ENABLED = 1,
	BFA_IOC_E_DISABLED = 2,
	BFA_IOC_E_FAILED = 3,
};

typedef void (*bfa_ioc_notify_cbfn_t)(void *, enum bfa_ioc_event_e);

struct bfa_ioc_notify_s {
	struct list_head qe;
	bfa_ioc_notify_cbfn_t cbfn;
	void *cbarg;
};

struct bfa_ioc_s;

struct bfa_iocpf_s {
	bfa_fsm_t fsm;
	struct bfa_ioc_s *ioc;
	enum bfa_boolean fw_mismatch_notified;
	enum bfa_boolean auto_recover;
	u32 poll_time;
};

struct bfa_s;

struct bfa_ioc_hwif_s;

struct bfa_ioc_s {
	bfa_fsm_t fsm;
	struct bfa_s *bfa;
	struct bfa_pcidev_s pcidev;
	struct bfa_timer_mod_s *timer_mod;
	struct bfa_timer_s ioc_timer;
	struct bfa_timer_s sem_timer;
	struct bfa_timer_s hb_timer;
	u32 hb_count;
	struct list_head notify_q;
	void *dbg_fwsave;
	int dbg_fwsave_len;
	enum bfa_boolean dbg_fwsave_once;
	enum bfi_pcifn_class clscode;
	struct bfa_ioc_regs_s ioc_regs;
	struct bfa_trc_mod_s *trcmod;
	struct bfa_ioc_drv_stats_s stats;
	enum bfa_boolean fcmode;
	enum bfa_boolean pllinit;
	enum bfa_boolean stats_busy;
	u8 port_id;
	struct bfa_dma_s attr_dma;
	struct bfi_ioc_attr_s *attr;
	struct bfa_ioc_cbfn_s *cbfn;
	struct bfa_ioc_mbox_mod_s mbox_mod;
	struct bfa_ioc_hwif_s *ioc_hwif;
	struct bfa_iocpf_s iocpf;
	enum bfi_asic_gen asic_gen;
	enum bfi_asic_mode asic_mode;
	enum bfi_port_mode port0_mode;
	enum bfi_port_mode port1_mode;
	enum bfa_mode_s port_mode;
	u8 ad_cap_bm;
	u8 port_mode_cfg;
	int ioc_aen_seq;
};

typedef void (*bfa_cb_cbfn_t)(void *, enum bfa_boolean);

struct bfa_cb_qe_s {
	struct list_head qe;
	bfa_cb_cbfn_t cbfn;
	enum bfa_boolean once;
	enum bfa_boolean pre_rmv;
	enum bfa_status fw_status;
	void *cbarg;
};

struct bfa_iocfc_regs_s {
	void *intr_status;
	void *intr_mask;
	void *cpe_q_pi[4];
	void *cpe_q_ci[4];
	void *cpe_q_ctrl[4];
	void *rme_q_ci[4];
	void *rme_q_pi[4];
	void *rme_q_ctrl[4];
};

struct bfa_hwif_s {
	void (*hw_reginit)(struct bfa_s *);
	void (*hw_reqq_ack)(struct bfa_s *, int);
	void (*hw_rspq_ack)(struct bfa_s *, int, u32);
	void (*hw_msix_init)(struct bfa_s *, int);
	void (*hw_msix_ctrl_install)(struct bfa_s *);
	void (*hw_msix_queue_install)(struct bfa_s *);
	void (*hw_msix_uninstall)(struct bfa_s *);
	void (*hw_isr_mode_set)(struct bfa_s *, enum bfa_boolean);
	void (*hw_msix_getvecs)(struct bfa_s *, u32 *, u32 *, u32 *);
	void (*hw_msix_get_rme_range)(struct bfa_s *, u32 *, u32 *);
	int cpe_vec_q0;
	int rme_vec_q0;
};

typedef void (*bfa_cb_iocfc_t)(void *, enum bfa_status);

struct bfa_faa_cbfn_s {
	bfa_cb_iocfc_t faa_cbfn;
	void *faa_cbarg;
};

struct bfa_faa_attr_s;

struct bfa_faa_args_s {
	struct bfa_faa_attr_s *faa_attr;
	struct bfa_faa_cbfn_s faa_cb;
	u8 faa_state;
	enum bfa_boolean busy;
};

struct bfi_iocfc_cfg_s;

struct bfi_iocfc_cfgrsp_s;

struct bfa_iocfc_s {
	bfa_fsm_t fsm;
	struct bfa_s *bfa;
	struct bfa_iocfc_cfg_s cfg;
	u32 req_cq_pi[4];
	u32 rsp_cq_ci[4];
	u8 hw_qid[4];
	struct bfa_cb_qe_s init_hcb_qe;
	struct bfa_cb_qe_s stop_hcb_qe;
	struct bfa_cb_qe_s dis_hcb_qe;
	struct bfa_cb_qe_s en_hcb_qe;
	struct bfa_cb_qe_s stats_hcb_qe;
	enum bfa_boolean submod_enabled;
	enum bfa_boolean cb_reqd;
	enum bfa_status op_status;
	struct bfa_dma_s cfg_info;
	struct bfi_iocfc_cfg_s *cfginfo;
	struct bfa_dma_s cfgrsp_dma;
	struct bfi_iocfc_cfgrsp_s *cfgrsp;
	struct bfa_dma_s req_cq_ba[4];
	struct bfa_dma_s req_cq_shadow_ci[4];
	struct bfa_dma_s rsp_cq_ba[4];
	struct bfa_dma_s rsp_cq_shadow_pi[4];
	struct bfa_iocfc_regs_s bfa_regs;
	struct bfa_hwif_s hwif;
	bfa_cb_iocfc_t updateq_cbfn;
	void *updateq_cbarg;
	u32 intr_mask;
	struct bfa_faa_args_s faa_args;
	struct bfa_mem_dma_s ioc_dma;
	struct bfa_mem_dma_s iocfc_dma;
	struct bfa_mem_dma_s reqq_dma[4];
	struct bfa_mem_dma_s rspq_dma[4];
	struct bfa_mem_kva_s kva_seg;
};

typedef void (*bfa_cb_diag_t)(void *, enum bfa_status);

struct bfa_fcdiag_lb_s {
	bfa_cb_diag_t cbfn;
	void *cbarg;
	void *result;
	enum bfa_boolean lock;
	u32 status;
};

struct bfa_diag_qtest_result_s;

struct bfa_fcdiag_qtest_s {
	struct bfa_diag_qtest_result_s *result;
	bfa_cb_diag_t cbfn;
	void *cbarg;
	struct bfa_timer_s timer;
	u32 status;
	u32 count;
	u8 lock;
	u8 queue;
	u8 all;
	u8 timer_active;
};

struct bfa_reqq_wait_s {
	struct list_head qe;
	void (*qresume)(void *);
	void *cbarg;
};

struct bfa_dport_s {
	struct bfa_s *bfa;
	bfa_sm_t sm;
	struct bfa_reqq_wait_s reqq_wait;
	bfa_cb_diag_t cbfn;
	void *cbarg;
	union bfi_diag_dport_msg_u i2hmsg;
	u8 test_state;
	u8 dynamic;
	u8 rsvd[2];
	u32 lpcnt;
	u32 payload;
	wwn_t rp_pwwn;
	wwn_t rp_nwwn;
	struct bfa_diag_dport_result_s result;
};

struct bfa_fcdiag_s {
	struct bfa_s *bfa;
	struct bfa_trc_mod_s *trcmod;
	struct bfa_fcdiag_lb_s lb;
	struct bfa_fcdiag_qtest_s qtest;
	struct bfa_dport_s dport;
};

struct bfi_fcport_rsp_s;

struct bfi_fcport_event_s;

struct bfi_fcport_trunk_scn_s;

union bfi_fcport_i2h_msg_u {
	struct bfi_msg_s *msg;
	struct bfi_fcport_rsp_s *penable_rsp;
	struct bfi_fcport_rsp_s *pdisable_rsp;
	struct bfi_fcport_rsp_s *psetsvcparams_rsp;
	struct bfi_fcport_rsp_s *pstatsget_rsp;
	struct bfi_fcport_rsp_s *pstatsclear_rsp;
	struct bfi_fcport_event_s *event;
	struct bfi_fcport_trunk_scn_s *trunk_scn;
};

struct bfa_fcport_s;

struct bfa_fcport_ln_s {
	struct bfa_fcport_s *fcport;
	bfa_sm_t sm;
	struct bfa_cb_qe_s ln_qe;
	enum bfa_port_linkstate ln_event;
};

struct bfa_fcport_trunk_s {
	struct bfa_trunk_attr_s attr;
};

struct bfa_fcport_s {
	struct bfa_s *bfa;
	bfa_sm_t sm;
	wwn_t nwwn;
	wwn_t pwwn;
	enum bfa_port_speed speed_sup;
	enum bfa_port_speed speed;
	enum bfa_port_topology topology;
	u8 rsvd[3];
	u8 myalpa;
	u8 alpabm_valid;
	struct fc_alpabm_s alpabm;
	struct bfa_port_cfg_s cfg;
	int: 24;
	enum bfa_boolean use_flash_cfg;
	struct bfa_qos_attr_s qos_attr;
	struct bfa_qos_vc_attr_s qos_vc_attr;
	struct bfa_reqq_wait_s reqq_wait;
	struct bfa_reqq_wait_s svcreq_wait;
	struct bfa_reqq_wait_s stats_reqq_wait;
	void *event_cbarg;
	void (*event_cbfn)(void *, enum bfa_port_linkstate);
	union {
		union bfi_fcport_i2h_msg_u i2hmsg;
	} event_arg;
	void *bfad;
	struct bfa_fcport_ln_s ln;
	struct bfa_cb_qe_s hcb_qe;
	struct bfa_timer_s timer;
	u32 msgtag;
	int: 32;
	u8 *stats_kva;
	u64 stats_pa;
	union bfa_fcport_stats_u *stats;
	enum bfa_status stats_status;
	int: 32;
	struct list_head stats_pending_q;
	struct list_head statsclr_pending_q;
	enum bfa_boolean stats_qfull;
	int: 32;
	time64_t stats_reset_time;
	enum bfa_boolean diag_busy;
	enum bfa_boolean beacon;
	enum bfa_boolean link_e2e_beacon;
	int: 32;
	struct bfa_fcport_trunk_s trunk;
	u16 fcoe_vlan;
	long: 48;
	struct bfa_mem_dma_s fcport_dma;
	enum bfa_boolean stats_dma_ready;
	struct bfa_bbcr_attr_s bbcr_attr;
	enum bfa_fec_state_s fec_state;
	int: 32;
} __attribute__((packed));

struct bfa_fcxp_s;

struct bfa_fcxp_mod_s {
	struct bfa_s *bfa;
	struct bfa_fcxp_s *fcxp_list;
	u16 num_fcxps;
	struct list_head fcxp_req_free_q;
	struct list_head fcxp_rsp_free_q;
	struct list_head fcxp_active_q;
	struct list_head req_wait_q;
	struct list_head rsp_wait_q;
	struct list_head fcxp_req_unused_q;
	struct list_head fcxp_rsp_unused_q;
	u32 req_pld_sz;
	u32 rsp_pld_sz;
	struct bfa_mem_dma_s dma_seg[13];
	struct bfa_mem_kva_s kva_seg;
};

struct bfa_lps_s;

struct bfa_lps_mod_s {
	struct list_head lps_free_q;
	struct list_head lps_active_q;
	struct list_head lps_login_q;
	struct bfa_lps_s *lps_arr;
	int num_lps;
	struct bfa_mem_kva_s kva_seg;
};

struct bfa_uf_s;

typedef void (*bfa_cb_uf_recv_t)(void *, struct bfa_uf_s *);

struct bfi_uf_buf_post_s;

struct bfa_uf_mod_s {
	struct bfa_s *bfa;
	struct bfa_uf_s *uf_list;
	u16 num_ufs;
	struct list_head uf_free_q;
	struct list_head uf_posted_q;
	struct list_head uf_unused_q;
	struct bfi_uf_buf_post_s *uf_buf_posts;
	bfa_cb_uf_recv_t ufrecv;
	void *cbarg;
	struct bfa_mem_dma_s dma_seg[5];
	struct bfa_mem_kva_s kva_seg;
};

struct bfa_rport_s;

struct bfa_rport_mod_s {
	struct bfa_rport_s *rps_list;
	struct list_head rp_free_q;
	struct list_head rp_active_q;
	struct list_head rp_unused_q;
	u16 num_rports;
	struct bfa_mem_kva_s kva_seg;
};

struct bfa_ioim_s;

typedef void (*bfa_fcpim_profile_t)(struct bfa_ioim_s *);

struct bfa_fcp_mod_s;

struct bfa_itnim_s;

struct bfa_ioim_sp_s;

struct bfa_tskim_s;

struct bfa_fcpim_s {
	struct bfa_s *bfa;
	struct bfa_fcp_mod_s *fcp;
	struct bfa_itnim_s *itnim_arr;
	struct bfa_ioim_s *ioim_arr;
	struct bfa_ioim_sp_s *ioim_sp_arr;
	struct bfa_tskim_s *tskim_arr;
	int num_itnims;
	int num_tskim_reqs;
	u32 path_tov;
	u16 q_depth;
	u8 reqq;
	struct list_head itnim_q;
	struct list_head ioim_resfree_q;
	struct list_head ioim_comp_q;
	struct list_head tskim_free_q;
	struct list_head tskim_unused_q;
	u32 ios_active;
	u32 delay_comp;
	struct bfa_fcpim_del_itn_stats_s del_itn_stats;
	enum bfa_boolean ioredirect;
	enum bfa_boolean io_profile;
	time64_t io_profile_start_time;
	bfa_fcpim_profile_t profile_comp;
	bfa_fcpim_profile_t profile_start;
};

struct bfa_iotag_s;

struct bfa_itn_s;

struct bfa_fcp_mod_s {
	struct bfa_s *bfa;
	struct list_head iotag_ioim_free_q;
	struct list_head iotag_tio_free_q;
	struct list_head iotag_unused_q;
	struct bfa_iotag_s *iotag_arr;
	struct bfa_itn_s *itn_arr;
	int max_ioim_reqs;
	int num_ioim_reqs;
	int num_fwtio_reqs;
	int num_itns;
	struct bfa_dma_s snsbase[4];
	struct bfa_fcpim_s fcpim;
	struct bfa_mem_dma_s dma_seg[4];
	struct bfa_mem_kva_s kva_seg;
	int throttle_update_required;
};

struct bfa_sgpg_mod_s {
	struct bfa_s *bfa;
	int num_sgpgs;
	int free_sgpgs;
	struct list_head sgpg_q;
	struct list_head sgpg_wait_q;
	struct bfa_mem_dma_s dma_seg[8];
	struct bfa_mem_kva_s kva_seg;
};

typedef void (*bfa_port_stats_cbfn_t)(void *, enum bfa_status);

typedef void (*bfa_port_endis_cbfn_t)(void *, enum bfa_status);

struct bfa_port_s {
	void *dev;
	struct bfa_ioc_s *ioc;
	struct bfa_trc_mod_s *trcmod;
	u32 msgtag;
	enum bfa_boolean stats_busy;
	struct bfa_mbox_cmd_s stats_mb;
	bfa_port_stats_cbfn_t stats_cbfn;
	void *stats_cbarg;
	enum bfa_status stats_status;
	time64_t stats_reset_time;
	union bfa_port_stats_u *stats;
	struct bfa_dma_s stats_dma;
	enum bfa_boolean endis_pending;
	struct bfa_mbox_cmd_s endis_mb;
	bfa_port_endis_cbfn_t endis_cbfn;
	void *endis_cbarg;
	enum bfa_status endis_status;
	struct bfa_ioc_notify_s ioc_notify;
	enum bfa_boolean pbc_disabled;
	enum bfa_boolean dport_enabled;
	struct bfa_mem_dma_s port_dma;
};

typedef void (*bfa_ablk_cbfn_t)(void *, enum bfa_status);

struct bfa_ablk_s {
	struct bfa_ioc_s *ioc;
	struct bfa_ablk_cfg_s *cfg;
	u16 *pcifn;
	struct bfa_dma_s dma_addr;
	enum bfa_boolean busy;
	struct bfa_mbox_cmd_s mb;
	bfa_ablk_cbfn_t cbfn;
	void *cbarg;
	struct bfa_ioc_notify_s ioc_notify;
	struct bfa_mem_dma_s ablk_dma;
};

typedef void (*bfa_cee_get_attr_cbfn_t)(void *, enum bfa_status);

typedef void (*bfa_cee_get_stats_cbfn_t)(void *, enum bfa_status);

typedef void (*bfa_cee_reset_stats_cbfn_t)(void *, enum bfa_status);

struct bfa_cee_cbfn_s {
	bfa_cee_get_attr_cbfn_t get_attr_cbfn;
	void *get_attr_cbarg;
	bfa_cee_get_stats_cbfn_t get_stats_cbfn;
	void *get_stats_cbarg;
	bfa_cee_reset_stats_cbfn_t reset_stats_cbfn;
	void *reset_stats_cbarg;
};

struct bfa_cee_s {
	void *dev;
	enum bfa_boolean get_attr_pending;
	enum bfa_boolean get_stats_pending;
	enum bfa_boolean reset_stats_pending;
	enum bfa_status get_attr_status;
	enum bfa_status get_stats_status;
	enum bfa_status reset_stats_status;
	struct bfa_cee_cbfn_s cbfn;
	struct bfa_ioc_notify_s ioc_notify;
	struct bfa_trc_mod_s *trcmod;
	struct bfa_cee_attr_s *attr;
	struct bfa_cee_stats_s *stats;
	struct bfa_dma_s attr_dma;
	struct bfa_dma_s stats_dma;
	struct bfa_ioc_s *ioc;
	struct bfa_mbox_cmd_s get_cfg_mb;
	struct bfa_mbox_cmd_s get_stats_mb;
	struct bfa_mbox_cmd_s reset_stats_mb;
	struct bfa_mem_dma_s cee_dma;
};

typedef void (*bfa_cb_sfp_t)(void *, enum bfa_status);

struct bfa_sfp_s {
	void *dev;
	struct bfa_ioc_s *ioc;
	struct bfa_trc_mod_s *trcmod;
	struct sfp_mem_s *sfpmem;
	bfa_cb_sfp_t cbfn;
	void *cbarg;
	enum bfi_sfp_mem_e memtype;
	u32 status;
	struct bfa_mbox_cmd_s mbcmd;
	u8 *dbuf_kva;
	u64 dbuf_pa;
	struct bfa_ioc_notify_s ioc_notify;
	enum bfa_defs_sfp_media_e *media;
	enum bfa_port_speed portspeed;
	bfa_cb_sfp_t state_query_cbfn;
	void *state_query_cbarg;
	u8 lock;
	u8 data_valid;
	u8 state;
	u8 state_query_lock;
	struct bfa_mem_dma_s sfp_dma;
	u8 is_elb;
};

typedef void (*bfa_cb_flash_t)(void *, enum bfa_status);

struct bfa_flash_s {
	struct bfa_ioc_s *ioc;
	struct bfa_trc_mod_s *trcmod;
	u32 type;
	u8 instance;
	u8 rsv[3];
	u32 op_busy;
	u32 residue;
	u32 offset;
	enum bfa_status status;
	u8 *dbuf_kva;
	u64 dbuf_pa;
	struct bfa_reqq_wait_s reqq_wait;
	bfa_cb_flash_t cbfn;
	void *cbarg;
	u8 *ubuf;
	struct bfa_cb_qe_s hcb_qe;
	u32 addr_off;
	struct bfa_mbox_cmd_s mb;
	struct bfa_ioc_notify_s ioc_notify;
	struct bfa_mem_dma_s flash_dma;
};

struct bfa_diag_results_fwping;

struct bfa_diag_fwping_s {
	struct bfa_diag_results_fwping *result;
	bfa_cb_diag_t cbfn;
	void *cbarg;
	u32 data;
	u8 lock;
	u8 rsv[3];
	u32 status;
	u32 count;
	struct bfa_mbox_cmd_s mbcmd;
	u8 *dbuf_kva;
	u64 dbuf_pa;
};

struct bfa_diag_results_tempsensor_s;

struct bfa_diag_tsensor_s {
	bfa_cb_diag_t cbfn;
	void *cbarg;
	struct bfa_diag_results_tempsensor_s *temp;
	u8 lock;
	u8 rsv[3];
	u32 status;
	struct bfa_mbox_cmd_s mbcmd;
};

struct bfa_diag_sfpshow_s {
	struct sfp_mem_s *sfpmem;
	bfa_cb_diag_t cbfn;
	void *cbarg;
	u8 lock;
	u8 static_data;
	u8 rsv[2];
	u32 status;
	struct bfa_mbox_cmd_s mbcmd;
	u8 *dbuf_kva;
	u64 dbuf_pa;
};

struct bfa_diag_led_s {
	struct bfa_mbox_cmd_s mbcmd;
	enum bfa_boolean lock;
};

struct bfa_diag_beacon_s {
	struct bfa_mbox_cmd_s mbcmd;
	enum bfa_boolean state;
	enum bfa_boolean link_e2e;
};

typedef void (*bfa_cb_diag_beacon_t)(void *, enum bfa_boolean, enum bfa_boolean);

struct bfa_diag_s {
	void *dev;
	struct bfa_ioc_s *ioc;
	struct bfa_trc_mod_s *trcmod;
	struct bfa_diag_fwping_s fwping;
	struct bfa_diag_tsensor_s tsensor;
	struct bfa_diag_sfpshow_s sfpshow;
	struct bfa_diag_led_s ledtest;
	struct bfa_diag_beacon_s beacon;
	void *result;
	struct bfa_timer_s timer;
	bfa_cb_diag_beacon_t cbfn_beacon;
	bfa_cb_diag_t cbfn;
	void *cbarg;
	u8 block;
	u8 timer_active;
	u8 rsvd[2];
	u32 status;
	struct bfa_ioc_notify_s ioc_notify;
	struct bfa_mem_dma_s diag_dma;
};

typedef void (*bfa_cb_phy_t)(void *, enum bfa_status);

struct bfa_phy_s {
	struct bfa_ioc_s *ioc;
	struct bfa_trc_mod_s *trcmod;
	u8 instance;
	u8 op_busy;
	u8 rsv[2];
	u32 residue;
	u32 offset;
	enum bfa_status status;
	u8 *dbuf_kva;
	u64 dbuf_pa;
	struct bfa_reqq_wait_s reqq_wait;
	bfa_cb_phy_t cbfn;
	void *cbarg;
	u8 *ubuf;
	struct bfa_cb_qe_s hcb_qe;
	u32 addr_off;
	struct bfa_mbox_cmd_s mb;
	struct bfa_ioc_notify_s ioc_notify;
	struct bfa_mem_dma_s phy_dma;
};

struct bfa_dconf_s;

struct bfa_dconf_mod_s {
	bfa_sm_t sm;
	u8 instance;
	enum bfa_boolean read_data_valid;
	enum bfa_boolean min_cfg;
	struct bfa_timer_s timer;
	struct bfa_s *bfa;
	void *bfad;
	void *trcmod;
	struct bfa_dconf_s *dconf;
	struct bfa_mem_kva_s kva_seg;
};

typedef void (*bfa_cb_fru_t)(void *, enum bfa_status);

struct bfa_fru_s {
	struct bfa_ioc_s *ioc;
	struct bfa_trc_mod_s *trcmod;
	u8 op_busy;
	u8 rsv[3];
	u32 residue;
	u32 offset;
	enum bfa_status status;
	u8 *dbuf_kva;
	u64 dbuf_pa;
	struct bfa_reqq_wait_s reqq_wait;
	bfa_cb_fru_t cbfn;
	void *cbarg;
	u8 *ubuf;
	struct bfa_cb_qe_s hcb_qe;
	u32 addr_off;
	struct bfa_mbox_cmd_s mb;
	struct bfa_ioc_notify_s ioc_notify;
	struct bfa_mem_dma_s fru_dma;
	u8 trfr_cmpl;
};

struct bfa_modules_s {
	struct bfa_fcdiag_s fcdiag;
	struct bfa_fcport_s fcport;
	struct bfa_fcxp_mod_s fcxp_mod;
	struct bfa_lps_mod_s lps_mod;
	struct bfa_uf_mod_s uf_mod;
	struct bfa_rport_mod_s rport_mod;
	struct bfa_fcp_mod_s fcp_mod;
	struct bfa_sgpg_mod_s sgpg_mod;
	struct bfa_port_s port;
	struct bfa_ablk_s ablk;
	struct bfa_cee_s cee;
	struct bfa_sfp_s sfp;
	struct bfa_flash_s flash;
	struct bfa_diag_s diag_mod;
	struct bfa_phy_s phy;
	struct bfa_dconf_mod_s dconf_mod;
	struct bfa_fru_s fru;
};

typedef void (*bfa_msix_handler_t)(struct bfa_s *, int);

struct bfa_msix_s {
	int nvecs;
	bfa_msix_handler_t handler[22];
};

struct bfa_s {
	void *bfad;
	struct bfa_plog_s *plog;
	struct bfa_trc_mod_s *trcmod;
	struct bfa_ioc_s ioc;
	struct bfa_iocfc_s iocfc;
	struct bfa_timer_mod_s timer_mod;
	struct bfa_modules_s modules;
	struct list_head comp_q;
	enum bfa_boolean queue_process;
	struct list_head reqq_waitq[4];
	enum bfa_boolean fcs;
	struct bfa_msix_s msix;
	int bfa_aen_seq;
	enum bfa_boolean intr_enabled;
};

struct bfa_ioc_hwif_s {
	enum bfa_status (*ioc_pll_init)(void *, enum bfi_asic_mode);
	enum bfa_boolean (*ioc_firmware_lock)(struct bfa_ioc_s *);
	void (*ioc_firmware_unlock)(struct bfa_ioc_s *);
	void (*ioc_reg_init)(struct bfa_ioc_s *);
	void (*ioc_map_port)(struct bfa_ioc_s *);
	void (*ioc_isr_mode_set)(struct bfa_ioc_s *, enum bfa_boolean);
	void (*ioc_notify_fail)(struct bfa_ioc_s *);
	void (*ioc_ownership_reset)(struct bfa_ioc_s *);
	enum bfa_boolean (*ioc_sync_start)(struct bfa_ioc_s *);
	void (*ioc_sync_join)(struct bfa_ioc_s *);
	void (*ioc_sync_leave)(struct bfa_ioc_s *);
	void (*ioc_sync_ack)(struct bfa_ioc_s *);
	enum bfa_boolean (*ioc_sync_complete)(struct bfa_ioc_s *);
	enum bfa_boolean (*ioc_lpu_read_stat)(struct bfa_ioc_s *);
	void (*ioc_set_fwstate)(struct bfa_ioc_s *, enum bfi_ioc_state);
	enum bfi_ioc_state (*ioc_get_fwstate)(struct bfa_ioc_s *);
	void (*ioc_set_alt_fwstate)(struct bfa_ioc_s *, enum bfi_ioc_state);
	enum bfi_ioc_state (*ioc_get_alt_fwstate)(struct bfa_ioc_s *);
};

struct bfa_diag_results_fwping {
	u32 data;
	u32 status;
	u32 dmastatus;
	u8 rsvd[4];
};

struct bfa_diag_qtest_result_s {
	u32 status;
	u16 count;
	u8 queue;
	u8 rsvd;
};

struct bfa_diag_results_tempsensor_s {
	u32 status;
	u16 temp;
	u16 brd_temp;
	u8 ts_junc;
	u8 ts_brd;
	u8 rsvd[6];
};

struct bfa_dconf_hdr_s {
	u32 signature;
	u32 version;
};

struct bfa_dconf_s {
	struct bfa_dconf_hdr_s hdr;
	struct bfa_lunmask_cfg_s lun_mask;
	struct bfa_throttle_cfg_s throttle_cfg;
};

typedef void (*bfa_isr_func_t)(struct bfa_s *, struct bfi_msg_s *);

struct bfa_faa_attr_s {
	wwn_t faa;
	u8 faa_state;
	u8 pwwn_source;
	u8 rsvd[6];
};

struct bfi_iocfc_cfg_s {
	u8 num_cqs;
	u8 sense_buf_len;
	u16 rsvd_1;
	u32 endian_sig;
	u8 rsvd_2;
	u8 single_msix_vec;
	u8 rsvd[2];
	__be16 num_ioim_reqs;
	__be16 num_fwtio_reqs;
	union bfi_addr_u req_cq_ba[4];
	union bfi_addr_u req_shadow_ci[4];
	__be16 req_cq_elems[4];
	union bfi_addr_u rsp_cq_ba[4];
	union bfi_addr_u rsp_shadow_pi[4];
	__be16 rsp_cq_elems[4];
	union bfi_addr_u stats_addr;
	union bfi_addr_u cfgrsp_addr;
	union bfi_addr_u ioim_snsbase[4];
	struct bfa_iocfc_intr_attr_s intr_attr;
};

struct bfi_iocfc_bootwwns {
	wwn_t wwn[4];
	u8 nwwns;
	u8 rsvd[7];
};

struct bfi_iocfc_qreg_s {
	u32 cpe_q_ci_off[4];
	u32 cpe_q_pi_off[4];
	u32 cpe_qctl_off[4];
	u32 rme_q_ci_off[4];
	u32 rme_q_pi_off[4];
	u32 rme_qctl_off[4];
	u8 hw_qid[4];
};

struct bfi_iocfc_cfgrsp_s {
	struct bfa_iocfc_fwcfg_s fwcfg;
	struct bfa_iocfc_intr_attr_s intr_attr;
	struct bfi_iocfc_bootwwns bootwwns;
	struct bfi_pbc_s pbc_cfg;
	struct bfi_iocfc_qreg_s qreg;
} __attribute__((packed));

struct bfi_fcport_rsp_s {
	struct bfi_mhdr_s mh;
	u8 status;
	u8 rsvd[3];
	struct bfa_port_cfg_s port_cfg;
	u32 msgtag;
};

struct bfi_fcport_event_s {
	struct bfi_mhdr_s mh;
	struct bfa_port_link_s link_state;
} __attribute__((packed));

struct bfi_fcport_trunk_link_s {
	wwn_t trunk_wwn;
	u8 fctl;
	u8 state;
	u8 speed;
	u8 rsvd;
	__be32 deskew;
};

struct bfi_fcport_trunk_scn_s {
	struct bfi_mhdr_s mh;
	u8 trunk_state;
	u8 trunk_speed;
	u8 rsvd_a[2];
	struct bfi_fcport_trunk_link_s tlink[2];
};

struct bfi_uf_buf_post_s {
	struct bfi_mhdr_s mh;
	u16 buf_tag;
	__be16 buf_len;
	struct bfi_alen_s alen;
};

struct bfi_lps_login_rsp_s {
	struct bfi_mhdr_s mh;
	u8 fw_tag;
	u8 status;
	u8 lsrjt_rsn;
	u8 lsrjt_expl;
	wwn_t port_name;
	wwn_t node_name;
	__be16 bb_credit;
	u8 f_port;
	u8 npiv_en;
	u32 lp_pid: 24;
	u32 auth_req: 8;
	struct mac_s lp_mac;
	struct mac_s fcf_mac;
	u8 ext_status;
	u8 brcd_switch;
	u8 bfa_tag;
	u8 rsvd;
};

enum bfi_tskim_status {
	BFI_TSKIM_STS_OK = 0,
	BFI_TSKIM_STS_NOT_SUPP = 4,
	BFI_TSKIM_STS_FAILED = 5,
	BFI_TSKIM_STS_TIMEOUT = 10,
	BFI_TSKIM_STS_ABORTED = 11,
	BFI_TSKIM_STS_UTAG = 12,
};

struct bfa_sgpg_wqe_s {
	struct list_head qe;
	int nsgpg;
	int nsgpg_total;
	void (*cbfn)(void *);
	void *cbarg;
	struct list_head sgpg_q;
};

struct bfa_sgpg_s {
	struct list_head qe;
	struct bfi_sgpg_s *sgpg;
	union bfi_addr_u sgpg_pa;
};

struct bfa_fcxp_req_info_s {
	struct bfa_rport_s *bfa_rport;
	struct fchs_s fchs;
	u8 cts;
	u8 class;
	u16 max_frmsz;
	u16 vf_id;
	u8 lp_tag;
	u32 req_tot_len;
};

struct bfa_fcxp_rsp_info_s {
	struct fchs_s rsp_fchs;
	u8 rsp_timeout;
	u8 rsvd2[3];
	u32 rsp_maxlen;
};

typedef u64 (*bfa_fcxp_get_sgaddr_t)(void *, int);

typedef u32 (*bfa_fcxp_get_sglen_t)(void *, int);

typedef void (*bfa_cb_fcxp_send_t)(void *, struct bfa_fcxp_s *, void *, enum bfa_status, u32, u32, struct fchs_s *);

struct bfa_fcxp_s {
	struct list_head qe;
	bfa_sm_t sm;
	void *caller;
	struct bfa_fcxp_mod_s *fcxp_mod;
	u16 fcxp_tag;
	struct bfa_fcxp_req_info_s req_info;
	struct bfa_fcxp_rsp_info_s rsp_info;
	u8 use_ireqbuf;
	u8 use_irspbuf;
	u32 nreq_sgles;
	u32 nrsp_sgles;
	struct list_head req_sgpg_q;
	struct list_head req_sgpg_wqe;
	struct list_head rsp_sgpg_q;
	struct list_head rsp_sgpg_wqe;
	bfa_fcxp_get_sgaddr_t req_sga_cbfn;
	bfa_fcxp_get_sglen_t req_sglen_cbfn;
	bfa_fcxp_get_sgaddr_t rsp_sga_cbfn;
	bfa_fcxp_get_sglen_t rsp_sglen_cbfn;
	bfa_cb_fcxp_send_t send_cbfn;
	void *send_cbarg;
	struct bfa_sge_s req_sge[2];
	struct bfa_sge_s rsp_sge[2];
	u8 rsp_status;
	u32 rsp_len;
	u32 residue_len;
	struct fchs_s rsp_fchs;
	struct bfa_cb_qe_s hcb_qe;
	struct bfa_reqq_wait_s reqq_wqe;
	enum bfa_boolean reqq_waiting;
	enum bfa_boolean req_rsp;
};

typedef void (*bfa_fcxp_alloc_cbfn_t)(void *, struct bfa_fcxp_s *);

struct bfa_rport_info_s {
	u16 max_frmsz;
	short: 16;
	u32 pid: 24;
	u32 lp_tag: 8;
	u32 local_pid: 24;
	u32 cisc: 8;
	u8 fc_class;
	u8 vf_en;
	u16 vf_id;
	enum bfa_port_speed speed;
};

union a {
	enum bfa_status status;
	void *fw_msg;
};

struct bfa_rport_s {
	struct list_head qe;
	bfa_sm_t sm;
	struct bfa_s *bfa;
	void *rport_drv;
	u16 fw_handle;
	u16 rport_tag;
	u8 lun_mask;
	struct bfa_rport_info_s rport_info;
	struct bfa_reqq_wait_s reqq_wait;
	struct bfa_cb_qe_s hcb_qe;
	struct bfa_rport_hal_stats_s stats;
	struct bfa_rport_qos_attr_s qos_attr;
	union a event_arg;
};

struct bfa_fcxp_wqe_s {
	struct list_head qe;
	bfa_fcxp_alloc_cbfn_t alloc_cbfn;
	void *alloc_cbarg;
	void *caller;
	struct bfa_s *bfa;
	int nreq_sgles;
	int nrsp_sgles;
	bfa_fcxp_get_sgaddr_t req_sga_cbfn;
	bfa_fcxp_get_sglen_t req_sglen_cbfn;
	bfa_fcxp_get_sgaddr_t rsp_sga_cbfn;
	bfa_fcxp_get_sglen_t rsp_sglen_cbfn;
};

struct bfa_uf_s {
	struct list_head qe;
	struct bfa_s *bfa;
	u16 uf_tag;
	u16 vf_id;
	u16 src_rport_handle;
	u16 rsvd;
	u8 *data_ptr;
	u16 data_len;
	u16 pb_len;
	void *buf_kva;
	u64 buf_pa;
	struct bfa_cb_qe_s hcb_qe;
	struct bfa_sge_s sges[2];
};

struct bfa_lps_s {
	struct list_head qe;
	struct bfa_s *bfa;
	bfa_sm_t sm;
	u8 bfa_tag;
	u8 fw_tag;
	u8 reqq;
	u8 alpa;
	u32 lp_pid;
	enum bfa_boolean fdisc;
	enum bfa_boolean auth_en;
	enum bfa_boolean auth_req;
	enum bfa_boolean npiv_en;
	enum bfa_boolean fport;
	enum bfa_boolean brcd_switch;
	enum bfa_status status;
	u16 pdusz;
	u16 pr_bbcred;
	u8 lsrjt_rsn;
	u8 lsrjt_expl;
	u8 lun_mask;
	wwn_t pwwn;
	wwn_t nwwn;
	wwn_t pr_pwwn;
	wwn_t pr_nwwn;
	struct mac_s lp_mac;
	struct mac_s fcf_mac;
	struct bfa_reqq_wait_s wqe;
	void *uarg;
	struct bfa_cb_qe_s hcb_qe;
	struct bfi_lps_login_rsp_s *loginrsp;
	enum bfa_eproto_status ext_status;
};

struct bfa_iotag_s {
	struct list_head qe;
	u16 tag;
};

struct bfa_itn_s {
	bfa_isr_func_t isr;
};

struct bfad_ioim_s;

struct bfa_ioim_s {
	struct list_head qe;
	bfa_sm_t sm;
	struct bfa_s *bfa;
	struct bfa_fcpim_s *fcpim;
	struct bfa_itnim_s *itnim;
	struct bfad_ioim_s *dio;
	u16 iotag;
	u16 abort_tag;
	u16 nsges;
	u16 nsgpgs;
	struct bfa_sgpg_s *sgpg;
	struct list_head sgpg_q;
	struct bfa_cb_qe_s hcb_qe;
	bfa_cb_cbfn_t io_cbfn;
	struct bfa_ioim_sp_s *iosp;
	u8 reqq;
	u8 mode;
	u64 start_time;
};

struct bfa_itnim_s {
	struct list_head qe;
	bfa_sm_t sm;
	struct bfa_s *bfa;
	struct bfa_rport_s *rport;
	void *ditn;
	struct bfi_mhdr_s mhdr;
	u8 msg_no;
	u8 reqq;
	struct bfa_cb_qe_s hcb_qe;
	struct list_head pending_q;
	struct list_head io_q;
	struct list_head io_cleanup_q;
	struct list_head tsk_q;
	struct list_head delay_comp_q;
	enum bfa_boolean seq_rec;
	enum bfa_boolean is_online;
	enum bfa_boolean iotov_active;
	struct bfa_wc_s wc;
	struct bfa_timer_s timer;
	struct bfa_reqq_wait_s reqq_wait;
	struct bfa_fcpim_s *fcpim;
	struct bfa_itnim_iostats_s stats;
	struct bfa_itnim_ioprofile_s ioprofile;
};

struct bfa_ioim_sp_s {
	struct bfi_msg_s comp_rspmsg;
	struct bfa_sgpg_wqe_s sgpg_wqe;
	struct bfa_reqq_wait_s reqq_wait;
	enum bfa_boolean abort_explicit;
	struct bfa_tskim_s *tskim;
};

struct bfad_tskim_s;

struct bfa_tskim_s {
	struct list_head qe;
	bfa_sm_t sm;
	struct bfa_s *bfa;
	struct bfa_fcpim_s *fcpim;
	struct bfa_itnim_s *itnim;
	struct bfad_tskim_s *dtsk;
	enum bfa_boolean notify;
	struct scsi_lun lun;
	enum fcp_tm_cmnd tm_cmnd;
	u16 tsk_tag;
	u8 tsecs;
	struct bfa_reqq_wait_s reqq_wait;
	struct list_head io_q;
	struct bfa_wc_s wc;
	struct bfa_cb_qe_s hcb_qe;
	enum bfi_tskim_status tsk_status;
};

struct bfa_vf_stats_s {
	u32 flogi_sent;
	u32 flogi_rsp_err;
	u32 flogi_acc_err;
	u32 flogi_accepts;
	u32 flogi_rejects;
	u32 flogi_unknown_rsp;
	u32 flogi_alloc_wait;
	u32 flogi_rcvd;
	u32 flogi_rejected;
	u32 fabric_onlines;
	u32 fabric_offlines;
	u32 resvd;
};

struct bfa_lport_symname_s {
	char symname[128];
};

enum bfa_lport_role {
	BFA_LPORT_ROLE_FCP_IM = 1,
	BFA_LPORT_ROLE_FCP_MAX = 1,
};

struct bfa_lport_cfg_s {
	wwn_t pwwn;
	wwn_t nwwn;
	struct bfa_lport_symname_s sym_name;
	struct bfa_lport_symname_s node_sym_name;
	enum bfa_lport_role roles;
	u32 rsvd;
	enum bfa_boolean preboot_vp;
	u8 tag[16];
	u8 padding[4];
};

struct bfa_lport_stats_s {
	u32 ns_plogi_sent;
	u32 ns_plogi_rsp_err;
	u32 ns_plogi_acc_err;
	u32 ns_plogi_accepts;
	u32 ns_rejects;
	u32 ns_plogi_unknown_rsp;
	u32 ns_plogi_alloc_wait;
	u32 ns_retries;
	u32 ns_timeouts;
	u32 ns_rspnid_sent;
	u32 ns_rspnid_accepts;
	u32 ns_rspnid_rsp_err;
	u32 ns_rspnid_rejects;
	u32 ns_rspnid_alloc_wait;
	u32 ns_rftid_sent;
	u32 ns_rftid_accepts;
	u32 ns_rftid_rsp_err;
	u32 ns_rftid_rejects;
	u32 ns_rftid_alloc_wait;
	u32 ns_rffid_sent;
	u32 ns_rffid_accepts;
	u32 ns_rffid_rsp_err;
	u32 ns_rffid_rejects;
	u32 ns_rffid_alloc_wait;
	u32 ns_gidft_sent;
	u32 ns_gidft_accepts;
	u32 ns_gidft_rsp_err;
	u32 ns_gidft_rejects;
	u32 ns_gidft_unknown_rsp;
	u32 ns_gidft_alloc_wait;
	u32 ns_rnnid_sent;
	u32 ns_rnnid_accepts;
	u32 ns_rnnid_rsp_err;
	u32 ns_rnnid_rejects;
	u32 ns_rnnid_alloc_wait;
	u32 ns_rsnn_nn_sent;
	u32 ns_rsnn_nn_accepts;
	u32 ns_rsnn_nn_rsp_err;
	u32 ns_rsnn_nn_rejects;
	u32 ns_rsnn_nn_alloc_wait;
	u32 ms_retries;
	u32 ms_timeouts;
	u32 ms_plogi_sent;
	u32 ms_plogi_rsp_err;
	u32 ms_plogi_acc_err;
	u32 ms_plogi_accepts;
	u32 ms_rejects;
	u32 ms_plogi_unknown_rsp;
	u32 ms_plogi_alloc_wait;
	u32 num_rscn;
	u32 num_portid_rscn;
	u32 uf_recvs;
	u32 uf_recv_drops;
	u32 plogi_rcvd;
	u32 prli_rcvd;
	u32 adisc_rcvd;
	u32 prlo_rcvd;
	u32 logo_rcvd;
	u32 rpsc_rcvd;
	u32 un_handled_els_rcvd;
	u32 rport_plogi_timeouts;
	u32 rport_del_max_plogi_retry;
};

struct bfa_vport_stats_s {
	struct bfa_lport_stats_s port_stats;
	u32 fdisc_sent;
	u32 fdisc_accepts;
	u32 fdisc_retries;
	u32 fdisc_timeouts;
	u32 fdisc_rsp_err;
	u32 fdisc_acc_bad;
	u32 fdisc_rejects;
	u32 fdisc_unknown_rsp;
	u32 fdisc_alloc_wait;
	u32 logo_alloc_wait;
	u32 logo_sent;
	u32 logo_accepts;
	u32 logo_rejects;
	u32 logo_rsp_err;
	u32 logo_unknown_rsp;
	u32 fab_no_npiv;
	u32 fab_offline;
	u32 fab_online;
	u32 fab_cleanup;
	u32 rsvd;
};

enum bfa_rport_function {
	BFA_RPORT_INITIATOR = 1,
	BFA_RPORT_TARGET = 2,
};

struct bfa_rport_symname_s {
	char symname[255];
};

struct bfa_rport_stats_s {
	u32 offlines;
	u32 onlines;
	u32 rscns;
	u32 plogis;
	u32 plogi_accs;
	u32 plogi_timeouts;
	u32 plogi_rejects;
	u32 plogi_failed;
	u32 plogi_rcvd;
	u32 prli_rcvd;
	u32 adisc_rcvd;
	u32 adisc_rejects;
	u32 adisc_sent;
	u32 adisc_accs;
	u32 adisc_failed;
	u32 adisc_rejected;
	u32 logos;
	u32 logo_accs;
	u32 logo_failed;
	u32 logo_rejected;
	u32 logo_rcvd;
	u32 rpsc_rcvd;
	u32 rpsc_rejects;
	u32 rpsc_sent;
	u32 rpsc_accs;
	u32 rpsc_failed;
	u32 rpsc_rejected;
	u32 rjt_insuff_res;
	struct bfa_rport_hal_stats_s hal_stats;
};

struct bfa_itnim_stats_s {
	u32 onlines;
	u32 offlines;
	u32 prli_sent;
	u32 fcxp_alloc_wait;
	u32 prli_rsp_err;
	u32 prli_rsp_acc;
	u32 initiator;
	u32 prli_rsp_parse_err;
	u32 prli_rsp_rjt;
	u32 timeout;
	u32 sler;
	u32 rsvd;
};

struct bfa_fcs_lport_s;

struct bfa_fcs_lport_ns_s {
	bfa_sm_t sm;
	struct bfa_timer_s timer;
	struct bfa_fcs_lport_s *port;
	struct bfa_fcxp_s *fcxp;
	struct bfa_fcxp_wqe_s fcxp_wqe;
	u8 num_rnnid_retries;
	u8 num_rsnn_nn_retries;
};

struct bfa_fcs_lport_scn_s {
	bfa_sm_t sm;
	struct bfa_timer_s timer;
	struct bfa_fcs_lport_s *port;
	struct bfa_fcxp_s *fcxp;
	struct bfa_fcxp_wqe_s fcxp_wqe;
};

struct bfa_fcs_lport_ms_s;

struct bfa_fcs_lport_fdmi_s {
	bfa_sm_t sm;
	struct bfa_timer_s timer;
	struct bfa_fcs_lport_ms_s *ms;
	struct bfa_fcxp_s *fcxp;
	struct bfa_fcxp_wqe_s fcxp_wqe;
	u8 retry_cnt;
	u8 rsvd[3];
};

struct bfa_fcs_lport_ms_s {
	bfa_sm_t sm;
	struct bfa_timer_s timer;
	struct bfa_fcs_lport_s *port;
	struct bfa_fcxp_s *fcxp;
	struct bfa_fcxp_wqe_s fcxp_wqe;
	struct bfa_fcs_lport_fdmi_s fdmi;
	u8 retry_cnt;
	u8 rsvd[3];
};

struct bfa_fcs_lport_fab_s {
	struct bfa_fcs_lport_ns_s ns;
	struct bfa_fcs_lport_scn_s scn;
	struct bfa_fcs_lport_ms_s ms;
};

struct bfa_fcs_lport_loop_s {
	u8 num_alpa;
	u8 alpabm_valid;
	u8 alpa_pos_map[127];
	struct bfa_fcs_lport_s *port;
};

struct bfa_fcs_lport_n2n_s {
	u32 rsvd;
	__be16 reply_oxid;
	wwn_t rem_port_wwn;
};

union bfa_fcs_lport_topo_u {
	struct bfa_fcs_lport_fab_s pfab;
	struct bfa_fcs_lport_loop_s ploop;
	struct bfa_fcs_lport_n2n_s pn2n;
};

struct bfa_fcs_fabric_s;

struct bfa_fcs_s;

struct bfad_port_s;

struct bfa_fcs_vport_s;

struct bfa_fcs_lport_s {
	struct list_head qe;
	bfa_sm_t sm;
	struct bfa_fcs_fabric_s *fabric;
	struct bfa_lport_cfg_s port_cfg;
	struct bfa_timer_s link_timer;
	u32 pid: 24;
	u8 lp_tag;
	u16 num_rports;
	struct list_head rport_q;
	struct bfa_fcs_s *fcs;
	union bfa_fcs_lport_topo_u port_topo;
	struct bfad_port_s *bfad_port;
	struct bfa_fcs_vport_s *vport;
	struct bfa_fcxp_s *fcxp;
	struct bfa_fcxp_wqe_s fcxp_wqe;
	struct bfa_lport_stats_s stats;
	struct bfa_wc_s wc;
};

enum bfa_fcs_fabric_type {
	BFA_FCS_FABRIC_UNKNOWN = 0,
	BFA_FCS_FABRIC_SWITCHED = 1,
	BFA_FCS_FABRIC_N2N = 2,
	BFA_FCS_FABRIC_LOOP = 3,
};

struct bfad_vf_s;

struct bfa_fcs_fabric_s {
	struct list_head qe;
	bfa_sm_t sm;
	struct bfa_fcs_s *fcs;
	struct bfa_fcs_lport_s bport;
	enum bfa_fcs_fabric_type fab_type;
	enum bfa_port_type oper_type;
	u8 is_vf;
	u8 is_npiv;
	u8 is_auth;
	u16 bb_credit;
	u16 vf_id;
	u16 num_vports;
	u16 rsvd;
	struct list_head vport_q;
	struct list_head vf_q;
	struct bfad_vf_s *vf_drv;
	struct bfa_timer_s link_timer;
	wwn_t fabric_name;
	enum bfa_boolean auth_reqd;
	struct bfa_timer_s delay_timer;
	union {
		u16 swp_vfid;
	} event_arg;
	struct bfa_wc_s wc;
	struct bfa_vf_stats_s stats;
	struct bfa_lps_s *lps;
	u8 fabric_ip_addr[16];
	struct bfa_wc_s stop_wc;
};

struct bfa_fcs_driver_info_s {
	u8 version[64];
	u8 host_machine_name[64];
	u8 host_os_name[64];
	u8 host_os_patch[64];
	u8 os_device_name[64];
};

struct bfa_fcs_stats_s {
	struct {
		u32 untagged;
		u32 tagged;
		u32 vfid_unknown;
	} uf;
};

struct bfad_s;

struct bfa_fcs_s {
	struct bfa_s *bfa;
	struct bfad_s *bfad;
	struct bfa_trc_mod_s *trcmod;
	enum bfa_boolean vf_enabled;
	enum bfa_boolean fdmi_enabled;
	enum bfa_boolean min_cfg;
	u16 port_vfid;
	struct bfa_fcs_driver_info_s driver_info;
	struct bfa_fcs_fabric_s fabric;
	struct bfa_fcs_stats_s stats;
	struct bfa_wc_s wc;
	int fcs_aen_seq;
	u32 num_rport_logins;
};

enum bfad_port_pvb_type {
	BFAD_PORT_PHYS_BASE = 0,
	BFAD_PORT_PHYS_VPORT = 1,
	BFAD_PORT_VF_BASE = 2,
	BFAD_PORT_VF_VPORT = 3,
};

struct bfad_im_port_s;

struct bfad_port_s {
	struct list_head list_entry;
	struct bfad_s *bfad;
	struct bfa_fcs_lport_s *fcs_port;
	u32 roles;
	s32 flags;
	u32 supported_fc4s;
	enum bfad_port_pvb_type pvb_type;
	struct bfad_im_port_s *im_port;
	struct dentry *port_debugfs_root;
};

struct bfad_vport_s;

struct bfa_fcs_vport_s {
	struct list_head qe;
	bfa_sm_t sm;
	struct bfa_fcs_lport_s lport;
	struct bfa_timer_s timer;
	struct bfad_vport_s *vport_drv;
	struct bfa_vport_stats_s vport_stats;
	struct bfa_lps_s *lps;
	int fdisc_retries;
};

struct bfad_vf_s {
	struct bfa_fcs_fabric_s fcs_vf;
	struct bfad_port_s base_port;
	struct bfad_s *bfad;
};

struct bfad_vport_s {
	struct bfad_port_s drv_port;
	struct bfa_fcs_vport_s fcs_vport;
	struct completion *comp_del;
	struct list_head list_entry;
};

struct bfa_fcs_rport_s;

struct bfa_fcs_rpf_s {
	bfa_sm_t sm;
	struct bfa_fcs_rport_s *rport;
	struct bfa_timer_s timer;
	struct bfa_fcxp_s *fcxp;
	struct bfa_fcxp_wqe_s fcxp_wqe;
	int rpsc_retries;
	enum bfa_port_speed rpsc_speed;
	enum bfa_port_speed assigned_speed;
};

struct bfa_fcs_tin_s;

struct bfa_fcs_iprp_s;

struct bfad_rport_s;

struct bfa_fcs_itnim_s;

struct bfa_fcs_rport_s {
	struct list_head qe;
	struct bfa_fcs_lport_s *port;
	struct bfa_fcs_s *fcs;
	struct bfad_rport_s *rp_drv;
	u32 pid;
	u32 old_pid;
	u16 maxfrsize;
	__be16 reply_oxid;
	enum fc_cos fc_cos;
	enum bfa_boolean cisc;
	enum bfa_boolean prlo;
	enum bfa_boolean plogi_pending;
	wwn_t pwwn;
	wwn_t nwwn;
	struct bfa_rport_symname_s psym_name;
	bfa_sm_t sm;
	struct bfa_timer_s timer;
	struct bfa_fcs_itnim_s *itnim;
	struct bfa_fcs_tin_s *tin;
	struct bfa_fcs_iprp_s *iprp;
	struct bfa_rport_s *bfa_rport;
	struct bfa_fcxp_s *fcxp;
	int plogi_retries;
	int ns_retries;
	struct bfa_fcxp_wqe_s fcxp_wqe;
	struct bfa_rport_stats_s stats;
	enum bfa_rport_function scsi_function;
	struct bfa_fcs_rpf_s rpf;
	enum bfa_boolean scn_online;
};

struct bfad_rport_s {
	struct bfa_fcs_rport_s fcs_rport;
};

struct bfad_itnim_s;

struct bfa_fcs_itnim_s {
	bfa_sm_t sm;
	struct bfa_fcs_rport_s *rport;
	struct bfad_itnim_s *itnim_drv;
	struct bfa_fcs_s *fcs;
	struct bfa_timer_s timer;
	struct bfa_itnim_s *bfa_itnim;
	u32 prli_retries;
	enum bfa_boolean seq_rec;
	enum bfa_boolean rec_support;
	enum bfa_boolean conf_comp;
	enum bfa_boolean task_retry_id;
	struct bfa_fcxp_wqe_s fcxp_wqe;
	struct bfa_fcxp_s *fcxp;
	struct bfa_itnim_stats_s stats;
};

enum bfad_itnim_state {
	ITNIM_STATE_NONE = 0,
	ITNIM_STATE_ONLINE = 1,
	ITNIM_STATE_OFFLINE_PENDING = 2,
	ITNIM_STATE_OFFLINE = 3,
	ITNIM_STATE_TIMEOUT = 4,
	ITNIM_STATE_FREE = 5,
};

struct bfad_im_s;

struct bfad_itnim_s {
	struct list_head list_entry;
	struct bfa_fcs_itnim_s fcs_itnim;
	struct work_struct itnim_work;
	u32 flags;
	enum bfad_itnim_state state;
	struct bfad_im_s *im;
	struct bfad_im_port_s *im_port;
	struct bfad_rport_s *drv_rport;
	struct fc_rport *fc_rport;
	struct bfa_itnim_s *bfa_itnim;
	u16 scsi_tgt_id;
	u16 channel;
	u16 queue_work;
	long unsigned int last_ramp_up_time;
	long unsigned int last_queue_full_time;
};

struct bfad_cfg_param_s {
	u32 rport_del_timeout;
	u32 ioc_queue_depth;
	u32 lun_queue_depth;
	u32 io_max_sge;
	u32 binding_method;
};

struct bfad_msix_s {
	struct bfad_s *bfad;
	struct msix_entry msix;
	char name[32];
};

union bfad_tmp_buf {
	char manufacturer[8];
	char serial_num[12];
	char model[16];
	char fw_ver[64];
	char optrom_ver[64];
	u8 chip_rev[8];
	wwn_t wwn[256];
};

struct bfad_s {
	bfa_sm_t sm;
	struct list_head list_entry;
	struct bfa_s bfa;
	struct bfa_fcs_s bfa_fcs;
	struct pci_dev *pcidev;
	const char *pci_name;
	struct bfa_pcidev_s hal_pcidev;
	struct bfa_ioc_pci_attr_s pci_attr;
	void *pci_bar0_kva;
	void *pci_bar2_kva;
	struct completion comp;
	struct completion suspend;
	struct completion enable_comp;
	struct completion disable_comp;
	enum bfa_boolean disable_active;
	struct bfad_port_s pport;
	struct bfa_meminfo_s meminfo;
	struct bfa_iocfc_cfg_s ioc_cfg;
	u32 inst_no;
	u32 bfad_flags;
	spinlock_t bfad_lock;
	struct task_struct *bfad_tsk;
	struct bfad_cfg_param_s cfg_data;
	struct bfad_msix_s msix_tab[22];
	int nvec;
	char adapter_name[64];
	char port_name[64];
	struct timer_list hal_tmo;
	long unsigned int hs_start;
	struct bfad_im_s *im;
	struct bfa_trc_mod_s *trcmod;
	struct bfa_plog_s plog_buf;
	int ref_count;
	union bfad_tmp_buf tmp_buf;
	struct fc_host_statistics link_stats;
	struct list_head pbc_vport_list;
	char *regdata;
	u32 reglen;
	struct dentry *bfad_dentry_files[5];
	struct list_head free_aen_q;
	struct list_head active_aen_q;
	struct bfa_aen_entry_s aen_list[512];
	spinlock_t bfad_aen_spinlock;
	struct list_head vport_list;
};

enum {
	BFA_TRC_LDRV_BFAD = 1,
	BFA_TRC_LDRV_IM = 2,
	BFA_TRC_LDRV_BSG = 3,
};

struct bfad_im_port_s {
	struct bfad_s *bfad;
	struct bfad_port_s *port;
	struct work_struct port_delete_work;
	int idr_id;
	u16 cur_scsi_id;
	u16 flags;
	struct list_head binding_list;
	struct Scsi_Host *shost;
	struct list_head itnim_mapped_list;
	struct fc_vport *fc_vport;
};

struct bfad_im_s {
	struct bfad_s *bfad;
	struct workqueue_struct *drv_workq;
	char drv_workq_name[20];
	struct work_struct aen_im_notify_work;
};

enum bfad_sm_event {
	BFAD_E_CREATE = 1,
	BFAD_E_KTHREAD_CREATE_FAILED = 2,
	BFAD_E_INIT = 3,
	BFAD_E_INIT_SUCCESS = 4,
	BFAD_E_HAL_INIT_FAILED = 5,
	BFAD_E_INIT_FAILED = 6,
	BFAD_E_FCS_EXIT_COMP = 7,
	BFAD_E_EXIT_COMP = 8,
	BFAD_E_STOP = 9,
};

struct bfad_hal_comp {
	enum bfa_status status;
	struct completion comp;
};

enum bfad_binding_type {
	FCP_PWWN_BINDING = 1,
	FCP_NWWN_BINDING = 2,
	FCP_FCID_BINDING = 3,
};

struct bfa_adapter_attr_s {
	char manufacturer[8];
	char serial_num[12];
	u32 card_type;
	char model[16];
	char model_descr[128];
	wwn_t pwwn;
	char node_symname[256];
	char hw_ver[64];
	char fw_ver[64];
	char optrom_ver[64];
	char os_type[64];
	struct bfa_mfg_vpd_s vpd;
	struct mac_s mac;
	u8 nports;
	u8 max_speed;
	u8 prototype;
	char asic_rev;
	u8 pcie_gen;
	u8 pcie_lanes_orig;
	u8 pcie_lanes;
	u8 cna_capable;
	u8 is_mezz;
	u8 trunk_capable;
	u8 mfg_day;
	u8 mfg_month;
	u16 mfg_year;
	u16 rsvd;
	u8 uuid[16];
};

struct bfa_ioc_driver_attr_s {
	char driver[16];
	char driver_ver[64];
	char fw_ver[64];
	char bios_ver[64];
	char efi_ver[64];
	char ob_ver[64];
};

enum bfa_ioc_state {
	BFA_IOC_UNINIT = 1,
	BFA_IOC_RESET = 2,
	BFA_IOC_SEMWAIT = 3,
	BFA_IOC_HWINIT = 4,
	BFA_IOC_GETATTR = 5,
	BFA_IOC_OPERATIONAL = 6,
	BFA_IOC_INITFAIL = 7,
	BFA_IOC_FAIL = 8,
	BFA_IOC_DISABLING = 9,
	BFA_IOC_DISABLED = 10,
	BFA_IOC_FWMISMATCH = 11,
	BFA_IOC_ENABLING = 12,
	BFA_IOC_HWFAIL = 13,
	BFA_IOC_ACQ_ADDR = 14,
};

enum bfa_ioc_type_e {
	BFA_IOC_TYPE_FC = 1,
	BFA_IOC_TYPE_FCoE = 2,
	BFA_IOC_TYPE_LL = 3,
};

struct bfa_ioc_attr_s {
	enum bfa_ioc_type_e ioc_type;
	enum bfa_ioc_state state;
	struct bfa_adapter_attr_s adapter_attr;
	struct bfa_ioc_driver_attr_s driver_attr;
	struct bfa_ioc_pci_attr_s pci_attr;
	u8 port_id;
	u8 port_mode;
	u8 cap_bm;
	u8 port_mode_cfg;
	u8 def_fn;
	u8 rsvd[3];
};

enum bfa_ioim_lun_mask_state_s {
	BFA_IOIM_LUN_MASK_INACTIVE = 0,
	BFA_IOIM_LUN_MASK_ACTIVE = 1,
	BFA_IOIM_LUN_MASK_FETCHED = 2,
};

enum bfa_lunmask_state_s {
	BFA_LUNMASK_DISABLED = 0,
	BFA_LUNMASK_ENABLED = 1,
	BFA_LUNMASK_MINCFG = 2,
	BFA_LUNMASK_UNINITIALIZED = 255,
};

enum bfi_ioim_status {
	BFI_IOIM_STS_OK = 0,
	BFI_IOIM_STS_HOST_ABORTED = 1,
	BFI_IOIM_STS_ABORTED = 2,
	BFI_IOIM_STS_TIMEDOUT = 3,
	BFI_IOIM_STS_RES_FREE = 4,
	BFI_IOIM_STS_SQER_NEEDED = 5,
	BFI_IOIM_STS_PROTO_ERR = 6,
	BFI_IOIM_STS_UTAG = 7,
	BFI_IOIM_STS_PATHTOV = 8,
};

struct bfad_itnim_data_s {
	struct bfad_itnim_s *itnim;
};

struct bfad_im_port_pointer {
	struct bfad_im_port_s *p;
};

struct bfad_fcp_binding {
	struct list_head list_entry;
	enum bfad_binding_type binding_type;
	u16 scsi_target_id;
	u32 fc_id;
	wwn_t nwwn;
	wwn_t pwwn;
};

struct fc_symname_s {
	u8 symname[256];
};

enum {
	BFI_ADAPTER_TYPE_FC = 1,
	BFI_ADAPTER_TYPE_MK = 983040,
	BFI_ADAPTER_TYPE_SH = 16,
	BFI_ADAPTER_NPORTS_MK = 65280,
	BFI_ADAPTER_NPORTS_SH = 8,
	BFI_ADAPTER_SPEED_MK = 255,
	BFI_ADAPTER_SPEED_SH = 0,
	BFI_ADAPTER_PROTO = 1048576,
	BFI_ADAPTER_TTV = 2097152,
	BFI_ADAPTER_UNSUPP = 4194304,
};

enum bfa_port_states {
	BFA_PORT_ST_UNINIT = 1,
	BFA_PORT_ST_ENABLING_QWAIT = 2,
	BFA_PORT_ST_ENABLING = 3,
	BFA_PORT_ST_LINKDOWN = 4,
	BFA_PORT_ST_LINKUP = 5,
	BFA_PORT_ST_DISABLING_QWAIT = 6,
	BFA_PORT_ST_DISABLING = 7,
	BFA_PORT_ST_DISABLED = 8,
	BFA_PORT_ST_STOPPED = 9,
	BFA_PORT_ST_IOCDOWN = 10,
	BFA_PORT_ST_IOCDIS = 11,
	BFA_PORT_ST_FWMISMATCH = 12,
	BFA_PORT_ST_PREBOOT_DISABLED = 13,
	BFA_PORT_ST_TOGGLING_QWAIT = 14,
	BFA_PORT_ST_FAA_MISCONFIG = 15,
	BFA_PORT_ST_DPORT = 16,
	BFA_PORT_ST_DDPORT = 17,
	BFA_PORT_ST_MAX_STATE = 18,
};

struct bfa_port_attr_s {
	wwn_t nwwn;
	wwn_t pwwn;
	wwn_t factorynwwn;
	wwn_t factorypwwn;
	enum fc_cos cos_supported;
	u32 rsvd;
	struct fc_symname_s port_symname;
	enum bfa_port_speed speed_supported;
	enum bfa_boolean pbind_enabled;
	struct bfa_port_cfg_s pport_cfg;
	enum bfa_port_states port_state;
	enum bfa_port_speed speed;
	enum bfa_port_topology topology;
	enum bfa_boolean beacon;
	enum bfa_boolean link_e2e_beacon;
	enum bfa_boolean bbsc_op_status;
	enum bfa_fec_state_s fec_state;
	u32 pid;
	enum bfa_port_type port_type;
	u32 loopback;
	u32 authfail;
	u16 fcoe_vlan;
	u8 rsvd1[2];
};

enum bfa_lport_state {
	BFA_LPORT_UNINIT = 0,
	BFA_LPORT_FDISC = 1,
	BFA_LPORT_ONLINE = 2,
	BFA_LPORT_OFFLINE = 3,
};

struct bfa_lport_attr_s {
	enum bfa_lport_state state;
	u32 pid;
	struct bfa_lport_cfg_s port_cfg;
	enum bfa_port_type port_type;
	u32 loopback;
	wwn_t fabric_name;
	u8 fabric_ip_addr[16];
	struct mac_s fpma_mac;
	u16 authfail;
};

struct bfa_rport_qualifier_s {
	wwn_t pwwn;
	u32 pid;
	u32 rsvd;
};

struct bfad_debug_info {
	char *debug_buffer;
	void *i_private;
	int buffer_len;
};

struct bfad_debugfs_entry {
	const char *name;
	umode_t mode;
	const struct file_operations *fops;
};

struct bfa_fw_ioc_stats_s {
	u32 enable_reqs;
	u32 disable_reqs;
	u32 get_attr_reqs;
	u32 dbg_sync;
	u32 dbg_dump;
	u32 unknown_reqs;
};

struct bfa_ioc_stats_s {
	struct bfa_ioc_drv_stats_s drv_stats;
	struct bfa_fw_ioc_stats_s fw_stats;
};

struct bfa_boot_bootlun_s {
	wwn_t pwwn;
	struct scsi_lun lun;
};

struct bfa_boot_cfg_s {
	u8 version;
	u8 rsvd1;
	u16 chksum;
	u8 enable;
	u8 speed;
	u8 topology;
	u8 bootopt;
	u32 nbluns;
	u32 rsvd2;
	struct bfa_boot_bootlun_s blun[4];
	struct bfa_boot_bootlun_s blun_disc[4];
};

struct bfa_boot_pbc_s {
	u8 enable;
	u8 speed;
	u8 topology;
	u8 rsvd1;
	u32 nbluns;
	struct bfa_boot_bootlun_s pblun[8];
};

struct bfa_ethboot_cfg_s {
	u8 version;
	u8 rsvd1;
	u16 chksum;
	u8 enable;
	u8 rsvd2;
	u16 vlan;
};

struct bfa_adapter_cfg_mode_s {
	u16 max_pf;
	u16 max_vf;
	enum bfa_mode_s mode;
};

enum bfa_flash_part_type {
	BFA_FLASH_PART_OPTROM = 1,
	BFA_FLASH_PART_FWIMG = 2,
	BFA_FLASH_PART_FWCFG = 3,
	BFA_FLASH_PART_DRV = 4,
	BFA_FLASH_PART_BOOT = 5,
	BFA_FLASH_PART_ASIC = 6,
	BFA_FLASH_PART_MFG = 7,
	BFA_FLASH_PART_OPTROM2 = 8,
	BFA_FLASH_PART_VPD = 9,
	BFA_FLASH_PART_PBC = 10,
	BFA_FLASH_PART_BOOTOVL = 11,
	BFA_FLASH_PART_LOG = 12,
	BFA_FLASH_PART_PXECFG = 13,
	BFA_FLASH_PART_PXEOVL = 14,
	BFA_FLASH_PART_PORTCFG = 15,
	BFA_FLASH_PART_ASICBK = 16,
};

struct bfa_flash_part_attr_s {
	u32 part_type;
	u32 part_instance;
	u32 part_off;
	u32 part_size;
	u32 part_len;
	u32 part_status;
	char rsv[8];
};

struct bfa_flash_attr_s {
	u32 status;
	u32 npart;
	struct bfa_flash_part_attr_s part[32];
};

struct bfa_diag_memtest_s {
	u8 algo;
	u8 rsvd[7];
};

struct bfa_diag_memtest_result {
	u32 status;
	u32 addr;
	u32 exp;
	u32 act;
	u32 err_status;
	u32 err_status1;
	u32 err_addr;
	u8 algo;
	u8 rsv[3];
};

struct bfa_diag_loopback_result_s {
	u32 numtxmfrm;
	u32 numosffrm;
	u32 numrcvfrm;
	u32 badfrminf;
	u32 badfrmnum;
	u8 status;
	u8 rsvd[3];
};

struct bfa_diag_ledtest_s {
	u32 cmd;
	u32 color;
	u16 freq;
	u8 led;
	u8 rsvd[5];
};

struct bfa_phy_attr_s {
	u32 status;
	u32 length;
	u32 fw_ver;
	u32 an_status;
	u32 pma_pmd_status;
	u32 pma_pmd_signal;
	u32 pcs_status;
};

struct bfa_phy_stats_s {
	u32 status;
	u32 link_breaks;
	u32 pma_pmd_fault;
	u32 pcs_fault;
	u32 speed_neg;
	u32 tx_eq_training;
	u32 tx_eq_timeout;
	u32 crc_error;
};

struct bfa_iocfc_attr_s {
	struct bfa_iocfc_cfg_s config;
	struct bfa_iocfc_intr_attr_s intr_attr;
};

enum bfa_qos_bw_alloc {
	BFA_QOS_BW_HIGH = 60,
	BFA_QOS_BW_MED = 30,
	BFA_QOS_BW_LOW = 10,
};

enum bfa_port_opmode {
	BFA_PORT_OPMODE_NORMAL = 0,
	BFA_PORT_OPMODE_LB_INT = 1,
	BFA_PORT_OPMODE_LB_SLW = 2,
	BFA_PORT_OPMODE_LB_EXT = 4,
	BFA_PORT_OPMODE_LB_CBL = 8,
	BFA_PORT_OPMODE_LB_NLINT = 32,
};

struct bfa_defs_fcpim_throttle_s {
	u16 max_value;
	u16 cur_value;
	u16 cfg_value;
	u16 rsvd;
};

struct bfa_vhba_attr_s {
	wwn_t nwwn;
	wwn_t pwwn;
	u32 pid;
	enum bfa_boolean io_profile;
	enum bfa_boolean plog_enabled;
	u16 path_tov;
	u8 rsvd[2];
};

struct bfa_port_cfg_mode_s {
	u16 max_pf;
	u16 max_vf;
	enum bfa_mode_s mode;
};

struct bfa_cb_pending_q_s {
	struct bfa_cb_qe_s hcb_qe;
	void *data;
};

typedef void (*fcxp_send_cb_t)(struct bfa_s *, struct bfa_fcxp_s *, void *, enum bfa_status, u32, u32, struct fchs_s *);

enum bfa_vport_state {
	BFA_FCS_VPORT_UNINIT = 0,
	BFA_FCS_VPORT_CREATED = 1,
	BFA_FCS_VPORT_OFFLINE = 1,
	BFA_FCS_VPORT_FDISC_SEND = 2,
	BFA_FCS_VPORT_FDISC = 3,
	BFA_FCS_VPORT_FDISC_RETRY = 4,
	BFA_FCS_VPORT_FDISC_RSP_WAIT = 5,
	BFA_FCS_VPORT_ONLINE = 6,
	BFA_FCS_VPORT_DELETING = 7,
	BFA_FCS_VPORT_CLEANUP = 8,
	BFA_FCS_VPORT_LOGO_SEND = 9,
	BFA_FCS_VPORT_LOGO = 10,
	BFA_FCS_VPORT_ERROR = 11,
	BFA_FCS_VPORT_MAX_STATE = 12,
};

struct bfa_vport_attr_s {
	struct bfa_lport_attr_s port_attr;
	enum bfa_vport_state vport_state;
	u32 rsvd;
};

enum bfa_rport_state {
	BFA_RPORT_UNINIT = 0,
	BFA_RPORT_OFFLINE = 1,
	BFA_RPORT_PLOGI = 2,
	BFA_RPORT_ONLINE = 3,
	BFA_RPORT_PLOGI_RETRY = 4,
	BFA_RPORT_NSQUERY = 5,
	BFA_RPORT_ADISC = 6,
	BFA_RPORT_LOGO = 7,
	BFA_RPORT_LOGORCV = 8,
	BFA_RPORT_NSDISC = 9,
};

struct bfa_rport_attr_s {
	wwn_t nwwn;
	wwn_t pwwn;
	enum fc_cos cos_supported;
	u32 pid;
	u32 df_sz;
	enum bfa_rport_state state;
	enum fc_cos fc_cos;
	enum bfa_boolean cisc;
	struct bfa_rport_symname_s symname;
	enum bfa_rport_function scsi_function;
	struct bfa_rport_qos_attr_s qos_attr;
	enum bfa_port_speed curr_speed;
	enum bfa_boolean trl_enforced;
	enum bfa_port_speed assigned_speed;
};

enum bfa_itnim_state {
	BFA_ITNIM_OFFLINE = 0,
	BFA_ITNIM_PRLI_SEND = 1,
	BFA_ITNIM_PRLI_SENT = 2,
	BFA_ITNIM_PRLI_RETRY = 3,
	BFA_ITNIM_HCB_ONLINE = 4,
	BFA_ITNIM_ONLINE = 5,
	BFA_ITNIM_HCB_OFFLINE = 6,
	BFA_ITNIM_INITIATIOR = 7,
};

struct bfa_itnim_attr_s {
	enum bfa_itnim_state state;
	u8 retry;
	u8 task_retry_id;
	u8 rec_support;
	u8 conf_comp;
};

struct bfad_buf_info {
	void *virt;
	dma_addr_t phys;
	u32 size;
};

struct bfad_fcxp {
	struct bfad_port_s *port;
	struct bfa_rport_s *bfa_rport;
	enum bfa_status req_status;
	u16 tag;
	u16 rsp_len;
	u16 rsp_maxlen;
	u8 use_ireqbuf;
	u8 use_irspbuf;
	u32 num_req_sgles;
	u32 num_rsp_sgles;
	struct fchs_s fchs;
	void *reqbuf_info;
	void *rspbuf_info;
	struct bfa_sge_s *req_sge;
	struct bfa_sge_s *rsp_sge;
	fcxp_send_cb_t send_cbfn;
	void *send_cbarg;
	void *bfa_fcxp;
	struct completion comp;
};

enum {
	IOCMD_IOC_ENABLE = 1,
	IOCMD_IOC_DISABLE = 2,
	IOCMD_IOC_GET_ATTR = 3,
	IOCMD_IOC_GET_INFO = 4,
	IOCMD_IOC_GET_STATS = 5,
	IOCMD_IOC_GET_FWSTATS = 6,
	IOCMD_IOC_RESET_STATS = 7,
	IOCMD_IOC_RESET_FWSTATS = 8,
	IOCMD_IOC_SET_ADAPTER_NAME = 9,
	IOCMD_IOC_SET_PORT_NAME = 10,
	IOCMD_IOC_FW_SIG_INV = 11,
	IOCMD_IOCFC_GET_ATTR = 12,
	IOCMD_IOCFC_SET_INTR = 13,
	IOCMD_PORT_ENABLE = 14,
	IOCMD_PORT_DISABLE = 15,
	IOCMD_PORT_GET_ATTR = 16,
	IOCMD_PORT_GET_STATS = 17,
	IOCMD_PORT_RESET_STATS = 18,
	IOCMD_PORT_CFG_TOPO = 19,
	IOCMD_PORT_CFG_SPEED = 20,
	IOCMD_PORT_CFG_ALPA = 21,
	IOCMD_PORT_CFG_MAXFRSZ = 22,
	IOCMD_PORT_CLR_ALPA = 23,
	IOCMD_PORT_BBCR_ENABLE = 24,
	IOCMD_PORT_BBCR_DISABLE = 25,
	IOCMD_PORT_BBCR_GET_ATTR = 26,
	IOCMD_LPORT_GET_ATTR = 27,
	IOCMD_LPORT_GET_RPORTS = 28,
	IOCMD_LPORT_GET_STATS = 29,
	IOCMD_LPORT_RESET_STATS = 30,
	IOCMD_LPORT_GET_IOSTATS = 31,
	IOCMD_RPORT_GET_ATTR = 32,
	IOCMD_RPORT_GET_ADDR = 33,
	IOCMD_RPORT_GET_STATS = 34,
	IOCMD_RPORT_RESET_STATS = 35,
	IOCMD_RPORT_SET_SPEED = 36,
	IOCMD_VPORT_GET_ATTR = 37,
	IOCMD_VPORT_GET_STATS = 38,
	IOCMD_VPORT_RESET_STATS = 39,
	IOCMD_FABRIC_GET_LPORTS = 40,
	IOCMD_RATELIM_ENABLE = 41,
	IOCMD_RATELIM_DISABLE = 42,
	IOCMD_RATELIM_DEF_SPEED = 43,
	IOCMD_FCPIM_FAILOVER = 44,
	IOCMD_FCPIM_MODSTATS = 45,
	IOCMD_FCPIM_MODSTATSCLR = 46,
	IOCMD_FCPIM_DEL_ITN_STATS = 47,
	IOCMD_ITNIM_GET_ATTR = 48,
	IOCMD_ITNIM_GET_IOSTATS = 49,
	IOCMD_ITNIM_RESET_STATS = 50,
	IOCMD_ITNIM_GET_ITNSTATS = 51,
	IOCMD_IOC_PCIFN_CFG = 52,
	IOCMD_FCPORT_ENABLE = 53,
	IOCMD_FCPORT_DISABLE = 54,
	IOCMD_PCIFN_CREATE = 55,
	IOCMD_PCIFN_DELETE = 56,
	IOCMD_PCIFN_BW = 57,
	IOCMD_ADAPTER_CFG_MODE = 58,
	IOCMD_PORT_CFG_MODE = 59,
	IOCMD_FLASH_ENABLE_OPTROM = 60,
	IOCMD_FLASH_DISABLE_OPTROM = 61,
	IOCMD_FAA_QUERY = 62,
	IOCMD_CEE_GET_ATTR = 63,
	IOCMD_CEE_GET_STATS = 64,
	IOCMD_CEE_RESET_STATS = 65,
	IOCMD_SFP_MEDIA = 66,
	IOCMD_SFP_SPEED = 67,
	IOCMD_FLASH_GET_ATTR = 68,
	IOCMD_FLASH_ERASE_PART = 69,
	IOCMD_FLASH_UPDATE_PART = 70,
	IOCMD_FLASH_READ_PART = 71,
	IOCMD_DIAG_TEMP = 72,
	IOCMD_DIAG_MEMTEST = 73,
	IOCMD_DIAG_LOOPBACK = 74,
	IOCMD_DIAG_FWPING = 75,
	IOCMD_DIAG_QUEUETEST = 76,
	IOCMD_DIAG_SFP = 77,
	IOCMD_DIAG_LED = 78,
	IOCMD_DIAG_BEACON_LPORT = 79,
	IOCMD_DIAG_LB_STAT = 80,
	IOCMD_PHY_GET_ATTR = 81,
	IOCMD_PHY_GET_STATS = 82,
	IOCMD_PHY_UPDATE_FW = 83,
	IOCMD_PHY_READ_FW = 84,
	IOCMD_VHBA_QUERY = 85,
	IOCMD_DEBUG_PORTLOG = 86,
	IOCMD_DEBUG_FW_CORE = 87,
	IOCMD_DEBUG_FW_STATE_CLR = 88,
	IOCMD_DEBUG_PORTLOG_CLR = 89,
	IOCMD_DEBUG_START_DTRC = 90,
	IOCMD_DEBUG_STOP_DTRC = 91,
	IOCMD_DEBUG_PORTLOG_CTL = 92,
	IOCMD_FCPIM_PROFILE_ON = 93,
	IOCMD_FCPIM_PROFILE_OFF = 94,
	IOCMD_ITNIM_GET_IOPROFILE = 95,
	IOCMD_FCPORT_GET_STATS = 96,
	IOCMD_FCPORT_RESET_STATS = 97,
	IOCMD_BOOT_CFG = 98,
	IOCMD_BOOT_QUERY = 99,
	IOCMD_PREBOOT_QUERY = 100,
	IOCMD_ETHBOOT_CFG = 101,
	IOCMD_ETHBOOT_QUERY = 102,
	IOCMD_TRUNK_ENABLE = 103,
	IOCMD_TRUNK_DISABLE = 104,
	IOCMD_TRUNK_GET_ATTR = 105,
	IOCMD_QOS_ENABLE = 106,
	IOCMD_QOS_DISABLE = 107,
	IOCMD_QOS_GET_ATTR = 108,
	IOCMD_QOS_GET_VC_ATTR = 109,
	IOCMD_QOS_GET_STATS = 110,
	IOCMD_QOS_RESET_STATS = 111,
	IOCMD_VF_GET_STATS = 112,
	IOCMD_VF_RESET_STATS = 113,
	IOCMD_FCPIM_LUNMASK_ENABLE = 114,
	IOCMD_FCPIM_LUNMASK_DISABLE = 115,
	IOCMD_FCPIM_LUNMASK_CLEAR = 116,
	IOCMD_FCPIM_LUNMASK_QUERY = 117,
	IOCMD_FCPIM_LUNMASK_ADD = 118,
	IOCMD_FCPIM_LUNMASK_DELETE = 119,
	IOCMD_DIAG_DPORT_ENABLE = 120,
	IOCMD_DIAG_DPORT_DISABLE = 121,
	IOCMD_QOS_SET_BW = 122,
	IOCMD_FCPIM_THROTTLE_QUERY = 123,
	IOCMD_FCPIM_THROTTLE_SET = 124,
	IOCMD_TFRU_READ = 125,
	IOCMD_TFRU_WRITE = 126,
	IOCMD_FRUVPD_READ = 127,
	IOCMD_FRUVPD_UPDATE = 128,
	IOCMD_FRUVPD_GET_MAX_SIZE = 129,
	IOCMD_DIAG_DPORT_SHOW = 130,
	IOCMD_DIAG_DPORT_START = 131,
};

struct bfa_bsg_gen_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
};

struct bfa_bsg_portlogctl_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	enum bfa_boolean ctl;
	int inst_no;
};

struct bfa_bsg_fcpim_profile_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
};

struct bfa_bsg_itnim_ioprofile_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t lpwwn;
	wwn_t rpwwn;
	struct bfa_itnim_ioprofile_s ioprofile;
};

struct bfa_bsg_fcport_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	union bfa_fcport_stats_u stats;
};

struct bfa_bsg_ioc_name_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	char name[64];
};

struct bfa_bsg_ioc_info_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	char serialnum[64];
	char hwpath[32];
	char adapter_hwpath[32];
	char guid[128];
	char name[64];
	char port_name[64];
	char eth_name[64];
	wwn_t pwwn;
	wwn_t nwwn;
	wwn_t factorypwwn;
	wwn_t factorynwwn;
	struct mac_s mac;
	struct mac_s factory_mac;
	struct mac_s current_mac;
	enum bfa_ioc_type_e ioc_type;
	u16 pvid;
	u16 rsvd1;
	u32 host;
	u32 bandwidth;
	u32 rsvd2;
};

struct bfa_bsg_ioc_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_ioc_attr_s ioc_attr;
};

struct bfa_bsg_ioc_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_ioc_stats_s ioc_stats;
};

struct bfa_bsg_ioc_fwstats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u32 buf_size;
	u32 rsvd1;
	u64 buf_ptr;
};

struct bfa_bsg_iocfc_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_iocfc_attr_s iocfc_attr;
};

struct bfa_bsg_iocfc_intr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_iocfc_intr_attr_s attr;
};

struct bfa_bsg_port_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_port_attr_s attr;
};

struct bfa_bsg_port_cfg_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u32 param;
	u32 rsvd1;
};

struct bfa_bsg_port_cfg_maxfrsize_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 maxfrsize;
};

struct bfa_bsg_port_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u32 buf_size;
	u32 rsvd1;
	u64 buf_ptr;
};

struct bfa_bsg_lport_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t pwwn;
	struct bfa_lport_attr_s port_attr;
};

struct bfa_bsg_lport_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t pwwn;
	struct bfa_lport_stats_s port_stats;
};

struct bfa_bsg_lport_iostats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t pwwn;
	struct bfa_itnim_iostats_s iostats;
};

struct bfa_bsg_lport_get_rports_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t pwwn;
	u64 rbuf_ptr;
	u32 nrports;
	u32 rsvd;
};

struct bfa_bsg_rport_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t pwwn;
	wwn_t rpwwn;
	u32 pid;
	u32 rsvd;
	struct bfa_rport_attr_s attr;
};

struct bfa_bsg_rport_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t pwwn;
	wwn_t rpwwn;
	struct bfa_rport_stats_s stats;
};

struct bfa_bsg_rport_scsi_addr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t pwwn;
	wwn_t rpwwn;
	u32 host;
	u32 bus;
	u32 target;
	u32 lun;
};

struct bfa_bsg_rport_reset_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t pwwn;
	wwn_t rpwwn;
};

struct bfa_bsg_rport_set_speed_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	enum bfa_port_speed speed;
	u32 rsvd;
	wwn_t pwwn;
	wwn_t rpwwn;
};

struct bfa_bsg_vport_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t vpwwn;
	struct bfa_vport_attr_s vport_attr;
};

struct bfa_bsg_vport_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t vpwwn;
	struct bfa_vport_stats_s vport_stats;
};

struct bfa_bsg_reset_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t vpwwn;
};

struct bfa_bsg_fabric_get_lports_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	u64 buf_ptr;
	u32 nports;
	u32 rsvd;
};

struct bfa_bsg_trl_speed_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	enum bfa_port_speed speed;
};

struct bfa_bsg_fcpim_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 param;
};

struct bfa_bsg_fcpim_modstats_s {
	enum bfa_status status;
	u16 bfad_num;
	struct bfa_itnim_iostats_s modstats;
};

struct bfa_bsg_fcpim_del_itn_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	struct bfa_fcpim_del_itn_stats_s modstats;
};

struct bfa_bsg_fcpim_modstatsclr_s {
	enum bfa_status status;
	u16 bfad_num;
};

struct bfa_bsg_itnim_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t lpwwn;
	wwn_t rpwwn;
	struct bfa_itnim_attr_s attr;
};

struct bfa_bsg_itnim_iostats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t lpwwn;
	wwn_t rpwwn;
	struct bfa_itnim_iostats_s iostats;
};

struct bfa_bsg_itnim_itnstats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t lpwwn;
	wwn_t rpwwn;
	struct bfa_itnim_stats_s itnstats;
};

struct bfa_bsg_pcifn_cfg_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_ablk_cfg_s pcifn_cfg;
};

struct bfa_bsg_pcifn_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 pcifn_id;
	u16 bw_min;
	u16 bw_max;
	u8 port;
	enum bfi_pcifn_class pcifn_class;
	u8 rsvd[1];
};

struct bfa_bsg_adapter_cfg_mode_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_adapter_cfg_mode_s cfg;
};

struct bfa_bsg_port_cfg_mode_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 instance;
	struct bfa_port_cfg_mode_s cfg;
};

struct bfa_bsg_bbcr_enable_s {
	enum bfa_status status;
	u16 bfad_num;
	u8 bb_scn;
	u8 rsvd;
};

struct bfa_bsg_bbcr_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_bbcr_attr_s attr;
};

struct bfa_bsg_faa_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_faa_attr_s faa_attr;
};

struct bfa_bsg_cee_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u32 buf_size;
	u32 rsvd1;
	u64 buf_ptr;
};

struct bfa_bsg_cee_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u32 buf_size;
	u32 rsvd1;
	u64 buf_ptr;
};

struct bfa_bsg_sfp_media_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	enum bfa_defs_sfp_media_e media;
};

struct bfa_bsg_sfp_speed_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	enum bfa_port_speed speed;
};

struct bfa_bsg_flash_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_flash_attr_s attr;
};

struct bfa_bsg_flash_s {
	enum bfa_status status;
	u16 bfad_num;
	u8 instance;
	u8 rsvd;
	enum bfa_flash_part_type type;
	int bufsz;
	u64 buf_ptr;
};

struct bfa_bsg_diag_get_temp_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_diag_results_tempsensor_s result;
};

struct bfa_bsg_diag_memtest_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd[3];
	u32 pat;
	struct bfa_diag_memtest_result result;
	struct bfa_diag_memtest_s memtest;
};

struct bfa_bsg_diag_loopback_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	enum bfa_port_opmode opmode;
	enum bfa_port_speed speed;
	u32 lpcnt;
	u32 pat;
	struct bfa_diag_loopback_result_s result;
};

struct bfa_bsg_diag_dport_show_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_diag_dport_result_s result;
};

struct bfa_bsg_dport_enable_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u16 lpcnt;
	u16 pat;
};

struct bfa_bsg_diag_fwping_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u32 cnt;
	u32 pattern;
	struct bfa_diag_results_fwping result;
};

struct bfa_bsg_diag_qtest_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u32 force;
	u32 queue;
	struct bfa_diag_qtest_result_s result;
};

struct bfa_bsg_sfp_show_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct sfp_mem_s sfp;
};

struct bfa_bsg_diag_led_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_diag_ledtest_s ledtest;
};

struct bfa_bsg_diag_beacon_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	enum bfa_boolean beacon;
	enum bfa_boolean link_e2e_beacon;
	u32 second;
};

struct bfa_bsg_diag_lb_stat_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
};

struct bfa_bsg_phy_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 instance;
	struct bfa_phy_attr_s attr;
};

struct bfa_bsg_phy_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 instance;
	u64 bufsz;
	u64 buf_ptr;
};

struct bfa_bsg_debug_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u32 bufsz;
	int inst_no;
	u64 buf_ptr;
	u64 offset;
};

struct bfa_bsg_phy_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 instance;
	struct bfa_phy_stats_s stats;
};

struct bfa_bsg_vhba_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 pcifn_id;
	struct bfa_vhba_attr_s attr;
};

struct bfa_bsg_boot_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_boot_cfg_s cfg;
};

struct bfa_bsg_preboot_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_boot_pbc_s cfg;
};

struct bfa_bsg_ethboot_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_ethboot_cfg_s cfg;
};

struct bfa_bsg_trunk_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_trunk_attr_s attr;
};

struct bfa_bsg_qos_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_qos_attr_s attr;
};

struct bfa_bsg_qos_vc_attr_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_qos_vc_attr_s attr;
};

struct bfa_bsg_qos_bw_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	struct bfa_qos_bw_s qos_bw;
};

struct bfa_bsg_vf_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	struct bfa_vf_stats_s stats;
};

struct bfa_bsg_vf_reset_stats_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
};

struct bfa_bsg_fcpim_lunmask_query_s {
	enum bfa_status status;
	u16 bfad_num;
	struct bfa_lunmask_cfg_s lun_mask;
	short: 16;
} __attribute__((packed));

struct bfa_bsg_fcpim_lunmask_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	wwn_t pwwn;
	wwn_t rpwwn;
	struct scsi_lun lun;
};

struct bfa_bsg_fcpim_throttle_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 vf_id;
	struct bfa_defs_fcpim_throttle_s throttle;
};

struct bfa_bsg_tfru_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u32 offset;
	u32 len;
	u8 data[64];
};

struct bfa_bsg_fruvpd_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd1;
	u32 offset;
	u32 len;
	u8 data[4096];
	u8 trfr_cmpl;
	u8 rsvd2[3];
};

struct bfa_bsg_fruvpd_max_size_s {
	enum bfa_status status;
	u16 bfad_num;
	u16 rsvd;
	u32 max_size;
};

struct bfa_bsg_fcpt_s {
	enum bfa_status status;
	u16 vf_id;
	wwn_t lpwwn;
	wwn_t dpwwn;
	u32 tsecs;
	int cts;
	enum fc_cos cos;
	struct fchs_s fchs;
};

struct bfa_bsg_data {
	int payload_len;
	u64 payload;
} __attribute__((packed));

struct bfa_sm_table_s {
	bfa_sm_t sm;
	int state;
	char *name;
};

enum {
	BFA_MFG_TYPE_CB_MAX = 825,
	BFA_MFG_TYPE_FC8P2 = 825,
	BFA_MFG_TYPE_FC8P1 = 815,
	BFA_MFG_TYPE_FC4P2 = 425,
	BFA_MFG_TYPE_FC4P1 = 415,
	BFA_MFG_TYPE_CNA10P2 = 1020,
	BFA_MFG_TYPE_CNA10P1 = 1010,
	BFA_MFG_TYPE_JAYHAWK = 804,
	BFA_MFG_TYPE_WANCHESE = 1007,
	BFA_MFG_TYPE_ASTRA = 807,
	BFA_MFG_TYPE_LIGHTNING_P0 = 902,
	BFA_MFG_TYPE_LIGHTNING = 1741,
	BFA_MFG_TYPE_PROWLER_F = 1560,
	BFA_MFG_TYPE_PROWLER_N = 1410,
	BFA_MFG_TYPE_PROWLER_C = 1710,
	BFA_MFG_TYPE_PROWLER_D = 1860,
	BFA_MFG_TYPE_CHINOOK = 1867,
	BFA_MFG_TYPE_CHINOOK2 = 1869,
	BFA_MFG_TYPE_INVALID = 0,
};

enum bfa_port_aen_event {
	BFA_PORT_AEN_ONLINE = 1,
	BFA_PORT_AEN_OFFLINE = 2,
	BFA_PORT_AEN_RLIR = 3,
	BFA_PORT_AEN_SFP_INSERT = 4,
	BFA_PORT_AEN_SFP_REMOVE = 5,
	BFA_PORT_AEN_SFP_POM = 6,
	BFA_PORT_AEN_ENABLE = 7,
	BFA_PORT_AEN_DISABLE = 8,
	BFA_PORT_AEN_AUTH_ON = 9,
	BFA_PORT_AEN_AUTH_OFF = 10,
	BFA_PORT_AEN_DISCONNECT = 11,
	BFA_PORT_AEN_QOS_NEG = 12,
	BFA_PORT_AEN_FABRIC_NAME_CHANGE = 13,
	BFA_PORT_AEN_SFP_ACCESS_ERROR = 14,
	BFA_PORT_AEN_SFP_UNSUPPORT = 15,
};

enum bfa_audit_aen_event {
	BFA_AUDIT_AEN_AUTH_ENABLE = 1,
	BFA_AUDIT_AEN_AUTH_DISABLE = 2,
	BFA_AUDIT_AEN_FLASH_ERASE = 3,
	BFA_AUDIT_AEN_FLASH_UPDATE = 4,
};

enum bfa_ioc_aen_event {
	BFA_IOC_AEN_HBGOOD = 1,
	BFA_IOC_AEN_HBFAIL = 2,
	BFA_IOC_AEN_ENABLE = 3,
	BFA_IOC_AEN_DISABLE = 4,
	BFA_IOC_AEN_FWMISMATCH = 5,
	BFA_IOC_AEN_FWCFG_ERROR = 6,
	BFA_IOC_AEN_INVALID_VENDOR = 7,
	BFA_IOC_AEN_INVALID_NWWN = 8,
	BFA_IOC_AEN_INVALID_PWWN = 9,
};

enum {
	BFA_PCI_FCOE_SSDEVICE_ID = 20,
	BFA_PCI_CT2_SSID_FCoE = 34,
	BFA_PCI_CT2_SSID_ETH = 35,
	BFA_PCI_CT2_SSID_FC = 36,
};

enum {
	SFP_XMTR_TECH_CU = 1,
	SFP_XMTR_TECH_CP = 2,
	SFP_XMTR_TECH_CA = 4,
	SFP_XMTR_TECH_LL = 8,
	SFP_XMTR_TECH_SL = 16,
	SFP_XMTR_TECH_SN = 32,
	SFP_XMTR_TECH_EL_INTRA = 64,
	SFP_XMTR_TECH_EL_INTER = 128,
	SFP_XMTR_TECH_LC = 256,
	SFP_XMTR_TECH_SA = 512,
};

union sfp_xcvr_e10g_code_u {
	u8 b;
	struct {
		u8 ib_cu_p: 1;
		u8 ib_cu_a: 1;
		u8 ib_lx: 1;
		u8 ib_sx: 1;
		u8 e10g_sr: 1;
		u8 e10g_lr: 1;
		u8 e10g_lrm: 1;
		u8 e10g_unall: 1;
	} r;
};

union sfp_xcvr_so1_code_u {
	u8 b;
	struct {
		u8 escon: 2;
		u8 oc192_reach: 1;
		u8 so_reach: 2;
		u8 oc48_reach: 3;
	} r;
};

union sfp_xcvr_so2_code_u {
	u8 b;
	struct {
		u8 reserved: 1;
		u8 oc12_reach: 3;
		u8 reserved1: 1;
		u8 oc3_reach: 3;
	} r;
};

union sfp_xcvr_eth_code_u {
	u8 b;
	struct {
		u8 base_px: 1;
		u8 base_bx10: 1;
		u8 e100base_fx: 1;
		u8 e100base_lx: 1;
		u8 e1000base_t: 1;
		u8 e1000base_cx: 1;
		u8 e1000base_lx: 1;
		u8 e1000base_sx: 1;
	} r;
};

struct sfp_xcvr_fc1_code_s {
	u8 link_len: 5;
	u8 xmtr_tech2: 3;
	u8 xmtr_tech1: 7;
	u8 reserved1: 1;
};

union sfp_xcvr_fc2_code_u {
	u8 b;
	struct {
		u8 tw_media: 1;
		u8 tp_media: 1;
		u8 mi_media: 1;
		u8 tv_media: 1;
		u8 m6_media: 1;
		u8 m5_media: 1;
		u8 reserved: 1;
		u8 sm_media: 1;
	} r;
};

union sfp_xcvr_fc3_code_u {
	u8 b;
	struct {
		u8 mb100: 1;
		u8 rsv1: 1;
		u8 mb200: 1;
		u8 rsv2: 1;
		u8 mb400: 1;
		u8 mb1600: 1;
		u8 mb800: 1;
		u8 rsv4: 1;
	} r;
};

struct sfp_xcvr_s {
	union sfp_xcvr_e10g_code_u e10g;
	union sfp_xcvr_so1_code_u so1;
	union sfp_xcvr_so2_code_u so2;
	union sfp_xcvr_eth_code_u eth;
	struct sfp_xcvr_fc1_code_s fc1;
	union sfp_xcvr_fc2_code_u fc2;
	union sfp_xcvr_fc3_code_u fc3;
};

enum bfi_ioc_h2i_msgs {
	BFI_IOC_H2I_ENABLE_REQ = 1,
	BFI_IOC_H2I_DISABLE_REQ = 2,
	BFI_IOC_H2I_GETATTR_REQ = 3,
	BFI_IOC_H2I_DBG_SYNC = 4,
	BFI_IOC_H2I_DBG_DUMP = 5,
};

enum bfi_ioc_i2h_msgs {
	BFI_IOC_I2H_ENABLE_REPLY = 129,
	BFI_IOC_I2H_DISABLE_REPLY = 130,
	BFI_IOC_I2H_GETATTR_REPLY = 131,
	BFI_IOC_I2H_HBEAT = 132,
	BFI_IOC_I2H_ACQ_ADDR_REPLY = 133,
};

struct bfi_ioc_getattr_req_s {
	struct bfi_mhdr_s mh;
	union bfi_addr_u attr_addr;
};

struct bfi_ioc_fwver_s {
	uint8_t major;
	uint8_t minor;
	uint8_t maint;
	uint8_t patch;
	uint8_t phase;
	uint8_t build;
	uint8_t rsvd[2];
};

struct bfi_ioc_image_hdr_s {
	u32 signature;
	u8 asic_gen;
	u8 asic_mode;
	u8 port0_mode;
	u8 port1_mode;
	u32 exec;
	u32 bootenv;
	u32 rsvd_b[2];
	struct bfi_ioc_fwver_s fwver;
	u32 md5sum[4];
};

enum bfi_ioc_img_ver_cmp_e {
	BFI_IOC_IMG_VER_INCOMP = 0,
	BFI_IOC_IMG_VER_OLD = 1,
	BFI_IOC_IMG_VER_SAME = 2,
	BFI_IOC_IMG_VER_BETTER = 3,
};

enum bfi_fwboot_type {
	BFI_FWBOOT_TYPE_NORMAL = 0,
	BFI_FWBOOT_TYPE_FLASH = 1,
	BFI_FWBOOT_TYPE_MEMTEST = 2,
};

struct bfi_ioc_ctrl_req_s {
	struct bfi_mhdr_s mh;
	u16 clscode;
	u16 rsvd;
	u32 tv_sec;
};

struct bfi_ioc_ctrl_reply_s {
	struct bfi_mhdr_s mh;
	u8 status;
	u8 port_mode;
	u8 cap_bm;
	u8 rsvd;
};

union bfi_ioc_i2h_msg_u {
	struct bfi_mhdr_s mh;
	struct bfi_ioc_ctrl_reply_s fw_event;
	u32 mboxmsg[8];
};

enum bfi_ablk_i2h_msgs_e {
	BFI_ABLK_I2H_QUERY = 129,
	BFI_ABLK_I2H_ADPT_CONFIG = 130,
	BFI_ABLK_I2H_PORT_CONFIG = 131,
	BFI_ABLK_I2H_PF_CREATE = 132,
	BFI_ABLK_I2H_PF_DELETE = 133,
	BFI_ABLK_I2H_PF_UPDATE = 134,
	BFI_ABLK_I2H_OPTROM_ENABLE = 135,
	BFI_ABLK_I2H_OPTROM_DISABLE = 136,
};

struct bfi_ablk_h2i_query_s {
	struct bfi_mhdr_s mh;
	union bfi_addr_u addr;
};

struct bfi_ablk_h2i_cfg_req_s {
	struct bfi_mhdr_s mh;
	u8 mode;
	u8 port;
	u8 max_pf;
	u8 max_vf;
};

struct bfi_ablk_h2i_pf_req_s {
	struct bfi_mhdr_s mh;
	u8 pcifn;
	u8 port;
	u16 pers;
	u16 bw_min;
	u16 bw_max;
};

struct bfi_ablk_h2i_optrom_s {
	struct bfi_mhdr_s mh;
};

struct bfi_ablk_i2h_rsp_s {
	struct bfi_mhdr_s mh;
	u8 status;
	u8 pcifn;
	u8 port_mode;
} __attribute__((packed));

enum bfi_sfp_i2h_e {
	BFI_SFP_I2H_SHOW = 129,
	BFI_SFP_I2H_SCN = 130,
};

struct bfi_sfp_scn_s {
	struct bfi_mhdr_s mhr;
	u8 event;
	u8 sfpid;
	u8 pomlvl;
	u8 is_elb;
};

enum bfa_sfp_stat_e {
	BFA_SFP_STATE_INIT = 0,
	BFA_SFP_STATE_REMOVED = 1,
	BFA_SFP_STATE_INSERTED = 2,
	BFA_SFP_STATE_VALID = 3,
	BFA_SFP_STATE_UNSUPPORT = 4,
	BFA_SFP_STATE_FAILED = 5,
};

struct bfi_sfp_req_s {
	struct bfi_mhdr_s mh;
	u8 memtype;
	u8 rsvd[3];
	struct bfi_alen_s alen;
};

struct bfi_sfp_rsp_s {
	struct bfi_mhdr_s mh;
	u8 status;
	u8 state;
	u8 rsvd[2];
};

enum bfi_flash_h2i_msgs {
	BFI_FLASH_H2I_QUERY_REQ = 1,
	BFI_FLASH_H2I_ERASE_REQ = 2,
	BFI_FLASH_H2I_WRITE_REQ = 3,
	BFI_FLASH_H2I_READ_REQ = 4,
	BFI_FLASH_H2I_BOOT_VER_REQ = 5,
};

enum bfi_flash_i2h_msgs {
	BFI_FLASH_I2H_QUERY_RSP = 129,
	BFI_FLASH_I2H_ERASE_RSP = 130,
	BFI_FLASH_I2H_WRITE_RSP = 131,
	BFI_FLASH_I2H_READ_RSP = 132,
	BFI_FLASH_I2H_BOOT_VER_RSP = 133,
	BFI_FLASH_I2H_EVENT = 255,
};

struct bfi_flash_query_req_s {
	struct bfi_mhdr_s mh;
	struct bfi_alen_s alen;
};

struct bfi_flash_erase_req_s {
	struct bfi_mhdr_s mh;
	u32 type;
	u8 instance;
	u8 rsv[3];
};

struct bfi_flash_write_req_s {
	struct bfi_mhdr_s mh;
	struct bfi_alen_s alen;
	u32 type;
	u8 instance;
	u8 last;
	u8 rsv[2];
	u32 offset;
	u32 length;
};

struct bfi_flash_read_req_s {
	struct bfi_mhdr_s mh;
	u32 type;
	u8 instance;
	u8 rsv[3];
	u32 offset;
	u32 length;
	struct bfi_alen_s alen;
};

struct bfi_flash_query_rsp_s {
	struct bfi_mhdr_s mh;
	u32 status;
};

struct bfi_flash_read_rsp_s {
	struct bfi_mhdr_s mh;
	u32 type;
	u8 instance;
	u8 rsv[3];
	u32 status;
	u32 length;
};

struct bfi_flash_write_rsp_s {
	struct bfi_mhdr_s mh;
	u32 type;
	u8 instance;
	u8 rsv[3];
	u32 status;
	u32 length;
};

struct bfi_flash_erase_rsp_s {
	struct bfi_mhdr_s mh;
	u32 type;
	u8 instance;
	u8 rsv[3];
	u32 status;
};

struct bfi_flash_event_s {
	struct bfi_mhdr_s mh;
	enum bfa_status status;
	u32 param;
};

enum bfi_diag_i2h {
	BFI_DIAG_I2H_PORTBEACON = 129,
	BFI_DIAG_I2H_LOOPBACK = 130,
	BFI_DIAG_I2H_FWPING = 131,
	BFI_DIAG_I2H_TEMPSENSOR = 132,
	BFI_DIAG_I2H_LEDTEST = 133,
	BFI_DIAG_I2H_QTEST = 134,
	BFI_DIAG_I2H_DPORT = 135,
	BFI_DIAG_I2H_DPORT_SCN = 136,
};

struct bfi_diag_fwping_req_s {
	struct bfi_mhdr_s mh;
	struct bfi_alen_s alen;
	u32 data;
	u32 count;
	u8 qtag;
	u8 rsv[3];
};

struct bfi_diag_fwping_rsp_s {
	struct bfi_mhdr_s mh;
	u32 data;
	u8 qtag;
	u8 dma_status;
	u8 rsv[2];
};

struct bfi_diag_ts_req_s {
	struct bfi_mhdr_s mh;
	u16 temp;
	u16 brd_temp;
	u8 status;
	u8 ts_junc;
	u8 ts_brd;
	u8 rsv;
};

struct bfi_diag_ledtest_req_s {
	struct bfi_mhdr_s mh;
	u8 cmd;
	u8 color;
	u8 portid;
	u8 led;
	u16 freq;
	u8 rsv[2];
};

struct bfi_diag_ledtest_rsp_s {
	struct bfi_mhdr_s mh;
};

struct bfi_diag_portbeacon_req_s {
	struct bfi_mhdr_s mh;
	u32 period;
	u8 beacon;
	u8 rsvd[3];
};

enum bfi_phy_h2i_msgs_e {
	BFI_PHY_H2I_QUERY_REQ = 1,
	BFI_PHY_H2I_STATS_REQ = 2,
	BFI_PHY_H2I_WRITE_REQ = 3,
	BFI_PHY_H2I_READ_REQ = 4,
};

enum bfi_phy_i2h_msgs_e {
	BFI_PHY_I2H_QUERY_RSP = 129,
	BFI_PHY_I2H_STATS_RSP = 130,
	BFI_PHY_I2H_WRITE_RSP = 131,
	BFI_PHY_I2H_READ_RSP = 132,
};

struct bfi_phy_query_req_s {
	struct bfi_mhdr_s mh;
	u8 instance;
	u8 rsv[3];
	struct bfi_alen_s alen;
};

struct bfi_phy_stats_req_s {
	struct bfi_mhdr_s mh;
	u8 instance;
	u8 rsv[3];
	struct bfi_alen_s alen;
};

struct bfi_phy_write_req_s {
	struct bfi_mhdr_s mh;
	u8 instance;
	u8 last;
	u8 rsv[2];
	u32 offset;
	u32 length;
	struct bfi_alen_s alen;
};

struct bfi_phy_read_req_s {
	struct bfi_mhdr_s mh;
	u8 instance;
	u8 rsv[3];
	u32 offset;
	u32 length;
	struct bfi_alen_s alen;
};

struct bfi_phy_query_rsp_s {
	struct bfi_mhdr_s mh;
	u32 status;
};

struct bfi_phy_stats_rsp_s {
	struct bfi_mhdr_s mh;
	u32 status;
};

struct bfi_phy_read_rsp_s {
	struct bfi_mhdr_s mh;
	u32 status;
	u32 length;
};

struct bfi_phy_write_rsp_s {
	struct bfi_mhdr_s mh;
	u32 status;
	u32 length;
};

enum bfi_fru_h2i_msgs {
	BFI_FRUVPD_H2I_WRITE_REQ = 1,
	BFI_FRUVPD_H2I_READ_REQ = 2,
	BFI_TFRU_H2I_WRITE_REQ = 3,
	BFI_TFRU_H2I_READ_REQ = 4,
};

enum bfi_fru_i2h_msgs {
	BFI_FRUVPD_I2H_WRITE_RSP = 129,
	BFI_FRUVPD_I2H_READ_RSP = 130,
	BFI_TFRU_I2H_WRITE_RSP = 131,
	BFI_TFRU_I2H_READ_RSP = 132,
};

struct bfi_fru_write_req_s {
	struct bfi_mhdr_s mh;
	u8 last;
	u8 rsv_1[3];
	u8 trfr_cmpl;
	u8 rsv_2[3];
	u32 offset;
	u32 length;
	struct bfi_alen_s alen;
};

struct bfi_fru_read_req_s {
	struct bfi_mhdr_s mh;
	u32 offset;
	u32 length;
	struct bfi_alen_s alen;
};

struct bfi_fru_rsp_s {
	struct bfi_mhdr_s mh;
	u32 status;
	u32 length;
};

enum iocfc_event {
	IOCFC_E_INIT = 1,
	IOCFC_E_START = 2,
	IOCFC_E_STOP = 3,
	IOCFC_E_ENABLE = 4,
	IOCFC_E_DISABLE = 5,
	IOCFC_E_IOC_ENABLED = 6,
	IOCFC_E_IOC_DISABLED = 7,
	IOCFC_E_IOC_FAILED = 8,
	IOCFC_E_DCONF_DONE = 9,
	IOCFC_E_CFG_DONE = 10,
};

enum {
	BFA_TRC_CNA_PORT = 1,
	BFA_TRC_CNA_IOC = 2,
	BFA_TRC_CNA_IOC_CB = 3,
	BFA_TRC_CNA_IOC_CT = 4,
};

enum ioc_event {
	IOC_E_RESET = 1,
	IOC_E_ENABLE = 2,
	IOC_E_DISABLE = 3,
	IOC_E_DETACH = 4,
	IOC_E_ENABLED = 5,
	IOC_E_FWRSP_GETATTR = 6,
	IOC_E_DISABLED = 7,
	IOC_E_PFFAILED = 8,
	IOC_E_HBFAIL = 9,
	IOC_E_HWERROR = 10,
	IOC_E_TIMEOUT = 11,
	IOC_E_HWFAILED = 12,
};

enum iocpf_event {
	IOCPF_E_ENABLE = 1,
	IOCPF_E_DISABLE = 2,
	IOCPF_E_STOP = 3,
	IOCPF_E_FWREADY = 4,
	IOCPF_E_FWRSP_ENABLE = 5,
	IOCPF_E_FWRSP_DISABLE = 6,
	IOCPF_E_FAIL = 7,
	IOCPF_E_INITFAIL = 8,
	IOCPF_E_GETATTRFAIL = 9,
	IOCPF_E_SEMLOCKED = 10,
	IOCPF_E_TIMEOUT = 11,
	IOCPF_E_SEM_ERROR = 12,
};

enum bfa_iocpf_state {
	BFA_IOCPF_RESET = 1,
	BFA_IOCPF_SEMWAIT = 2,
	BFA_IOCPF_HWINIT = 3,
	BFA_IOCPF_READY = 4,
	BFA_IOCPF_INITFAIL = 5,
	BFA_IOCPF_FAIL = 6,
	BFA_IOCPF_DISABLING = 7,
	BFA_IOCPF_DISABLED = 8,
	BFA_IOCPF_FWMISMATCH = 9,
};

enum bfa_dconf_event {
	BFA_DCONF_SM_INIT = 1,
	BFA_DCONF_SM_FLASH_COMP = 2,
	BFA_DCONF_SM_WR = 3,
	BFA_DCONF_SM_TIMEOUT = 4,
	BFA_DCONF_SM_EXIT = 5,
	BFA_DCONF_SM_IOCDISABLE = 6,
};

enum bfa_flash_cmd {
	BFA_FLASH_FAST_READ = 11,
	BFA_FLASH_READ_STATUS = 5,
};

enum bfa_flash_err {
	BFA_FLASH_NOT_PRESENT = 4294967295,
	BFA_FLASH_UNINIT = 4294967294,
	BFA_FLASH_BAD = 4294967293,
	BFA_FLASH_BUSY = 4294967292,
	BFA_FLASH_ERR_CMD_ACT = 4294967291,
	BFA_FLASH_ERR_FIFO_CNT = 4294967290,
	BFA_FLASH_ERR_WIP = 4294967289,
	BFA_FLASH_ERR_TIMEOUT = 4294967288,
	BFA_FLASH_ERR_LEN = 4294967287,
};

union bfa_flash_cmd_reg_u {
	struct {
		u32 cmd: 8;
		u32 addr_cnt: 4;
		u32 read_cnt: 9;
		u32 write_cnt: 9;
		u32 rsv: 1;
		u32 act: 1;
	} r;
	u32 i;
};

union bfa_flash_dev_status_reg_u {
	struct {
		u32 good: 1;
		u32 bad: 1;
		u32 present: 1;
		u32 init_status: 1;
		u32 busy: 1;
		u32 fifo_cnt: 6;
		u32 rsv: 21;
	} r;
	u32 i;
};

union bfa_flash_addr_reg_u {
	struct {
		u32 dummy: 8;
		u32 addr: 24;
	} r;
	u32 i;
};

enum {
	__F0_INTX_STATUS_MSIX = 0,
	__F0_INTX_STATUS_INTA = 1,
	__F0_INTX_STATUS_INTB = 2,
	__F0_INTX_STATUS_INTC = 3,
	__F0_INTX_STATUS_INTD = 4,
};

enum {
	BFI_MSIX_CPE_QMIN_CB = 0,
	BFI_MSIX_CPE_QMAX_CB = 7,
	BFI_MSIX_RME_QMIN_CB = 8,
	BFI_MSIX_RME_QMAX_CB = 15,
	BFI_MSIX_CB_MAX = 22,
};

enum {
	BFI_MSIX_LPU_ERR_CT = 0,
	BFI_MSIX_CPE_QMIN_CT = 1,
	BFI_MSIX_CPE_QMAX_CT = 4,
	BFI_MSIX_RME_QMIN_CT = 5,
	BFI_MSIX_RME_QMAX_CT = 8,
	BFI_MSIX_CT_MAX = 9,
};

enum {
	BFA_TRC_HAL_CORE = 1,
	BFA_TRC_HAL_FCXP = 2,
	BFA_TRC_HAL_FCPIM = 3,
	BFA_TRC_HAL_IOCFC_CT = 4,
	BFA_TRC_HAL_IOCFC_CB = 5,
};

enum {
	FC_RTG_FC4_DEV_DATA = 0,
	FC_RTG_EXT_LINK = 2,
	FC_RTG_FC4_LINK_DATA = 3,
	FC_RTG_VIDEO_DATA = 4,
	FC_RTG_EXT_HDR = 5,
	FC_RTG_BASIC_LINK = 8,
	FC_RTG_LINK_CTRL = 12,
};

enum {
	FC_CAT_VFT_HDR = 0,
	FC_CAT_IFR_HDR = 1,
	FC_CAT_ENC_HDR = 2,
};

enum {
	FC_MIN_WELL_KNOWN_ADDR = 16777200,
	FC_DOMAIN_CONTROLLER_MASK = 16776192,
	FC_ALIAS_SERVER = 16777208,
	FC_MGMT_SERVER = 16777210,
	FC_TIME_SERVER = 16777211,
	FC_NAME_SERVER = 16777212,
	FC_FABRIC_CONTROLLER = 16777213,
	FC_FABRIC_PORT = 16777214,
	FC_BROADCAST_SERVER = 16777215,
};

struct fc_els_cmd_s {
	u32 els_code: 8;
	u32 reserved: 24;
};

enum {
	FC_ELS_LS_RJT = 1,
	FC_ELS_ACC = 2,
	FC_ELS_PLOGI = 3,
	FC_ELS_FLOGI = 4,
	FC_ELS_LOGO = 5,
	FC_ELS_ABTX = 6,
	FC_ELS_RES = 8,
	FC_ELS_RSS = 9,
	FC_ELS_RSI = 10,
	FC_ELS_ESTC = 12,
	FC_ELS_RTV = 14,
	FC_ELS_RLS = 15,
	FC_ELS_ECHO = 16,
	FC_ELS_TEST = 17,
	FC_ELS_RRQ = 18,
	FC_ELS_REC = 19,
	FC_ELS_PRLI = 32,
	FC_ELS_PRLO = 33,
	FC_ELS_SCN = 34,
	FC_ELS_TPRLO = 36,
	FC_ELS_PDISC = 80,
	FC_ELS_FDISC = 81,
	FC_ELS_ADISC = 82,
	FC_ELS_FARP_REQ = 84,
	FC_ELS_FARP_REP = 85,
	FC_ELS_FAN = 96,
	FC_ELS_RSCN = 97,
	FC_ELS_SCR = 98,
	FC_ELS_RTIN = 119,
	FC_ELS_RNID = 120,
	FC_ELS_RLIR = 121,
	FC_ELS_RPSC = 125,
	FC_ELS_QSA = 126,
	FC_ELS_E2E_LBEACON = 129,
	FC_ELS_AUTH = 144,
	FC_ELS_RFCN = 151,
};

enum {
	FC_MIN_PDUSZ = 512,
	FC_MAX_PDUSZ = 2112,
};

struct fc_plogi_csp_s {
	u8 verhi;
	u8 verlo;
	__be16 bbcred;
	u8 reserved2: 2;
	u8 resolution: 1;
	u8 altbbcred: 1;
	u8 port_type: 1;
	u8 npiv_supp: 1;
	u8 rro: 1;
	u8 ciro: 1;
	u8 payload: 1;
	u8 cisc: 1;
	u8 dh_dup_supp: 1;
	u8 r_t_tov: 1;
	u8 sync_cap: 1;
	u8 security: 1;
	u8 query_dbc: 1;
	u8 hg_supp: 1;
	__be16 rxsz;
	__be16 conseq;
	__be16 ro_bitmap;
	__be32 e_d_tov;
};

struct fc_plogi_clp_s {
	u32 reserved2: 3;
	u32 sequential: 1;
	u32 reserved1: 2;
	u32 intermix: 1;
	u32 class_valid: 1;
	u32 reserved3: 24;
	u32 reserved4: 16;
	u32 rxsz: 16;
	u32 reserved5: 8;
	u32 conseq: 8;
	u32 e2e_credit: 16;
	u32 reserved7: 8;
	u32 ospx: 8;
	u32 reserved8: 16;
};

struct fc_logi_s {
	struct fc_els_cmd_s els_cmd;
	struct fc_plogi_csp_s csp;
	wwn_t port_name;
	wwn_t node_name;
	struct fc_plogi_clp_s class1;
	struct fc_plogi_clp_s class2;
	struct fc_plogi_clp_s class3;
	struct fc_plogi_clp_s class4;
	u8 vvl[16];
} __attribute__((packed));

struct fc_vft_s {
	u32 r_ctl: 8;
	u32 ver: 2;
	u32 type: 4;
	u32 res_a: 2;
	u32 priority: 3;
	u32 vf_id: 12;
	u32 res_b: 1;
	u32 hopct: 8;
	u32 res_c: 24;
};

enum bfa_lps_event {
	BFA_LPS_SM_LOGIN = 1,
	BFA_LPS_SM_LOGOUT = 2,
	BFA_LPS_SM_FWRSP = 3,
	BFA_LPS_SM_RESUME = 4,
	BFA_LPS_SM_DELETE = 5,
	BFA_LPS_SM_OFFLINE = 6,
	BFA_LPS_SM_RX_CVL = 7,
	BFA_LPS_SM_SET_N2N_PID = 8,
};

enum {
	BFA_TRC_FCS_FCS = 1,
	BFA_TRC_FCS_PORT = 2,
	BFA_TRC_FCS_RPORT = 3,
	BFA_TRC_FCS_FCPIM = 4,
};

enum bfa_fcs_fabric_event {
	BFA_FCS_FABRIC_SM_CREATE = 1,
	BFA_FCS_FABRIC_SM_DELETE = 2,
	BFA_FCS_FABRIC_SM_LINK_DOWN = 3,
	BFA_FCS_FABRIC_SM_LINK_UP = 4,
	BFA_FCS_FABRIC_SM_CONT_OP = 5,
	BFA_FCS_FABRIC_SM_RETRY_OP = 6,
	BFA_FCS_FABRIC_SM_NO_FABRIC = 7,
	BFA_FCS_FABRIC_SM_PERF_EVFP = 8,
	BFA_FCS_FABRIC_SM_ISOLATE = 9,
	BFA_FCS_FABRIC_SM_NO_TAGGING = 10,
	BFA_FCS_FABRIC_SM_DELAYED = 11,
	BFA_FCS_FABRIC_SM_AUTH_FAILED = 12,
	BFA_FCS_FABRIC_SM_AUTH_SUCCESS = 13,
	BFA_FCS_FABRIC_SM_DELCOMP = 14,
	BFA_FCS_FABRIC_SM_LOOPBACK = 15,
	BFA_FCS_FABRIC_SM_START = 16,
	BFA_FCS_FABRIC_SM_STOP = 17,
	BFA_FCS_FABRIC_SM_STOPCOMP = 18,
	BFA_FCS_FABRIC_SM_LOGOCOMP = 19,
};

enum {
	FC_TYPE_BLS___2 = 0,
	FC_TYPE_ELS___2 = 1,
	FC_TYPE_IP___2 = 5,
	FC_TYPE_FCP___2 = 8,
	FC_TYPE_GPP = 9,
	FC_TYPE_SERVICES = 32,
	FC_TYPE_FC_FSS = 34,
	FC_TYPE_FC_AL = 35,
	FC_TYPE_FC_SNMP = 36,
	FC_TYPE_FC_SPINFAB = 238,
	FC_TYPE_FC_DIAG = 239,
	FC_TYPE_MAX = 256,
};

struct fc_scr_s {
	u32 command: 8;
	u32 res: 24;
	u32 vu_reg_func: 8;
	u32 res1: 16;
	u32 reg_func: 8;
};

enum {
	FC_CAT_NOP = 0,
	FC_CAT_ABTS = 1,
	FC_CAT_RMC = 2,
	FC_CAT_BA_ACC = 4,
	FC_CAT_BA_RJT = 5,
	FC_CAT_PRMT = 6,
};

struct fc_ls_rjt_s {
	struct fc_els_cmd_s els_cmd;
	u32 res1: 8;
	u32 reason_code: 8;
	u32 reason_code_expl: 8;
	u32 vendor_unique: 8;
};

enum {
	FC_LS_RJT_RSN_INV_CMD_CODE = 1,
	FC_LS_RJT_RSN_LOGICAL_ERROR = 3,
	FC_LS_RJT_RSN_LOGICAL_BUSY = 5,
	FC_LS_RJT_RSN_PROTOCOL_ERROR = 7,
	FC_LS_RJT_RSN_UNABLE_TO_PERF_CMD = 9,
	FC_LS_RJT_RSN_CMD_NOT_SUPP = 11,
};

enum {
	FC_LS_RJT_EXP_NO_ADDL_INFO = 0,
	FC_LS_RJT_EXP_SPARMS_ERR_OPTIONS = 1,
	FC_LS_RJT_EXP_SPARMS_ERR_INI_CTL = 3,
	FC_LS_RJT_EXP_SPARMS_ERR_REC_CTL = 5,
	FC_LS_RJT_EXP_SPARMS_ERR_RXSZ = 7,
	FC_LS_RJT_EXP_SPARMS_ERR_CONSEQ = 9,
	FC_LS_RJT_EXP_SPARMS_ERR_CREDIT = 11,
	FC_LS_RJT_EXP_INV_PORT_NAME = 13,
	FC_LS_RJT_EXP_INV_NODE_FABRIC_NAME = 14,
	FC_LS_RJT_EXP_INV_CSP = 15,
	FC_LS_RJT_EXP_INV_ASSOC_HDR = 17,
	FC_LS_RJT_EXP_ASSOC_HDR_REQD = 19,
	FC_LS_RJT_EXP_INV_ORIG_S_ID = 21,
	FC_LS_RJT_EXP_INV_OXID_RXID_COMB = 23,
	FC_LS_RJT_EXP_CMD_ALREADY_IN_PROG = 25,
	FC_LS_RJT_EXP_LOGIN_REQUIRED = 30,
	FC_LS_RJT_EXP_INVALID_NPORT_ID = 31,
	FC_LS_RJT_EXP_INSUFF_RES = 41,
	FC_LS_RJT_EXP_CMD_NOT_SUPP = 44,
	FC_LS_RJT_EXP_INV_PAYLOAD_LEN = 45,
};

struct fc_ba_acc_s {
	u32 seq_id_valid: 8;
	u32 seq_id: 8;
	u32 res2: 16;
	u32 ox_id: 16;
	u32 rx_id: 16;
	u32 low_seq_cnt: 16;
	u32 high_seq_cnt: 16;
};

enum fc_rscn_format {
	FC_RSCN_FORMAT_PORTID = 0,
	FC_RSCN_FORMAT_AREA = 1,
	FC_RSCN_FORMAT_DOMAIN = 2,
	FC_RSCN_FORMAT_FABRIC = 3,
};

struct fc_rscn_event_s {
	u32 format: 2;
	u32 qualifier: 4;
	u32 resvd: 2;
	u32 portid: 24;
};

struct fc_rscn_pl_s {
	u8 command;
	u8 pagelen;
	__be16 payldlen;
	struct fc_rscn_event_s event[1];
};

struct fc_echo_s {
	struct fc_els_cmd_s els_cmd;
};

struct fc_rnid_cmd_s {
	struct fc_els_cmd_s els_cmd;
	u32 node_id_data_format: 8;
	u32 reserved: 24;
};

struct fc_rnid_common_id_data_s {
	wwn_t port_name;
	wwn_t node_name;
};

struct fc_rnid_general_topology_data_s {
	u32 vendor_unique[4];
	__be32 asso_type;
	u32 phy_port_num;
	__be32 num_attached_nodes;
	u32 node_mgmt: 8;
	u32 ip_version: 8;
	u32 udp_tcp_port_num: 16;
	u32 ip_address[4];
	u32 reserved: 16;
	u32 vendor_specific: 16;
};

struct fc_rnid_acc_s {
	struct fc_els_cmd_s els_cmd;
	u32 node_id_data_format: 8;
	u32 common_id_data_length: 8;
	u32 reserved: 8;
	u32 specific_id_data_length: 8;
	struct fc_rnid_common_id_data_s common_id_data;
	struct fc_rnid_general_topology_data_s gen_topology_data;
} __attribute__((packed));

struct ct_hdr_s {
	u32 rev_id: 8;
	u32 in_id: 24;
	u32 gs_type: 8;
	u32 gs_sub_type: 8;
	u32 options: 8;
	u32 rsvrd: 8;
	u32 cmd_rsp_code: 16;
	u32 max_res_size: 16;
	u32 frag_id: 8;
	u32 reason_code: 8;
	u32 exp_code: 8;
	u32 vendor_unq: 8;
};

enum {
	CT_RSP_REJECT = 32769,
	CT_RSP_ACCEPT = 32770,
};

enum {
	CT_RSN_INV_CMD = 1,
	CT_RSN_INV_VER = 2,
	CT_RSN_LOGIC_ERR = 3,
	CT_RSN_INV_SIZE = 4,
	CT_RSN_LOGICAL_BUSY = 5,
	CT_RSN_PROTO_ERR = 7,
	CT_RSN_UNABLE_TO_PERF = 9,
	CT_RSN_NOT_SUPP = 11,
	CT_RSN_SERVER_NOT_AVBL = 13,
	CT_RSN_SESSION_COULD_NOT_BE_ESTBD = 14,
	CT_RSN_VENDOR_SPECIFIC = 255,
};

enum {
	CT_NS_EXP_NOADDITIONAL = 0,
	CT_NS_EXP_ID_NOT_REG = 1,
	CT_NS_EXP_PN_NOT_REG = 2,
	CT_NS_EXP_NN_NOT_REG = 3,
	CT_NS_EXP_CS_NOT_REG = 4,
	CT_NS_EXP_IPN_NOT_REG = 5,
	CT_NS_EXP_IPA_NOT_REG = 6,
	CT_NS_EXP_FT_NOT_REG = 7,
	CT_NS_EXP_SPN_NOT_REG = 8,
	CT_NS_EXP_SNN_NOT_REG = 9,
	CT_NS_EXP_PT_NOT_REG = 10,
	CT_NS_EXP_IPP_NOT_REG = 11,
	CT_NS_EXP_FPN_NOT_REG = 12,
	CT_NS_EXP_HA_NOT_REG = 13,
	CT_NS_EXP_FD_NOT_REG = 14,
	CT_NS_EXP_FF_NOT_REG = 15,
	CT_NS_EXP_ACCESSDENIED = 16,
	CT_NS_EXP_UNACCEPTABLE_ID = 17,
	CT_NS_EXP_DATABASEEMPTY = 18,
	CT_NS_EXP_NOT_REG_IN_SCOPE = 19,
	CT_NS_EXP_DOM_ID_NOT_PRESENT = 20,
	CT_NS_EXP_PORT_NUM_NOT_PRESENT = 21,
	CT_NS_EXP_NO_DEVICE_ATTACHED = 22,
};

struct fcgs_gidft_resp_s {
	u8 last: 1;
	u8 reserved: 7;
	u32 pid: 24;
};

struct fcgs_gmal_resp_s {
	__be32 ms_len;
	u8 ms_ma[256];
};

struct fcgs_gmal_entry_s {
	u8 len;
	u8 prefix[7];
	u8 ip_addr[248];
};

enum fdmi_hba_attribute_type {
	FDMI_HBA_ATTRIB_NODENAME = 1,
	FDMI_HBA_ATTRIB_MANUFACTURER = 2,
	FDMI_HBA_ATTRIB_SERIALNUM = 3,
	FDMI_HBA_ATTRIB_MODEL = 4,
	FDMI_HBA_ATTRIB_MODEL_DESC = 5,
	FDMI_HBA_ATTRIB_HW_VERSION = 6,
	FDMI_HBA_ATTRIB_DRIVER_VERSION = 7,
	FDMI_HBA_ATTRIB_ROM_VERSION = 8,
	FDMI_HBA_ATTRIB_FW_VERSION = 9,
	FDMI_HBA_ATTRIB_OS_NAME = 10,
	FDMI_HBA_ATTRIB_MAX_CT = 11,
	FDMI_HBA_ATTRIB_NODE_SYM_NAME = 12,
	FDMI_HBA_ATTRIB_VENDOR_INFO = 13,
	FDMI_HBA_ATTRIB_NUM_PORTS = 14,
	FDMI_HBA_ATTRIB_FABRIC_NAME = 15,
	FDMI_HBA_ATTRIB_BIOS_VER = 16,
	FDMI_HBA_ATTRIB_VENDOR_ID = 224,
	FDMI_HBA_ATTRIB_MAX_TYPE = 225,
};

enum fdmi_port_attribute_type {
	FDMI_PORT_ATTRIB_FC4_TYPES = 1,
	FDMI_PORT_ATTRIB_SUPP_SPEED = 2,
	FDMI_PORT_ATTRIB_PORT_SPEED = 3,
	FDMI_PORT_ATTRIB_FRAME_SIZE = 4,
	FDMI_PORT_ATTRIB_DEV_NAME = 5,
	FDMI_PORT_ATTRIB_HOST_NAME = 6,
	FDMI_PORT_ATTRIB_NODE_NAME = 7,
	FDMI_PORT_ATTRIB_PORT_NAME = 8,
	FDMI_PORT_ATTRIB_PORT_SYM_NAME = 9,
	FDMI_PORT_ATTRIB_PORT_TYPE = 10,
	FDMI_PORT_ATTRIB_SUPP_COS = 11,
	FDMI_PORT_ATTRIB_PORT_FAB_NAME = 12,
	FDMI_PORT_ATTRIB_PORT_FC4_TYPE = 13,
	FDMI_PORT_ATTRIB_PORT_STATE = 257,
	FDMI_PORT_ATTRIB_PORT_NUM_RPRT = 258,
	FDMI_PORT_ATTR_MAX_TYPE = 259,
};

struct fdmi_attr_s {
	__be16 type;
	__be16 len;
	u8 value[1];
} __attribute__((packed));

struct fdmi_hba_attr_s {
	__be32 attr_count;
	struct fdmi_attr_s hba_attr;
} __attribute__((packed));

struct fdmi_port_list_s {
	__be32 num_ports;
	wwn_t port_entry;
} __attribute__((packed));

struct fdmi_port_attr_s {
	__be32 attr_count;
	struct fdmi_attr_s port_attr;
} __attribute__((packed));

struct fdmi_rhba_s {
	wwn_t hba_id;
	struct fdmi_port_list_s port_list;
	struct fdmi_hba_attr_s hba_attr_blk;
} __attribute__((packed));

struct fdmi_rprt_s {
	wwn_t hba_id;
	wwn_t port_name;
	struct fdmi_port_attr_s port_attr_blk;
} __attribute__((packed));

struct fdmi_rpa_s {
	wwn_t port_name;
	struct fdmi_port_attr_s port_attr_blk;
} __attribute__((packed));

enum bfa_lport_aen_event {
	BFA_LPORT_AEN_NEW = 1,
	BFA_LPORT_AEN_DELETE = 2,
	BFA_LPORT_AEN_ONLINE = 3,
	BFA_LPORT_AEN_OFFLINE = 4,
	BFA_LPORT_AEN_DISCONNECT = 5,
	BFA_LPORT_AEN_NEW_PROP = 6,
	BFA_LPORT_AEN_DELETE_PROP = 7,
	BFA_LPORT_AEN_NEW_STANDARD = 8,
	BFA_LPORT_AEN_DELETE_STANDARD = 9,
	BFA_LPORT_AEN_NPIV_DUP_WWN = 10,
	BFA_LPORT_AEN_NPIV_FABRIC_MAX = 11,
	BFA_LPORT_AEN_NPIV_UNKNOWN = 12,
};

enum bfa_lport_type {
	BFA_LPORT_TYPE_PHYSICAL = 0,
	BFA_LPORT_TYPE_VIRTUAL = 1,
};

struct bfa_lport_info_s {
	u8 port_type;
	u8 port_state;
	u8 offline_reason;
	wwn_t port_wwn;
	wwn_t node_wwn;
	u32 max_vports_supp;
	u32 num_vports_inuse;
	u32 max_rports_supp;
	u32 num_rports_inuse;
};

struct bfa_fcs_fdmi_hba_attr_s {
	wwn_t node_name;
	u8 manufacturer[64];
	u8 serial_num[64];
	u8 model[16];
	u8 model_desc[128];
	u8 hw_version[8];
	u8 driver_version[64];
	u8 option_rom_ver[64];
	u8 fw_version[64];
	u8 os_name[256];
	__be32 max_ct_pyld;
	struct bfa_lport_symname_s node_sym_name;
	u8 vendor_info[8];
	__be32 num_ports;
	wwn_t fabric_name;
	u8 bios_ver[64];
};

struct bfa_fcs_fdmi_port_attr_s {
	u8 supp_fc4_types[32];
	__be32 supp_speed;
	__be32 curr_speed;
	__be32 max_frm_size;
	u8 os_device_name[256];
	u8 host_name[256];
	wwn_t port_name;
	wwn_t node_name;
	struct bfa_lport_symname_s port_sym_name;
	__be32 port_type;
	enum fc_cos scos;
	wwn_t port_fabric_name;
	u8 port_act_fc4_type[32];
	__be32 port_state;
	__be32 num_ports;
};

enum rport_event {
	RPSM_EVENT_PLOGI_SEND = 1,
	RPSM_EVENT_PLOGI_RCVD = 2,
	RPSM_EVENT_PLOGI_COMP = 3,
	RPSM_EVENT_LOGO_RCVD = 4,
	RPSM_EVENT_LOGO_IMP = 5,
	RPSM_EVENT_FCXP_SENT = 6,
	RPSM_EVENT_DELETE = 7,
	RPSM_EVENT_FAB_SCN = 8,
	RPSM_EVENT_ACCEPTED = 9,
	RPSM_EVENT_FAILED = 10,
	RPSM_EVENT_TIMEOUT = 11,
	RPSM_EVENT_HCB_ONLINE = 12,
	RPSM_EVENT_HCB_OFFLINE = 13,
	RPSM_EVENT_FC4_OFFLINE = 14,
	RPSM_EVENT_ADDRESS_CHANGE = 15,
	RPSM_EVENT_ADDRESS_DISC = 16,
	RPSM_EVENT_PRLO_RCVD = 17,
	RPSM_EVENT_PLOGI_RETRY = 18,
	RPSM_EVENT_SCN_OFFLINE = 19,
	RPSM_EVENT_SCN_ONLINE = 20,
	RPSM_EVENT_FC4_FCS_ONLINE = 21,
};

enum fc_parse_status {
	FC_PARSE_OK = 0,
	FC_PARSE_FAILURE = 1,
	FC_PARSE_BUSY = 2,
	FC_PARSE_LEN_INVAL = 3,
	FC_PARSE_ACC_INVAL = 4,
	FC_PARSE_PWWN_NOT_EQUAL = 5,
	FC_PARSE_NWWN_NOT_EQUAL = 6,
	FC_PARSE_RXSZ_INVAL = 7,
	FC_PARSE_NOT_FCP = 8,
	FC_PARSE_OPAFLAG_INVAL = 9,
	FC_PARSE_RPAFLAG_INVAL = 10,
	FC_PARSE_OPA_INVAL = 11,
	FC_PARSE_RPA_INVAL = 12,
};

enum bfa_fcs_lport_event {
	BFA_FCS_PORT_SM_CREATE = 1,
	BFA_FCS_PORT_SM_ONLINE = 2,
	BFA_FCS_PORT_SM_OFFLINE = 3,
	BFA_FCS_PORT_SM_DELETE = 4,
	BFA_FCS_PORT_SM_DELRPORT = 5,
	BFA_FCS_PORT_SM_STOP = 6,
};

enum port_fdmi_event {
	FDMISM_EVENT_PORT_ONLINE = 1,
	FDMISM_EVENT_PORT_OFFLINE = 2,
	FDMISM_EVENT_RSP_OK = 4,
	FDMISM_EVENT_RSP_ERROR = 5,
	FDMISM_EVENT_TIMEOUT = 6,
	FDMISM_EVENT_RHBA_SENT = 7,
	FDMISM_EVENT_RPRT_SENT = 8,
	FDMISM_EVENT_RPA_SENT = 9,
};

enum port_ms_event {
	MSSM_EVENT_PORT_ONLINE = 1,
	MSSM_EVENT_PORT_OFFLINE = 2,
	MSSM_EVENT_RSP_OK = 3,
	MSSM_EVENT_RSP_ERROR = 4,
	MSSM_EVENT_TIMEOUT = 5,
	MSSM_EVENT_FCXP_SENT = 6,
	MSSM_EVENT_PORT_FABRIC_RSCN = 7,
};

enum vport_ns_event {
	NSSM_EVENT_PORT_ONLINE = 1,
	NSSM_EVENT_PORT_OFFLINE = 2,
	NSSM_EVENT_PLOGI_SENT = 3,
	NSSM_EVENT_RSP_OK = 4,
	NSSM_EVENT_RSP_ERROR = 5,
	NSSM_EVENT_TIMEOUT = 6,
	NSSM_EVENT_NS_QUERY = 7,
	NSSM_EVENT_RSPNID_SENT = 8,
	NSSM_EVENT_RFTID_SENT = 9,
	NSSM_EVENT_RFFID_SENT = 10,
	NSSM_EVENT_GIDFT_SENT = 11,
	NSSM_EVENT_RNNID_SENT = 12,
	NSSM_EVENT_RSNN_NN_SENT = 13,
};

enum port_scn_event {
	SCNSM_EVENT_PORT_ONLINE = 1,
	SCNSM_EVENT_PORT_OFFLINE = 2,
	SCNSM_EVENT_RSP_OK = 3,
	SCNSM_EVENT_RSP_ERROR = 4,
	SCNSM_EVENT_TIMEOUT = 5,
	SCNSM_EVENT_SCR_SENT = 6,
};

enum bfa_fcs_vport_event {
	BFA_FCS_VPORT_SM_CREATE = 1,
	BFA_FCS_VPORT_SM_DELETE = 2,
	BFA_FCS_VPORT_SM_START = 3,
	BFA_FCS_VPORT_SM_STOP = 4,
	BFA_FCS_VPORT_SM_ONLINE = 5,
	BFA_FCS_VPORT_SM_OFFLINE = 6,
	BFA_FCS_VPORT_SM_FRMSENT = 7,
	BFA_FCS_VPORT_SM_RSP_OK = 8,
	BFA_FCS_VPORT_SM_RSP_ERROR = 9,
	BFA_FCS_VPORT_SM_TIMEOUT = 10,
	BFA_FCS_VPORT_SM_DELCOMP = 11,
	BFA_FCS_VPORT_SM_RSP_DUP_WWN = 12,
	BFA_FCS_VPORT_SM_RSP_FAILED = 13,
	BFA_FCS_VPORT_SM_STOPCOMP = 14,
	BFA_FCS_VPORT_SM_FABRIC_MAX = 15,
};

struct fc_logo_s {
	struct fc_els_cmd_s els_cmd;
	u32 res1: 8;
	u32 nport_id: 24;
	wwn_t orig_port_name;
};

struct fc_adisc_s {
	struct fc_els_cmd_s els_cmd;
	u32 res1: 8;
	u32 orig_HA: 24;
	wwn_t orig_port_name;
	wwn_t orig_node_name;
	u32 res2: 8;
	u32 nport_id: 24;
} __attribute__((packed));

struct fc_prli_params_s {
	u32 reserved: 16;
	u32 retry: 1;
	u32 task_retry_id: 1;
	u32 rec_support: 1;
	u32 reserved1: 5;
	u32 wxrdisab: 1;
	u32 rxrdisab: 1;
	u32 drmix: 1;
	u32 cdmix: 1;
	u32 target: 1;
	u32 initiator: 1;
	u32 doverlay: 1;
	u32 confirm: 1;
};

struct fc_prli_params_page_s {
	u32 type: 8;
	u32 codext: 8;
	u32 rspcode: 4;
	u32 reserved1: 1;
	u32 imagepair: 1;
	u32 rsppav: 1;
	u32 origprocasv: 1;
	u32 reserved2: 8;
	u32 origprocas;
	u32 rspprocas;
	struct fc_prli_params_s servparams;
};

struct fc_prli_s {
	u32 command: 8;
	u32 pglen: 8;
	u32 pagebytes: 16;
	struct fc_prli_params_page_s parampage;
};

struct fc_prlo_acc_params_page_s {
	u32 type: 8;
	u32 type_ext: 8;
	u32 res1: 14;
	u32 rpa_valid: 1;
	u32 opa_valid: 1;
	u32 orig_process_assc;
	u32 resp_process_assc;
	u32 fc4type_csp;
};

struct fc_prlo_acc_s {
	u32 command: 8;
	u32 page_len: 8;
	u32 payload_len: 16;
	struct fc_prlo_acc_params_page_s prlo_acc_params[1];
};

enum fc_rpsc_speed_cap {
	RPSC_SPEED_CAP_1G = 32768,
	RPSC_SPEED_CAP_2G = 16384,
	RPSC_SPEED_CAP_4G = 8192,
	RPSC_SPEED_CAP_10G = 4096,
	RPSC_SPEED_CAP_8G = 2048,
	RPSC_SPEED_CAP_16G = 1024,
	RPSC_SPEED_CAP_UNKNOWN = 1,
};

enum fc_rpsc_op_speed {
	RPSC_OP_SPEED_1G = 32768,
	RPSC_OP_SPEED_2G = 16384,
	RPSC_OP_SPEED_4G = 8192,
	RPSC_OP_SPEED_10G = 4096,
	RPSC_OP_SPEED_8G = 2048,
	RPSC_OP_SPEED_16G = 1024,
	RPSC_OP_SPEED_NOT_EST = 1,
};

struct fc_rpsc_speed_info_s {
	__be16 port_speed_cap;
	__be16 port_op_speed;
};

struct fc_rpsc_acc_s {
	u32 command: 8;
	u32 rsvd: 8;
	u32 num_entries: 16;
	struct fc_rpsc_speed_info_s speed_info[1];
};

struct fc_rpsc2_cmd_s {
	struct fc_els_cmd_s els_cmd;
	__be32 token;
	u16 resvd;
	__be16 num_pids;
	struct {
		u32 rsvd1: 8;
		u32 pid: 24;
	} pid_list[1];
};

struct fc_rpsc2_port_info_s {
	__be32 pid;
	u16 resvd1;
	__be16 index;
	u8 resvd2;
	u8 type;
	__be16 speed;
};

struct fc_rpsc2_acc_s {
	u8 els_cmd;
	u8 resvd;
	__be16 num_pids;
	struct fc_rpsc2_port_info_s port_info[1];
};

struct fcgs_gidpn_resp_s {
	u32 rsvd: 8;
	u32 dap: 24;
};

enum bfa_rport_aen_event {
	BFA_RPORT_AEN_ONLINE = 1,
	BFA_RPORT_AEN_OFFLINE = 2,
	BFA_RPORT_AEN_DISCONNECT = 3,
	BFA_RPORT_AEN_QOS_PRIO = 4,
	BFA_RPORT_AEN_QOS_FLOWID = 5,
};

enum bfa_rport_event {
	BFA_RPORT_SM_CREATE = 1,
	BFA_RPORT_SM_DELETE = 2,
	BFA_RPORT_SM_ONLINE = 3,
	BFA_RPORT_SM_OFFLINE = 4,
	BFA_RPORT_SM_FWRSP = 5,
	BFA_RPORT_SM_HWFAIL = 6,
	BFA_RPORT_SM_QOS_SCN = 7,
	BFA_RPORT_SM_SET_SPEED = 8,
	BFA_RPORT_SM_QRESUME = 9,
};

enum bfa_fcs_itnim_event {
	BFA_FCS_ITNIM_SM_FCS_ONLINE = 1,
	BFA_FCS_ITNIM_SM_OFFLINE = 2,
	BFA_FCS_ITNIM_SM_FRMSENT = 3,
	BFA_FCS_ITNIM_SM_RSP_OK = 4,
	BFA_FCS_ITNIM_SM_RSP_ERROR = 5,
	BFA_FCS_ITNIM_SM_TIMEOUT = 6,
	BFA_FCS_ITNIM_SM_HCB_OFFLINE = 7,
	BFA_FCS_ITNIM_SM_HCB_ONLINE = 8,
	BFA_FCS_ITNIM_SM_INITIATOR = 9,
	BFA_FCS_ITNIM_SM_DELETE = 10,
	BFA_FCS_ITNIM_SM_PRLO = 11,
	BFA_FCS_ITNIM_SM_RSP_NOT_SUPP = 12,
	BFA_FCS_ITNIM_SM_HAL_ONLINE = 13,
};

enum rpf_event {
	RPFSM_EVENT_RPORT_OFFLINE = 1,
	RPFSM_EVENT_RPORT_ONLINE = 2,
	RPFSM_EVENT_FCXP_SENT = 3,
	RPFSM_EVENT_TIMEOUT = 4,
	RPFSM_EVENT_RPSC_COMP = 5,
	RPFSM_EVENT_RPSC_FAIL = 6,
	RPFSM_EVENT_RPSC_ERROR = 7,
};

enum bfa_itnim_aen_event {
	BFA_ITNIM_AEN_ONLINE = 1,
	BFA_ITNIM_AEN_OFFLINE = 2,
	BFA_ITNIM_AEN_DISCONNECT = 3,
};

enum {
	FC_CAT_LD_REQUEST = 2,
	FC_CAT_LD_REPLY = 3,
	FC_CAT_LD_DIAG = 15,
};

enum {
	FC_CAT_UNCATEG_INFO = 0,
	FC_CAT_SOLICIT_DATA = 1,
	FC_CAT_UNSOLICIT_CTRL = 2,
	FC_CAT_SOLICIT_CTRL = 3,
	FC_CAT_UNSOLICIT_DATA = 4,
	FC_CAT_DATA_DESC = 5,
	FC_CAT_UNSOLICIT_CMD = 6,
	FC_CAT_CMD_STATUS = 7,
};

enum {
	FCTL_EC_ORIG = 0,
	FCTL_EC_RESP = 8388608,
	FCTL_SEQ_INI = 0,
	FCTL_SEQ_REC = 4194304,
	FCTL_FS_EXCH = 2097152,
	FCTL_LS_EXCH = 1048576,
	FCTL_END_SEQ = 524288,
	FCTL_SI_XFER = 65536,
	FCTL_RO_PRESENT = 8,
	FCTL_FILLBYTE_MASK = 3,
};

enum {
	FC_RXID_ANY = 65535,
};

enum {
	FC_PH_VER_4_3 = 9,
	FC_PH_VER_PH_3 = 32,
};

enum {
	FC_PRLI_ACC_XQTD = 1,
	FC_PRLI_ACC_PREDEF_IMG = 5,
};

struct fc_prlo_params_page_s {
	u32 type: 8;
	u32 type_ext: 8;
	u32 res1: 14;
	u32 rpa_valid: 1;
	u32 opa_valid: 1;
	u32 orig_process_assc;
	u32 resp_process_assc;
	u32 res2;
};

struct fc_prlo_s {
	u32 command: 8;
	u32 page_len: 8;
	u32 payload_len: 16;
	struct fc_prlo_params_page_s prlo_params[1];
};

enum {
	FC_SCR_REG_FUNC_FABRIC_DETECTED = 1,
	FC_SCR_REG_FUNC_N_PORT_DETECTED = 2,
	FC_SCR_REG_FUNC_FULL = 3,
	FC_SCR_REG_FUNC_CLEAR_REG = 255,
};

enum {
	FC_VU_SCR_REG_FUNC_FABRIC_NAME_CHANGE = 1,
};

struct fc_rrq_s {
	struct fc_els_cmd_s els_cmd;
	u32 res1: 8;
	u32 s_id: 24;
	u32 ox_id: 16;
	u32 rx_id: 16;
	u32 res2[8];
};

struct fc_ba_rjt_s {
	u32 res1: 8;
	u32 reason_code: 8;
	u32 reason_expl: 8;
	u32 vendor_unique: 8;
};

struct fc_tprlo_params_page_s {
	u32 type: 8;
	u32 type_ext: 8;
	u32 res1: 12;
	u32 global_process_logout: 1;
	u32 tpo_nport_valid: 1;
	u32 rpa_valid: 1;
	u32 opa_valid: 1;
	u32 orig_process_assc;
	u32 resp_process_assc;
	u32 res2: 8;
	u32 tpo_nport_id;
} __attribute__((packed));

struct fc_tprlo_s {
	u32 command: 8;
	u32 page_len: 8;
	u32 payload_len: 16;
	struct fc_tprlo_params_page_s tprlo_params[1];
} __attribute__((packed));

enum fc_tprlo_type {
	FC_GLOBAL_LOGO = 1,
	FC_TPR_LOGO = 2,
};

struct fc_tprlo_acc_s {
	u32 command: 8;
	u32 page_len: 8;
	u32 payload_len: 16;
	struct fc_prlo_acc_params_page_s tprlo_acc_params[1];
};

struct fc_rpsc_cmd_s {
	struct fc_els_cmd_s els_cmd;
};

enum {
	CT_GS3_REVISION = 1,
};

enum {
	CT_GSTYPE_KEYSERVICE = 247,
	CT_GSTYPE_ALIASSERVICE = 248,
	CT_GSTYPE_MGMTSERVICE = 250,
	CT_GSTYPE_TIMESERVICE = 251,
	CT_GSTYPE_DIRSERVICE = 252,
};

enum {
	CT_GSSUBTYPE_NAMESERVER = 2,
};

enum {
	CT_GSSUBTYPE_CFGSERVER = 1,
	CT_GSSUBTYPE_UNZONED_NS = 2,
	CT_GSSUBTYPE_ZONESERVER = 3,
	CT_GSSUBTYPE_LOCKSERVER = 4,
	CT_GSSUBTYPE_HBA_MGMTSERVER = 16,
};

enum {
	GS_GID_PN = 289,
	GS_GPN_ID = 274,
	GS_GNN_ID = 275,
	GS_GID_FT = 369,
	GS_GSPN_ID = 280,
	GS_RFT_ID = 535,
	GS_RSPN_ID = 536,
	GS_RSNN_NN = 569,
	GS_RPN_ID = 530,
	GS_RNN_ID = 531,
	GS_RCS_ID = 532,
	GS_RPT_ID = 538,
	GS_GA_NXT = 256,
	GS_RFF_ID = 543,
};

struct fcgs_id_req_s {
	u32 rsvd: 8;
	u32 dap: 24;
};

struct fcgs_gidpn_req_s {
	wwn_t port_name;
};

struct fcgs_rftid_req_s {
	u32 rsvd: 8;
	u32 dap: 24;
	__be32 fc4_type[8];
};

struct fcgs_rffid_req_s {
	u32 rsvd: 8;
	u32 dap: 24;
	u32 rsvd1: 16;
	u32 fc4ftr_bits: 8;
	u32 fc4_type: 8;
};

struct fcgs_gidft_req_s {
	u8 reserved;
	u8 domain_id;
	u8 area_id;
	u8 fc4_type;
};

struct fcgs_rspnid_req_s {
	u32 rsvd: 8;
	u32 dap: 24;
	u8 spn_len;
	u8 spn[256];
} __attribute__((packed));

struct fcgs_rsnn_nn_req_s {
	wwn_t node_name;
	u8 snn_len;
	u8 snn[256];
} __attribute__((packed));

struct fcgs_rpnid_req_s {
	u32 rsvd: 8;
	u32 port_id: 24;
	wwn_t port_name;
} __attribute__((packed));

struct fcgs_rnnid_req_s {
	u32 rsvd: 8;
	u32 port_id: 24;
	wwn_t node_name;
} __attribute__((packed));

struct fcgs_rcsid_req_s {
	u32 rsvd: 8;
	u32 port_id: 24;
	u32 cos;
};

struct fcgs_rptid_req_s {
	u32 rsvd: 8;
	u32 port_id: 24;
	u32 port_type: 8;
	u32 rsvd1: 24;
};

struct fcgs_ganxt_req_s {
	u32 rsvd: 8;
	u32 port_id: 24;
};

enum {
	GS_FC_GFN_CMD = 276,
	GS_FC_GMAL_CMD = 278,
	GS_FC_TRACE_CMD = 1024,
	GS_FC_PING_CMD = 1025,
};

struct fcgs_req_s {
	wwn_t wwn;
};

enum bfi_port_h2i {
	BFI_PORT_H2I_ENABLE_REQ = 1,
	BFI_PORT_H2I_DISABLE_REQ = 2,
	BFI_PORT_H2I_GET_STATS_REQ = 3,
	BFI_PORT_H2I_CLEAR_STATS_REQ = 4,
};

enum bfi_port_i2h {
	BFI_PORT_I2H_ENABLE_RSP = 129,
	BFI_PORT_I2H_DISABLE_RSP = 130,
	BFI_PORT_I2H_GET_STATS_RSP = 131,
	BFI_PORT_I2H_CLEAR_STATS_RSP = 132,
};

struct bfi_port_generic_req_s {
	struct bfi_mhdr_s mh;
	u32 msgtag;
	u32 rsvd;
};

struct bfi_port_generic_rsp_s {
	struct bfi_mhdr_s mh;
	u8 status;
	u8 rsvd[3];
	u32 msgtag;
};

struct bfi_port_get_stats_req_s {
	struct bfi_mhdr_s mh;
	union bfi_addr_u dma_addr;
};

union bfi_port_i2h_msg_u {
	struct bfi_mhdr_s mh;
	struct bfi_port_generic_rsp_s enable_rsp;
	struct bfi_port_generic_rsp_s disable_rsp;
	struct bfi_port_generic_rsp_s getstats_rsp;
	struct bfi_port_generic_rsp_s clearstats_rsp;
};

enum bfi_cee_h2i_msgs_e {
	BFI_CEE_H2I_GET_CFG_REQ = 1,
	BFI_CEE_H2I_RESET_STATS = 2,
	BFI_CEE_H2I_GET_STATS_REQ = 3,
};

enum bfi_cee_i2h_msgs_e {
	BFI_CEE_I2H_GET_CFG_RSP = 129,
	BFI_CEE_I2H_RESET_STATS_RSP = 130,
	BFI_CEE_I2H_GET_STATS_RSP = 131,
};

struct bfi_cee_reset_stats_s {
	struct bfi_mhdr_s mh;
};

struct bfi_cee_get_req_s {
	struct bfi_mhdr_s mh;
	union bfi_addr_u dma_addr;
};

struct bfi_cee_get_rsp_s {
	struct bfi_mhdr_s mh;
	u8 cmd_status;
	u8 rsvd[3];
};

struct bfi_cee_stats_rsp_s {
	struct bfi_mhdr_s mh;
	u8 cmd_status;
	u8 rsvd[3];
};

union bfi_cee_i2h_msg_u {
	struct bfi_mhdr_s mh;
	struct bfi_cee_get_rsp_s get_rsp;
	struct bfi_cee_stats_rsp_s stats_rsp;
};

struct scsi_cdb_s {
	u8 scsi_cdb[16];
};

struct fcp_cmnd_s {
	struct scsi_lun lun;
	u8 crn;
	u8 taskattr: 3;
	u8 priority: 4;
	u8 resvd: 1;
	u8 tm_flags;
	u8 iodir: 2;
	u8 addl_cdb_len: 6;
	struct scsi_cdb_s cdb;
	__be32 fcp_dl;
};

enum fcp_iodir {
	FCP_IODIR_NONE = 0,
	FCP_IODIR_WRITE = 1,
	FCP_IODIR_READ = 2,
	FCP_IODIR_RW = 3,
};

enum fcp_residue {
	FCP_NO_RESIDUE = 0,
	FCP_RESID_OVER = 1,
	FCP_RESID_UNDER = 2,
};

enum {
	BFI_SGE_DATA = 0,
	BFI_SGE_DATA_CPL = 1,
	BFI_SGE_DATA_LAST = 3,
	BFI_SGE_LINK = 2,
	BFI_SGE_PGDLEN = 2,
};

enum {
	BFA_REQQ_IOC = 0,
	BFA_REQQ_FCXP = 0,
	BFA_REQQ_LPS = 0,
	BFA_REQQ_PORT = 0,
	BFA_REQQ_FLASH = 0,
	BFA_REQQ_DIAG = 0,
	BFA_REQQ_RPORT = 0,
	BFA_REQQ_SBOOT = 0,
	BFA_REQQ_QOS_LO = 1,
	BFA_REQQ_QOS_MD = 2,
	BFA_REQQ_QOS_HI = 3,
};

enum bfi_itn_h2i {
	BFI_ITN_H2I_CREATE_REQ = 1,
	BFI_ITN_H2I_DELETE_REQ = 2,
};

enum bfi_itn_i2h {
	BFI_ITN_I2H_CREATE_RSP = 129,
	BFI_ITN_I2H_DELETE_RSP = 130,
	BFI_ITN_I2H_SLER_EVENT = 131,
};

struct bfi_itn_create_req_s {
	struct bfi_mhdr_s mh;
	u16 fw_handle;
	u8 class;
	u8 seq_rec;
	u8 msg_no;
	u8 role;
};

struct bfi_itn_create_rsp_s {
	struct bfi_mhdr_s mh;
	u16 bfa_handle;
	u8 status;
	u8 seq_id;
};

struct bfi_itn_delete_req_s {
	struct bfi_mhdr_s mh;
	u16 fw_handle;
	u8 seq_id;
	u8 rsvd;
};

struct bfi_itn_delete_rsp_s {
	struct bfi_mhdr_s mh;
	u16 bfa_handle;
	u8 status;
	u8 seq_id;
};

struct bfi_itn_sler_event_s {
	struct bfi_mhdr_s mh;
	u16 bfa_handle;
	u16 rsvd;
};

union bfi_itn_i2h_msg_u {
	struct bfi_itn_create_rsp_s *create_rsp;
	struct bfi_itn_delete_rsp_s *delete_rsp;
	struct bfi_itn_sler_event_s *sler_event;
	struct bfi_msg_s *msg;
};

enum bfi_ioim_h2i {
	BFI_IOIM_H2I_IOABORT_REQ = 1,
	BFI_IOIM_H2I_IOCLEANUP_REQ = 2,
};

struct bfi_ioim_dif_s {
	u32 dif_info[4];
};

struct bfi_ioim_req_s {
	struct bfi_mhdr_s mh;
	__be16 io_tag;
	u16 rport_hdl;
	struct fcp_cmnd_s cmnd;
	struct bfi_sge_s sges[2];
	u8 io_timeout;
	u8 dif_en;
	u8 rsvd_a[2];
	struct bfi_ioim_dif_s dif;
};

struct bfi_ioim_rsp_s {
	struct bfi_mhdr_s mh;
	__be16 io_tag;
	u16 bfa_rport_hndl;
	u8 io_status;
	u8 reuse_io_tag;
	u16 abort_tag;
	u8 scsi_status;
	u8 sns_len;
	u8 resid_flags;
	u8 rsvd_a;
	__be32 residue;
	u32 rsvd_b[3];
};

struct bfi_ioim_abort_req_s {
	struct bfi_mhdr_s mh;
	__be16 io_tag;
	u16 abort_tag;
};

enum bfi_tskim_h2i {
	BFI_TSKIM_H2I_TM_REQ = 1,
	BFI_TSKIM_H2I_ABORT_REQ = 2,
};

struct bfi_tskim_req_s {
	struct bfi_mhdr_s mh;
	__be16 tsk_tag;
	u16 itn_fhdl;
	struct scsi_lun lun;
	u8 tm_flags;
	u8 t_secs;
	u8 rsvd[2];
};

struct bfi_tskim_abortreq_s {
	struct bfi_mhdr_s mh;
	__be16 tsk_tag;
	u16 rsvd;
};

struct bfi_tskim_rsp_s {
	struct bfi_mhdr_s mh;
	__be16 tsk_tag;
	u8 tsk_status;
	u8 rsvd;
};

enum bfa_ioim_lm_ua_status {
	BFA_IOIM_LM_UA_RESET = 0,
	BFA_IOIM_LM_UA_SET = 1,
};

enum bfa_itnim_event {
	BFA_ITNIM_SM_CREATE = 1,
	BFA_ITNIM_SM_ONLINE = 2,
	BFA_ITNIM_SM_OFFLINE = 3,
	BFA_ITNIM_SM_FWRSP = 4,
	BFA_ITNIM_SM_DELETE = 5,
	BFA_ITNIM_SM_CLEANUP = 6,
	BFA_ITNIM_SM_SLER = 7,
	BFA_ITNIM_SM_HWFAIL = 8,
	BFA_ITNIM_SM_QRESUME = 9,
};

enum bfa_ioim_event {
	BFA_IOIM_SM_START = 1,
	BFA_IOIM_SM_COMP_GOOD = 2,
	BFA_IOIM_SM_COMP = 3,
	BFA_IOIM_SM_COMP_UTAG = 4,
	BFA_IOIM_SM_DONE = 5,
	BFA_IOIM_SM_FREE = 6,
	BFA_IOIM_SM_ABORT = 7,
	BFA_IOIM_SM_ABORT_COMP = 8,
	BFA_IOIM_SM_ABORT_DONE = 9,
	BFA_IOIM_SM_QRESUME = 10,
	BFA_IOIM_SM_SGALLOCED = 11,
	BFA_IOIM_SM_SQRETRY = 12,
	BFA_IOIM_SM_HCB = 13,
	BFA_IOIM_SM_CLEANUP = 14,
	BFA_IOIM_SM_TMSTART = 15,
	BFA_IOIM_SM_TMDONE = 16,
	BFA_IOIM_SM_HWFAIL = 17,
	BFA_IOIM_SM_IOTOV = 18,
};

enum bfa_tskim_event {
	BFA_TSKIM_SM_START = 1,
	BFA_TSKIM_SM_DONE = 2,
	BFA_TSKIM_SM_QRESUME = 3,
	BFA_TSKIM_SM_HWFAIL = 5,
	BFA_TSKIM_SM_HCB = 6,
	BFA_TSKIM_SM_IOS_DONE = 7,
	BFA_TSKIM_SM_CLEANUP = 8,
	BFA_TSKIM_SM_CLEANUP_DONE = 9,
	BFA_TSKIM_SM_UTAG = 10,
};

typedef void (*bfa_cb_cbfn_status_t)(void *, enum bfa_status);

struct bfa_pciid_s {
	u16 device_id;
	u16 vendor_id;
};

enum bfi_iocfc_h2i_msgs {
	BFI_IOCFC_H2I_CFG_REQ = 1,
	BFI_IOCFC_H2I_SET_INTR_REQ = 2,
	BFI_IOCFC_H2I_UPDATEQ_REQ = 3,
	BFI_IOCFC_H2I_FAA_QUERY_REQ = 4,
	BFI_IOCFC_H2I_ADDR_REQ = 5,
};

enum bfi_iocfc_i2h_msgs {
	BFI_IOCFC_I2H_CFG_REPLY = 129,
	BFI_IOCFC_I2H_UPDATEQ_RSP = 131,
	BFI_IOCFC_I2H_FAA_QUERY_RSP = 132,
	BFI_IOCFC_I2H_ADDR_MSG = 133,
};

struct bfi_iocfc_cfg_req_s {
	struct bfi_mhdr_s mh;
	union bfi_addr_u ioc_cfg_dma_addr;
};

struct bfi_iocfc_cfg_reply_s {
	struct bfi_mhdr_s mh;
	u8 cfg_success;
	u8 lpu_bm;
	u8 rsvd[2];
};

struct bfi_iocfc_set_intr_req_s {
	struct bfi_mhdr_s mh;
	u8 coalesce;
	u8 rsvd[3];
	__be16 delay;
	__be16 latency;
};

struct bfi_iocfc_updateq_rsp_s {
	struct bfi_mhdr_s mh;
	u8 status;
	u8 rsvd[3];
};

union bfi_iocfc_i2h_msg_u {
	struct bfi_mhdr_s mh;
	struct bfi_iocfc_cfg_reply_s cfg_reply;
	struct bfi_iocfc_updateq_rsp_s updateq_rsp;
	u32 mboxmsg[8];
};

struct bfi_faa_addr_msg_s {
	struct bfi_mhdr_s mh;
	u8 rsvd[4];
	wwn_t pwwn;
	wwn_t nwwn;
};

struct bfi_faa_query_s {
	struct bfi_mhdr_s mh;
	u8 faa_status;
	u8 addr_source;
	u8 rsvd[2];
	wwn_t faa;
};

enum bfa_diag_dport_test_status {
	DPORT_TEST_ST_IDLE = 0,
	DPORT_TEST_ST_FINAL = 1,
	DPORT_TEST_ST_SKIP = 2,
	DPORT_TEST_ST_FAIL = 3,
	DPORT_TEST_ST_INPRG = 4,
	DPORT_TEST_ST_RESPONDER = 5,
	DPORT_TEST_ST_STOPPED = 6,
	DPORT_TEST_ST_MAX = 7,
};

enum bfa_diag_dport_test_opmode {
	BFA_DPORT_OPMODE_AUTO = 0,
	BFA_DPORT_OPMODE_MANU = 1,
};

struct bfa_diag_loopback_s {
	u32 loopcnt;
	u32 pattern;
	u8 lb_mode;
	u8 speed;
	u8 rsvd[2];
};

enum bfa_plog_log_type {
	BFA_PL_LOG_TYPE_INVALID = 0,
	BFA_PL_LOG_TYPE_INT = 1,
	BFA_PL_LOG_TYPE_STRING = 2,
};

struct bfi_diag_lb_req_s {
	struct bfi_mhdr_s mh;
	u32 loopcnt;
	u32 pattern;
	u8 lb_mode;
	u8 speed;
	u8 rsvd[2];
};

struct bfi_diag_lb_rsp_s {
	struct bfi_mhdr_s mh;
	struct bfa_diag_loopback_result_s res;
};

struct bfi_diag_qtest_req_s {
	struct bfi_mhdr_s mh;
	u32 data[31];
};

enum bfi_dport_req {
	BFI_DPORT_DISABLE = 0,
	BFI_DPORT_ENABLE = 1,
	BFI_DPORT_START = 2,
	BFI_DPORT_SHOW = 3,
	BFI_DPORT_DYN_DISABLE = 4,
};

enum bfi_dport_scn {
	BFI_DPORT_SCN_TESTSTART = 1,
	BFI_DPORT_SCN_TESTCOMP = 2,
	BFI_DPORT_SCN_SFP_REMOVED = 3,
	BFI_DPORT_SCN_DDPORT_ENABLE = 4,
	BFI_DPORT_SCN_DDPORT_DISABLE = 5,
	BFI_DPORT_SCN_FCPORT_DISABLE = 6,
	BFI_DPORT_SCN_SUBTESTSTART = 7,
	BFI_DPORT_SCN_TESTSKIP = 8,
	BFI_DPORT_SCN_DDPORT_DISABLED = 9,
};

enum bfa_qos_state {
	BFA_QOS_DISABLED = 0,
	BFA_QOS_ONLINE = 1,
	BFA_QOS_OFFLINE = 2,
};

enum bfa_bbcr_state {
	BFA_BBCR_DISABLED = 0,
	BFA_BBCR_ONLINE = 1,
	BFA_BBCR_OFFLINE = 2,
};

enum bfa_port_linkstate_rsn {
	BFA_PORT_LINKSTATE_RSN_NONE = 0,
	BFA_PORT_LINKSTATE_RSN_DISABLED = 1,
	BFA_PORT_LINKSTATE_RSN_RX_NOS = 2,
	BFA_PORT_LINKSTATE_RSN_RX_OLS = 3,
	BFA_PORT_LINKSTATE_RSN_RX_LIP = 4,
	BFA_PORT_LINKSTATE_RSN_RX_LIPF7 = 5,
	BFA_PORT_LINKSTATE_RSN_SFP_REMOVED = 6,
	BFA_PORT_LINKSTATE_RSN_PORT_FAULT = 7,
	BFA_PORT_LINKSTATE_RSN_RX_LOS = 8,
	BFA_PORT_LINKSTATE_RSN_LOCAL_FAULT = 9,
	BFA_PORT_LINKSTATE_RSN_REMOTE_FAULT = 10,
	BFA_PORT_LINKSTATE_RSN_TIMEOUT = 11,
	BFA_PORT_LINKSTATE_RSN_FAA_MISCONFIG = 12,
	CEE_LLDP_INFO_AGED_OUT = 20,
	CEE_LLDP_SHUTDOWN_TLV_RCVD = 21,
	CEE_PEER_NOT_ADVERTISE_DCBX = 22,
	CEE_PEER_NOT_ADVERTISE_PG = 23,
	CEE_PEER_NOT_ADVERTISE_PFC = 24,
	CEE_PEER_NOT_ADVERTISE_FCOE = 25,
	CEE_PG_NOT_COMPATIBLE = 26,
	CEE_PFC_NOT_COMPATIBLE = 27,
	CEE_FCOE_NOT_COMPATIBLE = 28,
	CEE_BAD_PG_RCVD = 29,
	CEE_BAD_BW_RCVD = 30,
	CEE_BAD_PFC_RCVD = 31,
	CEE_BAD_APP_PRI_RCVD = 32,
	CEE_FCOE_PRI_PFC_OFF = 33,
	CEE_DUP_CONTROL_TLV_RCVD = 34,
	CEE_DUP_FEAT_TLV_RCVD = 35,
	CEE_APPLY_NEW_CFG = 36,
	CEE_PROTOCOL_INIT = 37,
	CEE_PHY_LINK_DOWN = 38,
	CEE_LLS_FCOE_ABSENT = 39,
	CEE_LLS_FCOE_DOWN = 40,
	CEE_ISCSI_NOT_COMPATIBLE = 41,
	CEE_ISCSI_PRI_PFC_OFF = 42,
	CEE_ISCSI_PRI_OVERLAP_FCOE_PRI = 43,
};

enum bfi_fcport_h2i {
	BFI_FCPORT_H2I_ENABLE_REQ = 1,
	BFI_FCPORT_H2I_DISABLE_REQ = 2,
	BFI_FCPORT_H2I_SET_SVC_PARAMS_REQ = 3,
	BFI_FCPORT_H2I_STATS_GET_REQ = 4,
	BFI_FCPORT_H2I_STATS_CLEAR_REQ = 5,
};

enum bfi_fcport_i2h {
	BFI_FCPORT_I2H_ENABLE_RSP = 129,
	BFI_FCPORT_I2H_DISABLE_RSP = 130,
	BFI_FCPORT_I2H_SET_SVC_PARAMS_RSP = 131,
	BFI_FCPORT_I2H_STATS_GET_RSP = 132,
	BFI_FCPORT_I2H_STATS_CLEAR_RSP = 133,
	BFI_FCPORT_I2H_EVENT = 134,
	BFI_FCPORT_I2H_TRUNK_SCN = 135,
	BFI_FCPORT_I2H_ENABLE_AEN = 136,
	BFI_FCPORT_I2H_DISABLE_AEN = 137,
};

struct bfi_fcport_req_s {
	struct bfi_mhdr_s mh;
	u32 msgtag;
};

struct bfi_fcport_enable_req_s {
	struct bfi_mhdr_s mh;
	u32 rsvd1;
	wwn_t nwwn;
	wwn_t pwwn;
	struct bfa_port_cfg_s port_cfg;
	union bfi_addr_u stats_dma_addr;
	u32 msgtag;
	u8 use_flash_cfg;
	u8 rsvd2[3];
};

enum bfi_fcxp_h2i {
	BFI_FCXP_H2I_SEND_REQ = 1,
};

enum bfi_fcxp_i2h {
	BFI_FCXP_I2H_SEND_RSP = 129,
};

struct bfi_fcxp_send_req_s {
	struct bfi_mhdr_s mh;
	__be16 fcxp_tag;
	__be16 max_frmsz;
	__be16 vf_id;
	u16 rport_fw_hndl;
	u8 class;
	u8 rsp_timeout;
	u8 cts;
	u8 lp_fwtag;
	struct fchs_s fchs;
	__be32 req_len;
	__be32 rsp_maxlen;
	struct bfi_alen_s req_alen;
	struct bfi_alen_s rsp_alen;
};

struct bfi_fcxp_send_rsp_s {
	struct bfi_mhdr_s mh;
	__be16 fcxp_tag;
	u8 req_status;
	u8 rsvd;
	__be32 rsp_len;
	__be32 residue_len;
	struct fchs_s fchs;
};

enum bfi_uf_h2i {
	BFI_UF_H2I_BUF_POST = 1,
};

enum bfi_uf_i2h {
	BFI_UF_I2H_FRM_RCVD = 129,
};

struct bfi_uf_frm_rcvd_s {
	struct bfi_mhdr_s mh;
	u16 buf_tag;
	u16 rsvd;
	u16 frm_len;
	u16 xfr_len;
};

enum bfi_lps_h2i_msgs {
	BFI_LPS_H2I_LOGIN_REQ = 1,
	BFI_LPS_H2I_LOGOUT_REQ = 2,
	BFI_LPS_H2I_N2N_PID_REQ = 3,
};

enum bfi_lps_i2h_msgs {
	BFI_LPS_I2H_LOGIN_RSP = 129,
	BFI_LPS_I2H_LOGOUT_RSP = 130,
	BFI_LPS_I2H_CVL_EVENT = 131,
};

struct bfi_lps_login_req_s {
	struct bfi_mhdr_s mh;
	u8 bfa_tag;
	u8 alpa;
	__be16 pdu_size;
	wwn_t pwwn;
	wwn_t nwwn;
	u8 fdisc;
	u8 auth_en;
	u8 lps_role;
	u8 bb_scn;
	u32 vvl_flag;
};

struct bfi_lps_logout_req_s {
	struct bfi_mhdr_s mh;
	u8 fw_tag;
	u8 rsvd[3];
	wwn_t port_name;
};

struct bfi_lps_logout_rsp_s {
	struct bfi_mhdr_s mh;
	u8 bfa_tag;
	u8 status;
	u8 rsvd[2];
};

struct bfi_lps_cvl_event_s {
	struct bfi_mhdr_s mh;
	u8 bfa_tag;
	u8 rsvd[3];
};

struct bfi_lps_n2n_pid_req_s {
	struct bfi_mhdr_s mh;
	u8 fw_tag;
	u32 lp_pid: 24;
};

union bfi_lps_i2h_msg_u {
	struct bfi_msg_s *msg;
	struct bfi_lps_login_rsp_s *login_rsp;
	struct bfi_lps_logout_rsp_s *logout_rsp;
	struct bfi_lps_cvl_event_s *cvl_event;
};

enum bfi_rport_h2i_msgs {
	BFI_RPORT_H2I_CREATE_REQ = 1,
	BFI_RPORT_H2I_DELETE_REQ = 2,
	BFI_RPORT_H2I_SET_SPEED_REQ = 3,
};

enum bfi_rport_i2h_msgs {
	BFI_RPORT_I2H_CREATE_RSP = 129,
	BFI_RPORT_I2H_DELETE_RSP = 130,
	BFI_RPORT_I2H_QOS_SCN = 131,
	BFI_RPORT_I2H_LIP_SCN_ONLINE = 132,
	BFI_RPORT_I2H_LIP_SCN_OFFLINE = 133,
	BFI_RPORT_I2H_NO_DEV = 134,
};

struct bfi_rport_create_req_s {
	struct bfi_mhdr_s mh;
	u16 bfa_handle;
	__be16 max_frmsz;
	u32 pid: 24;
	u32 lp_fwtag: 8;
	u32 local_pid: 24;
	u32 cisc: 8;
	u8 fc_class;
	u8 vf_en;
	u16 vf_id;
};

struct bfi_rport_create_rsp_s {
	struct bfi_mhdr_s mh;
	u8 status;
	u8 rsvd[3];
	u16 bfa_handle;
	u16 fw_handle;
	struct bfa_rport_qos_attr_s qos_attr;
};

struct bfa_rport_speed_req_s {
	struct bfi_mhdr_s mh;
	u16 fw_handle;
	u8 speed;
	u8 rsvd;
};

struct bfi_rport_delete_req_s {
	struct bfi_mhdr_s mh;
	u16 fw_handle;
	u16 rsvd;
};

struct bfi_rport_delete_rsp_s {
	struct bfi_mhdr_s mh;
	u16 bfa_handle;
	u8 status;
	u8 rsvd;
};

struct bfi_rport_qos_scn_s {
	struct bfi_mhdr_s mh;
	u16 bfa_handle;
	u16 rsvd;
	struct bfa_rport_qos_attr_s old_qos_attr;
	struct bfa_rport_qos_attr_s new_qos_attr;
};

struct bfi_rport_lip_scn_s {
	struct bfi_mhdr_s mh;
	u16 bfa_handle;
	u8 status;
	u8 rsvd;
	struct bfa_fcport_loop_info_s loop_info;
};

union bfi_rport_i2h_msg_u {
	struct bfi_msg_s *msg;
	struct bfi_rport_create_rsp_s *create_rsp;
	struct bfi_rport_delete_rsp_s *delete_rsp;
	struct bfi_rport_qos_scn_s *qos_scn_evt;
	struct bfi_rport_lip_scn_s *lip_scn;
};

struct bfa_uf_buf_s {
	u8 d[2304];
};

enum bfa_fcport_sm_event {
	BFA_FCPORT_SM_START = 1,
	BFA_FCPORT_SM_STOP = 2,
	BFA_FCPORT_SM_ENABLE = 3,
	BFA_FCPORT_SM_DISABLE = 4,
	BFA_FCPORT_SM_FWRSP = 5,
	BFA_FCPORT_SM_LINKUP = 6,
	BFA_FCPORT_SM_LINKDOWN = 7,
	BFA_FCPORT_SM_QRESUME = 8,
	BFA_FCPORT_SM_HWFAIL = 9,
	BFA_FCPORT_SM_DPORTENABLE = 10,
	BFA_FCPORT_SM_DPORTDISABLE = 11,
	BFA_FCPORT_SM_FAA_MISCONFIG = 12,
	BFA_FCPORT_SM_DDPORTENABLE = 13,
	BFA_FCPORT_SM_DDPORTDISABLE = 14,
};

enum bfa_fcport_ln_sm_event {
	BFA_FCPORT_LN_SM_LINKUP = 1,
	BFA_FCPORT_LN_SM_LINKDOWN = 2,
	BFA_FCPORT_LN_SM_NOTIFICATION = 3,
};

enum bfa_dport_test_state_e {
	BFA_DPORT_ST_DISABLED = 0,
	BFA_DPORT_ST_INP = 1,
	BFA_DPORT_ST_COMP = 2,
	BFA_DPORT_ST_NO_SFP = 3,
	BFA_DPORT_ST_NOTSTART = 4,
};

enum bfa_dport_sm_event {
	BFA_DPORT_SM_ENABLE = 1,
	BFA_DPORT_SM_DISABLE = 2,
	BFA_DPORT_SM_FWRSP = 3,
	BFA_DPORT_SM_QRESUME = 4,
	BFA_DPORT_SM_HWFAIL = 5,
	BFA_DPORT_SM_START = 6,
	BFA_DPORT_SM_REQFAIL = 7,
	BFA_DPORT_SM_SCN = 8,
};

struct mbox_out {
	u8 cmd;
	u8 cmdid;
	u16 numsectors;
	u32 lba;
	u32 xferaddr;
	u8 logdrv;
	u8 numsgelements;
	u8 resvd;
} __attribute__((packed));

struct mbox_in {
	volatile u8 busy;
	volatile u8 numstatus;
	volatile u8 status;
	volatile u8 completed[46];
	volatile u8 poll;
	volatile u8 ack;
};

typedef struct {
	struct mbox_out m_out;
	struct mbox_in m_in;
} __attribute__((packed)) mbox_t;

typedef struct {
	u32 xfer_segment_lo;
	u32 xfer_segment_hi;
	mbox_t mbox;
} __attribute__((packed)) mbox64_t;

typedef struct {
	u8 timeout: 3;
	u8 ars: 1;
	u8 reserved: 3;
	u8 islogical: 1;
	u8 logdrv;
	u8 channel;
	u8 target;
	u8 queuetag;
	u8 queueaction;
	u8 cdb[10];
	u8 cdblen;
	u8 reqsenselen;
	u8 reqsensearea[32];
	u8 numsgelements;
	u8 scsistatus;
	u32 dataxferaddr;
	u32 dataxferlen;
} mega_passthru;

typedef struct {
	u8 timeout: 3;
	u8 ars: 1;
	u8 rsvd1: 1;
	u8 cd_rom: 1;
	u8 rsvd2: 1;
	u8 islogical: 1;
	u8 logdrv;
	u8 channel;
	u8 target;
	u8 queuetag;
	u8 queueaction;
	u8 cdblen;
	u8 rsvd3;
	u8 cdb[16];
	u8 numsgelements;
	u8 status;
	u8 reqsenselen;
	u8 reqsensearea[32];
	u8 rsvd4;
	u32 dataxferaddr;
	u32 dataxferlen;
} mega_ext_passthru;

typedef struct {
	u64 address;
	u32 length;
} __attribute__((packed)) mega_sgl64;

typedef struct {
	u32 address;
	u32 length;
} mega_sglist;

typedef struct {
	int idx;
	u32 state;
	struct list_head list;
	u8 raw_mbox[66];
	u32 dma_type;
	u32 dma_direction;
	struct scsi_cmnd *cmd;
	dma_addr_t dma_h_bulkdata;
	dma_addr_t dma_h_sgdata;
	mega_sglist *sgl;
	mega_sgl64 *sgl64;
	dma_addr_t sgl_dma_addr;
	mega_passthru *pthru;
	dma_addr_t pthru_dma_addr;
	mega_ext_passthru *epthru;
	dma_addr_t epthru_dma_addr;
} scb_t;

typedef struct {
	u32 data_size;
	u32 config_signature;
	u8 fw_version[16];
	u8 bios_version[16];
	u8 product_name[80];
	u8 max_commands;
	u8 nchannels;
	u8 fc_loop_present;
	u8 mem_type;
	u32 signature;
	u16 dram_size;
	u16 subsysid;
	u16 subsysvid;
	u8 notify_counters;
	u8 pad1k[889];
} mega_product_info;

struct notify {
	u32 global_counter;
	u8 param_counter;
	u8 param_id;
	u16 param_val;
	u8 write_config_counter;
	u8 write_config_rsvd[3];
	u8 ldrv_op_counter;
	u8 ldrv_opid;
	u8 ldrv_opcmd;
	u8 ldrv_opstatus;
	u8 ldrv_state_counter;
	u8 ldrv_state_id;
	u8 ldrv_state_new;
	u8 ldrv_state_old;
	u8 pdrv_state_counter;
	u8 pdrv_state_id;
	u8 pdrv_state_new;
	u8 pdrv_state_old;
	u8 pdrv_fmt_counter;
	u8 pdrv_fmt_id;
	u8 pdrv_fmt_val;
	u8 pdrv_fmt_rsvd;
	u8 targ_xfer_counter;
	u8 targ_xfer_id;
	u8 targ_xfer_val;
	u8 targ_xfer_rsvd;
	u8 fcloop_id_chg_counter;
	u8 fcloopid_pdrvid;
	u8 fcloop_id0;
	u8 fcloop_id1;
	u8 fcloop_state_counter;
	u8 fcloop_state0;
	u8 fcloop_state1;
	u8 fcloop_state_rsvd;
};

typedef struct {
	u32 data_size;
	struct notify notify;
	u8 notify_rsvd[88];
	u8 rebuild_rate;
	u8 cache_flush_interval;
	u8 sense_alert;
	u8 drive_insert_count;
	u8 battery_status;
	u8 num_ldrv;
	u8 recon_state[5];
	u16 ldrv_op_status[5];
	u32 ldrv_size[40];
	u8 ldrv_prop[40];
	u8 ldrv_state[40];
	u8 pdrv_state[256];
	u16 pdrv_format[16];
	u8 targ_xfer[80];
	u8 pad1k[263];
} __attribute__((packed)) mega_inquiry3;

typedef struct {
	u8 max_commands;
	u8 rebuild_rate;
	u8 max_targ_per_chan;
	u8 nchannels;
	u8 fw_version[4];
	u16 age_of_flash;
	u8 chip_set_value;
	u8 dram_size;
	u8 cache_flush_interval;
	u8 bios_version[4];
	u8 board_type;
	u8 sense_alert;
	u8 write_config_count;
	u8 drive_inserted_count;
	u8 inserted_drive;
	u8 battery_status;
	u8 dec_fault_bus_info;
} mega_adp_info;

typedef struct {
	u8 num_ldrv;
	u8 rsvd[3];
	u32 ldrv_size[8];
	u8 ldrv_prop[8];
	u8 ldrv_state[8];
} mega_ldrv_info;

typedef struct {
	u8 pdrv_state[75];
	u8 rsvd;
} mega_pdrv_info;

typedef struct {
	mega_adp_info adapter_info;
	mega_ldrv_info logdrv_info;
	mega_pdrv_info pdrv_info;
} mraid_inquiry;

typedef struct {
	mraid_inquiry raid_inq;
	u16 phys_drv_format[5];
	u8 stack_attn;
	u8 modem_status;
	u8 rsvd[2];
} __attribute__((packed)) mraid_ext_inquiry;

typedef struct {
	u8 channel;
	u8 target;
} adp_device;

typedef struct {
	u32 start_blk;
	u32 num_blks;
	adp_device device[32];
} adp_span_40ld;

typedef struct {
	u32 start_blk;
	u32 num_blks;
	adp_device device[8];
} adp_span_8ld;

typedef struct {
	u8 span_depth;
	u8 level;
	u8 read_ahead;
	u8 stripe_sz;
	u8 status;
	u8 write_mode;
	u8 direct_io;
	u8 row_size;
} logdrv_param;

typedef struct {
	logdrv_param lparam;
	adp_span_40ld span[8];
} logdrv_40ld;

typedef struct {
	logdrv_param lparam;
	adp_span_8ld span[8];
} logdrv_8ld;

typedef struct {
	u8 type;
	u8 cur_status;
	u8 tag_depth;
	u8 sync_neg;
	u32 size;
} phys_drv;

typedef struct {
	u8 nlog_drives;
	u8 resvd[3];
	logdrv_40ld ldrv[40];
	phys_drv pdrv[75];
} disk_array_40ld;

typedef struct {
	u8 nlog_drives;
	u8 resvd[3];
	logdrv_8ld ldrv[8];
	phys_drv pdrv[75];
} disk_array_8ld;

struct uioctl_t {
	u32 inlen;
	u32 outlen;
	union {
		u8 fca[16];
		struct {
			u8 opcode;
			u8 subopcode;
			u16 adapno;
			u8 *buffer;
			u32 length;
		} __attribute__((packed)) fcs;
	} ui;
	u8 mbox[18];
	mega_passthru pthru;
	char *data;
} __attribute__((packed));

struct mcontroller {
	u64 base;
	u8 irq;
	u8 numldrv;
	u8 pcibus;
	u16 pcidev;
	u8 pcifun;
	u16 pciid;
	u16 pcivendor;
	u8 pcislot;
	u32 uid;
};

typedef struct {
	u8 cmd;
	u8 cmdid;
	u8 opcode;
	u8 subopcode;
	u32 lba;
	u32 xferaddr;
	u8 logdrv;
	u8 rsvd[3];
	u8 numstatus;
	u8 status;
} __attribute__((packed)) megacmd_t;

typedef struct {
	char signature[8];
	u32 opcode;
	u32 adapno;
	union {
		u8 __raw_mbox[18];
		void *__uaddr;
	} __ua;
	u32 xferlen;
	u32 flags;
} nitioctl_t;

typedef struct {
	int num_ldrv;
	u32 nreads[40];
	u32 nreadblocks[40];
	u32 nwrites[40];
	u32 nwriteblocks[40];
	u32 rd_errors[40];
	u32 wr_errors[40];
} megastat_t;

struct private_bios_data {
	u8 geometry: 4;
	u8 unused: 4;
	u8 boot_drv;
	u8 rsvd[12];
	u16 cksum;
};

typedef struct {
	int this_id;
	u32 flag;
	long unsigned int base;
	void *mmio_base;
	mbox64_t *una_mbox64;
	dma_addr_t una_mbox64_dma;
	volatile mbox64_t *mbox64;
	volatile mbox_t *mbox;
	dma_addr_t mbox_dma;
	struct pci_dev *dev;
	struct list_head free_list;
	struct list_head pending_list;
	struct list_head completed_list;
	struct Scsi_Host *host;
	u8 *mega_buffer;
	dma_addr_t buf_dma_handle;
	mega_product_info product_info;
	u8 max_cmds;
	scb_t *scb_list;
	atomic_t pend_cmds;
	u8 numldrv;
	u8 fw_version[7];
	u8 bios_version[7];
	struct proc_dir_entry *controller_proc_dir_entry;
	int has_64bit_addr;
	int support_ext_cdb;
	int boot_ldrv_enabled;
	int boot_ldrv;
	int boot_pdrv_enabled;
	int boot_pdrv_ch;
	int boot_pdrv_tgt;
	int support_random_del;
	int read_ldidmap;
	atomic_t quiescent;
	spinlock_t lock;
	u8 logdrv_chan[9];
	int mega_ch_class;
	u8 sglen;
	scb_t int_scb;
	struct mutex int_mtx;
	int int_status;
	struct completion int_waitq;
	int has_cluster;
} adapter_t;

struct mega_hbas {
	int is_bios_enabled;
	adapter_t *hostdata_addr;
};

typedef struct {
	uint8_t cmd;
	uint8_t cmdid;
	uint16_t numsectors;
	uint32_t lba;
	uint32_t xferaddr;
	uint8_t logdrv;
	uint8_t numsge;
	uint8_t resvd;
	uint8_t busy;
	uint8_t numstatus;
	uint8_t status;
	uint8_t completed[46];
	uint8_t poll;
	uint8_t ack;
} __attribute__((packed)) mbox_t___2;

typedef struct {
	uint32_t xferaddr_lo;
	uint32_t xferaddr_hi;
	mbox_t___2 mbox32;
} __attribute__((packed)) mbox64_t___2;

typedef struct {
	uint8_t timeout: 3;
	uint8_t ars: 1;
	uint8_t reserved: 3;
	uint8_t islogical: 1;
	uint8_t logdrv;
	uint8_t channel;
	uint8_t target;
	uint8_t queuetag;
	uint8_t queueaction;
	uint8_t cdb[10];
	uint8_t cdblen;
	uint8_t reqsenselen;
	uint8_t reqsensearea[32];
	uint8_t numsge;
	uint8_t scsistatus;
	uint32_t dataxferaddr;
	uint32_t dataxferlen;
} mraid_passthru_t;

struct uioc {
	uint8_t signature[16];
	uint16_t mb_type;
	uint16_t app_type;
	uint32_t opcode;
	uint32_t adapno;
	uint64_t cmdbuf;
	uint32_t xferlen;
	uint32_t data_dir;
	int32_t status;
	uint8_t reserved[128];
	void *user_data;
	uint32_t user_data_len;
	uint32_t pad_for_64bit_align;
	mraid_passthru_t *user_pthru;
	mraid_passthru_t *pthru32;
	dma_addr_t pthru32_h;
	struct list_head list;
	void (*done)(struct uioc *);
	caddr_t buf_vaddr;
	dma_addr_t buf_paddr;
	int8_t pool_index;
	uint8_t free_buf;
	uint8_t timedout;
	long: 40;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
} __attribute__((packed));

typedef struct uioc uioc_t;

struct uioc_timeout {
	struct timer_list timer;
	uioc_t *uioc;
};

struct mraid_hba_info {
	uint16_t pci_vendor_id;
	uint16_t pci_device_id;
	uint16_t subsys_vendor_id;
	uint16_t subsys_device_id;
	uint64_t baseport;
	uint8_t pci_bus;
	uint8_t pci_dev_fn;
	uint8_t pci_slot;
	uint8_t irq;
	uint32_t unique_id;
	uint32_t host_no;
	uint8_t num_ldrv;
	long: 24;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef struct mraid_hba_info mraid_hba_info_t;

struct mcontroller___2 {
	uint64_t base;
	uint8_t irq;
	uint8_t numldrv;
	uint8_t pcibus;
	uint16_t pcidev;
	uint8_t pcifun;
	uint16_t pciid;
	uint16_t pcivendor;
	uint8_t pcislot;
	uint32_t uid;
} __attribute__((packed));

typedef struct mcontroller___2 mcontroller_t;

struct mm_dmapool {
	caddr_t vaddr;
	dma_addr_t paddr;
	uint32_t buf_size;
	struct dma_pool *handle;
	spinlock_t lock;
	uint8_t in_use;
};

typedef struct mm_dmapool mm_dmapool_t;

struct mraid_mmadp {
	uint32_t unique_id;
	uint32_t drvr_type;
	long unsigned int drvr_data;
	uint16_t timeout;
	uint8_t max_kioc;
	struct pci_dev *pdev;
	int (*issue_uioc)(long unsigned int, uioc_t *, uint32_t);
	uint32_t quiescent;
	struct list_head list;
	uioc_t *kioc_list;
	struct list_head kioc_pool;
	spinlock_t kioc_pool_lock;
	struct semaphore kioc_semaphore;
	mbox64_t___2 *mbox_list;
	struct dma_pool *pthru_dma_pool;
	mm_dmapool_t dma_pool_list[5];
};

typedef struct mraid_mmadp mraid_mmadp_t;

struct mimd {
	uint32_t inlen;
	uint32_t outlen;
	union {
		uint8_t fca[16];
		struct {
			uint8_t opcode;
			uint8_t subopcode;
			uint16_t adapno;
			uint8_t *buffer;
			uint32_t length;
		} __attribute__((packed)) fcs;
	} ui;
	uint8_t mbox[18];
	mraid_passthru_t pthru;
	char *data;
} __attribute__((packed));

typedef struct mimd mimd_t;

typedef struct {
	caddr_t ccb;
	struct list_head list;
	long unsigned int gp;
	unsigned int sno;
	struct scsi_cmnd *scp;
	uint32_t state;
	uint32_t dma_direction;
	uint32_t dma_type;
	uint16_t dev_channel;
	uint16_t dev_target;
	uint32_t status;
} scb_t___2;

typedef struct {
	struct tasklet_struct dpc_h;
	struct pci_dev *pdev;
	struct Scsi_Host *host;
	spinlock_t lock;
	uint8_t quiescent;
	int outstanding_cmds;
	scb_t___2 *kscb_list;
	struct list_head kscb_pool;
	spinlock_t kscb_pool_lock;
	struct list_head pend_list;
	spinlock_t pend_list_lock;
	struct list_head completed_list;
	spinlock_t completed_list_lock;
	uint16_t sglen;
	int device_ids[1040];
	caddr_t raid_device;
	uint8_t max_channel;
	uint16_t max_target;
	uint8_t max_lun;
	uint32_t unique_id;
	int irq;
	uint8_t ito;
	caddr_t ibuf;
	dma_addr_t ibuf_dma_h;
	scb_t___2 *uscb_list;
	struct list_head uscb_pool;
	spinlock_t uscb_pool_lock;
	int max_cmds;
	uint8_t fw_version[16];
	uint8_t bios_version[16];
	uint8_t max_cdb_sz;
	uint8_t ha;
	uint16_t init_id;
	uint16_t max_sectors;
	uint16_t cmd_per_lun;
	atomic_t being_detached;
} adapter_t___2;

struct mraid_pci_blk {
	caddr_t vaddr;
	dma_addr_t dma_addr;
};

typedef struct {
	uint8_t timeout: 3;
	uint8_t ars: 1;
	uint8_t rsvd1: 1;
	uint8_t cd_rom: 1;
	uint8_t rsvd2: 1;
	uint8_t islogical: 1;
	uint8_t logdrv;
	uint8_t channel;
	uint8_t target;
	uint8_t queuetag;
	uint8_t queueaction;
	uint8_t cdblen;
	uint8_t rsvd3;
	uint8_t cdb[16];
	uint8_t numsge;
	uint8_t status;
	uint8_t reqsenselen;
	uint8_t reqsensearea[32];
	uint8_t rsvd4;
	uint32_t dataxferaddr;
	uint32_t dataxferlen;
} mraid_epassthru_t;

typedef struct {
	uint32_t data_size;
	uint32_t config_signature;
	uint8_t fw_version[16];
	uint8_t bios_version[16];
	uint8_t product_name[80];
	uint8_t max_commands;
	uint8_t nchannels;
	uint8_t fc_loop_present;
	uint8_t mem_type;
	uint32_t signature;
	uint16_t dram_size;
	uint16_t subsysid;
	uint16_t subsysvid;
	uint8_t notify_counters;
	uint8_t pad1k[889];
} mraid_pinfo_t;

typedef struct {
	uint32_t global_counter;
	uint8_t param_counter;
	uint8_t param_id;
	uint16_t param_val;
	uint8_t write_config_counter;
	uint8_t write_config_rsvd[3];
	uint8_t ldrv_op_counter;
	uint8_t ldrv_opid;
	uint8_t ldrv_opcmd;
	uint8_t ldrv_opstatus;
	uint8_t ldrv_state_counter;
	uint8_t ldrv_state_id;
	uint8_t ldrv_state_new;
	uint8_t ldrv_state_old;
	uint8_t pdrv_state_counter;
	uint8_t pdrv_state_id;
	uint8_t pdrv_state_new;
	uint8_t pdrv_state_old;
	uint8_t pdrv_fmt_counter;
	uint8_t pdrv_fmt_id;
	uint8_t pdrv_fmt_val;
	uint8_t pdrv_fmt_rsvd;
	uint8_t targ_xfer_counter;
	uint8_t targ_xfer_id;
	uint8_t targ_xfer_val;
	uint8_t targ_xfer_rsvd;
	uint8_t fcloop_id_chg_counter;
	uint8_t fcloopid_pdrvid;
	uint8_t fcloop_id0;
	uint8_t fcloop_id1;
	uint8_t fcloop_state_counter;
	uint8_t fcloop_state0;
	uint8_t fcloop_state1;
	uint8_t fcloop_state_rsvd;
} mraid_notify_t;

typedef struct {
	uint32_t data_size;
	mraid_notify_t notify;
	uint8_t notify_rsvd[88];
	uint8_t rebuild_rate;
	uint8_t cache_flush_int;
	uint8_t sense_alert;
	uint8_t drive_insert_count;
	uint8_t battery_status;
	uint8_t num_ldrv;
	uint8_t recon_state[5];
	uint16_t ldrv_op_status[5];
	uint32_t ldrv_size[40];
	uint8_t ldrv_prop[40];
	uint8_t ldrv_state[40];
	uint8_t pdrv_state[256];
	uint16_t pdrv_format[16];
	uint8_t targ_xfer[80];
	uint8_t pad1k[263];
} __attribute__((packed)) mraid_inquiry3_t;

typedef struct {
	uint64_t address;
	uint32_t length;
} __attribute__((packed)) mbox_sgl64;

typedef struct {
	uint32_t address;
	uint32_t length;
} mbox_sgl32;

typedef struct {
	uint8_t *raw_mbox;
	mbox_t___2 *mbox;
	mbox64_t___2 *mbox64;
	dma_addr_t mbox_dma_h;
	mbox_sgl64 *sgl64;
	mbox_sgl32 *sgl32;
	dma_addr_t sgl_dma_h;
	mraid_passthru_t *pthru;
	dma_addr_t pthru_dma_h;
	mraid_epassthru_t *epthru;
	dma_addr_t epthru_dma_h;
	dma_addr_t buf_dma_h;
} mbox_ccb_t;

typedef struct {
	mbox64_t___2 *una_mbox64;
	dma_addr_t una_mbox64_dma;
	mbox_t___2 *mbox;
	mbox64_t___2 *mbox64;
	dma_addr_t mbox_dma;
	spinlock_t mailbox_lock;
	long unsigned int baseport;
	void *baseaddr;
	struct mraid_pci_blk mbox_pool[128];
	struct dma_pool *mbox_pool_handle;
	struct mraid_pci_blk epthru_pool[128];
	struct dma_pool *epthru_pool_handle;
	struct mraid_pci_blk sg_pool[128];
	struct dma_pool *sg_pool_handle;
	mbox_ccb_t ccb_list[128];
	mbox_ccb_t uccb_list[32];
	mbox64_t___2 umbox64[32];
	uint8_t pdrv_state[75];
	uint32_t last_disp;
	int hw_error;
	int fast_load;
	uint8_t channel_class;
	struct mutex sysfs_mtx;
	uioc_t *sysfs_uioc;
	mbox64_t___2 *sysfs_mbox64;
	caddr_t sysfs_buffer;
	dma_addr_t sysfs_buffer_dma;
	wait_queue_head_t sysfs_wait_q;
	int random_del_supported;
	uint16_t curr_ldmap[64];
} mraid_device_t;

struct devfreq_dev_status {
	long unsigned int total_time;
	long unsigned int busy_time;
	long unsigned int current_frequency;
	void *private_data;
};

struct devfreq_dev_profile {
	long unsigned int initial_freq;
	unsigned int polling_ms;
	int (*target)(struct device *, long unsigned int *, u32);
	int (*get_dev_status)(struct device *, struct devfreq_dev_status *);
	int (*get_cur_freq)(struct device *, long unsigned int *);
	void (*exit)(struct device *);
	long unsigned int *freq_table;
	unsigned int max_state;
};

struct devfreq_governor;

struct devfreq {
	struct list_head node;
	struct mutex lock;
	struct device dev;
	struct devfreq_dev_profile *profile;
	const struct devfreq_governor *governor;
	char governor_name[16];
	struct notifier_block nb;
	struct delayed_work work;
	long unsigned int previous_freq;
	struct devfreq_dev_status last_status;
	void *data;
	long unsigned int min_freq;
	long unsigned int max_freq;
	long unsigned int scaling_min_freq;
	long unsigned int scaling_max_freq;
	bool stop_polling;
	long unsigned int suspend_freq;
	long unsigned int resume_freq;
	atomic_t suspend_count;
	unsigned int total_trans;
	unsigned int *trans_table;
	long unsigned int *time_in_state;
	long unsigned int last_stat_updated;
	struct srcu_notifier_head transition_notifier_list;
};

struct devfreq_governor {
	struct list_head node;
	const char name[16];
	const unsigned int immutable;
	int (*get_target_freq)(struct devfreq *, long unsigned int *);
	int (*event_handler)(struct devfreq *, unsigned int, void *);
};

enum {
	FAST_MODE = 1,
	SLOW_MODE = 2,
	FASTAUTO_MODE = 4,
	SLOWAUTO_MODE = 5,
	UNCHANGED = 7,
};

enum {
	PA_HS_MODE_A = 1,
	PA_HS_MODE_B = 2,
};

enum ufs_pwm_gear_tag {
	UFS_PWM_DONT_CHANGE = 0,
	UFS_PWM_G1 = 1,
	UFS_PWM_G2 = 2,
	UFS_PWM_G3 = 3,
	UFS_PWM_G4 = 4,
	UFS_PWM_G5 = 5,
	UFS_PWM_G6 = 6,
	UFS_PWM_G7 = 7,
};

enum ufs_hs_gear_tag {
	UFS_HS_DONT_CHANGE = 0,
	UFS_HS_G1 = 1,
	UFS_HS_G2 = 2,
	UFS_HS_G3 = 3,
};

enum ufs_unipro_ver {
	UFS_UNIPRO_VER_RESERVED = 0,
	UFS_UNIPRO_VER_1_40 = 1,
	UFS_UNIPRO_VER_1_41 = 2,
	UFS_UNIPRO_VER_1_6 = 3,
	UFS_UNIPRO_VER_MAX = 4,
	UFS_UNIPRO_VER_MASK = 15,
};

enum {
	FALSE = 0,
	TRUE = 1,
};

struct utp_upiu_header {
	__be32 dword_0;
	__be32 dword_1;
	__be32 dword_2;
};

struct utp_upiu_query {
	__u8 opcode;
	__u8 idn;
	__u8 index;
	__u8 selector;
	__be16 reserved_osf;
	__be16 length;
	__be32 value;
	__be32 reserved[2];
};

struct utp_upiu_cmd {
	__be32 exp_data_transfer_len;
	__u8 cdb[16];
};

struct utp_upiu_req {
	struct utp_upiu_header header;
	union {
		struct utp_upiu_cmd sc;
		struct utp_upiu_query qr;
		struct utp_upiu_query tr;
		struct utp_upiu_query uc;
	};
};

enum {
	UFS_UPIU_REPORT_LUNS_WLUN = 129,
	UFS_UPIU_UFS_DEVICE_WLUN = 208,
	UFS_UPIU_BOOT_WLUN = 176,
	UFS_UPIU_RPMB_WLUN = 196,
};

enum {
	UFS_ABORT_TASK = 1,
	UFS_ABORT_TASK_SET = 2,
	UFS_CLEAR_TASK_SET = 4,
	UFS_LOGICAL_RESET = 8,
	UFS_QUERY_TASK = 128,
	UFS_QUERY_TASK_SET = 129,
};

enum {
	UPIU_TRANSACTION_NOP_OUT = 0,
	UPIU_TRANSACTION_COMMAND = 1,
	UPIU_TRANSACTION_DATA_OUT = 2,
	UPIU_TRANSACTION_TASK_REQ = 4,
	UPIU_TRANSACTION_QUERY_REQ = 22,
};

enum {
	UPIU_TRANSACTION_NOP_IN = 32,
	UPIU_TRANSACTION_RESPONSE = 33,
	UPIU_TRANSACTION_DATA_IN = 34,
	UPIU_TRANSACTION_TASK_RSP = 36,
	UPIU_TRANSACTION_READY_XFER = 49,
	UPIU_TRANSACTION_QUERY_RSP = 54,
	UPIU_TRANSACTION_REJECT_UPIU = 63,
};

enum {
	UPIU_CMD_FLAGS_NONE = 0,
	UPIU_CMD_FLAGS_WRITE = 32,
	UPIU_CMD_FLAGS_READ = 64,
};

enum {
	UPIU_QUERY_FUNC_STANDARD_READ_REQUEST = 1,
	UPIU_QUERY_FUNC_STANDARD_WRITE_REQUEST = 129,
};

enum flag_idn {
	QUERY_FLAG_IDN_FDEVICEINIT = 1,
	QUERY_FLAG_IDN_PERMANENT_WPE = 2,
	QUERY_FLAG_IDN_PWR_ON_WPE = 3,
	QUERY_FLAG_IDN_BKOPS_EN = 4,
	QUERY_FLAG_IDN_LIFE_SPAN_MODE_ENABLE = 5,
	QUERY_FLAG_IDN_PURGE_ENABLE = 6,
	QUERY_FLAG_IDN_RESERVED2 = 7,
	QUERY_FLAG_IDN_FPHYRESOURCEREMOVAL = 8,
	QUERY_FLAG_IDN_BUSY_RTC = 9,
	QUERY_FLAG_IDN_RESERVED3 = 10,
	QUERY_FLAG_IDN_PERMANENTLY_DISABLE_FW_UPDATE = 11,
};

enum attr_idn {
	QUERY_ATTR_IDN_BOOT_LU_EN = 0,
	QUERY_ATTR_IDN_RESERVED = 1,
	QUERY_ATTR_IDN_POWER_MODE = 2,
	QUERY_ATTR_IDN_ACTIVE_ICC_LVL = 3,
	QUERY_ATTR_IDN_OOO_DATA_EN = 4,
	QUERY_ATTR_IDN_BKOPS_STATUS = 5,
	QUERY_ATTR_IDN_PURGE_STATUS = 6,
	QUERY_ATTR_IDN_MAX_DATA_IN = 7,
	QUERY_ATTR_IDN_MAX_DATA_OUT = 8,
	QUERY_ATTR_IDN_DYN_CAP_NEEDED = 9,
	QUERY_ATTR_IDN_REF_CLK_FREQ = 10,
	QUERY_ATTR_IDN_CONF_DESC_LOCK = 11,
	QUERY_ATTR_IDN_MAX_NUM_OF_RTT = 12,
	QUERY_ATTR_IDN_EE_CONTROL = 13,
	QUERY_ATTR_IDN_EE_STATUS = 14,
	QUERY_ATTR_IDN_SECONDS_PASSED = 15,
	QUERY_ATTR_IDN_CNTX_CONF = 16,
	QUERY_ATTR_IDN_CORR_PRG_BLK_NUM = 17,
	QUERY_ATTR_IDN_RESERVED2 = 18,
	QUERY_ATTR_IDN_RESERVED3 = 19,
	QUERY_ATTR_IDN_FFU_STATUS = 20,
	QUERY_ATTR_IDN_PSA_STATE = 21,
	QUERY_ATTR_IDN_PSA_DATA_SIZE = 22,
};

enum desc_idn {
	QUERY_DESC_IDN_DEVICE = 0,
	QUERY_DESC_IDN_CONFIGURATION = 1,
	QUERY_DESC_IDN_UNIT = 2,
	QUERY_DESC_IDN_RFU_0 = 3,
	QUERY_DESC_IDN_INTERCONNECT = 4,
	QUERY_DESC_IDN_STRING = 5,
	QUERY_DESC_IDN_RFU_1 = 6,
	QUERY_DESC_IDN_GEOMETRY = 7,
	QUERY_DESC_IDN_POWER = 8,
	QUERY_DESC_IDN_HEALTH = 9,
	QUERY_DESC_IDN_MAX = 10,
};

enum desc_header_offset {
	QUERY_DESC_LENGTH_OFFSET = 0,
	QUERY_DESC_DESC_TYPE_OFFSET = 1,
};

enum ufs_desc_def_size {
	QUERY_DESC_DEVICE_DEF_SIZE = 64,
	QUERY_DESC_CONFIGURATION_DEF_SIZE = 144,
	QUERY_DESC_UNIT_DEF_SIZE = 35,
	QUERY_DESC_INTERCONNECT_DEF_SIZE = 6,
	QUERY_DESC_GEOMETRY_DEF_SIZE = 72,
	QUERY_DESC_POWER_DEF_SIZE = 98,
	QUERY_DESC_HEALTH_DEF_SIZE = 37,
};

enum unit_desc_param {
	UNIT_DESC_PARAM_LEN = 0,
	UNIT_DESC_PARAM_TYPE = 1,
	UNIT_DESC_PARAM_UNIT_INDEX = 2,
	UNIT_DESC_PARAM_LU_ENABLE = 3,
	UNIT_DESC_PARAM_BOOT_LUN_ID = 4,
	UNIT_DESC_PARAM_LU_WR_PROTECT = 5,
	UNIT_DESC_PARAM_LU_Q_DEPTH = 6,
	UNIT_DESC_PARAM_PSA_SENSITIVE = 7,
	UNIT_DESC_PARAM_MEM_TYPE = 8,
	UNIT_DESC_PARAM_DATA_RELIABILITY = 9,
	UNIT_DESC_PARAM_LOGICAL_BLK_SIZE = 10,
	UNIT_DESC_PARAM_LOGICAL_BLK_COUNT = 11,
	UNIT_DESC_PARAM_ERASE_BLK_SIZE = 19,
	UNIT_DESC_PARAM_PROVISIONING_TYPE = 23,
	UNIT_DESC_PARAM_PHY_MEM_RSRC_CNT = 24,
	UNIT_DESC_PARAM_CTX_CAPABILITIES = 32,
	UNIT_DESC_PARAM_LARGE_UNIT_SIZE_M1 = 34,
};

enum device_desc_param {
	DEVICE_DESC_PARAM_LEN = 0,
	DEVICE_DESC_PARAM_TYPE = 1,
	DEVICE_DESC_PARAM_DEVICE_TYPE = 2,
	DEVICE_DESC_PARAM_DEVICE_CLASS = 3,
	DEVICE_DESC_PARAM_DEVICE_SUB_CLASS = 4,
	DEVICE_DESC_PARAM_PRTCL = 5,
	DEVICE_DESC_PARAM_NUM_LU = 6,
	DEVICE_DESC_PARAM_NUM_WLU = 7,
	DEVICE_DESC_PARAM_BOOT_ENBL = 8,
	DEVICE_DESC_PARAM_DESC_ACCSS_ENBL = 9,
	DEVICE_DESC_PARAM_INIT_PWR_MODE = 10,
	DEVICE_DESC_PARAM_HIGH_PR_LUN = 11,
	DEVICE_DESC_PARAM_SEC_RMV_TYPE = 12,
	DEVICE_DESC_PARAM_SEC_LU = 13,
	DEVICE_DESC_PARAM_BKOP_TERM_LT = 14,
	DEVICE_DESC_PARAM_ACTVE_ICC_LVL = 15,
	DEVICE_DESC_PARAM_SPEC_VER = 16,
	DEVICE_DESC_PARAM_MANF_DATE = 18,
	DEVICE_DESC_PARAM_MANF_NAME = 20,
	DEVICE_DESC_PARAM_PRDCT_NAME = 21,
	DEVICE_DESC_PARAM_SN = 22,
	DEVICE_DESC_PARAM_OEM_ID = 23,
	DEVICE_DESC_PARAM_MANF_ID = 24,
	DEVICE_DESC_PARAM_UD_OFFSET = 26,
	DEVICE_DESC_PARAM_UD_LEN = 27,
	DEVICE_DESC_PARAM_RTT_CAP = 28,
	DEVICE_DESC_PARAM_FRQ_RTC = 29,
	DEVICE_DESC_PARAM_UFS_FEAT = 31,
	DEVICE_DESC_PARAM_FFU_TMT = 32,
	DEVICE_DESC_PARAM_Q_DPTH = 33,
	DEVICE_DESC_PARAM_DEV_VER = 34,
	DEVICE_DESC_PARAM_NUM_SEC_WPA = 36,
	DEVICE_DESC_PARAM_PSA_MAX_DATA = 37,
	DEVICE_DESC_PARAM_PSA_TMT = 41,
	DEVICE_DESC_PARAM_PRDCT_REV = 42,
};

enum ufs_lu_wp_type {
	UFS_LU_NO_WP = 0,
	UFS_LU_POWER_ON_WP = 1,
	UFS_LU_PERM_WP = 2,
};

enum {
	UFSHCD_NANO_AMP = 0,
	UFSHCD_MICRO_AMP = 1,
	UFSHCD_MILI_AMP = 2,
	UFSHCD_AMP = 3,
};

enum power_desc_param_offset {
	PWR_DESC_LEN = 0,
	PWR_DESC_TYPE = 1,
	PWR_DESC_ACTIVE_LVLS_VCC_0 = 2,
	PWR_DESC_ACTIVE_LVLS_VCCQ_0 = 34,
	PWR_DESC_ACTIVE_LVLS_VCCQ2_0 = 66,
};

enum {
	MASK_EE_STATUS = 65535,
	MASK_EE_URGENT_BKOPS = 4,
};

enum bkops_status {
	BKOPS_STATUS_NO_OP = 0,
	BKOPS_STATUS_NON_CRITICAL = 1,
	BKOPS_STATUS_PERF_IMPACT = 2,
	BKOPS_STATUS_CRITICAL = 3,
	BKOPS_STATUS_MAX = 3,
};

enum query_opcode {
	UPIU_QUERY_OPCODE_NOP = 0,
	UPIU_QUERY_OPCODE_READ_DESC = 1,
	UPIU_QUERY_OPCODE_WRITE_DESC = 2,
	UPIU_QUERY_OPCODE_READ_ATTR = 3,
	UPIU_QUERY_OPCODE_WRITE_ATTR = 4,
	UPIU_QUERY_OPCODE_READ_FLAG = 5,
	UPIU_QUERY_OPCODE_SET_FLAG = 6,
	UPIU_QUERY_OPCODE_CLEAR_FLAG = 7,
	UPIU_QUERY_OPCODE_TOGGLE_FLAG = 8,
};

enum ufs_ref_clk_freq {
	REF_CLK_FREQ_19_2_MHZ = 0,
	REF_CLK_FREQ_26_MHZ = 1,
	REF_CLK_FREQ_38_4_MHZ = 2,
	REF_CLK_FREQ_52_MHZ = 3,
	REF_CLK_FREQ_INVAL = 4294967295,
};

struct ufs_ref_clk {
	long unsigned int freq_hz;
	enum ufs_ref_clk_freq val;
};

enum {
	UPIU_COMMAND_SET_TYPE_SCSI = 0,
	UPIU_COMMAND_SET_TYPE_UFS = 1,
	UPIU_COMMAND_SET_TYPE_QUERY = 2,
};

enum {
	MASK_SCSI_STATUS = 255,
	MASK_TASK_RESPONSE = 65280,
	MASK_RSP_UPIU_RESULT = 65535,
	MASK_QUERY_DATA_SEG_LEN = 65535,
	MASK_RSP_UPIU_DATA_SEG_LEN = 65535,
	MASK_RSP_EXCEPTION_EVENT = 65536,
	MASK_TM_SERVICE_RESP = 255,
	MASK_TM_FUNC = 255,
};

enum {
	UPIU_TASK_MANAGEMENT_FUNC_COMPL = 0,
	UPIU_TASK_MANAGEMENT_FUNC_NOT_SUPPORTED = 4,
	UPIU_TASK_MANAGEMENT_FUNC_SUCCEEDED = 8,
	UPIU_TASK_MANAGEMENT_FUNC_FAILED = 5,
	UPIU_INCORRECT_LOGICAL_UNIT_NO = 9,
};

enum ufs_dev_pwr_mode {
	UFS_ACTIVE_PWR_MODE = 1,
	UFS_SLEEP_PWR_MODE = 2,
	UFS_POWERDOWN_PWR_MODE = 3,
};

struct utp_cmd_rsp {
	__be32 residual_transfer_count;
	__be32 reserved[4];
	__be16 sense_data_len;
	u8 sense_data[18];
};

struct utp_upiu_rsp {
	struct utp_upiu_header header;
	union {
		struct utp_cmd_rsp sr;
		struct utp_upiu_query qr;
	};
};

struct ufs_query_req {
	u8 query_func;
	struct utp_upiu_query upiu_req;
};

struct ufs_query_res {
	u8 response;
	struct utp_upiu_query upiu_res;
};

struct ufs_vreg {
	struct regulator *reg;
	const char *name;
	bool enabled;
	int min_uV;
	int max_uV;
	int max_uA;
};

struct ufs_vreg_info {
	struct ufs_vreg *vcc;
	struct ufs_vreg *vccq;
	struct ufs_vreg *vccq2;
	struct ufs_vreg *vdd_hba;
};

struct ufs_dev_info {
	bool f_power_on_wp_en;
	bool is_lu_power_on_wp;
};

struct ufs_dev_desc {
	u16 wmanufacturerid;
	u8 *model;
};

enum {
	TASK_REQ_UPIU_SIZE_DWORDS = 8,
	TASK_RSP_UPIU_SIZE_DWORDS = 8,
	ALIGNED_UPIU_SIZE = 512,
};

enum {
	REG_CONTROLLER_CAPABILITIES = 0,
	REG_UFS_VERSION = 8,
	REG_CONTROLLER_DEV_ID = 16,
	REG_CONTROLLER_PROD_ID = 20,
	REG_AUTO_HIBERNATE_IDLE_TIMER = 24,
	REG_INTERRUPT_STATUS = 32,
	REG_INTERRUPT_ENABLE = 36,
	REG_CONTROLLER_STATUS = 48,
	REG_CONTROLLER_ENABLE = 52,
	REG_UIC_ERROR_CODE_PHY_ADAPTER_LAYER = 56,
	REG_UIC_ERROR_CODE_DATA_LINK_LAYER = 60,
	REG_UIC_ERROR_CODE_NETWORK_LAYER = 64,
	REG_UIC_ERROR_CODE_TRANSPORT_LAYER = 68,
	REG_UIC_ERROR_CODE_DME = 72,
	REG_UTP_TRANSFER_REQ_INT_AGG_CONTROL = 76,
	REG_UTP_TRANSFER_REQ_LIST_BASE_L = 80,
	REG_UTP_TRANSFER_REQ_LIST_BASE_H = 84,
	REG_UTP_TRANSFER_REQ_DOOR_BELL = 88,
	REG_UTP_TRANSFER_REQ_LIST_CLEAR = 92,
	REG_UTP_TRANSFER_REQ_LIST_RUN_STOP = 96,
	REG_UTP_TASK_REQ_LIST_BASE_L = 112,
	REG_UTP_TASK_REQ_LIST_BASE_H = 116,
	REG_UTP_TASK_REQ_DOOR_BELL = 120,
	REG_UTP_TASK_REQ_LIST_CLEAR = 124,
	REG_UTP_TASK_REQ_LIST_RUN_STOP = 128,
	REG_UIC_COMMAND = 144,
	REG_UIC_COMMAND_ARG_1 = 148,
	REG_UIC_COMMAND_ARG_2 = 152,
	REG_UIC_COMMAND_ARG_3 = 156,
	UFSHCI_REG_SPACE_SIZE = 160,
	REG_UFS_CCAP = 256,
	REG_UFS_CRYPTOCAP = 260,
	UFSHCI_CRYPTO_REG_SPACE_SIZE = 1024,
};

enum {
	MASK_TRANSFER_REQUESTS_SLOTS = 31,
	MASK_TASK_MANAGEMENT_REQUEST_SLOTS = 458752,
	MASK_AUTO_HIBERN8_SUPPORT = 8388608,
	MASK_64_ADDRESSING_SUPPORT = 16777216,
	MASK_OUT_OF_ORDER_DATA_DELIVERY_SUPPORT = 33554432,
	MASK_UIC_DME_TEST_MODE_SUPPORT = 67108864,
};

enum {
	UFSHCI_VERSION_10 = 65536,
	UFSHCI_VERSION_11 = 65792,
	UFSHCI_VERSION_20 = 512,
	UFSHCI_VERSION_21 = 528,
};

enum {
	PWR_OK = 0,
	PWR_LOCAL = 1,
	PWR_REMOTE = 2,
	PWR_BUSY = 3,
	PWR_ERROR_CAP = 4,
	PWR_FATAL_ERROR = 5,
};

enum uic_cmd_dme {
	UIC_CMD_DME_GET = 1,
	UIC_CMD_DME_SET = 2,
	UIC_CMD_DME_PEER_GET = 3,
	UIC_CMD_DME_PEER_SET = 4,
	UIC_CMD_DME_POWERON = 16,
	UIC_CMD_DME_POWEROFF = 17,
	UIC_CMD_DME_ENABLE = 18,
	UIC_CMD_DME_RESET = 20,
	UIC_CMD_DME_END_PT_RST = 21,
	UIC_CMD_DME_LINK_STARTUP = 22,
	UIC_CMD_DME_HIBER_ENTER = 23,
	UIC_CMD_DME_HIBER_EXIT = 24,
	UIC_CMD_DME_TEST_MODE = 26,
};

enum {
	INTERRUPT_MASK_ALL_VER_10 = 200703,
	INTERRUPT_MASK_RW_VER_10 = 196608,
	INTERRUPT_MASK_ALL_VER_11 = 204799,
	INTERRUPT_MASK_ALL_VER_21 = 466943,
};

enum {
	UTP_CMD_TYPE_SCSI = 0,
	UTP_CMD_TYPE_UFS = 1,
	UTP_CMD_TYPE_DEV_MANAGE = 2,
};

enum {
	UTP_CMD_TYPE_UFS_STORAGE = 1,
};

enum {
	UTP_SCSI_COMMAND = 0,
	UTP_NATIVE_UFS_COMMAND = 268435456,
	UTP_DEVICE_MANAGEMENT_FUNCTION = 536870912,
	UTP_REQ_DESC_INT_CMD = 16777216,
};

enum {
	UTP_NO_DATA_TRANSFER = 0,
	UTP_HOST_TO_DEVICE = 33554432,
	UTP_DEVICE_TO_HOST = 67108864,
};

enum {
	OCS_SUCCESS = 0,
	OCS_INVALID_CMD_TABLE_ATTR = 1,
	OCS_INVALID_PRDT_ATTR = 2,
	OCS_MISMATCH_DATA_BUF_SIZE = 3,
	OCS_MISMATCH_RESP_UPIU_SIZE = 4,
	OCS_PEER_COMM_FAILURE = 5,
	OCS_ABORTED = 6,
	OCS_FATAL_ERROR = 7,
	OCS_INVALID_COMMAND_STATUS = 15,
	MASK_OCS = 15,
};

struct ufshcd_sg_entry {
	__le32 base_addr;
	__le32 upper_addr;
	__le32 reserved;
	__le32 size;
};

struct utp_transfer_cmd_desc {
	u8 command_upiu[512];
	u8 response_upiu[512];
	struct ufshcd_sg_entry prd_table[128];
};

struct request_desc_header {
	__le32 dword_0;
	__le32 dword_1;
	__le32 dword_2;
	__le32 dword_3;
};

struct utp_transfer_req_desc {
	struct request_desc_header header;
	__le32 command_desc_base_addr_lo;
	__le32 command_desc_base_addr_hi;
	__le16 response_upiu_length;
	__le16 response_upiu_offset;
	__le16 prd_table_length;
	__le16 prd_table_offset;
};

struct utp_task_req_desc {
	struct request_desc_header header;
	struct utp_upiu_header req_header;
	__be32 input_param1;
	__be32 input_param2;
	__be32 input_param3;
	__be32 __reserved1[2];
	struct utp_upiu_header rsp_header;
	__be32 output_param1;
	__be32 output_param2;
	__be32 __reserved2[3];
};

enum dev_cmd_type {
	DEV_CMD_TYPE_NOP = 0,
	DEV_CMD_TYPE_QUERY = 1,
};

struct uic_command {
	u32 command;
	u32 argument1;
	u32 argument2;
	u32 argument3;
	int cmd_active;
	int result;
	struct completion done;
};

enum ufs_pm_op {
	UFS_RUNTIME_PM = 0,
	UFS_SYSTEM_PM = 1,
	UFS_SHUTDOWN_PM = 2,
};

enum uic_link_state {
	UIC_LINK_OFF_STATE = 0,
	UIC_LINK_ACTIVE_STATE = 1,
	UIC_LINK_HIBERN8_STATE = 2,
};

enum ufs_pm_level {
	UFS_PM_LVL_0 = 0,
	UFS_PM_LVL_1 = 1,
	UFS_PM_LVL_2 = 2,
	UFS_PM_LVL_3 = 3,
	UFS_PM_LVL_4 = 4,
	UFS_PM_LVL_5 = 5,
	UFS_PM_LVL_MAX = 6,
};

struct ufs_pm_lvl_states {
	enum ufs_dev_pwr_mode dev_state;
	enum uic_link_state link_state;
};

struct ufshcd_lrb {
	struct utp_transfer_req_desc *utr_descriptor_ptr;
	struct utp_upiu_req *ucd_req_ptr;
	struct utp_upiu_rsp *ucd_rsp_ptr;
	struct ufshcd_sg_entry *ucd_prdt_ptr;
	dma_addr_t utrd_dma_addr;
	dma_addr_t ucd_req_dma_addr;
	dma_addr_t ucd_rsp_dma_addr;
	dma_addr_t ucd_prdt_dma_addr;
	struct scsi_cmnd *cmd;
	u8 *sense_buffer;
	unsigned int sense_bufflen;
	int scsi_status;
	int command_type;
	int task_tag;
	u8 lun;
	bool intr_cmd;
	ktime_t issue_time_stamp;
	ktime_t compl_time_stamp;
	bool req_abort_skip;
};

struct ufs_query {
	struct ufs_query_req request;
	u8 *descriptor;
	struct ufs_query_res response;
};

struct ufs_dev_cmd {
	enum dev_cmd_type type;
	struct mutex lock;
	struct completion *complete;
	struct ufs_query query;
};

struct ufs_desc_size {
	int dev_desc;
	int pwr_desc;
	int geom_desc;
	int interc_desc;
	int unit_desc;
	int conf_desc;
	int hlth_desc;
};

struct ufs_clk_info {
	struct list_head list;
	struct clk *clk;
	const char *name;
	u32 max_freq;
	u32 min_freq;
	u32 curr_freq;
	bool enabled;
};

enum ufs_notify_change_status {
	PRE_CHANGE = 0,
	POST_CHANGE = 1,
};

struct ufs_pa_layer_attr {
	u32 gear_rx;
	u32 gear_tx;
	u32 lane_rx;
	u32 lane_tx;
	u32 pwr_rx;
	u32 pwr_tx;
	u32 hs_rate;
};

struct ufs_pwr_mode_info {
	bool is_valid;
	struct ufs_pa_layer_attr info;
};

struct ufs_hba;

struct ufs_hba_variant_ops {
	const char *name;
	int (*init)(struct ufs_hba *);
	void (*exit)(struct ufs_hba *);
	u32 (*get_ufs_hci_version)(struct ufs_hba *);
	int (*clk_scale_notify)(struct ufs_hba *, bool, enum ufs_notify_change_status);
	int (*setup_clocks)(struct ufs_hba *, bool, enum ufs_notify_change_status);
	int (*setup_regulators)(struct ufs_hba *, bool);
	int (*hce_enable_notify)(struct ufs_hba *, enum ufs_notify_change_status);
	int (*link_startup_notify)(struct ufs_hba *, enum ufs_notify_change_status);
	int (*pwr_change_notify)(struct ufs_hba *, enum ufs_notify_change_status, struct ufs_pa_layer_attr *, struct ufs_pa_layer_attr *);
	void (*setup_xfer_req)(struct ufs_hba *, int, bool);
	void (*setup_task_mgmt)(struct ufs_hba *, int, u8);
	void (*hibern8_notify)(struct ufs_hba *, enum uic_cmd_dme, enum ufs_notify_change_status);
	int (*apply_dev_quirks)(struct ufs_hba *, struct ufs_dev_desc *);
	int (*suspend)(struct ufs_hba *, enum ufs_pm_op);
	int (*resume)(struct ufs_hba *, enum ufs_pm_op);
	void (*dbg_register_dump)(struct ufs_hba *);
	int (*phy_initialization)(struct ufs_hba *);
	void (*device_reset)(struct ufs_hba *);
};

struct ufs_init_prefetch {
	u32 icc_level;
};

struct ufs_err_reg_hist {
	int pos;
	u32 reg[8];
	ktime_t tstamp[8];
};

struct ufs_stats {
	u32 hibern8_exit_cnt;
	ktime_t last_hibern8_exit_tstamp;
	struct ufs_err_reg_hist pa_err;
	struct ufs_err_reg_hist dl_err;
	struct ufs_err_reg_hist nl_err;
	struct ufs_err_reg_hist tl_err;
	struct ufs_err_reg_hist dme_err;
	struct ufs_err_reg_hist auto_hibern8_err;
	struct ufs_err_reg_hist fatal_err;
	struct ufs_err_reg_hist link_startup_err;
	struct ufs_err_reg_hist resume_err;
	struct ufs_err_reg_hist suspend_err;
	struct ufs_err_reg_hist dev_reset;
	struct ufs_err_reg_hist host_reset;
	struct ufs_err_reg_hist task_abort;
};

enum clk_gating_state {
	CLKS_OFF = 0,
	CLKS_ON = 1,
	REQ_CLKS_OFF = 2,
	REQ_CLKS_ON = 3,
};

struct ufs_clk_gating {
	struct delayed_work gate_work;
	struct work_struct ungate_work;
	enum clk_gating_state state;
	long unsigned int delay_ms;
	bool is_suspended;
	struct device_attribute delay_attr;
	struct device_attribute enable_attr;
	bool is_enabled;
	int active_reqs;
	struct workqueue_struct *clk_gating_workq;
};

struct ufs_saved_pwr_info {
	struct ufs_pa_layer_attr info;
	bool is_valid;
};

struct ufs_clk_scaling {
	int active_reqs;
	long unsigned int tot_busy_t;
	long unsigned int window_start_t;
	ktime_t busy_start_t;
	struct device_attribute enable_attr;
	struct ufs_saved_pwr_info saved_pwr_info;
	struct workqueue_struct *workq;
	struct work_struct suspend_work;
	struct work_struct resume_work;
	bool is_allowed;
	bool is_busy_started;
	bool is_suspended;
};

struct ufs_hba {
	void *mmio_base;
	struct utp_transfer_cmd_desc *ucdl_base_addr;
	struct utp_transfer_req_desc *utrdl_base_addr;
	struct utp_task_req_desc *utmrdl_base_addr;
	dma_addr_t ucdl_dma_addr;
	dma_addr_t utrdl_dma_addr;
	dma_addr_t utmrdl_dma_addr;
	struct Scsi_Host *host;
	struct device *dev;
	struct request_queue *cmd_queue;
	struct scsi_device *sdev_ufs_device;
	enum ufs_dev_pwr_mode curr_dev_pwr_mode;
	enum uic_link_state uic_link_state;
	enum ufs_pm_level rpm_lvl;
	enum ufs_pm_level spm_lvl;
	struct device_attribute rpm_lvl_attr;
	struct device_attribute spm_lvl_attr;
	int pm_op_in_progress;
	u32 ahit;
	struct ufshcd_lrb *lrb;
	long unsigned int outstanding_tasks;
	long unsigned int outstanding_reqs;
	u32 capabilities;
	int nutrs;
	int nutmrs;
	u32 ufs_version;
	const struct ufs_hba_variant_ops *vops;
	void *priv;
	unsigned int irq;
	bool is_irq_enabled;
	enum ufs_ref_clk_freq dev_ref_clk_freq;
	unsigned int quirks;
	unsigned int dev_quirks;
	struct blk_mq_tag_set tmf_tag_set;
	struct request_queue *tmf_queue;
	struct uic_command *active_uic_cmd;
	struct mutex uic_cmd_mutex;
	struct completion *uic_async_done;
	u32 ufshcd_state;
	u32 eh_flags;
	u32 intr_mask;
	u16 ee_ctrl_mask;
	bool is_powered;
	bool is_init_prefetch;
	struct ufs_init_prefetch init_prefetch_data;
	struct work_struct eh_work;
	struct work_struct eeh_work;
	u32 errors;
	u32 uic_error;
	u32 saved_err;
	u32 saved_uic_err;
	struct ufs_stats ufs_stats;
	bool silence_err_logs;
	struct ufs_dev_cmd dev_cmd;
	ktime_t last_dme_cmd_tstamp;
	struct ufs_dev_info dev_info;
	bool auto_bkops_enabled;
	struct ufs_vreg_info vreg_info;
	struct list_head clk_list_head;
	bool wlun_dev_clr_ua;
	int req_abort_count;
	u32 lanes_per_direction;
	struct ufs_pa_layer_attr pwr_info;
	struct ufs_pwr_mode_info max_pwr_info;
	struct ufs_clk_gating clk_gating;
	u32 caps;
	struct devfreq *devfreq;
	struct ufs_clk_scaling clk_scaling;
	bool is_sys_suspended;
	enum bkops_status urgent_bkops_lvl;
	bool is_urgent_bkops_lvl_checked;
	struct rw_semaphore clk_scaling_lock;
	struct ufs_desc_size desc_size;
	atomic_t scsi_block_reqs_cnt;
	struct device bsg_dev;
	struct request_queue *bsg_queue;
};

struct ufs_dev_fix {
	struct ufs_dev_desc card;
	unsigned int quirk;
};

struct trace_event_raw_ufshcd_clk_gating {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	int state;
	char __data[0];
};

struct trace_event_raw_ufshcd_clk_scaling {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 __data_loc_state;
	u32 __data_loc_clk;
	u32 prev_state;
	u32 curr_state;
	char __data[0];
};

struct trace_event_raw_ufshcd_auto_bkops_state {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 __data_loc_state;
	char __data[0];
};

struct trace_event_raw_ufshcd_profiling_template {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 __data_loc_profile_info;
	s64 time_us;
	int err;
	char __data[0];
};

struct trace_event_raw_ufshcd_template {
	struct trace_entry ent;
	s64 usecs;
	int err;
	u32 __data_loc_dev_name;
	int dev_state;
	int link_state;
	char __data[0];
};

struct trace_event_raw_ufshcd_command {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 __data_loc_str;
	unsigned int tag;
	u32 doorbell;
	int transfer_len;
	u32 intr;
	u64 lba;
	u8 opcode;
	char __data[0];
};

struct trace_event_raw_ufshcd_upiu {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 __data_loc_str;
	unsigned char hdr[12];
	unsigned char tsf[16];
	char __data[0];
};

struct trace_event_data_offsets_ufshcd_clk_gating {
	u32 dev_name;
};

struct trace_event_data_offsets_ufshcd_clk_scaling {
	u32 dev_name;
	u32 state;
	u32 clk;
};

struct trace_event_data_offsets_ufshcd_auto_bkops_state {
	u32 dev_name;
	u32 state;
};

struct trace_event_data_offsets_ufshcd_profiling_template {
	u32 dev_name;
	u32 profile_info;
};

struct trace_event_data_offsets_ufshcd_template {
	u32 dev_name;
};

struct trace_event_data_offsets_ufshcd_command {
	u32 dev_name;
	u32 str;
};

struct trace_event_data_offsets_ufshcd_upiu {
	u32 dev_name;
	u32 str;
};

typedef void (*btf_trace_ufshcd_clk_gating)(void *, const char *, int);

typedef void (*btf_trace_ufshcd_clk_scaling)(void *, const char *, const char *, const char *, u32, u32);

typedef void (*btf_trace_ufshcd_auto_bkops_state)(void *, const char *, const char *);

typedef void (*btf_trace_ufshcd_profile_hibern8)(void *, const char *, const char *, s64, int);

typedef void (*btf_trace_ufshcd_profile_clk_gating)(void *, const char *, const char *, s64, int);

typedef void (*btf_trace_ufshcd_profile_clk_scaling)(void *, const char *, const char *, s64, int);

typedef void (*btf_trace_ufshcd_system_suspend)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_system_resume)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_runtime_suspend)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_runtime_resume)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_init)(void *, const char *, int, s64, int, int);

typedef void (*btf_trace_ufshcd_command)(void *, const char *, const char *, unsigned int, u32, int, u32, u64, u8);

typedef void (*btf_trace_ufshcd_upiu)(void *, const char *, const char *, void *, void *);

enum {
	UFSHCD_MAX_CHANNEL = 0,
	UFSHCD_MAX_ID = 1,
	UFSHCD_CMD_PER_LUN = 32,
	UFSHCD_CAN_QUEUE = 32,
};

enum {
	UFSHCD_STATE_RESET = 0,
	UFSHCD_STATE_ERROR = 1,
	UFSHCD_STATE_OPERATIONAL = 2,
	UFSHCD_STATE_EH_SCHEDULED = 3,
};

enum {
	UFSHCD_EH_IN_PROGRESS = 1,
};

enum {
	UFSHCD_UIC_DL_PA_INIT_ERROR = 1,
	UFSHCD_UIC_DL_NAC_RECEIVED_ERROR = 2,
	UFSHCD_UIC_DL_TCx_REPLAY_ERROR = 4,
	UFSHCD_UIC_NL_ERROR = 8,
	UFSHCD_UIC_TL_ERROR = 16,
	UFSHCD_UIC_DME_ERROR = 32,
};

struct uc_string_id {
	u8 len;
	u8 type;
	wchar_t uc[0];
};

struct ctm_info {
	struct ufs_hba *hba;
	long unsigned int pending;
	unsigned int ncpl;
};

enum interconnect_desc_param {
	INTERCONNECT_DESC_PARAM_LEN = 0,
	INTERCONNECT_DESC_PARAM_TYPE = 1,
	INTERCONNECT_DESC_PARAM_UNIPRO_VER = 2,
	INTERCONNECT_DESC_PARAM_MPHY_VER = 4,
};

enum geometry_desc_param {
	GEOMETRY_DESC_PARAM_LEN = 0,
	GEOMETRY_DESC_PARAM_TYPE = 1,
	GEOMETRY_DESC_PARAM_DEV_CAP = 4,
	GEOMETRY_DESC_PARAM_MAX_NUM_LUN = 12,
	GEOMETRY_DESC_PARAM_SEG_SIZE = 13,
	GEOMETRY_DESC_PARAM_ALLOC_UNIT_SIZE = 17,
	GEOMETRY_DESC_PARAM_MIN_BLK_SIZE = 18,
	GEOMETRY_DESC_PARAM_OPT_RD_BLK_SIZE = 19,
	GEOMETRY_DESC_PARAM_OPT_WR_BLK_SIZE = 20,
	GEOMETRY_DESC_PARAM_MAX_IN_BUF_SIZE = 21,
	GEOMETRY_DESC_PARAM_MAX_OUT_BUF_SIZE = 22,
	GEOMETRY_DESC_PARAM_RPMB_RW_SIZE = 23,
	GEOMETRY_DESC_PARAM_DYN_CAP_RSRC_PLC = 24,
	GEOMETRY_DESC_PARAM_DATA_ORDER = 25,
	GEOMETRY_DESC_PARAM_MAX_NUM_CTX = 26,
	GEOMETRY_DESC_PARAM_TAG_UNIT_SIZE = 27,
	GEOMETRY_DESC_PARAM_TAG_RSRC_SIZE = 28,
	GEOMETRY_DESC_PARAM_SEC_RM_TYPES = 29,
	GEOMETRY_DESC_PARAM_MEM_TYPES = 30,
	GEOMETRY_DESC_PARAM_SCM_MAX_NUM_UNITS = 32,
	GEOMETRY_DESC_PARAM_SCM_CAP_ADJ_FCTR = 36,
	GEOMETRY_DESC_PARAM_NPM_MAX_NUM_UNITS = 38,
	GEOMETRY_DESC_PARAM_NPM_CAP_ADJ_FCTR = 42,
	GEOMETRY_DESC_PARAM_ENM1_MAX_NUM_UNITS = 44,
	GEOMETRY_DESC_PARAM_ENM1_CAP_ADJ_FCTR = 48,
	GEOMETRY_DESC_PARAM_ENM2_MAX_NUM_UNITS = 50,
	GEOMETRY_DESC_PARAM_ENM2_CAP_ADJ_FCTR = 54,
	GEOMETRY_DESC_PARAM_ENM3_MAX_NUM_UNITS = 56,
	GEOMETRY_DESC_PARAM_ENM3_CAP_ADJ_FCTR = 60,
	GEOMETRY_DESC_PARAM_ENM4_MAX_NUM_UNITS = 62,
	GEOMETRY_DESC_PARAM_ENM4_CAP_ADJ_FCTR = 66,
	GEOMETRY_DESC_PARAM_OPT_LOG_BLK_SIZE = 68,
};

enum health_desc_param {
	HEALTH_DESC_PARAM_LEN = 0,
	HEALTH_DESC_PARAM_TYPE = 1,
	HEALTH_DESC_PARAM_EOL_INFO = 2,
	HEALTH_DESC_PARAM_LIFE_TIME_EST_A = 3,
	HEALTH_DESC_PARAM_LIFE_TIME_EST_B = 4,
};

struct atp_id {
	unsigned char dirct;
	unsigned char devsp;
	unsigned char devtype;
	long unsigned int tran_len;
	long unsigned int last_len;
	unsigned char *prd_pos;
	unsigned char *prd_table;
	dma_addr_t prd_bus;
	dma_addr_t prdaddr;
	struct scsi_cmnd *curr_req;
};

struct atp_unit {
	long unsigned int baseport;
	long unsigned int ioport[2];
	long unsigned int pciport[2];
	unsigned char last_cmd[2];
	unsigned char in_snd[2];
	unsigned char in_int[2];
	unsigned char quhd[2];
	unsigned char quend[2];
	unsigned char global_map[2];
	unsigned char host_id[2];
	unsigned int working[2];
	short unsigned int wide_id[2];
	short unsigned int active_id[2];
	short unsigned int ultra_map[2];
	short unsigned int async[2];
	unsigned char sp[32];
	unsigned char r1f[32];
	struct scsi_cmnd *quereq[64];
	struct atp_id id[32];
	struct Scsi_Host *host;
	struct pci_dev *pdev;
	unsigned int unit;
};

typedef struct {
	u32 sg_ptr;
	u32 sg_len;
} gdth_sg_str;

typedef struct {
	u64 sg_ptr;
	u32 sg_len;
} __attribute__((packed)) gdth_sg64_str;

typedef struct {
	u32 BoardNode;
	u32 CommandIndex;
	u16 OpCode;
	union {
		struct {
			u16 DeviceNo;
			u32 BlockNo;
			u32 BlockCnt;
			u32 DestAddr;
			u32 sg_canz;
			gdth_sg_str sg_lst[32];
		} __attribute__((packed)) cache;
		struct {
			u16 DeviceNo;
			u64 BlockNo;
			u32 BlockCnt;
			u64 DestAddr;
			u32 sg_canz;
			gdth_sg64_str sg_lst[32];
		} __attribute__((packed)) cache64;
		struct {
			u16 param_size;
			u32 subfunc;
			u32 channel;
			u64 p_param;
		} __attribute__((packed)) ioctl;
		struct {
			u16 reserved;
			union {
				struct {
					u32 msg_handle;
					u64 msg_addr;
				} __attribute__((packed)) msg;
				u8 data[12];
			} su;
		} __attribute__((packed)) screen;
		struct {
			u16 reserved;
			u32 direction;
			u32 mdisc_time;
			u32 mcon_time;
			u32 sdata;
			u32 sdlen;
			u32 clen;
			u8 cmd[12];
			u8 target;
			u8 lun;
			u8 bus;
			u8 priority;
			u32 sense_len;
			u32 sense_data;
			u32 link_p;
			u32 sg_ranz;
			gdth_sg_str sg_lst[32];
		} __attribute__((packed)) raw;
		struct {
			u16 reserved;
			u32 direction;
			u32 mdisc_time;
			u32 mcon_time;
			u64 sdata;
			u32 sdlen;
			u32 clen;
			u8 cmd[16];
			u8 target;
			u8 lun;
			u8 bus;
			u8 priority;
			u32 sense_len;
			u64 sense_data;
			u32 sg_ranz;
			gdth_sg64_str sg_lst[32];
		} __attribute__((packed)) raw64;
	} u;
	u8 Service;
	u8 reserved;
	u16 Status;
	u32 Info;
	void *RequestBuffer;
} __attribute__((packed)) gdth_cmd_str;

typedef struct {
	u16 size;
	union {
		char stream[16];
		struct {
			u16 ionode;
			u16 service;
			u32 index;
		} driver;
		struct {
			u16 ionode;
			u16 service;
			u16 status;
			u32 info;
			u8 scsi_coord[3];
		} __attribute__((packed)) async;
		struct {
			u16 ionode;
			u16 service;
			u16 status;
			u32 info;
			u16 hostdrive;
			u8 scsi_coord[3];
			u8 sense_key;
		} __attribute__((packed)) sync;
		struct {
			u32 l1;
			u32 l2;
			u32 l3;
			u32 l4;
		} test;
	} eu;
	u32 severity;
	u8 event_string[256];
} __attribute__((packed)) gdth_evt_data;

typedef struct {
	u32 first_stamp;
	u32 last_stamp;
	u16 same_count;
	u16 event_source;
	u16 event_idx;
	u8 application;
	u8 reserved;
	gdth_evt_data event_data;
} __attribute__((packed)) gdth_evt_str;

typedef struct {
	u16 ionode;
	u16 timeout;
	u32 info;
	u16 status;
	long unsigned int data_len;
	long unsigned int sense_len;
	gdth_cmd_str command;
} gdth_ioctl_general;

typedef struct {
	u16 ionode;
	u8 lock;
	u8 drive_cnt;
	u16 drives[255];
} gdth_ioctl_lockdrv;

typedef struct {
	u16 ionode;
	u8 lock;
	u8 channel;
} gdth_ioctl_lockchn;

typedef struct {
	u8 version;
	u8 subversion;
	u16 revision;
} gdth_ioctl_osvers;

typedef struct {
	u16 ionode;
	u8 type;
	u16 info;
	u16 oem_id;
	u16 bios_ver;
	u16 access;
	u16 ext_type;
	u16 device_id;
	u16 sub_device_id;
} gdth_ioctl_ctrtype;

typedef struct {
	u16 ionode;
	int erase;
	int handle;
	gdth_evt_str event;
} gdth_ioctl_event;

typedef struct {
	u16 ionode;
	u8 flag;
	u16 hdr_no;
	struct {
		u8 bus;
		u8 target;
		u8 lun;
		u8 cluster_type;
	} hdr_list[255];
} gdth_ioctl_rescan;

typedef struct {
	u16 ionode;
	u16 number;
	u16 status;
} gdth_ioctl_reset;

typedef struct {
	u32 msg_handle;
	u32 msg_len;
	u32 msg_alen;
	u8 msg_answer;
	u8 msg_ext;
	u8 msg_reserved[2];
	char msg_text[18];
} __attribute__((packed)) gdth_msg_str;

typedef struct {
	u8 vendor[8];
	u8 product[16];
	u8 revision[4];
	u32 sy_rate;
	u32 sy_max_rate;
	u32 no_ldrive;
	u32 blkcnt;
	u16 blksize;
	u8 available;
	u8 init;
	u8 devtype;
	u8 rm_medium;
	u8 wp_medium;
	u8 ansi;
	u8 protocol;
	u8 sync;
	u8 disc;
	u8 queueing;
	u8 cached;
	u8 target_id;
	u8 lun;
	u8 orphan;
	u32 last_error;
	u32 last_result;
	u32 check_errors;
	u8 percent;
	u8 last_check;
	u8 res[2];
	u32 flags;
	u8 multi_bus;
	u8 mb_status;
	u8 res2[2];
	u8 mb_alt_status;
	u8 mb_alt_bid;
	u8 mb_alt_tid;
	u8 res3;
	u8 fc_flag;
	u8 res4;
	u16 fc_frame_size;
	char wwn[8];
} gdth_diskinfo_str;

typedef struct {
	u32 channel_no;
	u32 drive_cnt;
	u8 siop_id;
	u8 siop_state;
} __attribute__((packed)) gdth_getch_str;

typedef struct {
	u32 sc_no;
	u32 sc_cnt;
	u32 sc_list[127];
} gdth_drlist_str;

typedef struct {
	u8 sddc_type;
	u8 sddc_format;
	u8 sddc_len;
	u8 sddc_res;
	u32 sddc_cnt;
} gdth_defcnt_str;

typedef struct {
	u32 bid;
	u32 first;
	u32 entries;
	u32 count;
	u32 mon_time;
	struct {
		u8 tid;
		u8 lun;
		u8 res[2];
		u32 blk_size;
		u32 rd_count;
		u32 wr_count;
		u32 rd_blk_count;
		u32 wr_blk_count;
		u32 retries;
		u32 reassigns;
	} list[1];
} gdth_dskstat_str;

typedef struct {
	u32 version;
	u8 list_entries;
	u8 first_chan;
	u8 last_chan;
	u8 chan_count;
	u32 list_offset;
} gdth_iochan_header;

typedef struct {
	gdth_iochan_header hdr;
	struct {
		u32 address;
		u8 type;
		u8 local_no;
		u16 features;
	} list[6];
} gdth_iochan_str;

typedef struct {
	gdth_iochan_header hdr;
	struct {
		u8 proc_id;
		u8 proc_defect;
		u8 reserved[2];
	} list[6];
} gdth_raw_iochan_str;

typedef struct {
	u32 al_controller;
	u8 al_cache_drive;
	u8 al_status;
	u8 al_res[2];
} gdth_arraycomp_str;

typedef struct {
	u8 ai_type;
	u8 ai_cache_drive_cnt;
	u8 ai_state;
	u8 ai_master_cd;
	u32 ai_master_controller;
	u32 ai_size;
	u32 ai_striping_size;
	u32 ai_secsize;
	u32 ai_err_info;
	u8 ai_name[8];
	u8 ai_controller_cnt;
	u8 ai_removable;
	u8 ai_write_protected;
	u8 ai_devtype;
	gdth_arraycomp_str ai_drives[35];
	u8 ai_drive_entries;
	u8 ai_protected;
	u8 ai_verify_state;
	u8 ai_ext_state;
	u8 ai_expand_state;
	u8 ai_reserved[3];
} gdth_arrayinf_str;

typedef struct {
	u32 controller_no;
	u8 cd_handle;
	u8 is_arrayd;
	u8 is_master;
	u8 is_parity;
	u8 is_hotfix;
	u8 res[3];
} gdth_alist_str;

typedef struct {
	u32 entries_avail;
	u32 entries_init;
	u32 first_entry;
	u32 list_offset;
	gdth_alist_str list[1];
} gdth_arcdl_str;

typedef struct {
	u32 version;
	u16 state;
	u16 strategy;
	u16 write_back;
	u16 block_size;
} gdth_cpar_str;

typedef struct {
	u32 csize;
	u32 read_cnt;
	u32 write_cnt;
	u32 tr_hits;
	u32 sec_hits;
	u32 sec_miss;
} gdth_cstat_str;

typedef struct {
	gdth_cpar_str cpar;
	gdth_cstat_str cstat;
} gdth_cinfo_str;

typedef struct {
	u8 cd_name[8];
	u32 cd_devtype;
	u32 cd_ldcnt;
	u32 cd_last_error;
	u8 cd_initialized;
	u8 cd_removable;
	u8 cd_write_protected;
	u8 cd_flags;
	u32 ld_blkcnt;
	u32 ld_blksize;
	u32 ld_dcnt;
	u32 ld_slave;
	u32 ld_dtype;
	u32 ld_last_error;
	u8 ld_name[8];
	u8 ld_error;
} __attribute__((packed)) gdth_cdrinfo_str;

typedef struct {
	u32 ctl_version;
	u32 file_major_version;
	u32 file_minor_version;
	u32 buffer_size;
	u32 cpy_count;
	u32 ext_error;
	u32 oem_id;
	u32 board_id;
} gdth_oem_str_params;

typedef struct {
	u8 product_0_1_name[16];
	u8 product_4_5_name[16];
	u8 product_cluster_name[16];
	u8 product_reserved[16];
	u8 scsi_cluster_target_vendor_id[16];
	u8 cluster_raid_fw_name[16];
	u8 oem_brand_name[16];
	u8 oem_raid_type[16];
	u8 bios_type[13];
	u8 bios_title[50];
	u8 oem_company_name[37];
	u32 pci_id_1;
	u32 pci_id_2;
	u8 validation_status[80];
	u8 reserved_1[4];
	u8 scsi_host_drive_inquiry_vendor_id[16];
	u8 library_file_template[16];
	u8 reserved_2[16];
	u8 tool_name_1[32];
	u8 tool_name_2[32];
	u8 tool_name_3[32];
	u8 oem_contact_1[84];
	u8 oem_contact_2[84];
	u8 oem_contact_3[84];
} gdth_oem_str;

typedef struct {
	gdth_oem_str_params params;
	gdth_oem_str text;
} gdth_oem_str_ioctl;

typedef struct {
	u8 chaining;
	u8 striping;
	u8 mirroring;
	u8 raid;
} gdth_bfeat_str;

typedef struct {
	u32 ser_no;
	u8 oem_id[2];
	u16 ep_flags;
	u32 proc_id;
	u32 memsize;
	u8 mem_banks;
	u8 chan_type;
	u8 chan_count;
	u8 rdongle_pres;
	u32 epr_fw_ver;
	u32 upd_fw_ver;
	u32 upd_revision;
	char type_string[16];
	char raid_string[16];
	u8 update_pres;
	u8 xor_pres;
	u8 prom_type;
	u8 prom_count;
	u32 dup_pres;
	u32 chan_pres;
	u32 mem_pres;
	u8 ft_bus_system;
	u8 subtype_valid;
	u8 board_subtype;
	u8 ramparity_pres;
} gdth_binfo_str;

typedef struct {
	char name[8];
	u32 size;
	u8 host_drive;
	u8 log_drive;
	u8 reserved;
	u8 rw_attribs;
	u32 start_sec;
} gdth_hentry_str;

typedef struct {
	u32 entries;
	u32 offset;
	u8 secs_p_head;
	u8 heads_p_cyl;
	u8 reserved;
	u8 clust_drvtype;
	u32 location;
	gdth_hentry_str entry[255];
} gdth_hget_str;

typedef struct {
	u8 S_Cmd_Indx;
	volatile u8 S_Status;
	u16 reserved1;
	u32 S_Info[4];
	volatile u8 Sema0;
	u8 reserved2[3];
	u8 Cmd_Index;
	u8 reserved3[3];
	volatile u16 Status;
	u16 Service;
	u32 Info[2];
	struct {
		u16 offset;
		u16 serv_id;
	} comm_queue[128];
	u32 bios_reserved[2];
	u8 gdt_dpr_cmd[1];
} __attribute__((packed)) gdt_dpr_if;

typedef struct {
	u32 magic;
	u16 need_deinit;
	u8 switch_support;
	u8 padding[9];
	u8 os_used[16];
	u8 unused[28];
	u8 fw_magic;
} __attribute__((packed)) gdt_pci_sram;

typedef struct {
	union {
		gdt_dpr_if ic;
		u8 if_area[4019];
	} u;
	gdt_pci_sram gdt6sr;
	struct {
		u8 unused0[1];
		volatile u8 Sema1;
		u8 unused1[3];
		u8 irqen;
		u8 unused2[2];
		u8 event;
		u8 unused3[3];
		u8 irqdel;
		u8 unused4[3];
	} io;
} __attribute__((packed)) gdt6_dpram_str;

typedef struct {
	u8 cfg_reg;
	u8 unused1[63];
	volatile u8 sema0_reg;
	volatile u8 sema1_reg;
	u8 unused2[2];
	volatile u16 status;
	u16 service;
	u32 info[2];
	u8 unused3[16];
	u8 ldoor_reg;
	u8 unused4[3];
	volatile u8 edoor_reg;
	u8 unused5[3];
	u8 control0;
	u8 control1;
	u8 unused6[22];
} gdt6c_plx_regs;

typedef struct {
	union {
		gdt_dpr_if ic;
		u8 if_area[16323];
	} u;
	gdt_pci_sram gdt6sr;
} __attribute__((packed)) gdt6c_dpram_str;

typedef struct {
	u8 unused1[16];
	volatile u8 sema0_reg;
	u8 unused2;
	volatile u8 sema1_reg;
	u8 unused3;
	volatile u16 status;
	u16 service;
	u32 info[2];
	u8 ldoor_reg;
	u8 unused4[11];
	volatile u8 edoor_reg;
	u8 unused5[7];
	u8 edoor_en_reg;
	u8 unused6[27];
	u32 unused7[939];
	u32 severity;
	char evt_str[256];
} gdt6m_i960_regs;

typedef struct {
	gdt6m_i960_regs i960r;
	union {
		gdt_dpr_if ic;
		u8 if_area[12227];
	} u;
	gdt_pci_sram gdt6sr;
} __attribute__((packed)) gdt6m_dpram_str;

typedef struct {
	struct pci_dev *pdev;
	long unsigned int dpmem;
	long unsigned int io;
} gdth_pci_str;

struct gdth_cmndinfo {
	int index;
	int internal_command;
	gdth_cmd_str *internal_cmd_str;
	dma_addr_t sense_paddr;
	u8 priority;
	int timeout_count;
	volatile int wait_for_completion;
	u16 status;
	u32 info;
	enum dma_data_direction dma_dir;
	int phase;
	int OpCode;
};

typedef struct {
	struct Scsi_Host *shost;
	struct list_head list;
	u16 hanum;
	u16 oem_id;
	u16 type;
	short: 16;
	u32 stype;
	u16 fw_vers;
	u16 cache_feat;
	u16 raw_feat;
	u16 screen_feat;
	int: 32;
	void *brd;
	u32 brd_phys;
	int: 32;
	gdt6c_plx_regs *plx;
	gdth_cmd_str cmdext;
	int: 32;
	gdth_cmd_str *pccb;
	u32 ccb_phys;
	int: 32;
	char *pscratch;
	u64 scratch_phys;
	u8 scratch_busy;
	u8 dma64_support;
	long: 48;
	gdth_msg_str *pmsg;
	u64 msg_phys;
	u8 scan_mode;
	u8 irq;
	u8 drq;
	char: 8;
	u16 status;
	u16 service;
	u32 info;
	u32 info2;
	struct scsi_cmnd *req_first;
	struct {
		u8 present;
		u8 is_logdrv;
		u8 is_arraydrv;
		u8 is_master;
		u8 is_parity;
		u8 is_hotfix;
		u8 master_no;
		u8 lock;
		u8 heads;
		u8 secs;
		u16 devtype;
		u64 size;
		u8 ldr_no;
		u8 rw_attribs;
		u8 cluster_type;
		u8 media_changed;
		u32 start_sec;
	} hdr[255];
	struct {
		u8 lock;
		u8 pdev_cnt;
		u8 local_no;
		u8 io_cnt[127];
		u32 address;
		u32 id_list[127];
	} raw[6];
	struct {
		struct scsi_cmnd *cmnd;
		u16 service;
	} cmd_tab[120];
	struct gdth_cmndinfo cmndinfo[120];
	u8 bus_cnt;
	u8 tid_cnt;
	u8 bus_id[6];
	u8 virt_bus;
	u8 more_proc;
	u16 cmd_cnt;
	u16 cmd_len;
	u16 cmd_offs_dpmem;
	u16 ic_all_size;
	gdth_cpar_str cpar;
	gdth_bfeat_str bfeat;
	gdth_binfo_str binfo;
	gdth_evt_data dvr;
	spinlock_t smp_lock;
	struct pci_dev *pdev;
	char oem_name[8];
	struct scsi_device *sdev;
} __attribute__((packed)) gdth_ha_str;

typedef struct {
	u8 type_qual;
	u8 modif_rmb;
	u8 version;
	u8 resp_aenc;
	u8 add_length;
	u8 reserved1;
	u8 reserved2;
	u8 misc;
	u8 vendor[8];
	u8 product[16];
	u8 revision[4];
} gdth_inq_data;

typedef struct {
	u32 last_block_no;
	u32 block_length;
} gdth_rdcap_data;

typedef struct {
	u64 last_block_no;
	u32 block_length;
} __attribute__((packed)) gdth_rdcap16_data;

typedef struct {
	u8 errorcode;
	u8 segno;
	u8 key;
	u32 info;
	u8 add_length;
	u32 cmd_info;
	u8 adsc;
	u8 adsq;
	u8 fruc;
	u8 key_spec[3];
} __attribute__((packed)) gdth_sense_data;

typedef struct {
	struct {
		u8 data_length;
		u8 med_type;
		u8 dev_par;
		u8 bd_length;
	} hd;
	struct {
		u8 dens_code;
		u8 block_count[3];
		u8 reserved;
		u8 block_length[3];
	} bd;
} gdth_modep_data;

typedef struct {
	long unsigned int b[10];
} gdth_stackframe;

struct sg_entry {
	u32 data;
	u32 len;
};

struct scsi_ctrl_blk {
	struct scsi_ctrl_blk *next;
	u8 status;
	u8 next_state;
	u8 mode;
	u8 msgin;
	u16 sgidx;
	u16 sgmax;
	u32 reserved[3];
	u32 xferlen;
	u32 totxlen;
	u32 paddr;
	u8 opcode;
	u8 flags;
	u8 target;
	u8 lun;
	u32 bufptr;
	u32 buflen;
	u8 sglen;
	u8 senselen;
	u8 hastat;
	u8 tastat;
	u8 cdblen;
	u8 ident;
	u8 tagmsg;
	u8 tagid;
	u8 cdb[12];
	u32 sgpaddr;
	u32 senseptr;
	void (*post)(u8 *, u8 *);
	struct scsi_cmnd *srb;
	struct sg_entry sglist[32];
};

struct target_control {
	u16 flags;
	u8 js_period;
	u8 sconfig0;
	u16 drv_flags;
	u8 heads;
	u8 sectors;
};

struct initio_host {
	u16 addr;
	u16 bios_addr;
	u8 irq;
	u8 scsi_id;
	u8 max_tar;
	u8 num_scbs;
	u8 flags;
	u8 index;
	u8 ha_id;
	u8 config;
	u16 idmask;
	u8 semaph;
	u8 phase;
	u8 jsstatus0;
	u8 jsint;
	u8 jsstatus1;
	u8 sconf1;
	u8 msg[8];
	struct scsi_ctrl_blk *next_avail;
	struct scsi_ctrl_blk *scb;
	struct scsi_ctrl_blk *scb_end;
	struct scsi_ctrl_blk *next_pending;
	struct scsi_ctrl_blk *next_contig;
	struct scsi_ctrl_blk *active;
	struct target_control *active_tc;
	struct scsi_ctrl_blk *first_avail;
	struct scsi_ctrl_blk *last_avail;
	struct scsi_ctrl_blk *first_pending;
	struct scsi_ctrl_blk *last_pending;
	struct scsi_ctrl_blk *first_busy;
	struct scsi_ctrl_blk *last_busy;
	struct scsi_ctrl_blk *first_done;
	struct scsi_ctrl_blk *last_done;
	u8 max_tags[16];
	u8 act_tags[16];
	struct target_control targets[16];
	spinlock_t avail_lock;
	spinlock_t semaph_lock;
	struct pci_dev *pci_dev;
};

struct _NVRAM_SCSI {
	u8 NVM_ChSCSIID;
	u8 NVM_ChConfig1;
	u8 NVM_ChConfig2;
	u8 NVM_NumOfTarg;
	u8 NVM_Targ0Config;
	u8 NVM_Targ1Config;
	u8 NVM_Targ2Config;
	u8 NVM_Targ3Config;
	u8 NVM_Targ4Config;
	u8 NVM_Targ5Config;
	u8 NVM_Targ6Config;
	u8 NVM_Targ7Config;
	u8 NVM_Targ8Config;
	u8 NVM_Targ9Config;
	u8 NVM_TargAConfig;
	u8 NVM_TargBConfig;
	u8 NVM_TargCConfig;
	u8 NVM_TargDConfig;
	u8 NVM_TargEConfig;
	u8 NVM_TargFConfig;
};

typedef struct _NVRAM_SCSI NVRAM_SCSI;

struct _NVRAM {
	u16 NVM_Signature;
	u8 NVM_Size;
	u8 NVM_Revision;
	u8 NVM_ModelByte0;
	u8 NVM_ModelByte1;
	u8 NVM_ModelInfo;
	u8 NVM_NumOfCh;
	u8 NVM_BIOSConfig1;
	u8 NVM_BIOSConfig2;
	u8 NVM_HAConfig1;
	u8 NVM_HAConfig2;
	NVRAM_SCSI NVM_SCSIInfo[2];
	u8 NVM_reserved[10];
	u16 NVM_CheckSum;
};

typedef struct _NVRAM NVRAM___2;

struct TAG_twa_message_type {
	unsigned int code;
	char *text;
};

typedef struct TAG_twa_message_type twa_message_type;

struct TAG_TW_SG_Entry {
	dma_addr_t address;
	u32 length;
} __attribute__((packed));

typedef struct TAG_TW_SG_Entry TW_SG_Entry;

struct TW_Command {
	unsigned char opcode__sgloffset;
	unsigned char size;
	unsigned char request_id;
	unsigned char unit__hostid;
	unsigned char status;
	unsigned char flags;
	union {
		short unsigned int block_count;
		short unsigned int parameter_count;
	} byte6_offset;
	union {
		struct {
			u32 lba;
			TW_SG_Entry sgl[41];
			dma_addr_t padding;
		} __attribute__((packed)) io;
		struct {
			TW_SG_Entry sgl[41];
			u32 padding;
			dma_addr_t padding2;
		} param;
	} byte8_offset;
};

typedef struct TW_Command TW_Command;

struct TAG_TW_Command_Apache {
	unsigned char opcode__reserved;
	unsigned char unit;
	short unsigned int request_id__lunl;
	unsigned char status;
	unsigned char sgl_offset;
	short unsigned int sgl_entries__lunh;
	unsigned char cdb[16];
	TW_SG_Entry sg_list[72];
	unsigned char padding[8];
};

typedef struct TAG_TW_Command_Apache TW_Command_Apache;

struct TAG_TW_Command_Apache_Header {
	unsigned char sense_data[18];
	struct {
		char reserved[4];
		short unsigned int error;
		unsigned char padding;
		unsigned char severity__reserved;
	} status_block;
	unsigned char err_specific_desc[98];
	struct {
		unsigned char size_header;
		short unsigned int reserved;
		unsigned char size_sense;
	} __attribute__((packed)) header_desc;
};

typedef struct TAG_TW_Command_Apache_Header TW_Command_Apache_Header;

struct TAG_TW_Command_Full {
	TW_Command_Apache_Header header;
	union {
		TW_Command oldcommand;
		TW_Command_Apache newcommand;
	} command;
};

typedef struct TAG_TW_Command_Full TW_Command_Full;

struct TAG_TW_Initconnect {
	unsigned char opcode__reserved;
	unsigned char size;
	unsigned char request_id;
	unsigned char res2;
	unsigned char status;
	unsigned char flags;
	short unsigned int message_credits;
	u32 features;
	short unsigned int fw_srl;
	short unsigned int fw_arch_id;
	short unsigned int fw_branch;
	short unsigned int fw_build;
	u32 result;
};

typedef struct TAG_TW_Initconnect TW_Initconnect;

struct TAG_TW_Event {
	unsigned int sequence_id;
	unsigned int time_stamp_sec;
	short unsigned int aen_code;
	unsigned char severity;
	unsigned char retrieved;
	unsigned char repeat_count;
	unsigned char parameter_len;
	unsigned char parameter_data[98];
};

typedef struct TAG_TW_Event TW_Event;

struct TAG_TW_Ioctl_Driver_Command {
	unsigned int control_code;
	unsigned int status;
	unsigned int unique_id;
	unsigned int sequence_id;
	unsigned int os_specific;
	unsigned int buffer_length;
};

typedef struct TAG_TW_Ioctl_Driver_Command TW_Ioctl_Driver_Command;

struct TAG_TW_Ioctl_Apache {
	TW_Ioctl_Driver_Command driver_command;
	char padding[488];
	TW_Command_Full firmware_command;
	char data_buffer[1];
} __attribute__((packed));

typedef struct TAG_TW_Ioctl_Apache TW_Ioctl_Buf_Apache;

struct TAG_TW_Lock {
	long unsigned int timeout_msec;
	long unsigned int time_remaining_msec;
	long unsigned int force_flag;
};

typedef struct TAG_TW_Lock TW_Lock;

typedef struct {
	short unsigned int table_id;
	short unsigned int parameter_id;
	short unsigned int parameter_size_bytes;
	short unsigned int actual_parameter_size_bytes;
	unsigned char data[1];
} __attribute__((packed)) TW_Param_Apache;

union TAG_TW_Response_Queue {
	u32 response_id;
	u32 value;
};

typedef union TAG_TW_Response_Queue TW_Response_Queue;

struct TAG_TW_Compatibility_Info {
	char driver_version[32];
	short unsigned int working_srl;
	short unsigned int working_branch;
	short unsigned int working_build;
	short unsigned int driver_srl_high;
	short unsigned int driver_branch_high;
	short unsigned int driver_build_high;
	short unsigned int driver_srl_low;
	short unsigned int driver_branch_low;
	short unsigned int driver_build_low;
	short unsigned int fw_on_ctlr_srl;
	short unsigned int fw_on_ctlr_branch;
	short unsigned int fw_on_ctlr_build;
};

typedef struct TAG_TW_Compatibility_Info TW_Compatibility_Info;

struct TAG_TW_Device_Extension {
	u32 *base_addr;
	long unsigned int *generic_buffer_virt[256];
	dma_addr_t generic_buffer_phys[256];
	TW_Command_Full *command_packet_virt[256];
	dma_addr_t command_packet_phys[256];
	struct pci_dev *tw_pci_dev;
	struct scsi_cmnd *srb[256];
	unsigned char free_queue[256];
	unsigned char free_head;
	unsigned char free_tail;
	unsigned char pending_queue[256];
	unsigned char pending_head;
	unsigned char pending_tail;
	int state[256];
	unsigned int posted_request_count;
	unsigned int max_posted_request_count;
	unsigned int pending_request_count;
	unsigned int max_pending_request_count;
	unsigned int max_sgl_entries;
	unsigned int sgl_entries;
	unsigned int num_resets;
	unsigned int sector_count;
	unsigned int max_sector_count;
	unsigned int aen_count;
	int: 32;
	struct Scsi_Host *host;
	long int flags;
	int reset_print;
	int: 32;
	TW_Event *event_queue[256];
	unsigned char error_index;
	unsigned char event_queue_wrapped;
	short: 16;
	unsigned int error_sequence_id;
	int ioctl_sem_lock;
	int: 32;
	ktime_t ioctl_time;
	int chrdev_request_id;
	int: 32;
	wait_queue_head_t ioctl_wqueue;
	struct mutex ioctl_lock;
	char aen_clobber;
	TW_Compatibility_Info tw_compat_info;
	long: 56;
} __attribute__((packed));

typedef struct TAG_TW_Device_Extension TW_Device_Extension;

struct hpt_iopmu_itl {
	__le32 resrved0[4];
	__le32 inbound_msgaddr0;
	__le32 inbound_msgaddr1;
	__le32 outbound_msgaddr0;
	__le32 outbound_msgaddr1;
	__le32 inbound_doorbell;
	__le32 inbound_intstatus;
	__le32 inbound_intmask;
	__le32 outbound_doorbell;
	__le32 outbound_intstatus;
	__le32 outbound_intmask;
	__le32 reserved1[2];
	__le32 inbound_queue;
	__le32 outbound_queue;
};

struct hpt_iopmu_mv {
	__le32 inbound_head;
	__le32 inbound_tail;
	__le32 outbound_head;
	__le32 outbound_tail;
	__le32 inbound_msg;
	__le32 outbound_msg;
	__le32 reserve[10];
	__le64 inbound_q[512];
	__le64 outbound_q[512];
};

struct hpt_iopmv_regs {
	__le32 reserved[33024];
	__le32 inbound_doorbell;
	__le32 inbound_intmask;
	__le32 outbound_doorbell;
	__le32 outbound_intmask;
};

struct hpt_iopmu_mvfrey {
	__le32 reserved0[4096];
	__le32 inbound_base;
	__le32 inbound_base_high;
	__le32 reserved1[4];
	__le32 inbound_write_ptr;
	__le32 reserved2[4];
	__le32 inbound_conf_ctl;
	__le32 reserved3[8];
	__le32 outbound_base;
	__le32 outbound_base_high;
	__le32 outbound_shadow_base;
	__le32 outbound_shadow_base_high;
	__le32 reserved4[10];
	__le32 isr_cause;
	__le32 isr_enable;
	__le32 reserved5[12383];
	__le32 pcie_f0_int_enable;
	__le32 reserved6[124];
	__le32 f0_to_cpu_msg_a;
	__le32 reserved7[7];
	__le32 cpu_to_f0_msg_a;
	__le32 reserved8[23];
	__le32 f0_doorbell;
	__le32 f0_doorbell_enable;
};

struct mvfrey_inlist_entry {
	dma_addr_t addr;
	__le32 intrfc_len;
	__le32 reserved;
};

struct mvfrey_outlist_entry {
	__le32 val;
};

enum hpt_iopmu_message {
	IOPMU_INBOUND_MSG0_NOP = 0,
	IOPMU_INBOUND_MSG0_RESET = 1,
	IOPMU_INBOUND_MSG0_FLUSH = 2,
	IOPMU_INBOUND_MSG0_SHUTDOWN = 3,
	IOPMU_INBOUND_MSG0_STOP_BACKGROUND_TASK = 4,
	IOPMU_INBOUND_MSG0_START_BACKGROUND_TASK = 5,
	IOPMU_INBOUND_MSG0_RESET_COMM = 6,
	IOPMU_INBOUND_MSG0_MAX = 255,
	IOPMU_OUTBOUND_MSG0_REGISTER_DEVICE_0 = 256,
	IOPMU_OUTBOUND_MSG0_REGISTER_DEVICE_MAX = 511,
	IOPMU_OUTBOUND_MSG0_UNREGISTER_DEVICE_0 = 512,
	IOPMU_OUTBOUND_MSG0_UNREGISTER_DEVICE_MAX = 767,
	IOPMU_OUTBOUND_MSG0_REVALIDATE_DEVICE_0 = 768,
	IOPMU_OUTBOUND_MSG0_REVALIDATE_DEVICE_MAX = 1023,
};

struct hpt_iop_request_header {
	__le32 size;
	__le32 type;
	__le32 flags;
	__le32 result;
	__le32 context;
	__le32 context_hi32;
};

enum hpt_iop_request_type {
	IOP_REQUEST_TYPE_GET_CONFIG = 0,
	IOP_REQUEST_TYPE_SET_CONFIG = 1,
	IOP_REQUEST_TYPE_BLOCK_COMMAND = 2,
	IOP_REQUEST_TYPE_SCSI_COMMAND = 3,
	IOP_REQUEST_TYPE_IOCTL_COMMAND = 4,
	IOP_REQUEST_TYPE_MAX = 5,
};

enum hpt_iop_result_type {
	IOP_RESULT_PENDING = 0,
	IOP_RESULT_SUCCESS = 1,
	IOP_RESULT_FAIL = 2,
	IOP_RESULT_BUSY = 3,
	IOP_RESULT_RESET = 4,
	IOP_RESULT_INVALID_REQUEST = 5,
	IOP_RESULT_BAD_TARGET = 6,
	IOP_RESULT_CHECK_CONDITION = 7,
};

struct hpt_iop_request_get_config {
	struct hpt_iop_request_header header;
	__le32 interface_version;
	__le32 firmware_version;
	__le32 max_requests;
	__le32 request_size;
	__le32 max_sg_count;
	__le32 data_transfer_length;
	__le32 alignment_mask;
	__le32 max_devices;
	__le32 sdram_size;
};

struct hpt_iop_request_set_config {
	struct hpt_iop_request_header header;
	__le32 iop_id;
	__le16 vbus_id;
	__le16 max_host_request_size;
	__le32 reserve[6];
};

struct hpt_iopsg {
	__le32 size;
	__le32 eot;
	__le64 pci_address;
};

struct hpt_iop_request_scsi_command {
	struct hpt_iop_request_header header;
	u8 channel;
	u8 target;
	u8 lun;
	u8 pad1;
	u8 cdb[16];
	__le32 dataxfer_length;
	struct hpt_iopsg sg_list[1];
};

struct hpt_iop_request_ioctl_command {
	struct hpt_iop_request_header header;
	__le32 ioctl_code;
	__le32 inbuf_size;
	__le32 outbuf_size;
	__le32 bytes_returned;
	u8 buf[1];
};

struct hptiop_request {
	struct hptiop_request *next;
	void *req_virt;
	u32 req_shifted_phy;
	struct scsi_cmnd *scp;
	int index;
};

struct hpt_scsi_pointer {
	int mapped;
	int sgcnt;
	dma_addr_t dma_handle;
};

enum hptiop_family {
	UNKNOWN_BASED_IOP = 0,
	INTEL_BASED_IOP = 1,
	MV_BASED_IOP = 2,
	MVFREY_BASED_IOP = 3,
};

struct hptiop_adapter_ops;

struct hptiop_hba {
	struct hptiop_adapter_ops *ops;
	union {
		struct {
			struct hpt_iopmu_itl *iop;
			void *plx;
		} itl;
		struct {
			struct hpt_iopmv_regs *regs;
			struct hpt_iopmu_mv *mu;
			void *internal_req;
			dma_addr_t internal_req_phy;
		} mv;
		struct {
			struct hpt_iop_request_get_config *config;
			struct hpt_iopmu_mvfrey *mu;
			int internal_mem_size;
			struct hptiop_request internal_req;
			int list_count;
			struct mvfrey_inlist_entry *inlist;
			dma_addr_t inlist_phy;
			__le32 inlist_wptr;
			struct mvfrey_outlist_entry *outlist;
			dma_addr_t outlist_phy;
			__le32 *outlist_cptr;
			dma_addr_t outlist_cptr_phy;
			__le32 outlist_rptr;
		} mvfrey;
	} u;
	struct Scsi_Host *host;
	struct pci_dev *pcidev;
	u32 interface_version;
	u32 firmware_version;
	u32 sdram_size;
	u32 max_devices;
	u32 max_requests;
	u32 max_request_size;
	u32 max_sg_descriptors;
	u32 req_size;
	u32 iopintf_v2: 1;
	u32 initialized: 1;
	u32 msg_done: 1;
	struct hptiop_request *req_list;
	struct hptiop_request reqs[256];
	void *dma_coherent[256];
	dma_addr_t dma_coherent_handle[256];
	atomic_t reset_count;
	atomic_t resetting;
	wait_queue_head_t reset_wq;
	wait_queue_head_t ioctl_wq;
};

struct hptiop_adapter_ops {
	enum hptiop_family family;
	int (*iop_wait_ready)(struct hptiop_hba *, u32);
	int (*internal_memalloc)(struct hptiop_hba *);
	int (*internal_memfree)(struct hptiop_hba *);
	int (*map_pci_bar)(struct hptiop_hba *);
	void (*unmap_pci_bar)(struct hptiop_hba *);
	void (*enable_intr)(struct hptiop_hba *);
	void (*disable_intr)(struct hptiop_hba *);
	int (*get_config)(struct hptiop_hba *, struct hpt_iop_request_get_config *);
	int (*set_config)(struct hptiop_hba *, struct hpt_iop_request_set_config *);
	int (*iop_intr)(struct hptiop_hba *);
	void (*post_msg)(struct hptiop_hba *, u32);
	void (*post_req)(struct hptiop_hba *, struct hptiop_request *);
	int hw_dma_bit_mask;
	int (*reset_comm)(struct hptiop_hba *);
	__le64 host_phy_flag;
};

struct hpt_ioctl_k {
	struct hptiop_hba *hba;
	u32 ioctl_code;
	u32 inbuf_size;
	u32 outbuf_size;
	void *inbuf;
	void *outbuf;
	u32 *bytes_returned;
	void (*done)(struct hpt_ioctl_k *);
	int result;
};

enum {
	IMR0 = 16,
	IMR1 = 20,
	OMR0 = 24,
	OMR1 = 28,
	IDBL = 32,
	IIS = 36,
	IIM = 40,
	ODBL = 44,
	OIS = 48,
	OIM = 60,
	YIOA_STATUS = 0,
	YH2I_INT = 32,
	YINT_EN = 52,
	YI2H_INT = 156,
	YI2H_INT_C = 160,
	YH2I_REQ = 192,
	YH2I_REQ_HI = 196,
	PSCRATCH0 = 176,
	PSCRATCH1 = 180,
	PSCRATCH2 = 184,
	PSCRATCH3 = 188,
	PSCRATCH4 = 200,
	MAILBOX_BASE = 4096,
	MAILBOX_HNDSHK_STS = 0,
	MU_INBOUND_DOORBELL_HANDSHAKE = 1,
	MU_INBOUND_DOORBELL_REQHEADCHANGED = 2,
	MU_INBOUND_DOORBELL_STATUSTAILCHANGED = 4,
	MU_INBOUND_DOORBELL_HMUSTOPPED = 8,
	MU_INBOUND_DOORBELL_RESET = 16,
	MU_OUTBOUND_DOORBELL_HANDSHAKE = 1,
	MU_OUTBOUND_DOORBELL_REQUESTTAILCHANGED = 2,
	MU_OUTBOUND_DOORBELL_STATUSHEADCHANGED = 4,
	MU_OUTBOUND_DOORBELL_BUSCHANGE = 8,
	MU_OUTBOUND_DOORBELL_HASEVENT = 16,
	MU_OUTBOUND_DOORBELL_REQUEST_RESET = 134217728,
	MU_STATE_STARTING = 1,
	MU_STATE_STARTED = 2,
	MU_STATE_RESETTING = 3,
	MU_STATE_FAILED = 4,
	MU_STATE_STOP = 5,
	MU_STATE_NOCONNECT = 6,
	MU_MAX_DELAY = 50,
	MU_HANDSHAKE_SIGNATURE = 1437248085,
	MU_HANDSHAKE_SIGNATURE_HALF = 1515847680,
	MU_HARD_RESET_WAIT = 30000,
	HMU_PARTNER_TYPE = 2,
	SRB_STATUS_SUCCESS = 1,
	SRB_STATUS_ERROR = 4,
	SRB_STATUS_BUSY = 5,
	SRB_STATUS_INVALID_REQUEST = 6,
	SRB_STATUS_SELECTION_TIMEOUT = 10,
	SRB_SEE_SENSE = 128,
	TASK_ATTRIBUTE_SIMPLE = 0,
	TASK_ATTRIBUTE_HEADOFQUEUE = 1,
	TASK_ATTRIBUTE_ORDERED = 2,
	TASK_ATTRIBUTE_ACA = 4,
	SS_STS_NORMAL = 2147483648,
	SS_STS_DONE = 1073741824,
	SS_STS_HANDSHAKE = 536870912,
	SS_HEAD_HANDSHAKE = 128,
	SS_H2I_INT_RESET = 256,
	SS_I2H_REQUEST_RESET = 8192,
	SS_MU_OPERATIONAL = 2147483648,
	STEX_CDB_LENGTH = 16,
	STATUS_VAR_LEN = 128,
	SG_CF_EOT = 128,
	SG_CF_64B = 64,
	SG_CF_HOST = 32,
	MSG_DATA_DIR_ND = 0,
	MSG_DATA_DIR_IN = 1,
	MSG_DATA_DIR_OUT = 2,
	st_shasta = 0,
	st_vsc = 1,
	st_yosemite = 2,
	st_seq = 3,
	st_yel = 4,
	st_P3 = 5,
	PASSTHRU_REQ_TYPE = 1,
	PASSTHRU_REQ_NO_WAKEUP = 256,
	ST_INTERNAL_TIMEOUT = 180,
	ST_TO_CMD = 0,
	ST_FROM_CMD = 1,
	MGT_CMD = 216,
	SINBAND_MGT_CMD = 217,
	ARRAY_CMD = 224,
	CONTROLLER_CMD = 225,
	DEBUGGING_CMD = 226,
	PASSTHRU_CMD = 227,
	PASSTHRU_GET_ADAPTER = 5,
	PASSTHRU_GET_DRVVER = 16,
	CTLR_CONFIG_CMD = 3,
	CTLR_SHUTDOWN = 13,
	CTLR_POWER_STATE_CHANGE = 14,
	CTLR_POWER_SAVING = 1,
	PASSTHRU_SIGNATURE = 1312903233,
	MGT_CMD_SIGNATURE = 186,
	INQUIRY_EVPD = 1,
	ST_ADDITIONAL_MEM = 2097152,
	ST_ADDITIONAL_MEM_MIN = 524288,
	PMIC_SHUTDOWN = 13,
	PMIC_REUMSE = 16,
	ST_IGNORED = 4294967295,
	ST_NOTHANDLED = 7,
	ST_S3 = 3,
	ST_S4 = 4,
	ST_S5 = 5,
	ST_S6 = 6,
};

struct st_sgitem {
	u8 ctrl;
	u8 reserved[3];
	__le32 count;
	__le64 addr;
};

struct st_ss_sgitem {
	__le32 addr;
	__le32 addr_hi;
	__le32 count;
};

struct st_sgtable {
	__le16 sg_count;
	__le16 max_sg_count;
	__le32 sz_in_byte;
};

struct st_msg_header {
	__le64 handle;
	u8 flag;
	u8 channel;
	__le16 timeout;
	u32 reserved;
};

struct handshake_frame {
	__le64 rb_phy;
	__le16 req_sz;
	__le16 req_cnt;
	__le16 status_sz;
	__le16 status_cnt;
	__le64 hosttime;
	u8 partner_type;
	u8 reserved0[7];
	__le32 partner_ver_major;
	__le32 partner_ver_minor;
	__le32 partner_ver_oem;
	__le32 partner_ver_build;
	__le32 extra_offset;
	__le32 extra_size;
	__le32 scratch_size;
	u32 reserved1;
};

struct req_msg {
	__le16 tag;
	u8 lun;
	u8 target;
	u8 task_attr;
	u8 task_manage;
	u8 data_dir;
	u8 payload_sz;
	u8 cdb[16];
	u32 variable[0];
};

struct status_msg {
	__le16 tag;
	u8 lun;
	u8 target;
	u8 srb_status;
	u8 scsi_status;
	u8 reserved;
	u8 payload_sz;
	u8 variable[128];
};

struct ver_info {
	u32 major;
	u32 minor;
	u32 oem;
	u32 build;
	u32 reserved[2];
};

struct st_frame {
	u32 base[6];
	u32 rom_addr;
	struct ver_info drv_ver;
	struct ver_info bios_ver;
	u32 bus;
	u32 slot;
	u32 irq_level;
	u32 irq_vec;
	u32 id;
	u32 subid;
	u32 dimm_size;
	u8 dimm_type;
	u8 reserved[3];
	u32 channel;
	u32 reserved1;
};

struct st_drvver {
	u32 major;
	u32 minor;
	u32 oem;
	u32 build;
	u32 signature[2];
	u8 console_id;
	u8 host_no;
	u8 reserved0[2];
	u32 reserved[3];
};

struct st_ccb {
	struct req_msg *req;
	struct scsi_cmnd *cmd;
	void *sense_buffer;
	unsigned int sense_bufflen;
	int sg_count;
	u32 req_type;
	u8 srb_status;
	u8 scsi_status;
	u8 reserved[2];
};

struct st_hba {
	void *mmio_base;
	void *dma_mem;
	dma_addr_t dma_handle;
	size_t dma_size;
	struct Scsi_Host *host;
	struct pci_dev *pdev;
	struct req_msg * (*alloc_rq)(struct st_hba *);
	int (*map_sg)(struct st_hba *, struct req_msg *, struct st_ccb *);
	void (*send)(struct st_hba *, struct req_msg *, u16);
	u32 req_head;
	u32 req_tail;
	u32 status_head;
	u32 status_tail;
	struct status_msg *status_buffer;
	void *copy_buffer;
	struct st_ccb *ccb;
	struct st_ccb *wait_ccb;
	__le32 *scratch;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	struct work_struct reset_work;
	wait_queue_head_t reset_waitq;
	unsigned int mu_status;
	unsigned int cardtype;
	int msi_enabled;
	int out_req_cnt;
	u32 extra_offset;
	u16 rq_count;
	u16 rq_size;
	u16 sts_count;
	u8 supports_pm;
	int msi_lock;
};

struct st_card_info {
	struct req_msg * (*alloc_rq)(struct st_hba *);
	int (*map_sg)(struct st_hba *, struct req_msg *, struct st_ccb *);
	void (*send)(struct st_hba *, struct req_msg *, u16);
	unsigned int max_id;
	unsigned int max_lun;
	unsigned int max_channel;
	u16 rq_count;
	u16 rq_size;
	u16 sts_count;
};

enum chip_flavors___2 {
	chip_6320 = 0,
	chip_6440 = 1,
	chip_6485 = 2,
	chip_9480 = 3,
	chip_9180 = 4,
	chip_9445 = 5,
	chip_9485 = 6,
	chip_1300 = 7,
	chip_1320 = 8,
};

enum driver_configuration {
	MVS_TX_RING_SZ = 1024,
	MVS_RX_RING_SZ = 1024,
	MVS_SOC_SLOTS = 64,
	MVS_SOC_TX_RING_SZ = 128,
	MVS_SOC_RX_RING_SZ = 128,
	MVS_SLOT_BUF_SZ = 8192,
	MVS_SSP_CMD_SZ = 64,
	MVS_ATA_CMD_SZ = 96,
	MVS_OAF_SZ = 64,
	MVS_QUEUE_SIZE = 64,
	MVS_SOC_CAN_QUEUE = 62,
};

enum hardware_details {
	MVS_MAX_PHYS = 8,
	MVS_MAX_PORTS = 8,
	MVS_SOC_PHYS = 4,
	MVS_SOC_PORTS = 4,
	MVS_MAX_DEVICES = 1024,
};

enum mvs_info_flags {
	MVF_PHY_PWR_FIX = 2,
	MVF_FLAG_SOC = 4,
};

enum mvs_port_type {
	PORT_TGT_MASK = 32,
	PORT_INIT_PORT = 16,
	PORT_TGT_PORT = 8,
	PORT_INIT_TGT_PORT = 24,
	PORT_TYPE_SAS___2 = 2,
	PORT_TYPE_SATA___2 = 1,
};

struct mvs_info;

struct mvs_port;

struct mvs_phy {
	struct mvs_info *mvi;
	struct mvs_port *port;
	struct asd_sas_phy sas_phy;
	struct sas_identify identify;
	struct scsi_device *sdev;
	struct timer_list timer;
	u64 dev_sas_addr;
	u64 att_dev_sas_addr;
	u32 att_dev_info;
	u32 dev_info;
	u32 phy_type;
	u32 phy_status;
	u32 irq_status;
	u32 frame_rcvd_size;
	u8 frame_rcvd[32];
	u8 phy_attached;
	u8 phy_mode;
	u8 reserved[2];
	u32 phy_event;
	enum sas_linkrate minimum_linkrate;
	enum sas_linkrate maximum_linkrate;
};

struct mvs_port {
	struct asd_sas_port sas_port;
	u8 port_attached;
	u8 wide_port_phymap;
	struct list_head list;
};

struct ffe_control {
	u8 ffe_cap_sel: 4;
	u8 ffe_rss_sel: 3;
	u8 reserved: 1;
};

struct phy_tuning {
	u8 trans_emp_en: 1;
	u8 trans_emp_amp: 4;
	u8 Reserved_2bit_1: 3;
	u8 trans_amp: 5;
	u8 trans_amp_adj: 2;
	u8 resv_2bit_2: 1;
	u8 reserved[2];
};

struct hba_info_page {
	u8 signature[4];
	u32 reserved1[13];
	u64 sas_addr[8];
	struct ffe_control ffe_ctl[8];
	u32 reserved2[12];
	u8 phy_rate[8];
	struct phy_tuning phy_tuning[8];
	u32 reserved3[10];
};

struct mvs_device {
	struct list_head dev_entry;
	enum sas_device_type dev_type;
	struct mvs_info *mvi_info;
	struct domain_device *sas_device;
	u32 attached_phy;
	u32 device_id;
	u32 running_req;
	u8 taskfileset;
	u8 dev_status;
	u16 reserved;
};

struct mvs_slot_info {
	struct list_head entry;
	union {
		struct sas_task *task;
		void *tdata;
	};
	u32 n_elem;
	u32 tx;
	u32 slot_tag;
	void *buf;
	dma_addr_t buf_dma;
	void *response;
	struct mvs_port *port;
	struct mvs_device *device;
	void *open_frame;
};

struct mvs_cmd_hdr;

struct mvs_chip_info;

struct mvs_info {
	long unsigned int flags;
	spinlock_t lock;
	struct pci_dev *pdev;
	struct device *dev;
	void *regs;
	void *regs_ex;
	u8 sas_addr[8];
	struct sas_ha_struct *sas;
	struct Scsi_Host *shost;
	__le32 *tx;
	dma_addr_t tx_dma;
	u32 tx_prod;
	__le32 *rx;
	dma_addr_t rx_dma;
	u32 rx_cons;
	__le32 *rx_fis;
	dma_addr_t rx_fis_dma;
	struct mvs_cmd_hdr *slot;
	dma_addr_t slot_dma;
	u32 chip_id;
	const struct mvs_chip_info *chip;
	int tags_num;
	long unsigned int *tags;
	struct mvs_phy phy[8];
	struct mvs_port port[8];
	u32 id;
	u64 sata_reg_set;
	struct list_head *hba_list;
	struct list_head soc_entry;
	struct list_head wq_list;
	long unsigned int instance;
	u16 flashid;
	u32 flashsize;
	u32 flashsectSize;
	void *addon;
	struct hba_info_page hba_info_param;
	struct mvs_device devices[1024];
	void *bulk_buffer;
	dma_addr_t bulk_buffer_dma;
	void *bulk_buffer1;
	dma_addr_t bulk_buffer_dma1;
	void *dma_pool;
	struct mvs_slot_info slot_info[0];
};

struct mvs_prv_info;

struct mvs_dispatch {
	char *name;
	int (*chip_init)(struct mvs_info *);
	int (*spi_init)(struct mvs_info *);
	int (*chip_ioremap)(struct mvs_info *);
	void (*chip_iounmap)(struct mvs_info *);
	irqreturn_t (*isr)(struct mvs_info *, int, u32);
	u32 (*isr_status)(struct mvs_info *, int);
	void (*interrupt_enable)(struct mvs_info *);
	void (*interrupt_disable)(struct mvs_info *);
	u32 (*read_phy_ctl)(struct mvs_info *, u32);
	void (*write_phy_ctl)(struct mvs_info *, u32, u32);
	u32 (*read_port_cfg_data)(struct mvs_info *, u32);
	void (*write_port_cfg_data)(struct mvs_info *, u32, u32);
	void (*write_port_cfg_addr)(struct mvs_info *, u32, u32);
	u32 (*read_port_vsr_data)(struct mvs_info *, u32);
	void (*write_port_vsr_data)(struct mvs_info *, u32, u32);
	void (*write_port_vsr_addr)(struct mvs_info *, u32, u32);
	u32 (*read_port_irq_stat)(struct mvs_info *, u32);
	void (*write_port_irq_stat)(struct mvs_info *, u32, u32);
	u32 (*read_port_irq_mask)(struct mvs_info *, u32);
	void (*write_port_irq_mask)(struct mvs_info *, u32, u32);
	void (*command_active)(struct mvs_info *, u32);
	void (*clear_srs_irq)(struct mvs_info *, u8, u8);
	void (*issue_stop)(struct mvs_info *, enum mvs_port_type, u32);
	void (*start_delivery)(struct mvs_info *, u32);
	u32 (*rx_update)(struct mvs_info *);
	void (*int_full)(struct mvs_info *);
	u8 (*assign_reg_set)(struct mvs_info *, u8 *);
	void (*free_reg_set)(struct mvs_info *, u8 *);
	u32 (*prd_size)();
	u32 (*prd_count)();
	void (*make_prd)(struct scatterlist *, int, void *);
	void (*detect_porttype)(struct mvs_info *, int);
	int (*oob_done)(struct mvs_info *, int);
	void (*fix_phy_info)(struct mvs_info *, int, struct sas_identify_frame *);
	void (*phy_work_around)(struct mvs_info *, int);
	void (*phy_set_link_rate)(struct mvs_info *, u32, struct sas_phy_linkrates *);
	u32 (*phy_max_link_rate)();
	void (*phy_disable)(struct mvs_info *, u32);
	void (*phy_enable)(struct mvs_info *, u32);
	void (*phy_reset)(struct mvs_info *, u32, int);
	void (*stp_reset)(struct mvs_info *, u32);
	void (*clear_active_cmds)(struct mvs_info *);
	u32 (*spi_read_data)(struct mvs_info *);
	void (*spi_write_data)(struct mvs_info *, u32);
	int (*spi_buildcmd)(struct mvs_info *, u32 *, u8, u8, u8, u32);
	int (*spi_issuecmd)(struct mvs_info *, u32);
	int (*spi_waitdataready)(struct mvs_info *, u32);
	void (*dma_fix)(struct mvs_info *, u32, int, int, void *);
	void (*tune_interrupt)(struct mvs_info *, u32);
	void (*non_spec_ncq_error)(struct mvs_info *);
	int (*gpio_write)(struct mvs_prv_info *, u8, u8, u8, u8 *);
};

enum dev_status {
	MVS_DEV_NORMAL = 0,
	MVS_DEV_EH = 1,
};

struct mvs_prv_info {
	u8 n_host;
	u8 n_phy;
	u8 scan_finished;
	u8 reserve;
	struct mvs_info *mvi[2];
	struct tasklet_struct mv_tasklet;
};

struct mvs_chip_info {
	u32 n_host;
	u32 n_phy;
	u32 fis_offs;
	u32 fis_count;
	u32 srs_sz;
	u32 sg_width;
	u32 slot_width;
	const struct mvs_dispatch *dispatch;
};

struct mvs_cmd_hdr {
	__le32 flags;
	__le32 lens;
	__le32 tags;
	__le32 data_len;
	__le64 cmd_tbl;
	__le64 open_frame;
	__le64 status_buf;
	__le64 prd_tbl;
	__le32 reserved[4];
};

struct mvs_wq {
	struct delayed_work work_q;
	struct mvs_info *mvi;
	void *data;
	int handler;
	struct list_head entry;
};

enum hw_register_bits {
	INT_EN = 2,
	HBA_RST = 1,
	INT_XOR = 16,
	INT_SAS_SATA = 1,
	SATA_TARGET = 65536,
	MODE_AUTO_DET_PORT7 = 32768,
	MODE_AUTO_DET_PORT6 = 16384,
	MODE_AUTO_DET_PORT5 = 8192,
	MODE_AUTO_DET_PORT4 = 4096,
	MODE_AUTO_DET_PORT3 = 2048,
	MODE_AUTO_DET_PORT2 = 1024,
	MODE_AUTO_DET_PORT1 = 512,
	MODE_AUTO_DET_PORT0 = 256,
	MODE_AUTO_DET_EN = 65280,
	MODE_SAS_PORT7_MASK = 128,
	MODE_SAS_PORT6_MASK = 64,
	MODE_SAS_PORT5_MASK = 32,
	MODE_SAS_PORT4_MASK = 16,
	MODE_SAS_PORT3_MASK = 8,
	MODE_SAS_PORT2_MASK = 4,
	MODE_SAS_PORT1_MASK = 2,
	MODE_SAS_PORT0_MASK = 1,
	MODE_SAS_SATA = 255,
	TX_EN = 65536,
	TX_RING_SZ_MASK = 4095,
	RX_EN = 65536,
	RX_RING_SZ_MASK = 4095,
	COAL_EN = 65536,
	CINT_I2C = 2147483648,
	CINT_SW0 = 1073741824,
	CINT_SW1 = 536870912,
	CINT_PRD_BC = 268435456,
	CINT_DMA_PCIE = 134217728,
	CINT_MEM = 67108864,
	CINT_I2C_SLAVE = 33554432,
	CINT_NON_SPEC_NCQ_ERROR = 33554432,
	CINT_SRS = 8,
	CINT_CI_STOP = 2,
	CINT_DONE = 1,
	CINT_PORT_STOPPED = 65536,
	CINT_PORT = 256,
	CINT_PORT_MASK_OFFSET = 8,
	CINT_PORT_MASK = 65280,
	CINT_PHY_MASK_OFFSET = 4,
	CINT_PHY_MASK = 240,
	TXQ_CMD_SHIFT = 29,
	TXQ_CMD_SSP = 1,
	TXQ_CMD_SMP = 2,
	TXQ_CMD_STP = 3,
	TXQ_CMD_SSP_FREE_LIST = 4,
	TXQ_CMD_SLOT_RESET = 7,
	TXQ_MODE_I = 268435456,
	TXQ_MODE_TARGET = 0,
	TXQ_MODE_INITIATOR = 1,
	TXQ_PRIO_HI = 134217728,
	TXQ_PRI_NORMAL = 0,
	TXQ_PRI_HIGH = 1,
	TXQ_SRS_SHIFT = 20,
	TXQ_SRS_MASK = 127,
	TXQ_PHY_SHIFT = 12,
	TXQ_PHY_MASK = 255,
	TXQ_SLOT_MASK = 4095,
	RXQ_GOOD = 8388608,
	RXQ_SLOT_RESET = 2097152,
	RXQ_CMD_RX = 1048576,
	RXQ_ATTN = 524288,
	RXQ_RSP = 262144,
	RXQ_ERR = 131072,
	RXQ_DONE = 65536,
	RXQ_SLOT_MASK = 4095,
	MCH_PRD_LEN_SHIFT = 16,
	MCH_SSP_FR_TYPE_SHIFT = 13,
	MCH_SSP_FR_CMD = 0,
	MCH_SSP_FR_TASK = 1,
	MCH_SSP_FR_XFER_RDY = 4,
	MCH_SSP_FR_RESP = 5,
	MCH_SSP_FR_READ = 6,
	MCH_SSP_FR_READ_RESP = 7,
	MCH_SSP_MODE_PASSTHRU = 1,
	MCH_SSP_MODE_NORMAL = 0,
	MCH_PASSTHRU = 4096,
	MCH_FBURST = 2048,
	MCH_CHK_LEN = 1024,
	MCH_RETRY = 512,
	MCH_PROTECTION = 256,
	MCH_RESET = 128,
	MCH_FPDMA = 64,
	MCH_ATAPI = 32,
	MCH_BIST = 16,
	MCH_PMP_MASK = 15,
	CCTL_RST = 32,
	CCTL_ENDIAN_DATA = 8,
	CCTL_ENDIAN_RSP = 4,
	CCTL_ENDIAN_OPEN = 2,
	CCTL_ENDIAN_CMD = 1,
	PHY_SSP_RST = 8,
	PHY_BCAST_CHG = 4,
	PHY_RST_HARD = 2,
	PHY_RST = 1,
	PHY_READY_MASK = 1048576,
	PHYEV_DEC_ERR = 16777216,
	PHYEV_DCDR_ERR = 8388608,
	PHYEV_CRC_ERR = 4194304,
	PHYEV_UNASSOC_FIS = 524288,
	PHYEV_AN = 262144,
	PHYEV_BIST_ACT = 131072,
	PHYEV_SIG_FIS = 65536,
	PHYEV_POOF = 4096,
	PHYEV_IU_BIG = 2048,
	PHYEV_IU_SMALL = 1024,
	PHYEV_UNK_TAG = 512,
	PHYEV_BROAD_CH = 256,
	PHYEV_COMWAKE = 128,
	PHYEV_PORT_SEL = 64,
	PHYEV_HARD_RST = 32,
	PHYEV_ID_TMOUT = 16,
	PHYEV_ID_FAIL = 8,
	PHYEV_ID_DONE = 4,
	PHYEV_HARD_RST_DONE = 2,
	PHYEV_RDY_CH = 1,
	PCS_EN_SATA_REG_SHIFT = 16,
	PCS_EN_PORT_XMT_SHIFT = 12,
	PCS_EN_PORT_XMT_SHIFT2 = 8,
	PCS_SATA_RETRY = 256,
	PCS_RSP_RX_EN = 128,
	PCS_SATA_RETRY_2 = 64,
	PCS_SELF_CLEAR = 32,
	PCS_FIS_RX_EN = 16,
	PCS_CMD_STOP_ERR = 8,
	PCS_CMD_RST = 2,
	PCS_CMD_EN = 1,
	PORT_DEV_SSP_TRGT = 524288,
	PORT_DEV_SMP_TRGT = 262144,
	PORT_DEV_STP_TRGT = 131072,
	PORT_DEV_SSP_INIT = 2048,
	PORT_DEV_SMP_INIT = 1024,
	PORT_DEV_STP_INIT = 512,
	PORT_PHY_ID_MASK = 4278190080,
	PORT_SSP_TRGT_MASK = 524288,
	PORT_SSP_INIT_MASK = 2048,
	PORT_DEV_TRGT_MASK = 917504,
	PORT_DEV_INIT_MASK = 3584,
	PORT_DEV_TYPE_MASK = 7,
	PHY_RDY = 4,
	PHY_DW_SYNC = 2,
	PHY_OOB_DTCTD = 1,
	PHY_MODE6_LATECLK = 536870912,
	PHY_MODE6_DTL_SPEED = 134217728,
	PHY_MODE6_FC_ORDER = 67108864,
	PHY_MODE6_MUCNT_EN = 16777216,
	PHY_MODE6_SEL_MUCNT_LEN = 4194304,
	PHY_MODE6_SELMUPI = 1048576,
	PHY_MODE6_SELMUPF = 262144,
	PHY_MODE6_SELMUFF = 65536,
	PHY_MODE6_SELMUFI = 16384,
	PHY_MODE6_FREEZE_LOOP = 4096,
	PHY_MODE6_INT_RXFOFFS = 8,
	PHY_MODE6_FRC_RXFOFFS = 4,
	PHY_MODE6_STAU_0D8 = 2,
	PHY_MODE6_RXSAT_DIS = 1,
};

enum sas_sata_config_port_regs {
	PHYR_IDENTIFY = 0,
	PHYR_ADDR_LO = 4,
	PHYR_ADDR_HI = 8,
	PHYR_ATT_DEV_INFO = 12,
	PHYR_ATT_ADDR_LO = 16,
	PHYR_ATT_ADDR_HI = 20,
	PHYR_SATA_CTL = 24,
	PHYR_PHY_STAT = 28,
	PHYR_SATA_SIG0 = 32,
	PHYR_SATA_SIG1 = 36,
	PHYR_SATA_SIG2 = 40,
	PHYR_SATA_SIG3 = 44,
	PHYR_R_ERR_COUNT = 48,
	PHYR_CRC_ERR_COUNT = 52,
	PHYR_WIDE_PORT = 56,
	PHYR_CURRENT0 = 128,
	PHYR_CURRENT1 = 132,
	PHYR_CURRENT2 = 136,
	CONFIG_ID_FRAME0 = 256,
	CONFIG_ID_FRAME1 = 260,
	CONFIG_ID_FRAME2 = 264,
	CONFIG_ID_FRAME3 = 268,
	CONFIG_ID_FRAME4 = 272,
	CONFIG_ID_FRAME5 = 276,
	CONFIG_ID_FRAME6 = 280,
	CONFIG_ATT_ID_FRAME0 = 284,
	CONFIG_ATT_ID_FRAME1 = 288,
	CONFIG_ATT_ID_FRAME2 = 292,
	CONFIG_ATT_ID_FRAME3 = 296,
	CONFIG_ATT_ID_FRAME4 = 300,
	CONFIG_ATT_ID_FRAME5 = 304,
	CONFIG_ATT_ID_FRAME6 = 308,
};

enum mvs_event_flags {
	PHY_PLUG_EVENT = 3,
	PHY_PLUG_IN = 1,
	PHY_PLUG_OUT = 2,
	EXP_BRCT_CHG = 4,
};

enum ct_format {
	SSP_F_H = 0,
	SSP_F_IU = 24,
	SSP_F_MAX = 77,
	STP_CMD_FIS = 0,
	STP_ATAPI_CMD = 64,
	STP_F_MAX = 16,
	SMP_F_T = 0,
	SMP_F_DEP = 1,
	SMP_F_MAX = 257,
};

enum status_buffer {
	SB_EIR_OFF = 0,
	SB_RFB_OFF = 8,
	SB_RFB_MAX = 1024,
};

enum error_info_rec {
	CMD_ISS_STPD = 2147483648,
	CMD_PI_ERR = 1073741824,
	RSP_OVER = 536870912,
	RETRY_LIM = 268435456,
	UNK_FIS = 134217728,
	DMA_TERM = 67108864,
	SYNC_ERR = 33554432,
	TFILE_ERR = 16777216,
	R_ERR = 8388608,
	RD_OFS = 1048576,
	XFER_RDY_OFS = 524288,
	UNEXP_XFER_RDY = 262144,
	DATA_OVER_UNDER = 65536,
	INTERLOCK = 32768,
	NAK = 16384,
	ACK_NAK_TO = 8192,
	CXN_CLOSED = 4096,
	OPEN_TO = 2048,
	PATH_BLOCKED = 1024,
	NO_DEST = 512,
	STP_RES_BSY = 256,
	BREAK = 128,
	BAD_DEST = 64,
	BAD_PROTO = 32,
	BAD_RATE = 16,
	WRONG_DEST = 8,
	CREDIT_TO = 4,
	WDOG_TO = 2,
	BUF_PAR = 1,
};

enum open_frame_protocol {
	PROTOCOL_SMP = 0,
	PROTOCOL_SSP = 1,
	PROTOCOL_STP = 2,
};

struct mvs_tmf_task {
	u8 tmf;
	u16 tag_of_task_to_be_managed;
};

enum dev_reset {
	MVS_SOFT_RESET = 0,
	MVS_HARD_RESET = 1,
	MVS_PHY_TUNE = 2,
};

struct mvs_task_exec_info {
	struct sas_task *task;
	struct mvs_cmd_hdr *hdr;
	struct mvs_port *port;
	u32 tag;
	int n_elem;
};

enum sas_cmd_port_registers {
	CMD_CMRST_OOB_DET = 256,
	CMD_CMWK_OOB_DET = 260,
	CMD_CMSAS_OOB_DET = 264,
	CMD_BRST_OOB_DET = 268,
	CMD_OOB_SPACE = 272,
	CMD_OOB_BURST = 276,
	CMD_PHY_TIMER = 280,
	CMD_PHY_CONFIG0 = 284,
	CMD_PHY_CONFIG1 = 288,
	CMD_SAS_CTL0 = 292,
	CMD_SAS_CTL1 = 296,
	CMD_SAS_CTL2 = 300,
	CMD_SAS_CTL3 = 304,
	CMD_ID_TEST = 308,
	CMD_PL_TIMER = 312,
	CMD_WD_TIMER = 316,
	CMD_PORT_SEL_COUNT = 320,
	CMD_APP_MEM_CTL = 324,
	CMD_XOR_MEM_CTL = 328,
	CMD_DMA_MEM_CTL = 332,
	CMD_PORT_MEM_CTL0 = 336,
	CMD_PORT_MEM_CTL1 = 340,
	CMD_SATA_PORT_MEM_CTL0 = 344,
	CMD_SATA_PORT_MEM_CTL1 = 348,
	CMD_XOR_MEM_BIST_CTL = 352,
	CMD_XOR_MEM_BIST_STAT = 356,
	CMD_DMA_MEM_BIST_CTL = 360,
	CMD_DMA_MEM_BIST_STAT = 364,
	CMD_PORT_MEM_BIST_CTL = 368,
	CMD_PORT_MEM_BIST_STAT0 = 372,
	CMD_PORT_MEM_BIST_STAT1 = 376,
	CMD_STP_MEM_BIST_CTL = 380,
	CMD_STP_MEM_BIST_STAT0 = 384,
	CMD_STP_MEM_BIST_STAT1 = 388,
	CMD_RESET_COUNT = 392,
	CMD_MONTR_DATA_SEL = 396,
	CMD_PLL_PHY_CONFIG = 400,
	CMD_PHY_CTL = 404,
	CMD_PHY_TEST_COUNT0 = 408,
	CMD_PHY_TEST_COUNT1 = 412,
	CMD_PHY_TEST_COUNT2 = 416,
	CMD_APP_ERR_CONFIG = 420,
	CMD_PND_FIFO_CTL0 = 424,
	CMD_HOST_CTL = 428,
	CMD_HOST_WR_DATA = 432,
	CMD_HOST_RD_DATA = 436,
	CMD_PHY_MODE_21 = 440,
	CMD_SL_MODE0 = 444,
	CMD_SL_MODE1 = 448,
	CMD_PND_FIFO_CTL1 = 452,
	CMD_PORT_LAYER_TIMER1 = 480,
	CMD_LINK_TIMER = 484,
};

enum pci_cfg_register_bits {
	PCTL_PWR_OFF = 251658240,
	PCTL_COM_ON = 15728640,
	PCTL_LINK_RST = 983040,
	PCTL_LINK_OFFS = 16,
	PCTL_PHY_DSBL = 61440,
	PCTL_PHY_DSBL_OFFS = 12,
	PRD_REQ_SIZE = 16384,
	PRD_REQ_MASK = 28672,
	PLS_NEG_LINK_WD = 1008,
	PLS_NEG_LINK_WD_OFFS = 4,
	PLS_LINK_SPD = 15,
	PLS_LINK_SPD_OFFS = 0,
};

enum hw_registers {
	MVS_GBL_CTL = 4,
	MVS_GBL_INT_STAT = 8,
	MVS_GBL_PI = 12,
	MVS_PHY_CTL = 64,
	MVS_PORTS_IMP = 156,
	MVS_GBL_PORT_TYPE = 160,
	MVS_CTL = 256,
	MVS_PCS = 260,
	MVS_CMD_LIST_LO = 264,
	MVS_CMD_LIST_HI = 268,
	MVS_RX_FIS_LO = 272,
	MVS_RX_FIS_HI = 276,
	MVS_TX_CFG = 288,
	MVS_TX_LO = 292,
	MVS_TX_HI = 296,
	MVS_TX_PROD_IDX = 300,
	MVS_TX_CONS_IDX = 304,
	MVS_RX_CFG = 308,
	MVS_RX_LO = 312,
	MVS_RX_HI = 316,
	MVS_RX_CONS_IDX = 320,
	MVS_INT_COAL = 328,
	MVS_INT_COAL_TMOUT = 332,
	MVS_INT_STAT = 336,
	MVS_INT_MASK = 340,
	MVS_INT_STAT_SRS_0 = 344,
	MVS_INT_MASK_SRS_0 = 348,
	MVS_P0_INT_STAT = 352,
	MVS_P0_INT_MASK = 356,
	MVS_P4_INT_STAT = 512,
	MVS_P4_INT_MASK = 516,
	MVS_P0_SER_CTLSTAT = 384,
	MVS_P4_SER_CTLSTAT = 544,
	MVS_CMD_ADDR = 440,
	MVS_CMD_DATA = 444,
	MVS_P0_CFG_ADDR = 448,
	MVS_P0_CFG_DATA = 452,
	MVS_P4_CFG_ADDR = 560,
	MVS_P4_CFG_DATA = 564,
	MVS_P0_VSR_ADDR = 480,
	MVS_P0_VSR_DATA = 484,
	MVS_P4_VSR_ADDR = 592,
	MVS_P4_VSR_DATA = 596,
};

enum pci_cfg_registers {
	PCR_PHY_CTL = 64,
	PCR_PHY_CTL2 = 144,
	PCR_DEV_CTRL = 232,
	PCR_LINK_STAT = 242,
};

enum sas_sata_vsp_regs {
	VSR_PHY_STAT = 0,
	VSR_PHY_MODE1 = 1,
	VSR_PHY_MODE2 = 2,
	VSR_PHY_MODE3 = 3,
	VSR_PHY_MODE4 = 4,
	VSR_PHY_MODE5 = 5,
	VSR_PHY_MODE6 = 6,
	VSR_PHY_MODE7 = 7,
	VSR_PHY_MODE8 = 8,
	VSR_PHY_MODE9 = 9,
	VSR_PHY_MODE10 = 10,
	VSR_PHY_MODE11 = 11,
	VSR_PHY_VS0 = 12,
	VSR_PHY_VS1 = 13,
};

enum chip_register_bits {
	PHY_MIN_SPP_PHYS_LINK_RATE_MASK = 3840,
	PHY_MAX_SPP_PHYS_LINK_RATE_MASK = 61440,
	PHY_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET = 16,
	PHY_NEG_SPP_PHYS_LINK_RATE_MASK = 983040,
};

struct mvs_prd {
	__le64 addr;
	__le32 reserved;
	__le32 len;
};

enum VANIR_REVISION_ID {
	VANIR_A0_REV = 160,
	VANIR_B0_REV = 1,
	VANIR_C0_REV = 2,
	VANIR_C1_REV = 3,
	VANIR_C2_REV = 194,
};

enum host_registers {
	MVS_HST_CHIP_CONFIG = 65796,
};

enum hw_registers___2 {
	MVS_GBL_CTL___2 = 4,
	MVS_GBL_INT_STAT___2 = 0,
	MVS_GBL_PI___2 = 12,
	MVS_PHY_CTL___2 = 64,
	MVS_PORTS_IMP___2 = 156,
	MVS_GBL_PORT_TYPE___2 = 160,
	MVS_CTL___2 = 256,
	MVS_PCS___2 = 260,
	MVS_CMD_LIST_LO___2 = 264,
	MVS_CMD_LIST_HI___2 = 268,
	MVS_RX_FIS_LO___2 = 272,
	MVS_RX_FIS_HI___2 = 276,
	MVS_STP_REG_SET_0 = 280,
	MVS_STP_REG_SET_1 = 284,
	MVS_TX_CFG___2 = 288,
	MVS_TX_LO___2 = 292,
	MVS_TX_HI___2 = 296,
	MVS_TX_PROD_IDX___2 = 300,
	MVS_TX_CONS_IDX___2 = 304,
	MVS_RX_CFG___2 = 308,
	MVS_RX_LO___2 = 312,
	MVS_RX_HI___2 = 316,
	MVS_RX_CONS_IDX___2 = 320,
	MVS_INT_COAL___2 = 328,
	MVS_INT_COAL_TMOUT___2 = 332,
	MVS_INT_STAT___2 = 336,
	MVS_INT_MASK___2 = 340,
	MVS_INT_STAT_SRS_0___2 = 344,
	MVS_INT_MASK_SRS_0___2 = 348,
	MVS_INT_STAT_SRS_1 = 352,
	MVS_INT_MASK_SRS_1 = 356,
	MVS_NON_NCQ_ERR_0 = 360,
	MVS_NON_NCQ_ERR_1 = 364,
	MVS_CMD_ADDR___2 = 368,
	MVS_CMD_DATA___2 = 372,
	MVS_MEM_PARITY_ERR = 376,
	MVS_P0_INT_STAT___2 = 384,
	MVS_P0_INT_MASK___2 = 388,
	MVS_P4_INT_STAT___2 = 416,
	MVS_P4_INT_MASK___2 = 420,
	MVS_P0_SER_CTLSTAT___2 = 464,
	MVS_P4_SER_CTLSTAT___2 = 480,
	MVS_P0_CFG_ADDR___2 = 512,
	MVS_P0_CFG_DATA___2 = 516,
	MVS_P4_CFG_ADDR___2 = 544,
	MVS_P4_CFG_DATA___2 = 548,
	MVS_P0_VSR_ADDR___2 = 592,
	MVS_P0_VSR_DATA___2 = 596,
	MVS_P4_VSR_ADDR___2 = 592,
	MVS_P4_VSR_DATA___2 = 596,
	MVS_PA_VSR_ADDR = 656,
	MVS_PA_VSR_PORT = 660,
	MVS_COMMAND_ACTIVE = 768,
};

enum pci_cfg_registers___2 {
	PCR_PHY_CTL___2 = 64,
	PCR_PHY_CTL2___2 = 144,
	PCR_DEV_CTRL___2 = 120,
	PCR_LINK_STAT___2 = 130,
};

enum sas_sata_vsp_regs___2 {
	VSR_PHY_STAT___2 = 0,
	VSR_PHY_MODE1___2 = 4,
	VSR_PHY_MODE2___2 = 8,
	VSR_PHY_MODE3___2 = 12,
	VSR_PHY_MODE4___2 = 16,
	VSR_PHY_MODE5___2 = 20,
	VSR_PHY_MODE6___2 = 24,
	VSR_PHY_MODE7___2 = 28,
	VSR_PHY_MODE8___2 = 32,
	VSR_PHY_MODE9___2 = 36,
	VSR_PHY_MODE10___2 = 40,
	VSR_PHY_MODE11___2 = 44,
	VSR_PHY_ACT_LED = 48,
	VSR_PHY_FFE_CONTROL = 268,
	VSR_PHY_DFE_UPDATE_CRTL = 272,
	VSR_REF_CLOCK_CRTL = 416,
};

enum chip_register_bits___2 {
	PHY_MIN_SPP_PHYS_LINK_RATE_MASK___2 = 1792,
	PHY_MAX_SPP_PHYS_LINK_RATE_MASK___2 = 28672,
	PHY_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET___2 = 16,
	PHY_NEG_SPP_PHYS_LINK_RATE_MASK___2 = 196608,
};

enum pci_interrupt_cause {
	MVS_IRQ_COM_IN_I2O_IOP0 = 1,
	MVS_IRQ_COM_IN_I2O_IOP1 = 2,
	MVS_IRQ_COM_IN_I2O_IOP2 = 4,
	MVS_IRQ_COM_IN_I2O_IOP3 = 8,
	MVS_IRQ_COM_OUT_I2O_HOS0 = 16,
	MVS_IRQ_COM_OUT_I2O_HOS1 = 32,
	MVS_IRQ_COM_OUT_I2O_HOS2 = 64,
	MVS_IRQ_COM_OUT_I2O_HOS3 = 128,
	MVS_IRQ_PCIF_TO_CPU_DRBL0 = 256,
	MVS_IRQ_PCIF_TO_CPU_DRBL1 = 512,
	MVS_IRQ_PCIF_TO_CPU_DRBL2 = 1024,
	MVS_IRQ_PCIF_TO_CPU_DRBL3 = 2048,
	MVS_IRQ_PCIF_DRBL0 = 4096,
	MVS_IRQ_PCIF_DRBL1 = 8192,
	MVS_IRQ_PCIF_DRBL2 = 16384,
	MVS_IRQ_PCIF_DRBL3 = 32768,
	MVS_IRQ_XOR_A = 65536,
	MVS_IRQ_XOR_B = 131072,
	MVS_IRQ_SAS_A = 262144,
	MVS_IRQ_SAS_B = 524288,
	MVS_IRQ_CPU_CNTRL = 1048576,
	MVS_IRQ_GPIO = 2097152,
	MVS_IRQ_UART = 4194304,
	MVS_IRQ_SPI = 8388608,
	MVS_IRQ_I2C = 16777216,
	MVS_IRQ_SGPIO = 33554432,
	MVS_IRQ_COM_ERR = 536870912,
	MVS_IRQ_I2O_ERR = 1073741824,
	MVS_IRQ_PCIE_ERR = 2147483648,
};

union reg_phy_cfg {
	u32 v;
	struct {
		u32 phy_reset: 1;
		u32 sas_support: 1;
		u32 sata_support: 1;
		u32 sata_host_mode: 1;
		u32 speed_support: 3;
		u32 snw_3_support: 1;
		u32 tx_lnk_parity: 1;
		u32 tx_spt_phs_lnk_rate: 6;
		u32 tx_lgcl_lnk_rate: 4;
		u32 tx_ssc_type: 1;
		u32 sata_spin_up_spt: 1;
		u32 sata_spin_up_en: 1;
		u32 bypass_oob: 1;
		u32 disable_phy: 1;
		u32 rsvd: 8;
	} u;
};

struct mvs_prd_imt {
	__le32 len: 22;
	u8 _r_a: 2;
	u8 misc_ctl: 4;
	u8 inter_sel: 4;
};

struct mvs_prd___2 {
	__le64 addr;
	__le32 im_len;
} __attribute__((packed));

enum sgpio_registers {
	MVS_SGPIO_HOST_OFFSET = 256,
	MVS_SGPIO_CFG0 = 49664,
	MVS_SGPIO_CFG0_ENABLE = 1,
	MVS_SGPIO_CFG0_BLINKB = 2,
	MVS_SGPIO_CFG0_BLINKA = 4,
	MVS_SGPIO_CFG0_INVSCLK = 8,
	MVS_SGPIO_CFG0_INVSLOAD = 16,
	MVS_SGPIO_CFG0_INVSDOUT = 32,
	MVS_SGPIO_CFG0_SLOAD_FALLEDGE = 64,
	MVS_SGPIO_CFG0_SDOUT_FALLEDGE = 128,
	MVS_SGPIO_CFG0_SDIN_RISEEDGE = 256,
	MVS_SGPIO_CFG0_MAN_BITLEN_SHIFT = 18,
	MVS_SGPIO_CFG0_AUT_BITLEN_SHIFT = 24,
	MVS_SGPIO_CFG1 = 49668,
	MVS_SGPIO_CFG1_LOWA_SHIFT = 0,
	MVS_SGPIO_CFG1_HIA_SHIFT = 4,
	MVS_SGPIO_CFG1_LOWB_SHIFT = 8,
	MVS_SGPIO_CFG1_HIB_SHIFT = 12,
	MVS_SGPIO_CFG1_MAXACTON_SHIFT = 16,
	MVS_SGPIO_CFG1_FORCEACTOFF_SHIFT = 20,
	MVS_SGPIO_CFG1_STRCHACTON_SHIFT = 24,
	MVS_SGPIO_CFG1_STRCHACTOFF_SHIFT = 28,
	MVS_SGPIO_CFG2 = 49672,
	MVS_SGPIO_CFG2_CLK_SHIFT = 0,
	MVS_SGPIO_CFG2_BLINK_SHIFT = 20,
	MVS_SGPIO_CTRL = 49676,
	MVS_SGPIO_CTRL_SDOUT_AUTO = 2,
	MVS_SGPIO_CTRL_SDOUT_SHIFT = 2,
	MVS_SGPIO_DSRC = 49696,
	MVS_SGPIO_DCTRL = 49720,
	MVS_SGPIO_DCTRL_ERR_SHIFT = 0,
	MVS_SGPIO_DCTRL_LOC_SHIFT = 3,
	MVS_SGPIO_DCTRL_ACT_SHIFT = 5,
};

enum sgpio_led_status {
	LED_OFF = 0,
	LED_ON = 1,
	LED_BLINKA = 2,
	LED_BLINKA_INV = 3,
	LED_BLINKA_SOF = 4,
	LED_BLINKA_EOF = 5,
	LED_BLINKB = 6,
	LED_BLINKB_INV = 7,
};

enum sas_sata_phy_regs {
	GENERATION_1_SETTING = 280,
	GENERATION_1_2_SETTING = 284,
	GENERATION_2_3_SETTING = 288,
	GENERATION_3_4_SETTING = 292,
};

enum mvumi_qc_result {
	MV_QUEUE_COMMAND_RESULT_SENT = 0,
	MV_QUEUE_COMMAND_RESULT_NO_RESOURCE = 1,
};

struct mvumi_hw_regs {
	void *main_int_cause_reg;
	void *enpointa_mask_reg;
	void *enpointb_mask_reg;
	void *rstoutn_en_reg;
	void *ctrl_sts_reg;
	void *rstoutn_mask_reg;
	void *sys_soft_rst_reg;
	void *pciea_to_arm_drbl_reg;
	void *arm_to_pciea_drbl_reg;
	void *arm_to_pciea_mask_reg;
	void *pciea_to_arm_msg0;
	void *pciea_to_arm_msg1;
	void *arm_to_pciea_msg0;
	void *arm_to_pciea_msg1;
	void *reset_request;
	void *reset_enable;
	void *inb_list_basel;
	void *inb_list_baseh;
	void *inb_aval_count_basel;
	void *inb_aval_count_baseh;
	void *inb_write_pointer;
	void *inb_read_pointer;
	void *outb_list_basel;
	void *outb_list_baseh;
	void *outb_copy_basel;
	void *outb_copy_baseh;
	void *outb_copy_pointer;
	void *outb_read_pointer;
	void *inb_isr_cause;
	void *outb_isr_cause;
	void *outb_coal_cfg;
	void *outb_coal_timeout;
	u32 int_comaout;
	u32 int_comaerr;
	u32 int_dl_cpu2pciea;
	u32 int_mu;
	u32 int_drbl_int_mask;
	u32 int_main_int_mask;
	u32 cl_pointer_toggle;
	u32 cl_slot_num_mask;
	u32 clic_irq;
	u32 clic_in_err;
	u32 clic_out_err;
};

struct mvumi_dyn_list_entry {
	u32 src_low_addr;
	u32 src_high_addr;
	u32 if_length;
	u32 reserve;
};

enum {
	DRBL_HANDSHAKE = 1,
	DRBL_SOFT_RESET = 2,
	DRBL_BUS_CHANGE = 4,
	DRBL_EVENT_NOTIFY = 8,
	DRBL_MU_RESET = 16,
	DRBL_HANDSHAKE_ISR = 1,
	CMD_FLAG_NON_DATA = 1,
	CMD_FLAG_DMA = 2,
	CMD_FLAG_PIO = 4,
	CMD_FLAG_DATA_IN = 8,
	CMD_FLAG_DATA_OUT = 16,
	CMD_FLAG_PRDT_IN_HOST = 32,
};

struct mvumi_hotplug_event {
	u16 size;
	u8 dummy[2];
	u8 bitmap[0];
};

struct mvumi_driver_event {
	u32 time_stamp;
	u32 sequence_no;
	u32 event_id;
	u8 severity;
	u8 param_count;
	u16 device_id;
	u32 params[4];
	u8 sense_data_length;
	u8 Reserved1;
	u8 sense_data[30];
};

struct mvumi_event_req {
	unsigned char count;
	unsigned char reserved[3];
	struct mvumi_driver_event events[6];
};

struct mvumi_hba;

struct mvumi_events_wq {
	struct work_struct work_q;
	struct mvumi_hba *mhba;
	unsigned int event;
	void *param;
};

struct mvumi_tag {
	short unsigned int *stack;
	short unsigned int top;
	short unsigned int size;
};

struct mvumi_instance_template;

struct mvumi_cmd;

struct mvumi_hba {
	void *base_addr[6];
	u32 pci_base[6];
	void *mmio;
	struct list_head cmd_pool;
	struct Scsi_Host *shost;
	wait_queue_head_t int_cmd_wait_q;
	struct pci_dev *pdev;
	unsigned int unique_id;
	atomic_t fw_outstanding;
	struct mvumi_instance_template *instancet;
	void *ib_list;
	dma_addr_t ib_list_phys;
	void *ib_frame;
	dma_addr_t ib_frame_phys;
	void *ob_list;
	dma_addr_t ob_list_phys;
	void *ib_shadow;
	dma_addr_t ib_shadow_phys;
	void *ob_shadow;
	dma_addr_t ob_shadow_phys;
	void *handshake_page;
	dma_addr_t handshake_page_phys;
	unsigned int global_isr;
	unsigned int isr_status;
	short unsigned int max_sge;
	short unsigned int max_target_id;
	unsigned char *target_map;
	unsigned int max_io;
	unsigned int list_num_io;
	unsigned int ib_max_size;
	unsigned int ob_max_size;
	unsigned int ib_max_size_setting;
	unsigned int ob_max_size_setting;
	unsigned int max_transfer_size;
	unsigned char hba_total_pages;
	unsigned char fw_flag;
	unsigned char request_id_enabled;
	unsigned char eot_flag;
	short unsigned int hba_capability;
	short unsigned int io_seq;
	unsigned int ib_cur_slot;
	unsigned int ob_cur_slot;
	unsigned int fw_state;
	struct mutex sas_discovery_mutex;
	struct list_head ob_data_list;
	struct list_head free_ob_list;
	struct list_head res_list;
	struct list_head waiting_req_list;
	struct mvumi_tag tag_pool;
	struct mvumi_cmd **tag_cmd;
	struct mvumi_hw_regs *regs;
	struct mutex device_lock;
	struct list_head mhba_dev_list;
	struct list_head shost_dev_list;
	struct task_struct *dm_thread;
	atomic_t pnp_count;
};

struct mvumi_sgl {
	u32 baseaddr_l;
	u32 baseaddr_h;
	u32 flags;
	u32 size;
};

struct mvumi_compact_sgl {
	u32 baseaddr_l;
	u32 baseaddr_h;
	u32 flags;
};

struct mvumi_res {
	struct list_head entry;
	dma_addr_t bus_addr;
	void *virt_addr;
	unsigned int size;
	short unsigned int type;
};

enum resource_type {
	RESOURCE_CACHED_MEMORY = 0,
	RESOURCE_UNCACHED_MEMORY = 1,
};

struct mvumi_msg_frame;

struct mvumi_cmd {
	struct list_head queue_pointer;
	struct mvumi_msg_frame *frame;
	dma_addr_t frame_phys;
	struct scsi_cmnd *scmd;
	atomic_t sync_cmd;
	void *data_buf;
	short unsigned int request_id;
	unsigned char cmd_status;
};

struct mvumi_msg_frame {
	u16 device_id;
	u16 tag;
	u8 cmd_flag;
	u8 req_function;
	u8 cdb_length;
	u8 sg_counts;
	u32 data_transfer_length;
	u16 request_id;
	u16 reserved1;
	u8 cdb[16];
	u32 payload[1];
};

struct mvumi_rsp_frame {
	u16 device_id;
	u16 tag;
	u8 req_status;
	u8 rsp_flag;
	u16 request_id;
	u32 payload[1];
};

struct mvumi_ob_data {
	struct list_head list;
	unsigned char data[0];
};

struct version_info {
	u32 ver_major;
	u32 ver_minor;
	u32 ver_oem;
	u32 ver_build;
};

struct mvumi_hs_header {
	u8 page_code;
	u8 checksum;
	u16 frame_length;
	u32 frame_content[1];
};

struct mvumi_hs_page1 {
	u8 pagecode;
	u8 checksum;
	u16 frame_length;
	u16 number_of_ports;
	u16 max_devices_support;
	u16 max_io_support;
	u16 umi_ver;
	u32 max_transfer_size;
	struct version_info fw_ver;
	u8 cl_in_max_entry_size;
	u8 cl_out_max_entry_size;
	u8 cl_inout_list_depth;
	u8 total_pages;
	u16 capability;
	u16 reserved1;
};

struct mvumi_hs_page2 {
	u8 pagecode;
	u8 checksum;
	u16 frame_length;
	u8 host_type;
	u8 host_cap;
	u8 reserved[2];
	struct version_info host_ver;
	u32 system_io_bus;
	u32 slot_number;
	u32 intr_level;
	u32 intr_vector;
	u64 seconds_since1970;
};

struct mvumi_hs_page3 {
	u8 pagecode;
	u8 checksum;
	u16 frame_length;
	u16 control;
	u8 reserved[2];
	u32 host_bufferaddr_l;
	u32 host_bufferaddr_h;
	u32 host_eventaddr_l;
	u32 host_eventaddr_h;
};

struct mvumi_hs_page4 {
	u8 pagecode;
	u8 checksum;
	u16 frame_length;
	u32 ib_baseaddr_l;
	u32 ib_baseaddr_h;
	u32 ob_baseaddr_l;
	u32 ob_baseaddr_h;
	u8 ib_entry_size;
	u8 ob_entry_size;
	u8 ob_depth;
	u8 ib_depth;
};

struct mvumi_device {
	struct list_head list;
	struct scsi_device *sdev;
	u64 wwid;
	u8 dev_type;
	int id;
};

struct mvumi_instance_template {
	void (*fire_cmd)(struct mvumi_hba *, struct mvumi_cmd *);
	void (*enable_intr)(struct mvumi_hba *);
	void (*disable_intr)(struct mvumi_hba *);
	int (*clear_intr)(void *);
	unsigned int (*read_fw_status_reg)(struct mvumi_hba *);
	unsigned int (*check_ib_list)(struct mvumi_hba *);
	int (*check_ob_list)(struct mvumi_hba *, unsigned int *, unsigned int *);
	int (*reset_host)(struct mvumi_hba *);
};

struct be_bus_address32 {
	unsigned int address_lo;
	unsigned int address_hi;
};

struct be_bus_address64 {
	long long unsigned int address;
};

struct be_bus_address {
	union {
		struct be_bus_address32 a32;
		struct be_bus_address64 a64;
	} u;
};

struct mem_array {
	struct be_bus_address bus_address;
	void *virtual_address;
	unsigned int size;
};

struct be_mem_descriptor {
	unsigned int size_in_bytes;
	unsigned int num_elements;
	struct mem_array *mem_array;
};

struct iscsi_sge;

struct sgl_handle {
	unsigned int sgl_index;
	unsigned int type;
	unsigned int cid;
	struct iscsi_task *task;
	struct iscsi_sge *pfrag;
};

struct iscsi_sge {
	u32 dw[4];
};

struct hba_parameters {
	unsigned int ios_per_ctrl;
	unsigned int cxns_per_ctrl;
	unsigned int icds_per_ctrl;
	unsigned int num_sge_per_io;
	unsigned int defpdu_hdr_sz;
	unsigned int defpdu_data_sz;
	unsigned int num_cq_entries;
	unsigned int num_eq_entries;
	unsigned int wrbs_per_cxn;
	unsigned int hwi_ws_sz;
};

struct wrb_handle;

struct iscsi_wrb;

struct hwi_wrb_context {
	spinlock_t wrb_lock;
	struct wrb_handle **pwrb_handle_base;
	struct wrb_handle **pwrb_handle_basestd;
	struct iscsi_wrb *plast_wrb;
	short unsigned int alloc_index;
	short unsigned int free_index;
	short unsigned int wrb_handles_available;
	short unsigned int cid;
	uint8_t ulp_num;
	uint32_t doorbell_offset;
};

struct wrb_handle {
	short unsigned int wrb_index;
	struct iscsi_task *pio_handle;
	struct iscsi_wrb *pwrb;
};

struct iscsi_wrb {
	u32 dw[16];
};

struct ulp_cid_info {
	short unsigned int *cid_array;
	short unsigned int avlbl_cids;
	short unsigned int cid_alloc;
	short unsigned int cid_free;
};

struct be_dma_mem {
	void *va;
	dma_addr_t dma;
	u32 size;
};

struct be_queue_info {
	struct be_dma_mem dma_mem;
	u16 len;
	u16 entry_size;
	u16 id;
	u16 tail;
	u16 head;
	bool created;
	u16 used;
};

struct be_aic_obj {
	long unsigned int jiffies;
	u32 eq_prev;
	u32 prev_eqd;
};

struct beiscsi_hba;

struct be_eq_obj {
	u32 cq_count;
	struct be_queue_info q;
	struct beiscsi_hba *phba;
	struct be_queue_info *cq;
	struct work_struct mcc_work;
	struct irq_poll iopoll;
};

struct be_mcc_obj {
	struct be_queue_info q;
	struct be_queue_info cq;
};

struct beiscsi_mcc_tag_state {
	long unsigned int tag_state;
	void (*cbfn)(struct beiscsi_hba *, unsigned int);
	struct be_dma_mem tag_mem_state;
};

struct be_ctrl_info {
	u8 *csr;
	u8 *db;
	u8 *pcicfg;
	struct pci_dev *pdev;
	struct mutex mbox_lock;
	struct be_dma_mem mbox_mem;
	struct be_dma_mem mbox_mem_alloced;
	struct be_mcc_obj mcc_obj;
	spinlock_t mcc_lock;
	wait_queue_head_t mcc_wait[17];
	unsigned int mcc_tag[16];
	unsigned int mcc_tag_status[17];
	short unsigned int mcc_alloc_index;
	short unsigned int mcc_free_index;
	unsigned int mcc_tag_available;
	struct beiscsi_mcc_tag_state ptag_state[17];
};

struct mgmt_session_login_options {
	u8 flags;
	u8 error_recovery_level;
	u16 rsvd0;
	u32 first_burst_length;
	u32 max_burst_length;
	u16 max_connections;
	u16 max_outstanding_r2t;
	u16 default_time2wait;
	u16 default_time2retain;
};

struct ip_addr_format {
	u16 size_of_structure;
	u8 reserved;
	u8 ip_type;
	u8 addr[16];
	u32 rsvd0;
};

struct mgmt_chap_format {
	u32 flags;
	u8 intr_chap_name[256];
	u8 intr_secret[16];
	u8 target_chap_name[256];
	u8 target_secret[16];
	u16 intr_chap_name_length;
	u16 intr_secret_length;
	u16 target_chap_name_length;
	u16 target_secret_length;
};

struct mgmt_auth_method_format {
	u8 auth_method_type;
	u8 padding[3];
	struct mgmt_chap_format chap;
};

struct mgmt_conn_login_options {
	u8 flags;
	u8 header_digest;
	u8 data_digest;
	u8 rsvd0;
	u32 max_recv_datasegment_len_ini;
	u32 max_recv_datasegment_len_tgt;
	u32 tcp_mss;
	u32 tcp_window_size;
	struct mgmt_auth_method_format auth_data;
};

struct mgmt_conn_info {
	u32 connection_handle;
	u32 connection_status;
	u16 src_port;
	u16 dest_port;
	u16 dest_port_redirected;
	u16 cid;
	u32 estimated_throughput;
	struct ip_addr_format src_ipaddr;
	struct ip_addr_format dest_ipaddr;
	struct ip_addr_format dest_ipaddr_redirected;
	struct mgmt_conn_login_options negotiated_login_options;
};

struct mgmt_session_info {
	u32 session_handle;
	u32 status;
	u8 isid[6];
	u16 tsih;
	u32 session_flags;
	u16 conn_count;
	u16 pad;
	u8 target_name[224];
	u8 initiator_iscsiname[224];
	struct mgmt_session_login_options negotiated_login_options;
	struct mgmt_conn_info conn_list[1];
};

struct boot_struct {
	int retry;
	unsigned int tag;
	unsigned int s_handle;
	struct be_dma_mem nonemb_cmd;
	enum {
		BEISCSI_BOOT_REOPEN_SESS = 1,
		BEISCSI_BOOT_GET_SHANDLE = 2,
		BEISCSI_BOOT_GET_SINFO = 3,
		BEISCSI_BOOT_LOGOUT_SESS = 4,
		BEISCSI_BOOT_CREATE_KSET = 5,
	} action;
	struct mgmt_session_info boot_sess;
	struct iscsi_boot_kset *boot_kset;
};

struct hwi_controller;

struct beiscsi_conn;

struct beiscsi_hba {
	struct hba_parameters params;
	struct hwi_controller *phwi_ctrlr;
	unsigned int mem_req[22];
	u8 *csr_va;
	u8 *db_va;
	u8 *pci_va;
	struct pci_dev *pcidev;
	unsigned int num_cpus;
	unsigned int nxt_cqid;
	char *msi_name[64];
	struct be_mem_descriptor *init_mem;
	short unsigned int io_sgl_alloc_index;
	short unsigned int io_sgl_free_index;
	short unsigned int io_sgl_hndl_avbl;
	struct sgl_handle **io_sgl_hndl_base;
	short unsigned int eh_sgl_alloc_index;
	short unsigned int eh_sgl_free_index;
	short unsigned int eh_sgl_hndl_avbl;
	struct sgl_handle **eh_sgl_hndl_base;
	spinlock_t io_sgl_lock;
	spinlock_t mgmt_sgl_lock;
	spinlock_t async_pdu_lock;
	struct list_head hba_queue;
	short unsigned int cid_to_cri_map[2048];
	struct ulp_cid_info *cid_array_info[2];
	struct iscsi_endpoint **ep_array;
	struct beiscsi_conn **conn_table;
	struct Scsi_Host *shost;
	struct iscsi_iface *ipv4_iface;
	struct iscsi_iface *ipv6_iface;
	struct {
		unsigned int phys_port;
		unsigned int eqid_count;
		unsigned int cqid_count;
		unsigned int iscsi_cid_start[2];
		unsigned int iscsi_cid_count[2];
		unsigned int iscsi_icd_count[2];
		unsigned int iscsi_icd_start[2];
		unsigned int iscsi_chain_start[2];
		unsigned int iscsi_chain_count[2];
		short unsigned int iscsi_features;
		uint16_t dual_ulp_aware;
		long unsigned int ulp_supported;
	} fw_config;
	long unsigned int state;
	u8 optic_state;
	struct delayed_work eqd_update;
	struct timer_list hw_check;
	u32 ue2rp;
	struct delayed_work recover_port;
	struct work_struct sess_work;
	bool mac_addr_set;
	u8 mac_address[6];
	u8 port_name;
	u8 port_speed;
	char fw_ver_str[32];
	struct workqueue_struct *wq;
	struct be_ctrl_info ctrl;
	unsigned int generation;
	unsigned int interface_handle;
	struct be_aic_obj aic_obj[64];
	unsigned int attr_log_enable;
	int (*iotask_fn)(struct iscsi_task *, struct scatterlist *, uint32_t, uint32_t, uint32_t);
	struct boot_struct boot_struct;
	struct work_struct boot_work;
};

struct be_sge {
	__le32 pa_lo;
	__le32 pa_hi;
	__le32 len;
};

struct be_mcc_wrb {
	u32 emb_sgecnt_special;
	u32 payload_length;
	u32 tag0;
	u32 tag1;
	u32 rsvd;
	union {
		u8 embedded_payload[236];
		struct be_sge sgl[19];
	} payload;
};

struct be_cmd_req_hdr {
	u8 opcode;
	u8 subsystem;
	u8 port_number;
	u8 domain;
	u32 timeout;
	u32 request_length;
	u8 version;
	u8 rsvd0[3];
};

struct be_cmd_resp_hdr {
	u32 info;
	u32 status;
	u32 response_length;
	u32 actual_resp_len;
};

struct be_ip_addr_subnet_format {
	u16 size_of_structure;
	u8 ip_type;
	u8 ipv6_prefix_length;
	u8 addr[16];
	u8 subnet_mask[16];
	u32 rsvd0;
};

struct be_cmd_get_if_info_resp {
	struct be_cmd_req_hdr hdr;
	u32 interface_hndl;
	u32 vlan_priority;
	u32 ip_addr_count;
	u32 dhcp_state;
	struct be_ip_addr_subnet_format ip_addr;
};

struct be_cmd_get_def_gateway_resp {
	struct be_cmd_req_hdr hdr;
	struct ip_addr_format ip_addr;
};

struct be_cmd_get_nic_conf_resp {
	struct be_cmd_resp_hdr hdr;
	u32 nic_port_count;
	u32 speed;
	u32 max_speed;
	u32 link_state;
	u32 max_frame_size;
	u16 size_of_structure;
	u8 mac_address[6];
};

struct tcp_connect_and_offload_out {
	struct be_cmd_resp_hdr hdr;
	u32 connection_handle;
	u16 cid;
	u16 rsvd0;
};

struct be_ring {
	u32 pages;
	u32 id;
	u32 num;
	u32 cidx;
	u32 pidx;
	u32 item_size;
	u8 ulp_num;
	u16 register_set;
	u16 doorbell_format;
	u32 doorbell_offset;
	void *va;
};

struct hwi_context_memory;

struct hwi_controller {
	struct hwi_wrb_context *wrb_context;
	struct be_ring default_pdu_hdr[2];
	struct be_ring default_pdu_data[2];
	struct hwi_context_memory *phwi_ctxt;
};

struct beiscsi_endpoint;

struct beiscsi_session;

struct beiscsi_conn {
	struct iscsi_conn *conn;
	struct beiscsi_hba *phba;
	u32 exp_statsn;
	u32 doorbell_offset;
	u32 beiscsi_conn_cid;
	struct beiscsi_endpoint *ep;
	short unsigned int login_in_progress;
	struct wrb_handle *plogin_wrb_handle;
	struct sgl_handle *plogin_sgl_handle;
	struct beiscsi_session *beiscsi_sess;
	struct iscsi_task *task;
};

struct beiscsi_session {
	struct dma_pool *bhs_pool;
};

struct beiscsi_endpoint {
	struct beiscsi_hba *phba;
	struct beiscsi_conn *conn;
	struct iscsi_endpoint *openiscsi_ep;
	short unsigned int ip_type;
	char dst6_addr[64];
	long unsigned int dst_addr;
	short unsigned int ep_cid;
	unsigned int fw_handle;
	u16 dst_tcpport;
	u16 cid_vld;
};

struct pdu_data_out {
	u32 dw[12];
};

struct be_cmd_bhs {
	struct iscsi_scsi_req iscsi_hdr;
	unsigned char pad1[16];
	struct pdu_data_out iscsi_data_pdu;
	unsigned char pad2[210];
};

struct beiscsi_io_task {
	struct wrb_handle *pwrb_handle;
	struct sgl_handle *psgl_handle;
	struct beiscsi_conn *conn;
	struct scsi_cmnd *scsi_cmnd;
	int num_sg;
	struct hwi_wrb_context *pwrb_context;
	itt_t libiscsi_itt;
	struct be_cmd_bhs *cmd_bhs;
	struct be_bus_address bhs_pa;
	short unsigned int bhs_len;
	dma_addr_t mtask_addr;
	uint32_t mtask_data_count;
	uint8_t wrb_type;
};

struct beiscsi_offload_params {
	u32 dw[6];
};

struct amap_beiscsi_offload_params {
	u8 max_burst_length[32];
	u8 max_send_data_segment_length[32];
	u8 first_burst_length[32];
	u8 erl[2];
	u8 dde[1];
	u8 hde[1];
	u8 ir2t[1];
	u8 imd[1];
	u8 data_seq_inorder[1];
	u8 pdu_seq_inorder[1];
	u8 max_r2t[16];
	u8 pad[8];
	u8 exp_statsn[32];
	u8 max_recv_data_segment_length[32];
};

struct hd_async_handle {
	struct list_head link;
	struct be_bus_address pa;
	void *pbuffer;
	u32 buffer_len;
	u16 index;
	u16 cri;
	u8 is_header;
	u8 is_final;
	u8 in_use;
};

struct cri_wait_queue {
	short unsigned int hdr_len;
	unsigned int bytes_received;
	unsigned int bytes_needed;
	struct list_head list;
};

struct hd_async_entry {
	struct cri_wait_queue wq;
	struct hd_async_handle *header;
	struct hd_async_handle *data;
};

struct hd_async_buf_context {
	struct be_bus_address pa_base;
	void *va_base;
	void *ring_base;
	struct hd_async_handle *handle_base;
	u32 buffer_size;
	u16 pi;
};

struct hd_async_context {
	struct hd_async_buf_context async_header;
	struct hd_async_buf_context async_data;
	u16 num_entries;
	short unsigned int cid_to_async_cri_map[2048];
	struct hd_async_entry *async_entry;
};

struct hwi_context_memory {
	struct be_eq_obj be_eq[64];
	struct be_queue_info be_cq[63];
	struct be_queue_info *be_wrbq;
	struct be_queue_info be_def_hdrq[2];
	struct be_queue_info be_def_dataq[2];
	struct hd_async_context *pasync_ctx[2];
};

struct iscsi_logout_rsp {
	uint8_t opcode;
	uint8_t flags;
	uint8_t response;
	uint8_t rsvd2;
	uint8_t hlength;
	uint8_t dlength[3];
	uint8_t rsvd3[8];
	itt_t itt;
	__be32 rsvd4;
	__be32 statsn;
	__be32 exp_cmdsn;
	__be32 max_cmdsn;
	__be32 rsvd5;
	__be16 t2wait;
	__be16 t2retain;
	__be32 rsvd6;
};

enum be_mem_enum {
	HWI_MEM_ADDN_CONTEXT = 0,
	HWI_MEM_WRB = 1,
	HWI_MEM_WRBH = 2,
	HWI_MEM_SGLH = 3,
	HWI_MEM_SGE = 4,
	HWI_MEM_TEMPLATE_HDR_ULP0 = 5,
	HWI_MEM_ASYNC_HEADER_BUF_ULP0 = 6,
	HWI_MEM_ASYNC_DATA_BUF_ULP0 = 7,
	HWI_MEM_ASYNC_HEADER_RING_ULP0 = 8,
	HWI_MEM_ASYNC_DATA_RING_ULP0 = 9,
	HWI_MEM_ASYNC_HEADER_HANDLE_ULP0 = 10,
	HWI_MEM_ASYNC_DATA_HANDLE_ULP0 = 11,
	HWI_MEM_ASYNC_PDU_CONTEXT_ULP0 = 12,
	HWI_MEM_TEMPLATE_HDR_ULP1 = 13,
	HWI_MEM_ASYNC_HEADER_BUF_ULP1 = 14,
	HWI_MEM_ASYNC_DATA_BUF_ULP1 = 15,
	HWI_MEM_ASYNC_HEADER_RING_ULP1 = 16,
	HWI_MEM_ASYNC_DATA_RING_ULP1 = 17,
	HWI_MEM_ASYNC_HEADER_HANDLE_ULP1 = 18,
	HWI_MEM_ASYNC_DATA_HANDLE_ULP1 = 19,
	HWI_MEM_ASYNC_PDU_CONTEXT_ULP1 = 20,
	ISCSI_MEM_GLOBAL_HEADER = 21,
	SE_MEM_MAX = 22,
};

struct be_mcc_compl {
	u32 status;
	u32 tag0;
	u32 tag1;
	u32 flags;
};

struct phys_addr {
	u32 lo;
	u32 hi;
};

struct be_set_eqd {
	u32 eq_id;
	u32 phase;
	u32 delay_multiplier;
};

enum {
	QTYPE_EQ = 1,
	QTYPE_CQ = 2,
	QTYPE_MCCQ = 3,
	QTYPE_WRBQ = 4,
	QTYPE_DPDUQ = 5,
	QTYPE_SGL = 6,
};

struct sol_cqe {
	u32 dw[4];
};

struct amap_sol_cqe {
	u8 hw_sts[8];
	u8 i_sts[8];
	u8 i_resp[8];
	u8 i_flags[7];
	u8 s;
	u8 i_exp_cmd_sn[32];
	u8 code[6];
	u8 cid[10];
	u8 wrb_index[8];
	u8 i_cmd_wnd[8];
	u8 i_res_cnt[31];
	u8 valid;
};

struct amap_sol_cqe_v2 {
	u8 hw_sts[8];
	u8 i_sts[8];
	u8 wrb_index[16];
	u8 i_exp_cmd_sn[32];
	u8 code[6];
	u8 cmd_cmpl;
	u8 rsvd0;
	u8 i_cmd_wnd[8];
	u8 cid[13];
	u8 u;
	u8 o;
	u8 s;
	u8 i_res_cnt[31];
	u8 valid;
};

struct common_sol_cqe {
	u32 exp_cmdsn;
	u32 res_cnt;
	u16 wrb_index;
	u16 cid;
	u8 hw_sts;
	u8 cmd_wnd;
	u8 res_flag;
	u8 i_resp;
	u8 i_flags;
	u8 i_sts;
};

struct amap_it_dmsg_cqe {
	u8 ack_num[32];
	u8 pdu_bytes_rcvd[32];
	u8 code[6];
	u8 cid[10];
	u8 wrb_idx[8];
	u8 rsvd0[8];
	u8 rsvd1[31];
	u8 valid;
};

struct amap_it_dmsg_cqe_v2 {
	u8 ack_num[32];
	u8 pdu_bytes_rcvd[32];
	u8 code[6];
	u8 rsvd0[10];
	u8 wrb_idx[16];
	u8 rsvd1[16];
	u8 cid[13];
	u8 rsvd2[2];
	u8 valid;
};

struct amap_pdu_data_out {
	u8 opcode[6];
	u8 rsvd0[2];
	u8 rsvd1[7];
	u8 final_bit;
	u8 rsvd2[16];
	u8 ahs_length[8];
	u8 data_len_hi[8];
	u8 data_len_lo[16];
	u8 lun[64];
	u8 itt[32];
	u8 ttt[32];
	u8 rsvd3[32];
	u8 exp_stat_sn[32];
	u8 rsvd4[32];
	u8 data_sn[32];
	u8 buffer_offset[32];
	u8 rsvd5[32];
};

struct be_status_bhs {
	struct iscsi_scsi_req iscsi_hdr;
	unsigned char pad1[16];
	unsigned char sense_info[258];
};

struct amap_iscsi_sge {
	u8 addr_hi[32];
	u8 addr_lo[32];
	u8 sge_offset[22];
	u8 rsvd0[9];
	u8 last_sge;
	u8 len[17];
	u8 rsvd1[15];
};

struct i_t_dpdu_cqe {
	u32 dw[4];
};

struct amap_i_t_dpdu_cqe {
	u8 db_addr_hi[32];
	u8 db_addr_lo[32];
	u8 code[6];
	u8 cid[10];
	u8 dpl[16];
	u8 index[16];
	u8 num_cons[10];
	u8 rsvd0[4];
	u8 final;
	u8 valid;
};

struct amap_i_t_dpdu_cqe_v2 {
	u8 db_addr_hi[32];
	u8 db_addr_lo[32];
	u8 code[6];
	u8 num_cons;
	u8 rsvd0[8];
	u8 dpl[17];
	u8 index[16];
	u8 cid[13];
	u8 rsvd1;
	u8 final;
	u8 valid;
};

struct be_eq_entry {
	u32 dw[1];
};

struct amap_eq_entry {
	u8 valid;
	u8 major_code[3];
	u8 minor_code[12];
	u8 resource_id[16];
};

struct amap_iscsi_wrb {
	u8 lun[14];
	u8 lt;
	u8 invld;
	u8 wrb_idx[8];
	u8 dsp;
	u8 dmsg;
	u8 undr_run;
	u8 over_run;
	u8 type[4];
	u8 ptr2nextwrb[8];
	u8 r2t_exp_dtl[24];
	u8 sgl_icd_idx[12];
	u8 rsvd0[20];
	u8 exp_data_sn[32];
	u8 iscsi_bhs_addr_hi[32];
	u8 iscsi_bhs_addr_lo[32];
	u8 cmdsn_itt[32];
	u8 dif_ref_tag[32];
	u8 sge0_addr_hi[32];
	u8 sge0_addr_lo[32];
	u8 sge0_offset[22];
	u8 pbs;
	u8 dif_mode[2];
	u8 rsvd1[6];
	u8 sge0_last;
	u8 sge0_len[17];
	u8 dif_meta_tag[14];
	u8 sge0_in_ddr;
	u8 sge1_addr_hi[32];
	u8 sge1_addr_lo[32];
	u8 sge1_r2t_offset[22];
	u8 rsvd2[9];
	u8 sge1_last;
	u8 sge1_len[17];
	u8 ref_sgl_icd_idx[12];
	u8 rsvd3[2];
	u8 sge1_in_ddr;
};

struct amap_iscsi_wrb_v2 {
	u8 r2t_exp_dtl[25];
	u8 rsvd0[2];
	u8 type[5];
	u8 ptr2nextwrb[8];
	u8 wrb_idx[8];
	u8 lun[16];
	u8 sgl_idx[16];
	u8 ref_sgl_icd_idx[16];
	u8 exp_data_sn[32];
	u8 iscsi_bhs_addr_hi[32];
	u8 iscsi_bhs_addr_lo[32];
	u8 cq_id[16];
	u8 rsvd1[16];
	u8 cmdsn_itt[32];
	u8 sge0_addr_hi[32];
	u8 sge0_addr_lo[32];
	u8 sge0_offset[24];
	u8 rsvd2[7];
	u8 sge0_last;
	u8 sge0_len[17];
	u8 rsvd3[7];
	u8 diff_enbl;
	u8 u_run;
	u8 o_run;
	u8 invld;
	u8 dsp;
	u8 dmsg;
	u8 rsvd4;
	u8 lt;
	u8 sge1_addr_hi[32];
	u8 sge1_addr_lo[32];
	u8 sge1_r2t_offset[24];
	u8 rsvd5[7];
	u8 sge1_last;
	u8 sge1_len[17];
	u8 rsvd6[15];
};

struct pdu_nop_out {
	u32 dw[12];
};

struct amap_pdu_nop_out {
	u8 opcode[6];
	u8 i_bit;
	u8 x_bit;
	u8 fp_bit_filler1[7];
	u8 f_bit;
	u8 reserved1[16];
	u8 ahs_length[8];
	u8 data_len_hi[8];
	u8 data_len_lo[16];
	u8 lun[64];
	u8 itt[32];
	u8 ttt[32];
	u8 cmd_sn[32];
	u8 exp_stat_sn[32];
	u8 reserved5[128];
};

struct pdu_base {
	u32 dw[16];
};

struct amap_pdu_base {
	u8 opcode[6];
	u8 i_bit;
	u8 x_bit;
	u8 reserved1[24];
	u8 ahs_length[8];
	u8 data_len_hi[8];
	u8 data_len_lo[16];
	u8 lun[64];
	u8 itt[32];
	u8 reserved4[224];
};

enum hwh_type_enum {
	HWH_TYPE_IO = 1,
	HWH_TYPE_LOGOUT = 2,
	HWH_TYPE_TMF = 3,
	HWH_TYPE_NOP = 4,
	HWH_TYPE_IO_RD = 5,
	HWH_TYPE_LOGIN = 11,
	HWH_TYPE_INVALID = 4294967295,
};

struct invldt_cmd_tbl {
	short unsigned int icd;
	short unsigned int cid;
};

struct beiscsi_invldt_cmd_tbl {
	struct invldt_cmd_tbl tbl[128];
	struct iscsi_task *task[128];
};

struct be_cmd_req_logout_fw_sess {
	struct be_cmd_req_hdr hdr;
	uint32_t session_handle;
};

struct be_cmd_resp_logout_fw_sess {
	struct be_cmd_resp_hdr hdr;
	uint32_t session_status;
};

struct be_cmd_get_session_req {
	struct be_cmd_req_hdr hdr;
	u32 session_handle;
};

struct be_cmd_get_session_resp {
	struct be_cmd_resp_hdr hdr;
	struct mgmt_session_info session_info;
};

struct be_cmd_get_boot_target_req {
	struct be_cmd_req_hdr hdr;
};

struct be_cmd_get_boot_target_resp {
	struct be_cmd_resp_hdr hdr;
	u32 boot_session_count;
	u32 boot_session_handle;
};

struct be_cmd_reopen_session_req {
	struct be_cmd_req_hdr hdr;
	u16 reopen_type;
	u16 rsvd;
	u32 session_handle;
};

struct be_cmd_get_if_info_req {
	struct be_cmd_req_hdr hdr;
	u32 interface_hndl;
	u32 ip_type;
};

struct be_ip_addr_record {
	u32 action;
	u32 interface_hndl;
	struct be_ip_addr_subnet_format ip_addr;
	u32 status;
};

struct be_ip_addr_record_params {
	u32 record_entry_count;
	struct be_ip_addr_record ip_record;
};

struct be_cmd_set_ip_addr_req {
	struct be_cmd_req_hdr hdr;
	struct be_ip_addr_record_params ip_params;
};

struct be_cmd_set_dhcp_req {
	struct be_cmd_req_hdr hdr;
	u32 interface_hndl;
	u32 ip_type;
	u32 flags;
	u32 retry_count;
};

struct be_cmd_rel_dhcp_req {
	struct be_cmd_req_hdr hdr;
	u32 interface_hndl;
	u32 ip_type;
};

struct be_cmd_set_def_gateway_req {
	struct be_cmd_req_hdr hdr;
	u32 action;
	struct ip_addr_format ip_addr;
};

struct be_cmd_get_def_gateway_req {
	struct be_cmd_req_hdr hdr;
	u32 ip_type;
};

struct be_cmd_req_modify_eq_delay {
	struct be_cmd_req_hdr hdr;
	__le32 num_eq;
	struct {
		__le32 eq_id;
		__le32 phase;
		__le32 delay_multiplier;
	} delay[64];
};

struct be_cmd_hba_name {
	struct be_cmd_req_hdr hdr;
	u16 flags;
	u16 rsvd0;
	u8 initiator_name[224];
	u8 initiator_alias[32];
};

struct tcp_connect_and_offload_in_v1 {
	struct be_cmd_req_hdr hdr;
	struct ip_addr_format ip_address;
	u16 tcp_port;
	u16 cid;
	u16 cq_id;
	u16 defq_id;
	struct phys_addr dataout_template_pa;
	u16 hdr_ring_id;
	u16 data_ring_id;
	u8 do_offload;
	u8 ifd_state;
	u8 rsvd0[2];
	u16 tcp_window_size;
	u8 tcp_window_scale_count;
	u8 rsvd1;
	u32 tcp_mss: 24;
	u8 rsvd2;
};

struct be_invalidate_connection_params_in {
	struct be_cmd_req_hdr hdr;
	u32 session_handle;
	u16 cid;
	u16 unused;
	u16 cleanup_type;
	u16 save_cfg;
};

struct be_tcp_upload_params_in {
	struct be_cmd_req_hdr hdr;
	u16 id;
	u16 upload_type;
	u32 reset_seq;
};

struct be_cmd_get_all_if_id_req {
	struct be_cmd_req_hdr hdr;
	u32 if_count;
	u32 if_hndl_list[1];
};

struct amap_iscsi_target_context_update_wrb {
	u8 lun[14];
	u8 lt;
	u8 invld;
	u8 wrb_idx[8];
	u8 dsp;
	u8 dmsg;
	u8 undr_run;
	u8 over_run;
	u8 type[4];
	u8 ptr2nextwrb[8];
	u8 max_burst_length[19];
	u8 rsvd0[5];
	u8 rsvd1[15];
	u8 max_send_data_segment_length[17];
	u8 first_burst_length[14];
	u8 rsvd2[2];
	u8 tx_wrbindex_drv_msg[8];
	u8 rsvd3[5];
	u8 session_state[3];
	u8 rsvd4[16];
	u8 tx_jumbo;
	u8 hde;
	u8 dde;
	u8 erl[2];
	u8 domain_id[5];
	u8 mode;
	u8 imd;
	u8 ir2t;
	u8 notpredblq[2];
	u8 compltonack;
	u8 stat_sn[32];
	u8 pad_buffer_addr_hi[32];
	u8 pad_buffer_addr_lo[32];
	u8 pad_addr_hi[32];
	u8 pad_addr_lo[32];
	u8 rsvd5[32];
	u8 rsvd6[32];
	u8 rsvd7[32];
	u8 rsvd8[32];
	u8 rsvd9[32];
	u8 rsvd10[32];
};

struct amap_iscsi_target_context_update_wrb_v2 {
	u8 max_burst_length[24];
	u8 rsvd0[3];
	u8 type[5];
	u8 ptr2nextwrb[8];
	u8 wrb_idx[8];
	u8 rsvd1[16];
	u8 max_send_data_segment_length[24];
	u8 rsvd2[8];
	u8 first_burst_length[24];
	u8 rsvd3[8];
	u8 max_r2t[16];
	u8 rsvd4;
	u8 hde;
	u8 dde;
	u8 erl[2];
	u8 rsvd5[6];
	u8 imd;
	u8 ir2t;
	u8 rsvd6[3];
	u8 stat_sn[32];
	u8 rsvd7[32];
	u8 rsvd8[32];
	u8 max_recv_dataseg_len[24];
	u8 rsvd9[8];
	u8 rsvd10[32];
	u8 rsvd11[32];
	u8 max_cxns[16];
	u8 rsvd12[11];
	u8 invld;
	u8 rsvd13;
	u8 dmsg;
	u8 data_seq_inorder;
	u8 pdu_seq_inorder;
	u8 rsvd14[32];
	u8 rsvd15[32];
	u8 rsvd16[32];
	u8 rsvd17[32];
};

struct invldt_cmds_params_in {
	struct be_cmd_req_hdr hdr;
	unsigned int ref_handle;
	unsigned int icd_count;
	struct invldt_cmd_tbl table[128];
	short unsigned int cleanup_type;
	short unsigned int unused;
};

struct be_bsg_vendor_cmd {
	struct be_cmd_req_hdr hdr;
	short unsigned int region;
	short unsigned int offset;
	short unsigned int sector;
} __attribute__((packed));

struct be_async_event_trailer {
	u32 code;
};

struct be_async_event_link_state {
	u8 physical_port;
	u8 port_link_status;
	u8 port_duplex;
	u8 port_speed;
	u8 port_fault;
	u8 event_reason;
	u16 qos_link_speed;
	u32 event_tag;
	struct be_async_event_trailer trailer;
};

struct be_async_event_sli {
	u32 event_data1;
	u32 event_data2;
	u32 reserved;
	u32 trailer;
};

struct be_mcc_mailbox {
	struct be_mcc_wrb wrb;
	struct be_mcc_compl compl;
};

struct virt_addr {
	u32 lo;
	u32 hi;
};

struct amap_eq_context {
	u8 cidx[13];
	u8 rsvd0[3];
	u8 epidx[13];
	u8 valid;
	u8 rsvd1;
	u8 size;
	u8 pidx[13];
	u8 rsvd2[3];
	u8 pd[10];
	u8 count[3];
	u8 solevent;
	u8 stalled;
	u8 armed;
	u8 rsvd3[4];
	u8 func[8];
	u8 rsvd4;
	u8 delaymult[10];
	u8 rsvd5[2];
	u8 phase[2];
	u8 nodelay;
	u8 rsvd6[4];
	u8 rsvd7[32];
};

struct be_cmd_req_eq_create {
	struct be_cmd_req_hdr hdr;
	u16 num_pages;
	u16 rsvd0;
	u8 context[16];
	struct phys_addr pages[8];
};

struct be_cmd_resp_eq_create {
	struct be_cmd_resp_hdr resp_hdr;
	u16 eq_id;
	u16 rsvd0;
};

struct be_cmd_set_vlan_req {
	struct be_cmd_req_hdr hdr;
	u32 interface_hndl;
	u32 vlan_priority;
};

struct amap_cq_context {
	u8 cidx[11];
	u8 rsvd0;
	u8 coalescwm[2];
	u8 nodelay;
	u8 epidx[11];
	u8 rsvd1;
	u8 count[2];
	u8 valid;
	u8 solevent;
	u8 eventable;
	u8 pidx[11];
	u8 rsvd2;
	u8 pd[10];
	u8 eqid[8];
	u8 stalled;
	u8 armed;
	u8 rsvd3[4];
	u8 func[8];
	u8 rsvd4[20];
	u8 rsvd5[32];
};

struct amap_cq_context_v2 {
	u8 rsvd0[12];
	u8 coalescwm[2];
	u8 nodelay;
	u8 rsvd1[12];
	u8 count[2];
	u8 valid;
	u8 rsvd2;
	u8 eventable;
	u8 eqid[16];
	u8 rsvd3[15];
	u8 armed;
	u8 cqecount[16];
	u8 rsvd4[16];
	u8 rsvd5[32];
};

struct be_cmd_req_cq_create {
	struct be_cmd_req_hdr hdr;
	u16 num_pages;
	u8 page_size;
	u8 rsvd0;
	u8 context[16];
	struct phys_addr pages[4];
};

struct be_cmd_resp_cq_create {
	struct be_cmd_resp_hdr hdr;
	u16 cq_id;
	u16 rsvd0;
};

struct amap_mcc_context {
	u8 con_index[14];
	u8 rsvd0[2];
	u8 ring_size[4];
	u8 fetch_wrb;
	u8 fetch_r2t;
	u8 cq_id[10];
	u8 prod_index[14];
	u8 fid[8];
	u8 pdid[9];
	u8 valid;
	u8 rsvd1[32];
	u8 rsvd2[32];
};

struct be_cmd_req_mcc_create_ext {
	struct be_cmd_req_hdr hdr;
	u16 num_pages;
	u16 rsvd0;
	u32 async_evt_bitmap;
	u8 context[16];
	struct phys_addr pages[8];
};

struct be_cmd_resp_mcc_create {
	struct be_cmd_resp_hdr hdr;
	u16 id;
	u16 rsvd0;
};

struct be_cmd_req_q_destroy {
	struct be_cmd_req_hdr hdr;
	u16 id;
	u16 bypass_flush;
};

struct be_sethost_req {
	u32 param_id;
	u32 param_len;
	u32 param_data[32];
};

struct be_sethost_resp {
	u32 rsvd0;
};

struct be_cmd_set_host_data {
	union {
		struct be_cmd_req_hdr req_hdr;
		struct be_cmd_resp_hdr resp_hdr;
	} h;
	union {
		struct be_sethost_req req;
		struct be_sethost_resp resp;
	} param;
};

struct be_uer_req {
	u32 uer;
	u32 rsvd;
};

struct be_uer_resp {
	u32 uer;
	u16 ue2rp;
	u16 ue2sr;
};

struct be_cmd_set_features {
	union {
		struct be_cmd_req_hdr req_hdr;
		struct be_cmd_resp_hdr resp_hdr;
	} h;
	u32 feature;
	u32 param_len;
	union {
		struct be_uer_req req;
		struct be_uer_resp resp;
		u32 rsvd[2];
	} param;
};

struct be_default_pdu_context {
	u32 dw[4];
};

struct amap_be_default_pdu_context {
	u8 dbuf_cindex[13];
	u8 rsvd0[3];
	u8 ring_size[4];
	u8 ring_state[4];
	u8 rsvd1[8];
	u8 dbuf_pindex[13];
	u8 rsvd2;
	u8 pci_func_id[8];
	u8 rx_pdid[9];
	u8 rx_pdid_valid;
	u8 default_buffer_size[16];
	u8 cq_id_recv[10];
	u8 rx_pdid_not_valid;
	u8 rsvd3[5];
	u8 rsvd4[32];
};

struct amap_default_pdu_context_ext {
	u8 rsvd0[16];
	u8 ring_size[4];
	u8 rsvd1[12];
	u8 rsvd2[22];
	u8 rx_pdid[9];
	u8 rx_pdid_valid;
	u8 default_buffer_size[16];
	u8 cq_id_recv[16];
	u8 rsvd3[32];
};

struct be_defq_create_req {
	struct be_cmd_req_hdr hdr;
	u16 num_pages;
	u8 ulp_num;
	u8 dua_feature;
	struct be_default_pdu_context context;
	struct phys_addr pages[8];
};

struct be_defq_create_resp {
	struct be_cmd_req_hdr hdr;
	u16 id;
	u8 rsvd0;
	u8 ulp_num;
	u32 doorbell_offset;
	u16 register_set;
	u16 doorbell_format;
};

struct be_post_template_pages_req {
	struct be_cmd_req_hdr hdr;
	u16 num_pages;
	u16 type;
	struct phys_addr scratch_pa;
	struct virt_addr scratch_va;
	struct virt_addr pages_va;
	struct phys_addr pages[16];
};

struct be_remove_template_pages_req {
	struct be_cmd_req_hdr hdr;
	u16 type;
	u16 rsvd0;
};

struct be_post_sgl_pages_req {
	struct be_cmd_req_hdr hdr;
	u16 num_pages;
	u16 page_offset;
	u32 rsvd0;
	struct phys_addr pages[26];
	u32 rsvd1;
};

struct be_wrbq_create_req {
	struct be_cmd_req_hdr hdr;
	u16 num_pages;
	u8 ulp_num;
	u8 dua_feature;
	struct phys_addr pages[8];
};

struct be_wrbq_create_resp {
	struct be_cmd_resp_hdr resp_hdr;
	u16 cid;
	u8 rsvd0;
	u8 ulp_num;
	u32 doorbell_offset;
	u16 register_set;
	u16 doorbell_format;
};

struct iscsi_cleanup_req {
	struct be_cmd_req_hdr hdr;
	u16 chute;
	u8 hdr_ring_id;
	u8 data_ring_id;
};

struct iscsi_cleanup_req_v1 {
	struct be_cmd_req_hdr hdr;
	u16 chute;
	u16 rsvd1;
	u16 hdr_ring_id;
	u16 rsvd2;
	u16 data_ring_id;
	u16 rsvd3;
};

struct be_ulp_fw_cfg {
	u32 ulp_mode;
	u32 etx_base;
	u32 etx_count;
	u32 sq_base;
	u32 sq_count;
	u32 rq_base;
	u32 rq_count;
	u32 dq_base;
	u32 dq_count;
	u32 lro_base;
	u32 lro_count;
	u32 icd_base;
	u32 icd_count;
};

struct be_ulp_chain_icd {
	u32 chain_base;
	u32 chain_count;
};

struct be_fw_cfg {
	struct be_cmd_req_hdr hdr;
	u32 be_config_number;
	u32 asic_revision;
	u32 phys_port;
	u32 function_mode;
	struct be_ulp_fw_cfg ulp[2];
	u32 function_caps;
	u32 cqid_base;
	u32 cqid_count;
	u32 eqid_base;
	u32 eqid_count;
	struct be_ulp_chain_icd chain_icd[2];
};

struct be_cmd_get_port_name {
	union {
		struct be_cmd_req_hdr req_hdr;
		struct be_cmd_resp_hdr resp_hdr;
	} h;
	union {
		struct {
			u32 reserved;
		} req;
		struct {
			u32 port_names;
		} resp;
	} p;
};

struct mgmt_hba_attributes {
	u8 flashrom_version_string[32];
	u8 manufacturer_name[32];
	u32 supported_modes;
	u8 seeprom_version_lo;
	u8 seeprom_version_hi;
	u8 rsvd0[2];
	u32 fw_cmd_data_struct_version;
	u32 ep_fw_data_struct_version;
	u8 ncsi_version_string[12];
	u32 default_extended_timeout;
	u8 controller_model_number[32];
	u8 controller_description[64];
	u8 controller_serial_number[32];
	u8 ip_version_string[32];
	u8 firmware_version_string[32];
	u8 bios_version_string[32];
	u8 redboot_version_string[32];
	u8 driver_version_string[32];
	u8 fw_on_flash_version_string[32];
	u32 functionalities_supported;
	u16 max_cdblength;
	u8 asic_revision;
	u8 generational_guid[16];
	u8 hba_port_count;
	u16 default_link_down_timeout;
	u8 iscsi_ver_min_max;
	u8 multifunction_device;
	u8 cache_valid;
	u8 hba_status;
	u8 max_domains_supported;
	u8 phy_port;
	u32 firmware_post_status;
	u32 hba_mtu[8];
	u8 iscsi_features;
	u8 asic_generation;
	u8 future_u8[2];
	u32 future_u32[3];
};

struct mgmt_controller_attributes {
	struct mgmt_hba_attributes hba_attribs;
	u16 pci_vendor_id;
	u16 pci_device_id;
	u16 pci_sub_vendor_id;
	u16 pci_sub_system_id;
	u8 pci_bus_number;
	u8 pci_device_number;
	u8 pci_function_number;
	u8 interface_type;
	u64 unique_identifier;
	u8 netfilters;
	u8 rsvd0[3];
	u32 future_u32[4];
} __attribute__((packed));

struct be_mgmt_controller_attributes {
	struct be_cmd_req_hdr hdr;
	struct mgmt_controller_attributes params;
} __attribute__((packed));

struct be_mgmt_controller_attributes_resp {
	struct be_cmd_resp_hdr hdr;
	struct mgmt_controller_attributes params;
} __attribute__((packed));

struct pmcraid_ioadl_desc {
	__le64 address;
	__le32 data_len;
	__u8 reserved[3];
	__u8 flags;
};

struct pmcraid_ioarcb_add_data {
	union {
		struct pmcraid_ioadl_desc ioadl[27];
		__u8 add_cmd_params[48];
	} u;
};

struct pmcraid_ioarcb {
	__le64 ioarcb_bus_addr;
	__le32 resource_handle;
	__le32 response_handle;
	__le64 ioadl_bus_addr;
	__le32 ioadl_length;
	__le32 data_transfer_length;
	__le64 ioasa_bus_addr;
	__le16 ioasa_len;
	__le16 cmd_timeout;
	__le16 add_cmd_param_offset;
	__le16 add_cmd_param_length;
	__le32 reserved1[2];
	__le32 reserved2;
	__u8 request_type;
	__u8 request_flags0;
	__u8 request_flags1;
	__u8 hrrq_id;
	__u8 cdb[16];
	struct pmcraid_ioarcb_add_data add_data;
};

struct pmcraid_ioasa_vset {
	__le32 failing_lba_hi;
	__le32 failing_lba_lo;
	__le32 reserved;
};

struct pmcraid_ioasa {
	__le32 ioasc;
	__le16 returned_status_length;
	__le16 available_status_length;
	__le32 residual_data_length;
	__le32 ilid;
	__le32 fd_ioasc;
	__le32 fd_res_address;
	__le32 fd_res_handle;
	__le32 reserved;
	union {
		struct pmcraid_ioasa_vset vset;
	} u;
	__le16 auto_sense_length;
	__le16 error_data_length;
	__u8 sense_data[256];
};

struct pmcraid_config_table_entry {
	__u8 resource_type;
	__u8 bus_protocol;
	__le16 array_id;
	__u8 common_flags0;
	__u8 common_flags1;
	__u8 unique_flags0;
	__u8 unique_flags1;
	__le32 resource_handle;
	__le32 resource_address;
	__u8 device_id[8];
	__u8 lun[8];
};

struct pmcraid_config_table_entry_ext {
	struct pmcraid_config_table_entry cfgte;
};

struct pmcraid_config_table {
	__le16 num_entries;
	__u8 table_format;
	__u8 reserved1;
	__u8 flags;
	__u8 reserved2[11];
	union {
		struct pmcraid_config_table_entry entries[256];
		struct pmcraid_config_table_entry_ext entries_ext[256];
	};
};

struct pmcraid_hostrcb_error {
	__le32 fd_ioasc;
	__le32 fd_ra;
	__le32 fd_rh;
	__le32 prc;
	union {
		__u8 data[4056];
	} u;
};

struct pmcraid_hcam_hdr {
	__u8 op_code;
	__u8 notification_type;
	__u8 notification_lost;
	__u8 flags;
	__u8 overlay_id;
	__u8 reserved1[3];
	__le32 ilid;
	__le32 timestamp1;
	__le32 timestamp2;
	__le32 data_len;
};

struct pmcraid_hcam_ccn {
	struct pmcraid_hcam_hdr header;
	struct pmcraid_config_table_entry cfg_entry;
	struct pmcraid_config_table_entry cfg_entry_old;
};

struct pmcraid_hcam_ldn {
	struct pmcraid_hcam_hdr header;
	struct pmcraid_hostrcb_error error_log;
};

struct pmcraid_chip_details {
	long unsigned int ioastatus;
	long unsigned int ioarrin;
	long unsigned int mailbox;
	long unsigned int global_intr_mask;
	long unsigned int ioa_host_intr;
	long unsigned int ioa_host_msix_intr;
	long unsigned int ioa_host_intr_clr;
	long unsigned int ioa_host_mask;
	long unsigned int ioa_host_mask_clr;
	long unsigned int host_ioa_intr;
	long unsigned int host_ioa_intr_clr;
	long unsigned int transop_timeout;
};

struct pmcraid_control_block {
	struct pmcraid_ioarcb ioarcb;
	struct pmcraid_ioadl_desc ioadl[40];
	struct pmcraid_ioasa ioasa;
	long: 64;
	long: 64;
};

struct pmcraid_sglist {
	u32 order;
	u32 num_sg;
	u32 num_dma_sg;
	struct scatterlist *scatterlist;
};

struct pmcraid_inquiry_data {
	__u8 ph_dev_type;
	__u8 page_code;
	__u8 reserved1;
	__u8 add_page_len;
	__u8 length;
	__u8 reserved2;
	__be16 fw_version;
	__u8 reserved3[16];
};

struct pmcraid_timestamp_data {
	__u8 reserved1[4];
	__u8 timestamp[6];
	__u8 reserved2[2];
};

struct pmcraid_resource_entry {
	struct list_head queue;
	union {
		struct pmcraid_config_table_entry cfg_entry;
		struct pmcraid_config_table_entry_ext cfg_entry_ext;
	};
	struct scsi_device *scsi_dev;
	atomic_t read_failures;
	atomic_t write_failures;
	u8 change_detected;
	u8 reset_progress;
	u8 sync_reqd;
	u8 target;
};

struct pmcraid_instance;

struct pmcraid_cmd {
	struct pmcraid_control_block *ioa_cb;
	dma_addr_t ioa_cb_bus_addr;
	dma_addr_t dma_handle;
	struct scsi_cmnd *scsi_cmd;
	struct list_head free_list;
	struct completion wait_for_completion;
	struct timer_list timer;
	u32 timeout;
	u32 index;
	u8 completion_req;
	u8 release;
	void (*cmd_done)(struct pmcraid_cmd *);
	struct pmcraid_instance *drv_inst;
	struct pmcraid_sglist *sglist;
	union {
		long unsigned int time_left;
		struct pmcraid_resource_entry *res;
		int hrrq_index;
		struct {
			u8 *sense_buffer;
			dma_addr_t sense_buffer_dma;
		};
	};
};

struct pmcraid_interrupts {
	void *ioa_host_interrupt_reg;
	void *ioa_host_msix_interrupt_reg;
	void *ioa_host_interrupt_clr_reg;
	void *ioa_host_interrupt_mask_reg;
	void *ioa_host_interrupt_mask_clr_reg;
	void *global_interrupt_mask_reg;
	void *host_ioa_interrupt_reg;
	void *host_ioa_interrupt_clr_reg;
};

struct pmcraid_aen_msg;

struct pmcraid_hostrcb {
	struct pmcraid_instance *drv_inst;
	struct pmcraid_aen_msg *msg;
	struct pmcraid_hcam_hdr *hcam;
	struct pmcraid_cmd *cmd;
	dma_addr_t baddr;
	atomic_t ignore;
};

struct pmcraid_aen_msg {
	u32 hostno;
	u32 length;
	u8 reserved[8];
	u8 data[0];
};

struct pmcraid_state_msg {
	struct pmcraid_aen_msg msg;
	u32 ioa_state;
};

struct pmcraid_isr_param {
	struct pmcraid_instance *drv_inst;
	u8 hrrq_id;
};

struct pmcraid_instance {
	struct pmcraid_resource_entry *res_entries;
	struct list_head free_res_q;
	struct list_head used_res_q;
	spinlock_t resource_lock;
	void *mapped_dma_addr;
	void *ioa_status;
	void *mailbox;
	void *ioarrin;
	struct pmcraid_interrupts int_regs;
	struct pmcraid_chip_details *chip_cfg;
	struct pmcraid_hostrcb ldn;
	struct pmcraid_hostrcb ccn;
	struct pmcraid_state_msg scn;
	dma_addr_t hrrq_start_bus_addr[16];
	__le32 *hrrq_start[16];
	__le32 *hrrq_end[16];
	__le32 *hrrq_curr[16];
	spinlock_t hrrq_lock[16];
	struct pmcraid_inquiry_data *inq_data;
	dma_addr_t inq_data_baddr;
	struct pmcraid_timestamp_data *timestamp_data;
	dma_addr_t timestamp_data_baddr;
	u32 config_table_entry_size;
	u8 host_toggle_bit[16];
	wait_queue_head_t reset_wait_q;
	struct pmcraid_cmd *reset_cmd;
	struct fasync_struct *aen_queue;
	struct mutex aen_queue_lock;
	struct cdev cdev;
	struct Scsi_Host *host;
	struct pci_dev *pdev;
	u8 ioa_reset_attempts;
	u8 current_log_level;
	u8 num_hrrq;
	u8 interrupt_mode;
	dev_t dev;
	struct pmcraid_isr_param hrrq_vector[16];
	atomic_t last_message_id;
	struct pmcraid_config_table *cfg_table;
	dma_addr_t cfg_table_bus_addr;
	struct kmem_cache *cmd_cachep;
	struct dma_pool *control_pool;
	char cmd_pool_name[64];
	char ctl_pool_name[64];
	struct pmcraid_cmd *cmd_list[1024];
	struct list_head free_cmd_pool;
	struct list_head pending_cmd_pool;
	spinlock_t free_pool_lock;
	spinlock_t pending_pool_lock;
	struct tasklet_struct isr_tasklet[16];
	struct work_struct worker_q;
	atomic_t outstanding_cmds;
	atomic_t expose_resources;
	u32 ioa_state: 4;
	u32 ioa_reset_in_progress: 1;
	u32 ioa_hard_reset: 1;
	u32 ioa_unit_check: 1;
	u32 ioa_bringdown: 1;
	u32 force_ioa_reset: 1;
	u32 reinit_cfg_table: 1;
	u32 ioa_shutdown_type: 2;
	u32 timestamp_error: 1;
};

struct pmcraid_ioasc_error {
	u32 ioasc_code;
	u8 log_level;
	char *error_string;
};

struct pmcraid_ioctl_header {
	u8 signature[8];
	u32 reserved;
	u32 buffer_length;
};

struct pmcraid_passthrough_ioctl_buffer {
	struct pmcraid_ioctl_header ioctl_header;
	struct pmcraid_ioarcb ioarcb;
	struct pmcraid_ioasa ioasa;
	u8 request_buffer[1];
} __attribute__((packed));

enum {
	PMCRAID_AEN_ATTR_UNSPEC = 0,
	PMCRAID_AEN_ATTR_EVENT = 1,
	__PMCRAID_AEN_ATTR_MAX = 2,
};

enum {
	PMCRAID_AEN_CMD_UNSPEC = 0,
	PMCRAID_AEN_CMD_EVENT = 1,
	__PMCRAID_AEN_CMD_MAX = 2,
};

struct virtio_scsi_cmd_req {
	__u8 lun[8];
	__virtio64 tag;
	__u8 task_attr;
	__u8 prio;
	__u8 crn;
	__u8 cdb[32];
} __attribute__((packed));

struct virtio_scsi_cmd_req_pi {
	__u8 lun[8];
	__virtio64 tag;
	__u8 task_attr;
	__u8 prio;
	__u8 crn;
	__virtio32 pi_bytesout;
	__virtio32 pi_bytesin;
	__u8 cdb[32];
} __attribute__((packed));

struct virtio_scsi_cmd_resp {
	__virtio32 sense_len;
	__virtio32 resid;
	__virtio16 status_qualifier;
	__u8 status;
	__u8 response;
	__u8 sense[96];
};

struct virtio_scsi_ctrl_tmf_req {
	__virtio32 type;
	__virtio32 subtype;
	__u8 lun[8];
	__virtio64 tag;
};

struct virtio_scsi_ctrl_tmf_resp {
	__u8 response;
};

struct virtio_scsi_ctrl_an_req {
	__virtio32 type;
	__u8 lun[8];
	__virtio32 event_requested;
};

struct virtio_scsi_ctrl_an_resp {
	__virtio32 event_actual;
	__u8 response;
} __attribute__((packed));

struct virtio_scsi_event {
	__virtio32 event;
	__u8 lun[8];
	__virtio32 reason;
};

struct virtio_scsi_config {
	__u32 num_queues;
	__u32 seg_max;
	__u32 max_sectors;
	__u32 cmd_per_lun;
	__u32 event_info_size;
	__u32 sense_size;
	__u32 cdb_size;
	__u16 max_channel;
	__u16 max_target;
	__u32 max_lun;
};

struct virtio_scsi_cmd {
	struct scsi_cmnd *sc;
	struct completion *comp;
	union {
		struct virtio_scsi_cmd_req cmd;
		struct virtio_scsi_cmd_req_pi cmd_pi;
		struct virtio_scsi_ctrl_tmf_req tmf;
		struct virtio_scsi_ctrl_an_req an;
	} req;
	union {
		struct virtio_scsi_cmd_resp cmd;
		struct virtio_scsi_ctrl_tmf_resp tmf;
		struct virtio_scsi_ctrl_an_resp an;
		struct virtio_scsi_event evt;
	} resp;
	long: 8;
	long: 64;
} __attribute__((packed));

struct virtio_scsi;

struct virtio_scsi_event_node {
	struct virtio_scsi *vscsi;
	struct virtio_scsi_event event;
	struct work_struct work;
};

struct virtio_scsi_vq {
	spinlock_t vq_lock;
	struct virtqueue *vq;
};

struct virtio_scsi {
	struct virtio_device *vdev;
	struct virtio_scsi_event_node event_list[8];
	u32 num_queues;
	struct hlist_node node;
	bool stop_events;
	struct virtio_scsi_vq ctrl_vq;
	struct virtio_scsi_vq event_vq;
	struct virtio_scsi_vq req_vqs[0];
};

struct mtop {
	short int mt_op;
	int mt_count;
};

struct st_cmdstatus {
	int midlevel_result;
	struct scsi_sense_hdr sense_hdr;
	int have_sense;
	int residual;
	u64 uremainder64;
	u8 flags;
	u8 remainder_valid;
	u8 fixed_format;
	u8 deferred;
};

struct scsi_tape;

struct st_request {
	unsigned char cmd[16];
	unsigned char sense[96];
	int result;
	struct scsi_tape *stp;
	struct completion *waiting;
	struct bio *bio;
};

struct st_modedef {
	unsigned char defined;
	unsigned char sysv;
	unsigned char do_async_writes;
	unsigned char do_buffer_writes;
	unsigned char do_read_ahead;
	unsigned char defaults_for_writes;
	unsigned char default_compression;
	short int default_density;
	int default_blksize;
	struct scsi_tape *tape;
	struct device *devs[2];
	struct cdev *cdevs[2];
};

struct st_partstat {
	unsigned char rw;
	unsigned char eof;
	unsigned char at_sm;
	unsigned char last_block_valid;
	u32 last_block_visited;
	int drv_block;
	int drv_file;
};

struct st_buffer;

struct scsi_tape_stats;

struct scsi_tape {
	struct scsi_driver *driver;
	struct scsi_device *device;
	struct mutex lock;
	struct completion wait;
	struct st_buffer *buffer;
	int index;
	unsigned char omit_blklims;
	unsigned char do_auto_lock;
	unsigned char can_bsr;
	unsigned char can_partitions;
	unsigned char two_fm;
	unsigned char fast_mteom;
	unsigned char immediate;
	unsigned char restr_dma;
	unsigned char scsi2_logical;
	unsigned char default_drvbuffer;
	unsigned char cln_mode;
	unsigned char cln_sense_value;
	unsigned char cln_sense_mask;
	unsigned char use_pf;
	unsigned char try_dio;
	unsigned char try_dio_now;
	unsigned char c_algo;
	unsigned char pos_unknown;
	unsigned char sili;
	unsigned char immediate_filemark;
	int tape_type;
	int long_timeout;
	struct st_modedef modes[4];
	int current_mode;
	int partition;
	int new_partition;
	int nbr_partitions;
	struct st_partstat ps[4];
	unsigned char dirty;
	unsigned char ready;
	unsigned char write_prot;
	unsigned char drv_write_prot;
	unsigned char in_use;
	unsigned char blksize_changed;
	unsigned char density_changed;
	unsigned char compression_changed;
	unsigned char drv_buffer;
	unsigned char density;
	unsigned char door_locked;
	unsigned char autorew_dev;
	unsigned char rew_at_close;
	unsigned char inited;
	unsigned char cleaning_req;
	int block_size;
	int min_block;
	int max_block;
	int recover_count;
	int recover_reg;
	unsigned char write_pending;
	int nbr_finished;
	int nbr_waits;
	int nbr_requests;
	int nbr_dio;
	int nbr_pages;
	unsigned char last_cmnd[6];
	unsigned char last_sense[16];
	struct gendisk *disk;
	struct kref kref;
	struct scsi_tape_stats *stats;
};

struct st_buffer {
	unsigned char dma;
	unsigned char cleared;
	short unsigned int do_dio;
	int buffer_size;
	int buffer_blocks;
	int buffer_bytes;
	int read_pointer;
	int writing;
	int syscall_result;
	struct st_request *last_SRpnt;
	struct st_cmdstatus cmdstat;
	struct page **reserved_pages;
	int reserved_page_order;
	struct page **mapped_pages;
	struct rq_map_data map_data;
	unsigned char *b_data;
	short unsigned int use_sg;
	short unsigned int sg_segs;
	short unsigned int frp_segs;
};

struct scsi_tape_stats {
	atomic64_t read_byte_cnt;
	atomic64_t write_byte_cnt;
	atomic64_t in_flight;
	atomic64_t read_cnt;
	atomic64_t write_cnt;
	atomic64_t other_cnt;
	atomic64_t resid_cnt;
	atomic64_t tot_read_time;
	atomic64_t tot_write_time;
	atomic64_t tot_io_time;
	ktime_t read_time;
	ktime_t write_time;
	ktime_t other_time;
	atomic_t last_read_size;
	atomic_t last_write_size;
};

struct st_dev_parm {
	char *name;
	int *val;
};

struct st_reject_data {
	char *vendor;
	char *model;
	char *rev;
	char *driver_hint;
};

enum {
	SD_EXT_CDB_SIZE = 32,
	SD_MEMPOOL_SIZE = 2,
};

enum {
	SD_DEF_XFER_BLOCKS = 65535,
	SD_MAX_XFER_BLOCKS = 4294967295,
	SD_MAX_WS10_BLOCKS = 65535,
	SD_MAX_WS16_BLOCKS = 8388607,
};

enum {
	SD_LBP_FULL = 0,
	SD_LBP_UNMAP = 1,
	SD_LBP_WS16 = 2,
	SD_LBP_WS10 = 3,
	SD_LBP_ZERO = 4,
	SD_LBP_DISABLE = 5,
};

enum {
	SD_ZERO_WRITE = 0,
	SD_ZERO_WS = 1,
	SD_ZERO_WS16_UNMAP = 2,
	SD_ZERO_WS10_UNMAP = 3,
};

struct scsi_disk {
	struct scsi_driver *driver;
	struct scsi_device *device;
	struct device dev;
	struct gendisk *disk;
	struct opal_dev *opal_dev;
	atomic_t openers;
	sector_t capacity;
	u32 max_xfer_blocks;
	u32 opt_xfer_blocks;
	u32 max_ws_blocks;
	u32 max_unmap_blocks;
	u32 unmap_granularity;
	u32 unmap_alignment;
	u32 index;
	unsigned int physical_block_size;
	unsigned int max_medium_access_timeouts;
	unsigned int medium_access_timed_out;
	u8 media_present;
	u8 write_prot;
	u8 protection_type;
	u8 provisioning_mode;
	u8 zeroing_mode;
	unsigned int ATO: 1;
	unsigned int cache_override: 1;
	unsigned int WCE: 1;
	unsigned int RCD: 1;
	unsigned int DPOFUA: 1;
	unsigned int first_scan: 1;
	unsigned int lbpme: 1;
	unsigned int lbprz: 1;
	unsigned int lbpu: 1;
	unsigned int lbpws: 1;
	unsigned int lbpws10: 1;
	unsigned int lbpvpd: 1;
	unsigned int ws10: 1;
	unsigned int ws16: 1;
	unsigned int rc_basis: 2;
	unsigned int zoned: 2;
	unsigned int urswrz: 1;
	unsigned int security: 1;
	unsigned int ignore_medium_access_errors: 1;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

struct sg_scsi_id {
	int host_no;
	int channel;
	int scsi_id;
	int lun;
	int scsi_type;
	short int h_cmd_per_lun;
	short int d_queue_depth;
	int unused[2];
};

typedef struct sg_scsi_id sg_scsi_id_t;

struct sg_header {
	int pack_len;
	int reply_len;
	int pack_id;
	int result;
	unsigned int twelve_byte: 1;
	unsigned int target_status: 5;
	unsigned int host_status: 8;
	unsigned int driver_status: 8;
	unsigned int other_flags: 10;
	unsigned char sense_buffer[16];
};

struct sg_scatter_hold {
	short unsigned int k_use_sg;
	unsigned int sglist_len;
	unsigned int bufflen;
	struct page **pages;
	int page_order;
	char dio_in_use;
	unsigned char cmd_opcode;
};

typedef struct sg_scatter_hold Sg_scatter_hold;

struct sg_fd;

struct sg_request {
	struct list_head entry;
	struct sg_fd *parentfp;
	Sg_scatter_hold data;
	sg_io_hdr_t header;
	unsigned char sense_b[96];
	char res_used;
	char orphan;
	char sg_io_owned;
	char done;
	struct request *rq;
	struct bio *bio;
	struct execute_work ew;
};

typedef struct sg_request Sg_request;

struct sg_device;

struct sg_fd {
	struct list_head sfd_siblings;
	struct sg_device *parentdp;
	wait_queue_head_t read_wait;
	rwlock_t rq_list_lock;
	struct mutex f_mutex;
	int timeout;
	int timeout_user;
	Sg_scatter_hold reserve;
	struct list_head rq_list;
	struct fasync_struct *async_qp;
	Sg_request req_arr[16];
	char force_packid;
	char cmd_q;
	unsigned char next_cmd_len;
	char keep_orphan;
	char mmap_called;
	char res_in_use;
	struct kref f_ref;
	struct execute_work ew;
};

struct sg_device {
	struct scsi_device *device;
	wait_queue_head_t open_wait;
	struct mutex open_rel_lock;
	int sg_tablesize;
	u32 index;
	struct list_head sfds;
	rwlock_t sfd_lock;
	atomic_t detaching;
	bool exclude;
	int open_cnt;
	char sgdebug;
	struct gendisk *disk;
	struct cdev *cdev;
	struct kref d_ref;
};

typedef struct sg_fd Sg_fd;

typedef struct sg_device Sg_device;

struct sg_proc_deviter {
	loff_t index;
	size_t max;
};

struct changer_params {
	int cp_curpicker;
	int cp_npickers;
	int cp_nslots;
	int cp_nportals;
	int cp_ndrives;
};

struct changer_vendor_params {
	int cvp_n1;
	char cvp_label1[16];
	int cvp_n2;
	char cvp_label2[16];
	int cvp_n3;
	char cvp_label3[16];
	int cvp_n4;
	char cvp_label4[16];
	int reserved[8];
};

struct changer_move {
	int cm_fromtype;
	int cm_fromunit;
	int cm_totype;
	int cm_tounit;
	int cm_flags;
};

struct changer_exchange {
	int ce_srctype;
	int ce_srcunit;
	int ce_fdsttype;
	int ce_fdstunit;
	int ce_sdsttype;
	int ce_sdstunit;
	int ce_flags;
};

struct changer_position {
	int cp_type;
	int cp_unit;
	int cp_flags;
};

struct changer_element_status {
	int ces_type;
	unsigned char *ces_data;
};

struct changer_get_element {
	int cge_type;
	int cge_unit;
	int cge_status;
	int cge_errno;
	int cge_srctype;
	int cge_srcunit;
	int cge_id;
	int cge_lun;
	char cge_pvoltag[36];
	char cge_avoltag[36];
	int cge_flags;
};

struct changer_set_voltag {
	int csv_type;
	int csv_unit;
	char csv_voltag[36];
	int csv_flags;
};

typedef struct {
	struct kref ref;
	struct list_head list;
	int minor;
	char name[8];
	struct scsi_device *device;
	struct scsi_device **dt;
	u_int firsts[8];
	u_int counts[8];
	u_int unit_attention;
	u_int voltags;
	struct mutex lock;
} scsi_changer;

struct changer_element_status32 {
	int ces_type;
	compat_uptr_t ces_data;
};

struct devprobe2 {
	struct net_device * (*probe)(int);
	int status;
};

enum {
	SKBTX_HW_TSTAMP = 1,
	SKBTX_SW_TSTAMP = 2,
	SKBTX_IN_PROGRESS = 4,
	SKBTX_DEV_ZEROCOPY = 8,
	SKBTX_WIFI_STATUS = 16,
	SKBTX_SHARED_FRAG = 32,
	SKBTX_SCHED_TSTAMP = 64,
};

struct mdio_board_info {
	const char *bus_id;
	char modalias[32];
	int mdio_addr;
	const void *platform_data;
};

struct mdio_board_entry {
	struct list_head list;
	struct mdio_board_info board_info;
};

struct ethtool_cmd {
	__u32 cmd;
	__u32 supported;
	__u32 advertising;
	__u16 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 transceiver;
	__u8 autoneg;
	__u8 mdio_support;
	__u32 maxtxpkt;
	__u32 maxrxpkt;
	__u16 speed_hi;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__u32 lp_advertising;
	__u32 reserved[2];
};

struct mii_ioctl_data {
	__u16 phy_id;
	__u16 reg_num;
	__u16 val_in;
	__u16 val_out;
};

struct phy_setting {
	u32 speed;
	u8 duplex;
	u8 bit;
};

struct phy_fixup {
	struct list_head list;
	char bus_id[64];
	u32 phy_uid;
	u32 phy_uid_mask;
	int (*run)(struct phy_device *);
};

struct trace_event_raw_mdio_access {
	struct trace_entry ent;
	char busid[61];
	char read;
	u8 addr;
	u16 val;
	unsigned int regnum;
	char __data[0];
};

struct trace_event_data_offsets_mdio_access {};

typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);

struct mdio_driver {
	struct mdio_driver_common mdiodrv;
	int (*probe)(struct mdio_device *);
	void (*remove)(struct mdio_device *);
};

struct fixed_phy_status {
	int link;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
};

struct swmii_regs {
	u16 bmsr;
	u16 lpa;
	u16 lpagb;
	u16 estat;
};

enum {
	SWMII_SPEED_10 = 0,
	SWMII_SPEED_100 = 1,
	SWMII_SPEED_1000 = 2,
	SWMII_DUPLEX_HALF = 0,
	SWMII_DUPLEX_FULL = 1,
};

struct fixed_mdio_bus {
	struct mii_bus *mii_bus;
	struct list_head phys;
};

struct fixed_phy {
	int addr;
	struct phy_device *phydev;
	seqcount_t seqcount;
	struct fixed_phy_status status;
	bool no_carrier;
	int (*link_update)(struct net_device *, struct fixed_phy_status *);
	struct list_head node;
	struct gpio_desc *link_gpiod;
};

typedef unsigned char U8;

typedef short unsigned int U16___2;

typedef u_int32_t U32___2;

struct _U64 {
	U32___2 Low;
	U32___2 High;
};

typedef struct _U64 U64___2;

struct _SGE_SIMPLE32 {
	U32___2 FlagsLength;
	U32___2 Address;
};

typedef struct _SGE_SIMPLE32 SGESimple32_t;

struct _SGE_SIMPLE64 {
	U32___2 FlagsLength;
	U64___2 Address;
};

typedef struct _SGE_SIMPLE64 SGESimple64_t;

struct _SGE_SIMPLE_UNION {
	U32___2 FlagsLength;
	union {
		U32___2 Address32;
		U64___2 Address64;
	} u;
};

typedef struct _SGE_SIMPLE_UNION SGE_SIMPLE_UNION;

struct _SGE_CHAIN32 {
	U16___2 Length;
	U8 NextChainOffset;
	U8 Flags;
	U32___2 Address;
};

typedef struct _SGE_CHAIN32 SGEChain32_t;

struct _SGE_CHAIN64 {
	U16___2 Length;
	U8 NextChainOffset;
	U8 Flags;
	U64___2 Address;
};

typedef struct _SGE_CHAIN64 SGEChain64_t;

struct _SGE_CHAIN_UNION {
	U16___2 Length;
	U8 NextChainOffset;
	U8 Flags;
	union {
		U32___2 Address32;
		U64___2 Address64;
	} u;
};

typedef struct _SGE_CHAIN_UNION SGE_CHAIN_UNION;

struct _SGE_TRANSACTION_UNION {
	U8 Reserved;
	U8 ContextSize;
	U8 DetailsLength;
	U8 Flags;
	union {
		U32___2 TransactionContext32[1];
		U32___2 TransactionContext64[2];
		U32___2 TransactionContext96[3];
		U32___2 TransactionContext128[4];
	} u;
	U32___2 TransactionDetails[1];
};

typedef struct _SGE_TRANSACTION_UNION SGE_TRANSACTION_UNION;

struct _SGE_IO_UNION {
	union {
		SGE_SIMPLE_UNION Simple;
		SGE_CHAIN_UNION Chain;
	} u;
};

typedef struct _SGE_IO_UNION SGE_IO_UNION;

struct _SGE_MPI_UNION {
	union {
		SGE_SIMPLE_UNION Simple;
		SGE_CHAIN_UNION Chain;
		SGE_TRANSACTION_UNION Transaction;
	} u;
};

typedef struct _SGE_MPI_UNION SGE_MPI_UNION;

struct _MSG_REQUEST_HEADER {
	U8 Reserved[2];
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
};

typedef struct _MSG_REQUEST_HEADER MPIHeader_t;

struct _MSG_DEFAULT_REPLY {
	U8 Reserved[2];
	U8 MsgLength;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2[2];
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
};

typedef struct _MSG_DEFAULT_REPLY MPIDefaultReply_t;

struct _MSG_IOC_INIT {
	U8 WhoInit;
	U8 Reserved;
	U8 ChainOffset;
	U8 Function;
	U8 Flags;
	U8 MaxDevices;
	U8 MaxBuses;
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 ReplyFrameSize;
	U8 Reserved1[2];
	U32___2 HostMfaHighAddr;
	U32___2 SenseBufferHighAddr;
	U32___2 ReplyFifoHostSignalingAddr;
	SGE_SIMPLE_UNION HostPageBufferSGE;
	U16___2 MsgVersion;
	U16___2 HeaderVersion;
};

typedef struct _MSG_IOC_INIT IOCInit_t;

typedef struct _MSG_IOC_INIT *pIOCInit_t;

struct _MSG_IOC_FACTS {
	U8 Reserved[2];
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
};

typedef struct _MSG_IOC_FACTS IOCFacts_t;

struct _MPI_FW_VERSION_STRUCT {
	U8 Dev;
	U8 Unit;
	U8 Minor;
	U8 Major;
};

typedef struct _MPI_FW_VERSION_STRUCT MPI_FW_VERSION_STRUCT;

union _MPI_FW_VERSION {
	MPI_FW_VERSION_STRUCT Struct;
	U32___2 Word;
};

typedef union _MPI_FW_VERSION MPI_FW_VERSION;

struct _MSG_IOC_FACTS_REPLY {
	U16___2 MsgVersion;
	U8 MsgLength;
	U8 Function;
	U16___2 HeaderVersion;
	U8 IOCNumber;
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 IOCExceptions;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U8 MaxChainDepth;
	U8 WhoInit;
	U8 BlockSize;
	U8 Flags;
	U16___2 ReplyQueueDepth;
	U16___2 RequestFrameSize;
	U16___2 Reserved_0101_FWVersion;
	U16___2 ProductID;
	U32___2 CurrentHostMfaHighAddr;
	U16___2 GlobalCredits;
	U8 NumberOfPorts;
	U8 EventState;
	U32___2 CurrentSenseBufferHighAddr;
	U16___2 CurReplyFrameSize;
	U8 MaxDevices;
	U8 MaxBuses;
	U32___2 FWImageSize;
	U32___2 IOCCapabilities;
	MPI_FW_VERSION FWVersion;
	U16___2 HighPriorityQueueDepth;
	U16___2 Reserved2;
	SGE_SIMPLE_UNION HostPageBufferSGE;
	U32___2 ReplyFifoHostSignalingAddr;
};

typedef struct _MSG_IOC_FACTS_REPLY IOCFactsReply_t;

struct _MSG_PORT_FACTS {
	U8 Reserved[2];
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[2];
	U8 PortNumber;
	U8 MsgFlags;
	U32___2 MsgContext;
};

typedef struct _MSG_PORT_FACTS PortFacts_t;

struct _MSG_PORT_FACTS_REPLY {
	U16___2 Reserved;
	U8 MsgLength;
	U8 Function;
	U16___2 Reserved1;
	U8 PortNumber;
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 Reserved2;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U8 Reserved3;
	U8 PortType;
	U16___2 MaxDevices;
	U16___2 PortSCSIID;
	U16___2 ProtocolFlags;
	U16___2 MaxPostedCmdBuffers;
	U16___2 MaxPersistentIDs;
	U16___2 MaxLanBuckets;
	U8 MaxInitiators;
	U8 Reserved4;
	U32___2 Reserved5;
};

typedef struct _MSG_PORT_FACTS_REPLY PortFactsReply_t;

struct _MSG_PORT_ENABLE {
	U8 Reserved[2];
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[2];
	U8 PortNumber;
	U8 MsgFlags;
	U32___2 MsgContext;
};

typedef struct _MSG_PORT_ENABLE PortEnable_t;

struct _MSG_EVENT_NOTIFY {
	U8 Switch;
	U8 Reserved;
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
};

typedef struct _MSG_EVENT_NOTIFY EventNotification_t;

struct _MSG_EVENT_NOTIFY_REPLY {
	U16___2 EventDataLength;
	U8 MsgLength;
	U8 Function;
	U8 Reserved1[2];
	U8 AckRequired;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2[2];
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 Event;
	U32___2 EventContext;
	U32___2 Data[1];
};

typedef struct _MSG_EVENT_NOTIFY_REPLY EventNotificationReply_t;

struct _MSG_EVENT_ACK {
	U8 Reserved[2];
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
	U32___2 Event;
	U32___2 EventContext;
};

typedef struct _MSG_EVENT_ACK EventAck_t;

struct _EVENT_DATA_RAID {
	U8 VolumeID;
	U8 VolumeBus;
	U8 ReasonCode;
	U8 PhysDiskNum;
	U8 ASC;
	U8 ASCQ;
	U16___2 Reserved;
	U32___2 SettingsStatus;
};

typedef struct _EVENT_DATA_RAID MpiEventDataRaid_t;

struct _MSG_FW_UPLOAD {
	U8 ImageType;
	U8 Reserved;
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
	SGE_MPI_UNION SGL;
};

typedef struct _MSG_FW_UPLOAD FWUpload_t;

struct _FWUploadTCSGE {
	U8 Reserved;
	U8 ContextSize;
	U8 DetailsLength;
	U8 Flags;
	U32___2 Reserved1;
	U32___2 ImageOffset;
	U32___2 ImageSize;
};

typedef struct _FWUploadTCSGE FWUploadTCSGE_t;

struct _MSG_FW_UPLOAD_REPLY {
	U8 ImageType;
	U8 Reserved;
	U8 MsgLength;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 Reserved2;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 ActualImageSize;
};

typedef struct _MSG_FW_UPLOAD_REPLY FWUploadReply_t;

struct _MPI_FW_HEADER {
	U32___2 ArmBranchInstruction0;
	U32___2 Signature0;
	U32___2 Signature1;
	U32___2 Signature2;
	U32___2 ArmBranchInstruction1;
	U32___2 ArmBranchInstruction2;
	U32___2 Reserved;
	U32___2 Checksum;
	U16___2 VendorId;
	U16___2 ProductId;
	MPI_FW_VERSION FWVersion;
	U32___2 SeqCodeVersion;
	U32___2 ImageSize;
	U32___2 NextImageHeaderOffset;
	U32___2 LoadStartAddress;
	U32___2 IopResetVectorValue;
	U32___2 IopResetRegAddr;
	U32___2 VersionNameWhat;
	U8 VersionName[32];
	U32___2 VendorNameWhat;
	U8 VendorName[32];
};

typedef struct _MPI_FW_HEADER MpiFwHeader_t;

struct _MPI_EXT_IMAGE_HEADER {
	U8 ImageType;
	U8 Reserved;
	U16___2 Reserved1;
	U32___2 Checksum;
	U32___2 ImageSize;
	U32___2 NextImageHeaderOffset;
	U32___2 LoadStartAddress;
	U32___2 Reserved2;
};

typedef struct _MPI_EXT_IMAGE_HEADER MpiExtImageHeader_t;

struct _CONFIG_PAGE_HEADER {
	U8 PageVersion;
	U8 PageLength;
	U8 PageNumber;
	U8 PageType;
};

typedef struct _CONFIG_PAGE_HEADER CONFIG_PAGE_HEADER;

typedef struct _CONFIG_PAGE_HEADER ConfigPageHeader_t;

struct _CONFIG_EXTENDED_PAGE_HEADER {
	U8 PageVersion;
	U8 Reserved1;
	U8 PageNumber;
	U8 PageType;
	U16___2 ExtPageLength;
	U8 ExtPageType;
	U8 Reserved2;
};

typedef struct _CONFIG_EXTENDED_PAGE_HEADER CONFIG_EXTENDED_PAGE_HEADER;

typedef struct _CONFIG_EXTENDED_PAGE_HEADER ConfigExtendedPageHeader_t;

struct _MSG_CONFIG {
	U8 Action;
	U8 Reserved;
	U8 ChainOffset;
	U8 Function;
	U16___2 ExtPageLength;
	U8 ExtPageType;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2[8];
	CONFIG_PAGE_HEADER Header;
	U32___2 PageAddress;
	SGE_IO_UNION PageBufferSGE;
};

typedef struct _MSG_CONFIG Config_t;

struct _MSG_CONFIG_REPLY {
	U8 Action;
	U8 Reserved;
	U8 MsgLength;
	U8 Function;
	U16___2 ExtPageLength;
	U8 ExtPageType;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2[2];
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	CONFIG_PAGE_HEADER Header;
};

typedef struct _MSG_CONFIG_REPLY ConfigReply_t;

struct _CONFIG_PAGE_MANUFACTURING_0 {
	CONFIG_PAGE_HEADER Header;
	U8 ChipName[16];
	U8 ChipRevision[8];
	U8 BoardName[16];
	U8 BoardAssembly[16];
	U8 BoardTracerNumber[16];
};

typedef struct _CONFIG_PAGE_MANUFACTURING_0 ManufacturingPage0_t;

struct _MPI_ADAPTER_INFO {
	U8 PciBusNumber;
	U8 PciDeviceAndFunctionNumber;
	U16___2 AdapterFlags;
};

typedef struct _MPI_ADAPTER_INFO MPI_ADAPTER_INFO;

struct _CONFIG_PAGE_IO_UNIT_2 {
	CONFIG_PAGE_HEADER Header;
	U32___2 Flags;
	U32___2 BiosVersion;
	MPI_ADAPTER_INFO AdapterOrder[4];
	U32___2 Reserved1;
};

typedef struct _CONFIG_PAGE_IO_UNIT_2 IOUnitPage2_t;

struct _CONFIG_PAGE_IOC_1 {
	CONFIG_PAGE_HEADER Header;
	U32___2 Flags;
	U32___2 CoalescingTimeout;
	U8 CoalescingDepth;
	U8 PCISlotNum;
	U8 Reserved[2];
};

typedef struct _CONFIG_PAGE_IOC_1 IOCPage1_t;

struct _CONFIG_PAGE_IOC_2_RAID_VOL {
	U8 VolumeID;
	U8 VolumeBus;
	U8 VolumeIOC;
	U8 VolumePageNumber;
	U8 VolumeType;
	U8 Flags;
	U16___2 Reserved3;
};

typedef struct _CONFIG_PAGE_IOC_2_RAID_VOL CONFIG_PAGE_IOC_2_RAID_VOL;

struct _CONFIG_PAGE_IOC_2 {
	CONFIG_PAGE_HEADER Header;
	U32___2 CapabilitiesFlags;
	U8 NumActiveVolumes;
	U8 MaxVolumes;
	U8 NumActivePhysDisks;
	U8 MaxPhysDisks;
	CONFIG_PAGE_IOC_2_RAID_VOL RaidVolume[1];
};

typedef struct _CONFIG_PAGE_IOC_2 IOCPage2_t;

struct _IOC_3_PHYS_DISK {
	U8 PhysDiskID;
	U8 PhysDiskBus;
	U8 PhysDiskIOC;
	U8 PhysDiskNum;
};

typedef struct _IOC_3_PHYS_DISK IOC_3_PHYS_DISK;

struct _CONFIG_PAGE_IOC_3 {
	CONFIG_PAGE_HEADER Header;
	U8 NumPhysDisks;
	U8 Reserved1;
	U16___2 Reserved2;
	IOC_3_PHYS_DISK PhysDisk[1];
};

typedef struct _CONFIG_PAGE_IOC_3 IOCPage3_t;

struct _IOC_4_SEP {
	U8 SEPTargetID;
	U8 SEPBus;
	U16___2 Reserved;
};

typedef struct _IOC_4_SEP IOC_4_SEP;

struct _CONFIG_PAGE_IOC_4 {
	CONFIG_PAGE_HEADER Header;
	U8 ActiveSEP;
	U8 MaxSEP;
	U16___2 Reserved1;
	IOC_4_SEP SEP[1];
};

typedef struct _CONFIG_PAGE_IOC_4 IOCPage4_t;

struct _CONFIG_PAGE_SCSI_PORT_0 {
	CONFIG_PAGE_HEADER Header;
	U32___2 Capabilities;
	U32___2 PhysicalInterface;
};

typedef struct _CONFIG_PAGE_SCSI_PORT_0 SCSIPortPage0_t;

struct _MPI_DEVICE_INFO {
	U8 Timeout;
	U8 SyncFactor;
	U16___2 DeviceFlags;
};

typedef struct _MPI_DEVICE_INFO MPI_DEVICE_INFO;

typedef struct _MPI_DEVICE_INFO MpiDeviceInfo_t;

struct _CONFIG_PAGE_SCSI_PORT_2 {
	CONFIG_PAGE_HEADER Header;
	U32___2 PortFlags;
	U32___2 PortSettings;
	MPI_DEVICE_INFO DeviceSettings[16];
};

typedef struct _CONFIG_PAGE_SCSI_PORT_2 SCSIPortPage2_t;

struct _CONFIG_PAGE_FC_PORT_0 {
	CONFIG_PAGE_HEADER Header;
	U32___2 Flags;
	U8 MPIPortNumber;
	U8 LinkType;
	U8 PortState;
	U8 Reserved;
	U32___2 PortIdentifier;
	U64___2 WWNN;
	U64___2 WWPN;
	U32___2 SupportedServiceClass;
	U32___2 SupportedSpeeds;
	U32___2 CurrentSpeed;
	U32___2 MaxFrameSize;
	U64___2 FabricWWNN;
	U64___2 FabricWWPN;
	U32___2 DiscoveredPortsCount;
	U32___2 MaxInitiators;
	U8 MaxAliasesSupported;
	U8 MaxHardAliasesSupported;
	U8 NumCurrentAliases;
	U8 Reserved1;
};

typedef struct _CONFIG_PAGE_FC_PORT_0 FCPortPage0_t;

struct _CONFIG_PAGE_FC_PORT_1 {
	CONFIG_PAGE_HEADER Header;
	U32___2 Flags;
	U64___2 NoSEEPROMWWNN;
	U64___2 NoSEEPROMWWPN;
	U8 HardALPA;
	U8 LinkConfig;
	U8 TopologyConfig;
	U8 AltConnector;
	U8 NumRequestedAliases;
	U8 RR_TOV;
	U8 InitiatorDeviceTimeout;
	U8 InitiatorIoPendTimeout;
};

typedef struct _CONFIG_PAGE_FC_PORT_1 FCPortPage1_t;

struct _RAID_VOL0_PHYS_DISK {
	U16___2 Reserved;
	U8 PhysDiskMap;
	U8 PhysDiskNum;
};

typedef struct _RAID_VOL0_PHYS_DISK RAID_VOL0_PHYS_DISK;

struct _RAID_VOL0_STATUS {
	U8 Flags;
	U8 State;
	U16___2 Reserved;
};

typedef struct _RAID_VOL0_STATUS RAID_VOL0_STATUS;

struct _RAID_VOL0_SETTINGS {
	U16___2 Settings;
	U8 HotSparePool;
	U8 Reserved;
};

typedef struct _RAID_VOL0_SETTINGS RAID_VOL0_SETTINGS;

struct _CONFIG_PAGE_RAID_VOL_0 {
	CONFIG_PAGE_HEADER Header;
	U8 VolumeID;
	U8 VolumeBus;
	U8 VolumeIOC;
	U8 VolumeType;
	RAID_VOL0_STATUS VolumeStatus;
	RAID_VOL0_SETTINGS VolumeSettings;
	U32___2 MaxLBA;
	U32___2 MaxLBAHigh;
	U32___2 StripeSize;
	U32___2 Reserved2;
	U32___2 Reserved3;
	U8 NumPhysDisks;
	U8 DataScrubRate;
	U8 ResyncRate;
	U8 InactiveStatus;
	RAID_VOL0_PHYS_DISK PhysDisk[1];
};

typedef struct _CONFIG_PAGE_RAID_VOL_0 *pRaidVolumePage0_t;

struct _RAID_PHYS_DISK0_ERROR_DATA {
	U8 ErrorCdbByte;
	U8 ErrorSenseKey;
	U16___2 Reserved;
	U16___2 ErrorCount;
	U8 ErrorASC;
	U8 ErrorASCQ;
	U16___2 SmartCount;
	U8 SmartASC;
	U8 SmartASCQ;
};

typedef struct _RAID_PHYS_DISK0_ERROR_DATA RAID_PHYS_DISK0_ERROR_DATA;

struct _RAID_PHYS_DISK_INQUIRY_DATA {
	U8 VendorID[8];
	U8 ProductID[16];
	U8 ProductRevLevel[4];
	U8 Info[32];
};

typedef struct _RAID_PHYS_DISK_INQUIRY_DATA RAID_PHYS_DISK0_INQUIRY_DATA;

struct _RAID_PHYS_DISK0_SETTINGS {
	U8 SepID;
	U8 SepBus;
	U8 HotSparePool;
	U8 PhysDiskSettings;
};

typedef struct _RAID_PHYS_DISK0_SETTINGS RAID_PHYS_DISK0_SETTINGS;

struct _RAID_PHYS_DISK0_STATUS {
	U8 Flags;
	U8 State;
	U16___2 Reserved;
};

typedef struct _RAID_PHYS_DISK0_STATUS RAID_PHYS_DISK0_STATUS;

struct _CONFIG_PAGE_RAID_PHYS_DISK_0 {
	CONFIG_PAGE_HEADER Header;
	U8 PhysDiskID;
	U8 PhysDiskBus;
	U8 PhysDiskIOC;
	U8 PhysDiskNum;
	RAID_PHYS_DISK0_SETTINGS PhysDiskSettings;
	U32___2 Reserved1;
	U8 ExtDiskIdentifier[8];
	U8 DiskIdentifier[16];
	RAID_PHYS_DISK0_INQUIRY_DATA InquiryData;
	RAID_PHYS_DISK0_STATUS PhysDiskStatus;
	U32___2 MaxLBA;
	RAID_PHYS_DISK0_ERROR_DATA ErrorData;
};

typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_0 RaidPhysDiskPage0_t;

typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_0 *pRaidPhysDiskPage0_t;

struct _RAID_PHYS_DISK1_PATH {
	U8 PhysDiskID;
	U8 PhysDiskBus;
	U16___2 Reserved1;
	U64___2 WWID;
	U64___2 OwnerWWID;
	U8 OwnerIdentifier;
	U8 Reserved2;
	U16___2 Flags;
};

typedef struct _RAID_PHYS_DISK1_PATH RAID_PHYS_DISK1_PATH;

struct _CONFIG_PAGE_RAID_PHYS_DISK_1 {
	CONFIG_PAGE_HEADER Header;
	U8 NumPhysDiskPaths;
	U8 PhysDiskNum;
	U16___2 Reserved2;
	U32___2 Reserved1;
	RAID_PHYS_DISK1_PATH Path[1];
};

typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_1 RaidPhysDiskPage1_t;

typedef struct _CONFIG_PAGE_RAID_PHYS_DISK_1 *pRaidPhysDiskPage1_t;

struct _CONFIG_PAGE_LAN_0 {
	ConfigPageHeader_t Header;
	U16___2 TxRxModes;
	U16___2 Reserved;
	U32___2 PacketPrePad;
};

typedef struct _CONFIG_PAGE_LAN_0 LANPage0_t;

struct _CONFIG_PAGE_LAN_1 {
	ConfigPageHeader_t Header;
	U16___2 Reserved;
	U8 CurrentDeviceState;
	U8 Reserved1;
	U32___2 MinPacketSize;
	U32___2 MaxPacketSize;
	U32___2 HardwareAddressLow;
	U32___2 HardwareAddressHigh;
	U32___2 MaxWireSpeedLow;
	U32___2 MaxWireSpeedHigh;
	U32___2 BucketsRemaining;
	U32___2 MaxReplySize;
	U32___2 NegWireSpeedLow;
	U32___2 NegWireSpeedHigh;
};

typedef struct _CONFIG_PAGE_LAN_1 LANPage1_t;

struct _MPI_SAS_IO_UNIT0_PHY_DATA {
	U8 Port;
	U8 PortFlags;
	U8 PhyFlags;
	U8 NegotiatedLinkRate;
	U32___2 ControllerPhyDeviceInfo;
	U16___2 AttachedDeviceHandle;
	U16___2 ControllerDevHandle;
	U32___2 DiscoveryStatus;
};

typedef struct _MPI_SAS_IO_UNIT0_PHY_DATA MPI_SAS_IO_UNIT0_PHY_DATA;

struct _CONFIG_PAGE_SAS_IO_UNIT_0 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U16___2 NvdataVersionDefault;
	U16___2 NvdataVersionPersistent;
	U8 NumPhys;
	U8 Reserved2;
	U16___2 Reserved3;
	MPI_SAS_IO_UNIT0_PHY_DATA PhyData[1];
};

typedef struct _CONFIG_PAGE_SAS_IO_UNIT_0 SasIOUnitPage0_t;

struct _MSG_SCSI_IO_REQUEST {
	U8 TargetID;
	U8 Bus;
	U8 ChainOffset;
	U8 Function;
	U8 CDBLength;
	U8 SenseBufferLength;
	U8 Reserved;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 LUN[8];
	U32___2 Control;
	U8 CDB[16];
	U32___2 DataLength;
	U32___2 SenseBufferLowAddr;
	SGE_IO_UNION SGL;
};

typedef struct _MSG_SCSI_IO_REQUEST SCSIIORequest_t;

struct _MSG_SCSI_IO_REPLY {
	U8 TargetID;
	U8 Bus;
	U8 MsgLength;
	U8 Function;
	U8 CDBLength;
	U8 SenseBufferLength;
	U8 Reserved;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 SCSIStatus;
	U8 SCSIState;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 TransferCount;
	U32___2 SenseCount;
	U32___2 ResponseInfo;
	U16___2 TaskTag;
	U16___2 Reserved1;
};

typedef struct _MSG_SCSI_IO_REPLY SCSIIOReply_t;

struct _MSG_SAS_IOUNIT_CONTROL_REQUEST {
	U8 Operation;
	U8 Reserved1;
	U8 ChainOffset;
	U8 Function;
	U16___2 DevHandle;
	U8 IOCParameter;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 TargetID;
	U8 Bus;
	U8 PhyNum;
	U8 PrimFlags;
	U32___2 Primitive;
	U64___2 SASAddress;
	U32___2 IOCParameterValue;
};

typedef struct _MSG_SAS_IOUNIT_CONTROL_REQUEST SasIoUnitControlRequest_t;

struct _MSG_SAS_IOUNIT_CONTROL_REPLY {
	U8 Operation;
	U8 Reserved1;
	U8 MsgLength;
	U8 Function;
	U16___2 DevHandle;
	U8 IOCParameter;
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 Reserved4;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
};

typedef struct _MSG_SAS_IOUNIT_CONTROL_REPLY SasIoUnitControlReply_t;

struct _ATTO_DEVICE_INFO {
	u8 Offset;
	u8 Period;
	u16 ATTOFlags;
};

typedef struct _ATTO_DEVICE_INFO ATTO_DEVICE_INFO;

typedef struct _ATTO_DEVICE_INFO ATTODeviceInfo_t;

struct _ATTO_CONFIG_PAGE_SCSI_PORT_2 {
	CONFIG_PAGE_HEADER Header;
	u16 PortFlags;
	u16 Unused1;
	u32 Unused2;
	ATTO_DEVICE_INFO DeviceSettings[16];
};

typedef struct _ATTO_CONFIG_PAGE_SCSI_PORT_2 ATTO_SCSIPortPage2_t;

typedef enum {
	MPTBASE_DRIVER = 0,
	MPTCTL_DRIVER = 1,
	MPTSPI_DRIVER = 2,
	MPTFC_DRIVER = 3,
	MPTSAS_DRIVER = 4,
	MPTLAN_DRIVER = 5,
	MPTSTM_DRIVER = 6,
	MPTUNKNOWN_DRIVER = 7,
} MPT_DRIVER_CLASS;

struct mpt_pci_driver {
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
};

union _MPT_FRAME_TRACKER {
	struct {
		struct list_head list;
		u32 arg1;
		u32 pad;
		void *argp1;
	} linkage;
	struct {
		u32 __hdr[2];
		union {
			u32 MsgContext;
			struct {
				u16 req_idx;
				u8 cb_idx;
				u8 rsvd;
			} fld;
		} msgctxu;
	} hwhdr;
};

typedef union _MPT_FRAME_TRACKER MPT_FRAME_TRACKER;

struct _MPT_FRAME_HDR {
	union {
		MPIHeader_t hdr;
		SCSIIORequest_t scsireq;
		SCSIIOReply_t sreply;
		ConfigReply_t configreply;
		MPIDefaultReply_t reply;
		MPT_FRAME_TRACKER frame;
	} u;
};

typedef struct _MPT_FRAME_HDR MPT_FRAME_HDR;

struct _SYSIF_REGS {
	u32 Doorbell;
	u32 WriteSequence;
	u32 Diagnostic;
	u32 TestBase;
	u32 DiagRwData;
	u32 DiagRwAddress;
	u32 Reserved1[6];
	u32 IntStatus;
	u32 IntMask;
	u32 Reserved2[2];
	u32 RequestFifo;
	u32 ReplyFifo;
	u32 RequestHiPriFifo;
	u32 Reserved3;
	u32 HostIndex;
	u32 Reserved4[15];
	u32 Fubar;
	u32 Reserved5[1050];
	u32 Reset_1078;
};

typedef struct _SYSIF_REGS SYSIF_REGS;

struct _MPT_MGMT {
	struct mutex mutex;
	struct completion done;
	u8 reply[128];
	u8 sense[64];
	u8 status;
	int completion_code;
	u32 msg_context;
};

typedef struct _MPT_MGMT MPT_MGMT;

struct _mpt_ioctl_events {
	u32 event;
	u32 eventContext;
	u32 data[2];
};

struct _SpiCfgData {
	u32 PortFlags;
	int *nvram;
	IOCPage4_t *pIocPg4;
	dma_addr_t IocPg4_dma;
	int IocPg4Sz;
	u8 minSyncFactor;
	u8 maxSyncOffset;
	u8 maxBusWidth;
	u8 busType;
	u8 sdp1version;
	u8 sdp1length;
	u8 sdp0version;
	u8 sdp0length;
	u8 dvScheduled;
	u8 noQas;
	u8 Saf_Te;
	u8 bus_reset;
	u8 rsvd[1];
};

typedef struct _SpiCfgData SpiCfgData;

struct _SasCfgData {
	u8 ptClear;
};

typedef struct _SasCfgData SasCfgData;

struct inactive_raid_component_info {
	struct list_head list;
	u8 volumeID;
	u8 volumeBus;
	IOC_3_PHYS_DISK d;
};

struct _RaidCfgData {
	IOCPage2_t *pIocPg2;
	IOCPage3_t *pIocPg3;
	struct mutex inactive_list_mutex;
	struct list_head inactive_list;
};

typedef struct _RaidCfgData RaidCfgData;

struct _FcCfgData {
	struct {
		FCPortPage1_t *data;
		dma_addr_t dma;
		int pg_sz;
	} fc_port_page1[2];
};

typedef struct _FcCfgData FcCfgData;

enum {
	FC = 0,
	SPI = 1,
	SAS___2 = 2,
};

struct _MPT_ADAPTER;

struct _MPT_SCSI_HOST {
	struct _MPT_ADAPTER *ioc;
	ushort sel_timeout[255];
	char *info_kbuf;
	long int last_queue_full;
	u16 spi_pending;
	struct list_head target_reset_list;
};

typedef void (*MPT_ADD_SGE)(void *, u32, dma_addr_t);

typedef void (*MPT_ADD_CHAIN)(void *, u8, u16, dma_addr_t);

typedef void (*MPT_SCHEDULE_TARGET_RESET)(void *);

typedef struct _MPT_SCSI_HOST MPT_SCSI_HOST;

typedef void (*MPT_FLUSH_RUNNING_CMDS)(MPT_SCSI_HOST *);

struct mptsas_portinfo;

struct _MPT_ADAPTER {
	int id;
	int pci_irq;
	char name[32];
	const char *prod_name;
	char evStr[100];
	char board_name[16];
	char board_assembly[16];
	char board_tracer[16];
	u16 nvdata_version_persistent;
	u16 nvdata_version_default;
	int debug_level;
	u8 io_missing_delay;
	u16 device_missing_delay;
	SYSIF_REGS *chip;
	SYSIF_REGS *pio_chip;
	u8 bus_type;
	u32 mem_phys;
	u32 pio_mem_phys;
	int mem_size;
	int number_of_buses;
	int devices_per_bus;
	int alloc_total;
	u32 last_state;
	int active;
	u8 *alloc;
	dma_addr_t alloc_dma;
	u32 alloc_sz;
	MPT_FRAME_HDR *reply_frames;
	u32 reply_frames_low_dma;
	int reply_depth;
	int reply_sz;
	int num_chain;
	MPT_ADD_SGE add_sge;
	MPT_ADD_CHAIN add_chain;
	int *ReqToChain;
	int *RequestNB;
	int *ChainToChain;
	u8 *ChainBuffer;
	dma_addr_t ChainBufferDMA;
	struct list_head FreeChainQ;
	spinlock_t FreeChainQlock;
	dma_addr_t req_frames_dma;
	MPT_FRAME_HDR *req_frames;
	u32 req_frames_low_dma;
	int req_depth;
	int req_sz;
	spinlock_t FreeQlock;
	struct list_head FreeQ;
	u8 *sense_buf_pool;
	dma_addr_t sense_buf_pool_dma;
	u32 sense_buf_low_dma;
	u8 *HostPageBuffer;
	u32 HostPageBuffer_sz;
	dma_addr_t HostPageBuffer_dma;
	struct pci_dev *pcidev;
	int bars;
	int msi_enable;
	u8 *memmap;
	struct Scsi_Host *sh;
	SpiCfgData spi_data;
	RaidCfgData raid_data;
	SasCfgData sas_data;
	FcCfgData fc_data;
	struct proc_dir_entry *ioc_dentry;
	struct _MPT_ADAPTER *alt_ioc;
	u32 biosVersion;
	int eventTypes;
	int eventContext;
	int eventLogSize;
	struct _mpt_ioctl_events *events;
	u8 *cached_fw;
	dma_addr_t cached_fw_dma;
	int hs_reply_idx;
	u32 pad0;
	u32 NB_for_64_byte_frame;
	u32 hs_req[32];
	u16 hs_reply[64];
	IOCFactsReply_t facts;
	PortFactsReply_t pfacts[2];
	FCPortPage0_t fc_port_page0[2];
	LANPage0_t lan_cnfg_page0;
	LANPage1_t lan_cnfg_page1;
	u8 ir_firmware;
	int errata_flag_1064;
	int aen_event_read_flag;
	u8 FirstWhoInit;
	u8 upload_fw;
	u8 NBShiftFactor;
	u8 pad1[4];
	u8 DoneCtx;
	u8 TaskCtx;
	u8 InternalCtx;
	struct list_head list;
	struct net_device *netdev;
	struct list_head sas_topology;
	struct mutex sas_topology_mutex;
	struct workqueue_struct *fw_event_q;
	struct list_head fw_event_list;
	spinlock_t fw_event_lock;
	u8 fw_events_off;
	char fw_event_q_name[20];
	struct mutex sas_discovery_mutex;
	u8 sas_discovery_runtime;
	u8 sas_discovery_ignore_events;
	struct mptsas_portinfo *hba_port_info;
	u64 hba_port_sas_addr;
	u16 hba_port_num_phy;
	struct list_head sas_device_info_list;
	struct mutex sas_device_info_mutex;
	u8 old_sas_discovery_protocal;
	u8 sas_discovery_quiesce_io;
	int sas_index;
	MPT_MGMT sas_mgmt;
	MPT_MGMT mptbase_cmds;
	MPT_MGMT internal_cmds;
	MPT_MGMT taskmgmt_cmds;
	MPT_MGMT ioctl_cmds;
	spinlock_t taskmgmt_lock;
	int taskmgmt_in_progress;
	u8 taskmgmt_quiesce_io;
	u8 ioc_reset_in_progress;
	u8 reset_status;
	u8 wait_on_reset_completion;
	MPT_SCHEDULE_TARGET_RESET schedule_target_reset;
	MPT_FLUSH_RUNNING_CMDS schedule_dead_ioc_flush_running_cmds;
	struct work_struct sas_persist_task;
	struct work_struct fc_setup_reset_work;
	struct list_head fc_rports;
	struct work_struct fc_lsc_work;
	u8 fc_link_speed[2];
	spinlock_t fc_rescan_work_lock;
	struct work_struct fc_rescan_work;
	char fc_rescan_work_q_name[20];
	struct workqueue_struct *fc_rescan_work_q;
	long unsigned int hard_resets;
	long unsigned int soft_resets;
	long unsigned int timeouts;
	struct scsi_cmnd **ScsiLookup;
	spinlock_t scsi_lookup_lock;
	u64 dma_mask;
	u32 broadcast_aen_busy;
	char reset_work_q_name[20];
	struct workqueue_struct *reset_work_q;
	struct delayed_work fault_reset_work;
	u8 sg_addr_size;
	u8 in_rescan;
	u8 SGE_size;
};

typedef struct _MPT_ADAPTER MPT_ADAPTER;

typedef int (*MPT_CALLBACK)(MPT_ADAPTER *, MPT_FRAME_HDR *, MPT_FRAME_HDR *);

typedef int (*MPT_EVHANDLER)(MPT_ADAPTER *, EventNotificationReply_t *);

typedef int (*MPT_RESETHANDLER)(MPT_ADAPTER *, int);

struct _x_config_parms {
	union {
		ConfigExtendedPageHeader_t *ehdr;
		ConfigPageHeader_t *hdr;
	} cfghdr;
	dma_addr_t physAddr;
	u32 pageAddr;
	u16 status;
	u8 action;
	u8 dir;
	u8 timeout;
};

typedef struct _x_config_parms CONFIGPARMS;

enum _MpiIocLogInfoFc {
	MPI_IOCLOGINFO_FC_INIT_BASE = 536870912,
	MPI_IOCLOGINFO_FC_INIT_ERROR_OUT_OF_ORDER_FRAME = 536870913,
	MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_START_OF_FRAME = 536870914,
	MPI_IOCLOGINFO_FC_INIT_ERROR_BAD_END_OF_FRAME = 536870915,
	MPI_IOCLOGINFO_FC_INIT_ERROR_OVER_RUN = 536870916,
	MPI_IOCLOGINFO_FC_INIT_ERROR_RX_OTHER = 536870917,
	MPI_IOCLOGINFO_FC_INIT_ERROR_SUBPROC_DEAD = 536870918,
	MPI_IOCLOGINFO_FC_INIT_ERROR_RX_OVERRUN = 536870919,
	MPI_IOCLOGINFO_FC_INIT_ERROR_RX_BAD_STATUS = 536870920,
	MPI_IOCLOGINFO_FC_INIT_ERROR_RX_UNEXPECTED_FRAME = 536870921,
	MPI_IOCLOGINFO_FC_INIT_ERROR_LINK_FAILURE = 536870922,
	MPI_IOCLOGINFO_FC_INIT_ERROR_TX_TIMEOUT = 536870923,
	MPI_IOCLOGINFO_FC_TARGET_BASE = 553648128,
	MPI_IOCLOGINFO_FC_TARGET_NO_PDISC = 553648129,
	MPI_IOCLOGINFO_FC_TARGET_NO_LOGIN = 553648130,
	MPI_IOCLOGINFO_FC_TARGET_DOAR_KILLED_BY_LIP = 553648131,
	MPI_IOCLOGINFO_FC_TARGET_DIAR_KILLED_BY_LIP = 553648132,
	MPI_IOCLOGINFO_FC_TARGET_DIAR_MISSING_DATA = 553648133,
	MPI_IOCLOGINFO_FC_TARGET_DONR_KILLED_BY_LIP = 553648134,
	MPI_IOCLOGINFO_FC_TARGET_WRSP_KILLED_BY_LIP = 553648135,
	MPI_IOCLOGINFO_FC_TARGET_DINR_KILLED_BY_LIP = 553648136,
	MPI_IOCLOGINFO_FC_TARGET_DINR_MISSING_DATA = 553648137,
	MPI_IOCLOGINFO_FC_TARGET_MRSP_KILLED_BY_LIP = 553648138,
	MPI_IOCLOGINFO_FC_TARGET_NO_CLASS_3 = 553648139,
	MPI_IOCLOGINFO_FC_TARGET_LOGIN_NOT_VALID = 553648140,
	MPI_IOCLOGINFO_FC_TARGET_FROM_OUTBOUND = 553648142,
	MPI_IOCLOGINFO_FC_TARGET_WAITING_FOR_DATA_IN = 553648143,
	MPI_IOCLOGINFO_FC_LAN_BASE = 570425344,
	MPI_IOCLOGINFO_FC_LAN_TRANS_SGL_MISSING = 570425345,
	MPI_IOCLOGINFO_FC_LAN_TRANS_WRONG_PLACE = 570425346,
	MPI_IOCLOGINFO_FC_LAN_TRANS_RES_BITS_SET = 570425347,
	MPI_IOCLOGINFO_FC_LAN_WRONG_SGL_FLAG = 570425348,
	MPI_IOCLOGINFO_FC_MSG_BASE = 587202560,
	MPI_IOCLOGINFO_FC_LINK_BASE = 603979776,
	MPI_IOCLOGINFO_FC_LINK_LOOP_INIT_TIMEOUT = 603979777,
	MPI_IOCLOGINFO_FC_LINK_ALREADY_INITIALIZED = 603979778,
	MPI_IOCLOGINFO_FC_LINK_LINK_NOT_ESTABLISHED = 603979779,
	MPI_IOCLOGINFO_FC_LINK_CRC_ERROR = 603979780,
	MPI_IOCLOGINFO_FC_CTX_BASE = 620756992,
	MPI_IOCLOGINFO_FC_INVALID_FIELD_BYTE_OFFSET = 637534208,
	MPI_IOCLOGINFO_FC_INVALID_FIELD_MAX_OFFSET = 654311423,
	MPI_IOCLOGINFO_FC_STATE_CHANGE = 654311424,
};

union loginfo_type {
	u32 loginfo;
	struct {
		u32 subcode: 16;
		u32 code: 8;
		u32 originator: 4;
		u32 bus_type: 4;
	} dw;
};

struct _MSG_SCSI_TASK_MGMT {
	U8 TargetID;
	U8 Bus;
	U8 ChainOffset;
	U8 Function;
	U8 Reserved;
	U8 TaskType;
	U8 Reserved1;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 LUN[8];
	U32___2 Reserved2[7];
	U32___2 TaskMsgContext;
};

typedef struct _MSG_SCSI_TASK_MGMT SCSITaskMgmt_t;

struct _MSG_SCSI_TASK_MGMT_REPLY {
	U8 TargetID;
	U8 Bus;
	U8 MsgLength;
	U8 Function;
	U8 ResponseCode;
	U8 TaskType;
	U8 Reserved1;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2[2];
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 TerminationCount;
};

typedef struct _MSG_SCSI_TASK_MGMT_REPLY SCSITaskMgmtReply_t;

struct _MSG_SEP_REQUEST {
	U8 TargetID;
	U8 Bus;
	U8 ChainOffset;
	U8 Function;
	U8 Action;
	U8 Flags;
	U8 Reserved1;
	U8 MsgFlags;
	U32___2 MsgContext;
	U32___2 SlotStatus;
	U32___2 Reserved2;
	U32___2 Reserved3;
	U32___2 Reserved4;
	U16___2 Slot;
	U16___2 EnclosureHandle;
};

typedef struct _MSG_SEP_REQUEST SEPRequest_t;

struct _MSG_RAID_ACTION_REPLY {
	U8 Action;
	U8 Reserved;
	U8 MsgLength;
	U8 Function;
	U8 VolumeID;
	U8 VolumeBus;
	U8 PhysDiskNum;
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 ActionStatus;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 VolumeStatus;
	U32___2 ActionData;
};

typedef struct _MSG_RAID_ACTION_REPLY MpiRaidActionReply_t;

struct _VirtTarget {
	struct scsi_target *starget;
	u8 tflags;
	u8 ioc_id;
	u8 id;
	u8 channel;
	u8 minSyncFactor;
	u8 maxOffset;
	u8 maxWidth;
	u8 negoFlags;
	u8 raidVolume;
	u8 type;
	u8 deleted;
	u8 inDMD;
	u32 num_luns;
};

typedef struct _VirtTarget VirtTarget;

struct _VirtDevice {
	VirtTarget *vtarget;
	u8 configured_lun;
	u64 lun;
};

typedef struct _VirtDevice VirtDevice;

struct _internal_cmd {
	char *data;
	dma_addr_t data_dma;
	int size;
	u8 cmd;
	u8 channel;
	u8 id;
	u64 lun;
	u8 flags;
	u8 physDiskNum;
	u8 rsvd2;
	u8 rsvd;
};

typedef struct _internal_cmd INTERNAL_CMD;

struct _CONFIG_PAGE_SCSI_DEVICE_0 {
	CONFIG_PAGE_HEADER Header;
	U32___2 NegotiatedParameters;
	U32___2 Information;
};

struct _CONFIG_PAGE_SCSI_DEVICE_1 {
	CONFIG_PAGE_HEADER Header;
	U32___2 RequestedParameters;
	U32___2 Reserved;
	U32___2 Configuration;
};

struct _MSG_RAID_ACTION {
	U8 Action;
	U8 Reserved1;
	U8 ChainOffset;
	U8 Function;
	U8 VolumeID;
	U8 VolumeBus;
	U8 PhysDiskNum;
	U8 MsgFlags;
	U32___2 MsgContext;
	U32___2 Reserved2;
	U32___2 ActionDataWord;
	SGE_SIMPLE_UNION ActionDataSGE;
};

typedef struct _MSG_RAID_ACTION MpiRaidActionRequest_t;

struct work_queue_wrapper___2 {
	struct work_struct work;
	struct _MPT_SCSI_HOST *hd;
	int disk;
};

struct _CONFIG_PAGE_FC_DEVICE_0 {
	CONFIG_PAGE_HEADER Header;
	U64___2 WWNN;
	U64___2 WWPN;
	U32___2 PortIdentifier;
	U8 Protocol;
	U8 Flags;
	U16___2 BBCredit;
	U16___2 MaxRxFrameSize;
	U8 ADISCHardALPA;
	U8 PortNumber;
	U8 FcPhLowestVersion;
	U8 FcPhHighestVersion;
	U8 CurrentTargetID;
	U8 CurrentBus;
};

typedef struct _CONFIG_PAGE_FC_DEVICE_0 FCDevicePage0_t;

struct mptfc_rport_info {
	struct list_head list;
	struct fc_rport *rport;
	struct scsi_target *starget;
	FCDevicePage0_t pg0;
	u8 flags;
};

struct _EVENT_DATA_SAS_DEVICE_STATUS_CHANGE {
	U8 TargetID;
	U8 Bus;
	U8 ReasonCode;
	U8 Reserved;
	U8 ASC;
	U8 ASCQ;
	U16___2 DevHandle;
	U32___2 DeviceInfo;
	U16___2 ParentDevHandle;
	U8 PhyNum;
	U8 Reserved1;
	U64___2 SASAddress;
	U8 LUN[8];
	U16___2 TaskTag;
	U16___2 Reserved2;
};

typedef struct _EVENT_DATA_SAS_DEVICE_STATUS_CHANGE EVENT_DATA_SAS_DEVICE_STATUS_CHANGE;

typedef struct _EVENT_DATA_SAS_DEVICE_STATUS_CHANGE MpiEventDataSasDeviceStatusChange_t;

struct _EVENT_DATA_QUEUE_FULL {
	U8 TargetID;
	U8 Bus;
	U16___2 CurrentDepth;
};

typedef struct _EVENT_DATA_QUEUE_FULL EventDataQueueFull_t;

typedef struct _EVENT_DATA_RAID EVENT_DATA_RAID;

struct _IR2_STATE_CHANGED {
	U16___2 PreviousState;
	U16___2 NewState;
};

typedef struct _IR2_STATE_CHANGED IR2_STATE_CHANGED;

struct _IR2_PD_INFO {
	U16___2 DeviceHandle;
	U8 TruncEnclosureHandle;
	U8 TruncatedSlot;
};

typedef struct _IR2_PD_INFO IR2_PD_INFO;

union _MPI_IR2_RC_EVENT_DATA {
	IR2_STATE_CHANGED StateChanged;
	U32___2 Lba;
	IR2_PD_INFO PdInfo;
};

typedef union _MPI_IR2_RC_EVENT_DATA MPI_IR2_RC_EVENT_DATA;

struct _MPI_EVENT_DATA_IR2 {
	U8 TargetID;
	U8 Bus;
	U8 ReasonCode;
	U8 PhysDiskNum;
	MPI_IR2_RC_EVENT_DATA IR2EventData;
};

typedef struct _MPI_EVENT_DATA_IR2 MPI_EVENT_DATA_IR2;

struct _EVENT_DATA_SAS_BROADCAST_PRIMITIVE {
	U8 PhyNum;
	U8 Port;
	U8 PortWidth;
	U8 Primitive;
};

typedef struct _EVENT_DATA_SAS_BROADCAST_PRIMITIVE EVENT_DATA_SAS_BROADCAST_PRIMITIVE;

struct _EVENT_DATA_SAS_PHY_LINK_STATUS {
	U8 PhyNum;
	U8 LinkRates;
	U16___2 DevHandle;
	U64___2 SASAddress;
};

typedef struct _EVENT_DATA_SAS_PHY_LINK_STATUS MpiEventDataSasPhyLinkStatus_t;

struct _EVENT_DATA_SAS_DISCOVERY {
	U32___2 DiscoveryStatus;
	U32___2 Reserved1;
};

typedef struct _EVENT_DATA_SAS_DISCOVERY EventDataSasDiscovery_t;

struct _EVENT_DATA_SAS_EXPANDER_STATUS_CHANGE {
	U8 ReasonCode;
	U8 Reserved1;
	U16___2 Reserved2;
	U8 PhysicalPort;
	U8 Reserved3;
	U16___2 EnclosureHandle;
	U64___2 SASAddress;
	U32___2 DiscoveryStatus;
	U16___2 DevHandle;
	U16___2 ParentDevHandle;
	U16___2 ExpanderChangeCount;
	U16___2 ExpanderRouteIndexes;
	U8 NumPhys;
	U8 SASLevel;
	U8 Flags;
	U8 Reserved4;
};

typedef struct _EVENT_DATA_SAS_EXPANDER_STATUS_CHANGE MpiEventDataSasExpanderStatusChange_t;

struct _MPI_SAS_IO_UNIT1_PHY_DATA {
	U8 Port;
	U8 PortFlags;
	U8 PhyFlags;
	U8 MaxMinLinkRate;
	U32___2 ControllerPhyDeviceInfo;
	U16___2 MaxTargetPortConnectTime;
	U16___2 Reserved1;
};

typedef struct _MPI_SAS_IO_UNIT1_PHY_DATA MPI_SAS_IO_UNIT1_PHY_DATA;

struct _CONFIG_PAGE_SAS_IO_UNIT_1 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U16___2 ControlFlags;
	U16___2 MaxNumSATATargets;
	U16___2 AdditionalControlFlags;
	U16___2 Reserved1;
	U8 NumPhys;
	U8 SATAMaxQDepth;
	U8 ReportDeviceMissingDelay;
	U8 IODeviceMissingDelay;
	MPI_SAS_IO_UNIT1_PHY_DATA PhyData[1];
};

typedef struct _CONFIG_PAGE_SAS_IO_UNIT_1 SasIOUnitPage1_t;

struct _CONFIG_PAGE_SAS_EXPANDER_0 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U8 PhysicalPort;
	U8 Reserved1;
	U16___2 EnclosureHandle;
	U64___2 SASAddress;
	U32___2 DiscoveryStatus;
	U16___2 DevHandle;
	U16___2 ParentDevHandle;
	U16___2 ExpanderChangeCount;
	U16___2 ExpanderRouteIndexes;
	U8 NumPhys;
	U8 SASLevel;
	U8 Flags;
	U8 Reserved3;
};

typedef struct _CONFIG_PAGE_SAS_EXPANDER_0 SasExpanderPage0_t;

struct _CONFIG_PAGE_SAS_EXPANDER_1 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U8 PhysicalPort;
	U8 Reserved1;
	U16___2 Reserved2;
	U8 NumPhys;
	U8 Phy;
	U16___2 NumTableEntriesProgrammed;
	U8 ProgrammedLinkRate;
	U8 HwLinkRate;
	U16___2 AttachedDevHandle;
	U32___2 PhyInfo;
	U32___2 AttachedDeviceInfo;
	U16___2 OwnerDevHandle;
	U8 ChangeCount;
	U8 NegotiatedLinkRate;
	U8 PhyIdentifier;
	U8 AttachedPhyIdentifier;
	U8 Reserved3;
	U8 DiscoveryInfo;
	U32___2 Reserved4;
};

typedef struct _CONFIG_PAGE_SAS_EXPANDER_1 SasExpanderPage1_t;

struct _CONFIG_PAGE_SAS_DEVICE_0 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U16___2 Slot;
	U16___2 EnclosureHandle;
	U64___2 SASAddress;
	U16___2 ParentDevHandle;
	U8 PhyNum;
	U8 AccessStatus;
	U16___2 DevHandle;
	U8 TargetID;
	U8 Bus;
	U32___2 DeviceInfo;
	U16___2 Flags;
	U8 PhysicalPort;
	U8 Reserved2;
};

typedef struct _CONFIG_PAGE_SAS_DEVICE_0 SasDevicePage0_t;

struct _CONFIG_PAGE_SAS_PHY_0 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U16___2 OwnerDevHandle;
	U16___2 Reserved1;
	U64___2 SASAddress;
	U16___2 AttachedDevHandle;
	U8 AttachedPhyIdentifier;
	U8 Reserved2;
	U32___2 AttachedDeviceInfo;
	U8 ProgrammedLinkRate;
	U8 HwLinkRate;
	U8 ChangeCount;
	U8 Flags;
	U32___2 PhyInfo;
};

typedef struct _CONFIG_PAGE_SAS_PHY_0 SasPhyPage0_t;

struct _CONFIG_PAGE_SAS_PHY_1 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U32___2 Reserved1;
	U32___2 InvalidDwordCount;
	U32___2 RunningDisparityErrorCount;
	U32___2 LossDwordSynchCount;
	U32___2 PhyResetProblemCount;
};

typedef struct _CONFIG_PAGE_SAS_PHY_1 SasPhyPage1_t;

struct _CONFIG_PAGE_SAS_ENCLOSURE_0 {
	CONFIG_EXTENDED_PAGE_HEADER Header;
	U32___2 Reserved1;
	U64___2 EnclosureLogicalID;
	U16___2 Flags;
	U16___2 EnclosureHandle;
	U16___2 NumSlots;
	U16___2 StartSlot;
	U8 StartTargetID;
	U8 StartBus;
	U8 SEPTargetID;
	U8 SEPBus;
	U32___2 Reserved2;
	U32___2 Reserved3;
};

typedef struct _CONFIG_PAGE_SAS_ENCLOSURE_0 SasEnclosurePage0_t;

struct _MSG_SMP_PASSTHROUGH_REQUEST {
	U8 PassthroughFlags;
	U8 PhysicalPort;
	U8 ChainOffset;
	U8 Function;
	U16___2 RequestDataLength;
	U8 ConnectionRate;
	U8 MsgFlags;
	U32___2 MsgContext;
	U32___2 Reserved1;
	U64___2 SASAddress;
	U32___2 Reserved2;
	U32___2 Reserved3;
	SGE_SIMPLE_UNION SGL;
};

typedef struct _MSG_SMP_PASSTHROUGH_REQUEST SmpPassthroughRequest_t;

struct _MSG_SMP_PASSTHROUGH_REPLY {
	U8 PassthroughFlags;
	U8 PhysicalPort;
	U8 MsgLength;
	U8 Function;
	U16___2 ResponseDataLength;
	U8 Reserved1;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Reserved2;
	U8 SASStatus;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
	U32___2 Reserved3;
	U8 ResponseData[4];
};

typedef struct _MSG_SMP_PASSTHROUGH_REPLY SmpPassthroughReply_t;

struct mptsas_phyinfo;

struct mptsas_portinfo {
	struct list_head list;
	u16 num_phys;
	struct mptsas_phyinfo *phy_info;
};

struct mptsas_target_reset_event {
	struct list_head list;
	EVENT_DATA_SAS_DEVICE_STATUS_CHANGE sas_event_data;
	u8 target_reset_issued;
	long unsigned int time_count;
};

enum mptsas_hotplug_action {
	MPTSAS_ADD_DEVICE = 0,
	MPTSAS_DEL_DEVICE = 1,
	MPTSAS_ADD_RAID = 2,
	MPTSAS_DEL_RAID = 3,
	MPTSAS_ADD_PHYSDISK = 4,
	MPTSAS_ADD_PHYSDISK_REPROBE = 5,
	MPTSAS_DEL_PHYSDISK = 6,
	MPTSAS_DEL_PHYSDISK_REPROBE = 7,
	MPTSAS_ADD_INACTIVE_VOLUME = 8,
	MPTSAS_IGNORE_EVENT = 9,
};

struct mptsas_mapping {
	u8 id;
	u8 channel;
};

struct mptsas_device_info {
	struct list_head list;
	struct mptsas_mapping os;
	struct mptsas_mapping fw;
	u64 sas_address;
	u32 device_info;
	u16 slot;
	u64 enclosure_logical_id;
	u8 is_logical_volume;
	u8 is_hidden_raid_component;
	u8 volume_id;
	u8 is_cached;
};

struct mptsas_hotplug_event {
	MPT_ADAPTER *ioc;
	enum mptsas_hotplug_action event_type;
	u64 sas_address;
	u8 channel;
	u8 id;
	u32 device_info;
	u16 handle;
	u8 phy_id;
	u8 phys_disk_num;
	struct scsi_device *sdev;
};

struct fw_event_work {
	struct list_head list;
	struct delayed_work work;
	MPT_ADAPTER *ioc;
	u32 event;
	u8 retries;
	int: 24;
	char event_data[0];
};

struct mptsas_devinfo {
	u16 handle;
	u16 handle_parent;
	u16 handle_enclosure;
	u16 slot;
	u8 phy_id;
	u8 port_id;
	u8 id;
	u32 phys_disk_num;
	u8 channel;
	u64 sas_address;
	u32 device_info;
	u16 flags;
};

struct mptsas_portinfo_details {
	u16 num_phys;
	u64 phy_bitmask;
	struct sas_rphy *rphy;
	struct sas_port *port;
	struct scsi_target *starget;
	struct mptsas_portinfo *port_info;
};

struct mptsas_phyinfo {
	u16 handle;
	u8 phy_id;
	u8 port_id;
	u8 negotiated_link_rate;
	u8 hw_link_rate;
	u8 programmed_link_rate;
	u8 sas_port_add_phy;
	struct mptsas_devinfo identify;
	struct mptsas_devinfo attached;
	struct sas_phy *phy;
	struct mptsas_portinfo *portinfo;
	struct mptsas_portinfo_details *port_details;
};

struct mptsas_enclosure {
	u64 enclosure_logical_id;
	u16 enclosure_handle;
	u16 flags;
	u16 num_slot;
	u16 start_slot;
	u8 start_id;
	u8 start_channel;
	u8 sep_id;
	u8 sep_channel;
};

struct rep_manu_request {
	u8 smp_frame_type;
	u8 function;
	u8 reserved;
	u8 request_length;
};

struct rep_manu_reply {
	u8 smp_frame_type;
	u8 function;
	u8 function_result;
	u8 response_length;
	u16 expander_change_count;
	u8 reserved0[2];
	u8 sas_format: 1;
	u8 reserved1: 7;
	u8 reserved2[3];
	u8 vendor_id[8];
	u8 product_id[16];
	u8 product_rev[4];
	u8 component_vendor_id[8];
	u16 component_id;
	u8 component_revision_id;
	u8 reserved3;
	u8 vendor_specific[8];
};

struct _MSG_FW_DOWNLOAD {
	U8 ImageType;
	U8 Reserved;
	U8 ChainOffset;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
	SGE_MPI_UNION SGL;
};

typedef struct _MSG_FW_DOWNLOAD FWDownload_t;

struct _FWDownloadTCSGE {
	U8 Reserved;
	U8 ContextSize;
	U8 DetailsLength;
	U8 Flags;
	U32___2 Reserved_0100_Checksum;
	U32___2 ImageOffset;
	U32___2 ImageSize;
};

typedef struct _FWDownloadTCSGE FWDownloadTCSGE_t;

struct _MSG_FW_DOWNLOAD_REPLY {
	U8 ImageType;
	U8 Reserved;
	U8 MsgLength;
	U8 Function;
	U8 Reserved1[3];
	U8 MsgFlags;
	U32___2 MsgContext;
	U16___2 Reserved2;
	U16___2 IOCStatus;
	U32___2 IOCLogInfo;
};

typedef struct _MSG_FW_DOWNLOAD_REPLY *pFWDownloadReply_t;

typedef struct _CONFIG_PAGE_SCSI_DEVICE_0 SCSIDevicePage0_t;

struct _CONFIG_PAGE_SCSI_DEVICE_3 {
	CONFIG_PAGE_HEADER Header;
	U16___2 MsgRejectCount;
	U16___2 PhaseErrorCount;
	U16___2 ParityErrorCount;
	U16___2 Reserved;
};

typedef struct _CONFIG_PAGE_SCSI_DEVICE_3 SCSIDevicePage3_t;

struct _MSG_TOOLBOX_ISTWI_READ_WRITE_REQUEST {
	U8 Tool;
	U8 Reserved;
	U8 ChainOffset;
	U8 Function;
	U16___2 Reserved1;
	U8 Reserved2;
	U8 MsgFlags;
	U32___2 MsgContext;
	U8 Flags;
	U8 BusNum;
	U16___2 Reserved3;
	U8 NumAddressBytes;
	U8 Reserved4;
	U16___2 DataLength;
	U8 DeviceAddr;
	U8 Addr1;
	U8 Addr2;
	U8 Addr3;
	U32___2 Reserved5;
	SGE_SIMPLE_UNION SGL;
};

typedef struct _MSG_TOOLBOX_ISTWI_READ_WRITE_REQUEST ToolboxIstwiReadWriteRequest_t;

typedef struct _mpt_ioctl_events MPT_IOCTL_EVENTS;

struct _mpt_sge {
	u32 FlagsLength;
	dma_addr_t Address;
};

typedef struct _mpt_sge MptSge_t;

struct mpt_fw_xfer {
	unsigned int iocnum;
	unsigned int fwlen;
	void *bufp;
};

struct mpt_fw_xfer32 {
	unsigned int iocnum;
	unsigned int fwlen;
	u32 bufp;
};

struct _mpt_ioctl_header {
	unsigned int iocnum;
	unsigned int port;
	int maxDataSize;
};

typedef struct _mpt_ioctl_header mpt_ioctl_header;

struct mpt_ioctl_diag_reset {
	mpt_ioctl_header hdr;
};

struct mpt_ioctl_pci_info2 {
	union {
		struct {
			unsigned int deviceNumber: 5;
			unsigned int functionNumber: 3;
			unsigned int busNumber: 24;
		} bits;
		unsigned int asUlong;
	} u;
	int segmentID;
};

struct mpt_ioctl_iocinfo {
	mpt_ioctl_header hdr;
	int adapterType;
	int port;
	int pciId;
	int hwRev;
	int subSystemDevice;
	int subSystemVendor;
	int numDevices;
	int FWVersion;
	int BIOSVersion;
	char driverVersion[32];
	char busChangeEvent;
	char hostId;
	char rsvd[2];
	struct mpt_ioctl_pci_info2 pciInfo;
};

struct mpt_ioctl_targetinfo {
	mpt_ioctl_header hdr;
	int numDevices;
	int targetInfo[1];
};

struct mpt_ioctl_eventquery {
	mpt_ioctl_header hdr;
	short unsigned int eventEntries;
	short unsigned int reserved;
	unsigned int eventTypes;
};

struct mpt_ioctl_eventenable {
	mpt_ioctl_header hdr;
	unsigned int eventTypes;
};

struct mpt_ioctl_eventreport {
	mpt_ioctl_header hdr;
	MPT_IOCTL_EVENTS eventData[1];
};

struct mpt_ioctl_test {
	mpt_ioctl_header hdr;
	u8 name[32];
	int chip_type;
	u8 product[12];
};

struct mpt_ioctl_replace_fw {
	mpt_ioctl_header hdr;
	int newImageSize;
	u8 newImage[1];
};

struct mpt_ioctl_command {
	mpt_ioctl_header hdr;
	int timeout;
	char *replyFrameBufPtr;
	char *dataInBufPtr;
	char *dataOutBufPtr;
	char *senseDataPtr;
	int maxReplyBytes;
	int dataInSize;
	int dataOutSize;
	int maxSenseBytes;
	int dataSgeOffset;
	char MF[1];
};

struct mpt_ioctl_command32 {
	mpt_ioctl_header hdr;
	int timeout;
	u32 replyFrameBufPtr;
	u32 dataInBufPtr;
	u32 dataOutBufPtr;
	u32 senseDataPtr;
	int maxReplyBytes;
	int dataInSize;
	int dataOutSize;
	int maxSenseBytes;
	int dataSgeOffset;
	char MF[1];
};

struct _hp_header {
	unsigned int iocnum;
	unsigned int host;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
};

typedef struct _hp_header hp_header_t;

struct _hp_host_info {
	hp_header_t hdr;
	u16 vendor;
	u16 device;
	u16 subsystem_vendor;
	u16 subsystem_id;
	u8 devfn;
	u8 bus;
	ushort host_no;
	u8 fw_version[16];
	u8 serial_number[24];
	u32 ioc_status;
	u32 bus_phys_width;
	u32 base_io_addr;
	u32 rsvd;
	unsigned int hard_resets;
	unsigned int soft_resets;
	unsigned int timeouts;
};

typedef struct _hp_host_info hp_host_info_t;

struct _hp_target_info {
	hp_header_t hdr;
	u32 parity_errors;
	u32 phase_errors;
	u32 select_timeouts;
	u32 message_rejects;
	u32 negotiated_speed;
	u8 negotiated_width;
	u8 rsvd[7];
};

typedef struct _hp_target_info hp_target_info_t;

struct buflist {
	u8 *kptr;
	int len;
};

struct ohci {
	void *registers;
};

enum usb_device_speed {
	USB_SPEED_UNKNOWN = 0,
	USB_SPEED_LOW = 1,
	USB_SPEED_FULL = 2,
	USB_SPEED_HIGH = 3,
	USB_SPEED_WIRELESS = 4,
	USB_SPEED_SUPER = 5,
	USB_SPEED_SUPER_PLUS = 6,
};

enum usb_device_state {
	USB_STATE_NOTATTACHED = 0,
	USB_STATE_ATTACHED = 1,
	USB_STATE_POWERED = 2,
	USB_STATE_RECONNECTING = 3,
	USB_STATE_UNAUTHENTICATED = 4,
	USB_STATE_DEFAULT = 5,
	USB_STATE_ADDRESS = 6,
	USB_STATE_CONFIGURED = 7,
	USB_STATE_SUSPENDED = 8,
};

enum usb_otg_state {
	OTG_STATE_UNDEFINED = 0,
	OTG_STATE_B_IDLE = 1,
	OTG_STATE_B_SRP_INIT = 2,
	OTG_STATE_B_PERIPHERAL = 3,
	OTG_STATE_B_WAIT_ACON = 4,
	OTG_STATE_B_HOST = 5,
	OTG_STATE_A_IDLE = 6,
	OTG_STATE_A_WAIT_VRISE = 7,
	OTG_STATE_A_WAIT_BCON = 8,
	OTG_STATE_A_HOST = 9,
	OTG_STATE_A_SUSPEND = 10,
	OTG_STATE_A_PERIPHERAL = 11,
	OTG_STATE_A_WAIT_VFALL = 12,
	OTG_STATE_A_VBUS_ERR = 13,
};

enum usb_dr_mode {
	USB_DR_MODE_UNKNOWN = 0,
	USB_DR_MODE_HOST = 1,
	USB_DR_MODE_PERIPHERAL = 2,
	USB_DR_MODE_OTG = 3,
};

struct usb_device_id {
	__u16 match_flags;
	__u16 idVendor;
	__u16 idProduct;
	__u16 bcdDevice_lo;
	__u16 bcdDevice_hi;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 bInterfaceNumber;
	kernel_ulong_t driver_info;
};

struct usb_descriptor_header {
	__u8 bLength;
	__u8 bDescriptorType;
};

struct usb_device_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__le16 idVendor;
	__le16 idProduct;
	__le16 bcdDevice;
	__u8 iManufacturer;
	__u8 iProduct;
	__u8 iSerialNumber;
	__u8 bNumConfigurations;
};

struct usb_config_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumInterfaces;
	__u8 bConfigurationValue;
	__u8 iConfiguration;
	__u8 bmAttributes;
	__u8 bMaxPower;
} __attribute__((packed));

struct usb_interface_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bInterfaceNumber;
	__u8 bAlternateSetting;
	__u8 bNumEndpoints;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 iInterface;
};

struct usb_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bEndpointAddress;
	__u8 bmAttributes;
	__le16 wMaxPacketSize;
	__u8 bInterval;
	__u8 bRefresh;
	__u8 bSynchAddress;
} __attribute__((packed));

struct usb_ssp_isoc_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wReseved;
	__le32 dwBytesPerInterval;
};

struct usb_ss_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bMaxBurst;
	__u8 bmAttributes;
	__le16 wBytesPerInterval;
};

struct usb_interface_assoc_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bFirstInterface;
	__u8 bInterfaceCount;
	__u8 bFunctionClass;
	__u8 bFunctionSubClass;
	__u8 bFunctionProtocol;
	__u8 iFunction;
};

struct usb_bos_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumDeviceCaps;
} __attribute__((packed));

struct usb_ext_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__le32 bmAttributes;
} __attribute__((packed));

struct usb_ss_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bmAttributes;
	__le16 wSpeedSupported;
	__u8 bFunctionalitySupport;
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
};

struct usb_ss_container_id_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__u8 ContainerID[16];
};

struct usb_ssp_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__le32 bmAttributes;
	__le16 wFunctionalitySupport;
	__le16 wReserved;
	__le32 bmSublinkSpeedAttr[1];
};

struct usb_ptm_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

enum usb3_link_state {
	USB3_LPM_U0 = 0,
	USB3_LPM_U1 = 1,
	USB3_LPM_U2 = 2,
	USB3_LPM_U3 = 3,
};

struct ep_device;

struct usb_host_endpoint {
	struct usb_endpoint_descriptor desc;
	struct usb_ss_ep_comp_descriptor ss_ep_comp;
	struct usb_ssp_isoc_ep_comp_descriptor ssp_isoc_ep_comp;
	char: 8;
	struct list_head urb_list;
	void *hcpriv;
	struct ep_device *ep_dev;
	unsigned char *extra;
	int extralen;
	int enabled;
	int streams;
	int: 32;
} __attribute__((packed));

struct usb_host_interface {
	struct usb_interface_descriptor desc;
	int extralen;
	unsigned char *extra;
	struct usb_host_endpoint *endpoint;
	char *string;
};

enum usb_interface_condition {
	USB_INTERFACE_UNBOUND = 0,
	USB_INTERFACE_BINDING = 1,
	USB_INTERFACE_BOUND = 2,
	USB_INTERFACE_UNBINDING = 3,
};

struct usb_interface {
	struct usb_host_interface *altsetting;
	struct usb_host_interface *cur_altsetting;
	unsigned int num_altsetting;
	struct usb_interface_assoc_descriptor *intf_assoc;
	int minor;
	enum usb_interface_condition condition;
	unsigned int sysfs_files_created: 1;
	unsigned int ep_devs_created: 1;
	unsigned int unregistering: 1;
	unsigned int needs_remote_wakeup: 1;
	unsigned int needs_altsetting0: 1;
	unsigned int needs_binding: 1;
	unsigned int resetting_device: 1;
	unsigned int authorized: 1;
	struct device dev;
	struct device *usb_dev;
	struct work_struct reset_ws;
};

struct usb_interface_cache {
	unsigned int num_altsetting;
	struct kref ref;
	struct usb_host_interface altsetting[0];
};

struct usb_host_config {
	struct usb_config_descriptor desc;
	char *string;
	struct usb_interface_assoc_descriptor *intf_assoc[16];
	struct usb_interface *interface[32];
	struct usb_interface_cache *intf_cache[32];
	unsigned char *extra;
	int extralen;
};

struct usb_host_bos {
	struct usb_bos_descriptor *desc;
	struct usb_ext_cap_descriptor *ext_cap;
	struct usb_ss_cap_descriptor *ss_cap;
	struct usb_ssp_cap_descriptor *ssp_cap;
	struct usb_ss_container_id_descriptor *ss_id;
	struct usb_ptm_cap_descriptor *ptm_cap;
};

struct usb_devmap {
	long unsigned int devicemap[2];
};

struct usb_device;

struct usb_bus {
	struct device *controller;
	struct device *sysdev;
	int busnum;
	const char *bus_name;
	u8 uses_pio_for_control;
	u8 otg_port;
	unsigned int is_b_host: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int no_stop_on_short: 1;
	unsigned int no_sg_constraint: 1;
	unsigned int sg_tablesize;
	int devnum_next;
	struct mutex devnum_next_mutex;
	struct usb_devmap devmap;
	struct usb_device *root_hub;
	struct usb_bus *hs_companion;
	int bandwidth_allocated;
	int bandwidth_int_reqs;
	int bandwidth_isoc_reqs;
	unsigned int resuming_ports;
};

struct wusb_dev;

enum usb_device_removable {
	USB_DEVICE_REMOVABLE_UNKNOWN = 0,
	USB_DEVICE_REMOVABLE = 1,
	USB_DEVICE_FIXED = 2,
};

struct usb2_lpm_parameters {
	unsigned int besl;
	int timeout;
};

struct usb3_lpm_parameters {
	unsigned int mel;
	unsigned int pel;
	unsigned int sel;
	int timeout;
};

struct usb_tt;

struct usb_device {
	int devnum;
	char devpath[16];
	u32 route;
	enum usb_device_state state;
	enum usb_device_speed speed;
	unsigned int rx_lanes;
	unsigned int tx_lanes;
	struct usb_tt *tt;
	int ttport;
	unsigned int toggle[2];
	struct usb_device *parent;
	struct usb_bus *bus;
	struct usb_host_endpoint ep0;
	struct device dev;
	struct usb_device_descriptor descriptor;
	struct usb_host_bos *bos;
	struct usb_host_config *config;
	struct usb_host_config *actconfig;
	struct usb_host_endpoint *ep_in[16];
	struct usb_host_endpoint *ep_out[16];
	char **rawdescriptors;
	short unsigned int bus_mA;
	u8 portnum;
	u8 level;
	u8 devaddr;
	unsigned int can_submit: 1;
	unsigned int persist_enabled: 1;
	unsigned int have_langid: 1;
	unsigned int authorized: 1;
	unsigned int authenticated: 1;
	unsigned int wusb: 1;
	unsigned int lpm_capable: 1;
	unsigned int usb2_hw_lpm_capable: 1;
	unsigned int usb2_hw_lpm_besl_capable: 1;
	unsigned int usb2_hw_lpm_enabled: 1;
	unsigned int usb2_hw_lpm_allowed: 1;
	unsigned int usb3_lpm_u1_enabled: 1;
	unsigned int usb3_lpm_u2_enabled: 1;
	int string_langid;
	char *product;
	char *manufacturer;
	char *serial;
	struct list_head filelist;
	int maxchild;
	u32 quirks;
	atomic_t urbnum;
	long unsigned int active_duration;
	long unsigned int connect_time;
	unsigned int do_remote_wakeup: 1;
	unsigned int reset_resume: 1;
	unsigned int port_is_suspended: 1;
	struct wusb_dev *wusb_dev;
	int slot_id;
	enum usb_device_removable removable;
	struct usb2_lpm_parameters l1_params;
	struct usb3_lpm_parameters u1_params;
	struct usb3_lpm_parameters u2_params;
	unsigned int lpm_disable_count;
	u16 hub_delay;
};

enum usb_port_connect_type {
	USB_PORT_CONNECT_TYPE_UNKNOWN = 0,
	USB_PORT_CONNECT_TYPE_HOT_PLUG = 1,
	USB_PORT_CONNECT_TYPE_HARD_WIRED = 2,
	USB_PORT_NOT_USED = 3,
};

struct usb_tt {
	struct usb_device *hub;
	int multi;
	unsigned int think_time;
	void *hcpriv;
	spinlock_t lock;
	struct list_head clear_list;
	struct work_struct clear_work;
};

struct usb_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct usbdrv_wrap {
	struct device_driver driver;
	int for_devices;
};

struct usb_driver {
	const char *name;
	int (*probe)(struct usb_interface *, const struct usb_device_id *);
	void (*disconnect)(struct usb_interface *);
	int (*unlocked_ioctl)(struct usb_interface *, unsigned int, void *);
	int (*suspend)(struct usb_interface *, pm_message_t);
	int (*resume)(struct usb_interface *);
	int (*reset_resume)(struct usb_interface *);
	int (*pre_reset)(struct usb_interface *);
	int (*post_reset)(struct usb_interface *);
	const struct usb_device_id *id_table;
	const struct attribute_group **dev_groups;
	struct usb_dynids dynids;
	struct usbdrv_wrap drvwrap;
	unsigned int no_dynamic_id: 1;
	unsigned int supports_autosuspend: 1;
	unsigned int disable_hub_initiated_lpm: 1;
	unsigned int soft_unbind: 1;
};

struct usb_device_driver {
	const char *name;
	int (*probe)(struct usb_device *);
	void (*disconnect)(struct usb_device *);
	int (*suspend)(struct usb_device *, pm_message_t);
	int (*resume)(struct usb_device *, pm_message_t);
	const struct attribute_group **dev_groups;
	struct usbdrv_wrap drvwrap;
	unsigned int supports_autosuspend: 1;
};

struct usb_iso_packet_descriptor {
	unsigned int offset;
	unsigned int length;
	unsigned int actual_length;
	int status;
};

struct usb_anchor {
	struct list_head urb_list;
	wait_queue_head_t wait;
	spinlock_t lock;
	atomic_t suspend_wakeups;
	unsigned int poisoned: 1;
};

struct urb;

typedef void (*usb_complete_t)(struct urb *);

struct urb {
	struct kref kref;
	int unlinked;
	void *hcpriv;
	atomic_t use_count;
	atomic_t reject;
	struct list_head urb_list;
	struct list_head anchor_list;
	struct usb_anchor *anchor;
	struct usb_device *dev;
	struct usb_host_endpoint *ep;
	unsigned int pipe;
	unsigned int stream_id;
	int status;
	unsigned int transfer_flags;
	void *transfer_buffer;
	dma_addr_t transfer_dma;
	struct scatterlist *sg;
	int num_mapped_sgs;
	int num_sgs;
	u32 transfer_buffer_length;
	u32 actual_length;
	unsigned char *setup_packet;
	dma_addr_t setup_dma;
	int start_frame;
	int number_of_packets;
	int interval;
	int error_count;
	void *context;
	usb_complete_t complete;
	struct usb_iso_packet_descriptor iso_frame_desc[0];
};

struct giveback_urb_bh {
	bool running;
	spinlock_t lock;
	struct list_head head;
	struct tasklet_struct bh;
	struct usb_host_endpoint *completing_ep;
};

enum usb_dev_authorize_policy {
	USB_DEVICE_AUTHORIZE_NONE = 0,
	USB_DEVICE_AUTHORIZE_ALL = 1,
	USB_DEVICE_AUTHORIZE_INTERNAL = 2,
};

struct usb_phy_roothub;

struct hc_driver;

struct usb_phy;

struct usb_hcd {
	struct usb_bus self;
	struct kref kref;
	const char *product_desc;
	int speed;
	char irq_descr[24];
	struct timer_list rh_timer;
	struct urb *status_urb;
	struct work_struct wakeup_work;
	struct work_struct died_work;
	const struct hc_driver *driver;
	struct usb_phy *usb_phy;
	struct usb_phy_roothub *phy_roothub;
	long unsigned int flags;
	enum usb_dev_authorize_policy dev_policy;
	unsigned int rh_registered: 1;
	unsigned int rh_pollable: 1;
	unsigned int msix_enabled: 1;
	unsigned int msi_enabled: 1;
	unsigned int skip_phy_initialization: 1;
	unsigned int uses_new_polling: 1;
	unsigned int wireless: 1;
	unsigned int has_tt: 1;
	unsigned int amd_resume_bug: 1;
	unsigned int can_do_streams: 1;
	unsigned int tpl_support: 1;
	unsigned int cant_recv_wakeups: 1;
	unsigned int irq;
	void *regs;
	resource_size_t rsrc_start;
	resource_size_t rsrc_len;
	unsigned int power_budget;
	struct giveback_urb_bh high_prio_bh;
	struct giveback_urb_bh low_prio_bh;
	struct mutex *address0_mutex;
	struct mutex *bandwidth_mutex;
	struct usb_hcd *shared_hcd;
	struct usb_hcd *primary_hcd;
	struct dma_pool *pool[4];
	int state;
	struct gen_pool *localmem_pool;
	long unsigned int hcd_priv[0];
};

struct hc_driver {
	const char *description;
	const char *product_desc;
	size_t hcd_priv_size;
	irqreturn_t (*irq)(struct usb_hcd *);
	int flags;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*pci_suspend)(struct usb_hcd *, bool);
	int (*pci_resume)(struct usb_hcd *, bool);
	void (*stop)(struct usb_hcd *);
	void (*shutdown)(struct usb_hcd *);
	int (*get_frame_number)(struct usb_hcd *);
	int (*urb_enqueue)(struct usb_hcd *, struct urb *, gfp_t);
	int (*urb_dequeue)(struct usb_hcd *, struct urb *, int);
	int (*map_urb_for_dma)(struct usb_hcd *, struct urb *, gfp_t);
	void (*unmap_urb_for_dma)(struct usb_hcd *, struct urb *);
	void (*endpoint_disable)(struct usb_hcd *, struct usb_host_endpoint *);
	void (*endpoint_reset)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*hub_status_data)(struct usb_hcd *, char *);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
	int (*bus_suspend)(struct usb_hcd *);
	int (*bus_resume)(struct usb_hcd *);
	int (*start_port_reset)(struct usb_hcd *, unsigned int);
	long unsigned int (*get_resuming_ports)(struct usb_hcd *);
	void (*relinquish_port)(struct usb_hcd *, int);
	int (*port_handed_over)(struct usb_hcd *, int);
	void (*clear_tt_buffer_complete)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*alloc_dev)(struct usb_hcd *, struct usb_device *);
	void (*free_dev)(struct usb_hcd *, struct usb_device *);
	int (*alloc_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, unsigned int, gfp_t);
	int (*free_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, gfp_t);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*address_device)(struct usb_hcd *, struct usb_device *);
	int (*enable_device)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*reset_device)(struct usb_hcd *, struct usb_device *);
	int (*update_device)(struct usb_hcd *, struct usb_device *);
	int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
	int (*enable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*disable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*find_raw_port_number)(struct usb_hcd *, int);
	int (*port_power)(struct usb_hcd *, int, bool);
};

enum usb_phy_type {
	USB_PHY_TYPE_UNDEFINED = 0,
	USB_PHY_TYPE_USB2 = 1,
	USB_PHY_TYPE_USB3 = 2,
};

enum usb_phy_events {
	USB_EVENT_NONE = 0,
	USB_EVENT_VBUS = 1,
	USB_EVENT_ID = 2,
	USB_EVENT_CHARGER = 3,
	USB_EVENT_ENUMERATED = 4,
};

struct extcon_dev;

enum usb_charger_type {
	UNKNOWN_TYPE = 0,
	SDP_TYPE = 1,
	DCP_TYPE = 2,
	CDP_TYPE = 3,
	ACA_TYPE = 4,
};

enum usb_charger_state {
	USB_CHARGER_DEFAULT = 0,
	USB_CHARGER_PRESENT = 1,
	USB_CHARGER_ABSENT = 2,
};

struct usb_charger_current {
	unsigned int sdp_min;
	unsigned int sdp_max;
	unsigned int dcp_min;
	unsigned int dcp_max;
	unsigned int cdp_min;
	unsigned int cdp_max;
	unsigned int aca_min;
	unsigned int aca_max;
};

struct usb_otg;

struct usb_phy_io_ops;

struct usb_phy {
	struct device *dev;
	const char *label;
	unsigned int flags;
	enum usb_phy_type type;
	enum usb_phy_events last_event;
	struct usb_otg *otg;
	struct device *io_dev;
	struct usb_phy_io_ops *io_ops;
	void *io_priv;
	struct extcon_dev *edev;
	struct extcon_dev *id_edev;
	struct notifier_block vbus_nb;
	struct notifier_block id_nb;
	struct notifier_block type_nb;
	enum usb_charger_type chg_type;
	enum usb_charger_state chg_state;
	struct usb_charger_current chg_cur;
	struct work_struct chg_work;
	struct atomic_notifier_head notifier;
	u16 port_status;
	u16 port_change;
	struct list_head head;
	int (*init)(struct usb_phy *);
	void (*shutdown)(struct usb_phy *);
	int (*set_vbus)(struct usb_phy *, int);
	int (*set_power)(struct usb_phy *, unsigned int);
	int (*set_suspend)(struct usb_phy *, int);
	int (*set_wakeup)(struct usb_phy *, bool);
	int (*notify_connect)(struct usb_phy *, enum usb_device_speed);
	int (*notify_disconnect)(struct usb_phy *, enum usb_device_speed);
	enum usb_charger_type (*charger_detect)(struct usb_phy *);
};

struct usb_port_status {
	__le16 wPortStatus;
	__le16 wPortChange;
	__le32 dwExtPortStatus;
};

struct usb_hub_status {
	__le16 wHubStatus;
	__le16 wHubChange;
};

struct usb_hub_descriptor {
	__u8 bDescLength;
	__u8 bDescriptorType;
	__u8 bNbrPorts;
	__le16 wHubCharacteristics;
	__u8 bPwrOn2PwrGood;
	__u8 bHubContrCurrent;
	union {
		struct {
			__u8 DeviceRemovable[4];
			__u8 PortPwrCtrlMask[4];
		} hs;
		struct {
			__u8 bHubHdrDecLat;
			__le16 wHubDelay;
			__le16 DeviceRemovable;
		} __attribute__((packed)) ss;
	} u;
} __attribute__((packed));

struct usb_phy_io_ops {
	int (*read)(struct usb_phy *, u32);
	int (*write)(struct usb_phy *, u32, u32);
};

struct usb_gadget;

struct usb_otg {
	u8 default_a;
	struct phy *phy;
	struct usb_phy *usb_phy;
	struct usb_bus *host;
	struct usb_gadget *gadget;
	enum usb_otg_state state;
	int (*set_host)(struct usb_otg *, struct usb_bus *);
	int (*set_peripheral)(struct usb_otg *, struct usb_gadget *);
	int (*set_vbus)(struct usb_otg *, bool);
	int (*start_srp)(struct usb_otg *);
	int (*start_hnp)(struct usb_otg *);
};

typedef u32 usb_port_location_t;

struct usb_port;

struct usb_hub {
	struct device *intfdev;
	struct usb_device *hdev;
	struct kref kref;
	struct urb *urb;
	u8 (*buffer)[8];
	union {
		struct usb_hub_status hub;
		struct usb_port_status port;
	} *status;
	struct mutex status_mutex;
	int error;
	int nerrors;
	long unsigned int event_bits[1];
	long unsigned int change_bits[1];
	long unsigned int removed_bits[1];
	long unsigned int wakeup_bits[1];
	long unsigned int power_bits[1];
	long unsigned int child_usage_bits[1];
	long unsigned int warm_reset_bits[1];
	struct usb_hub_descriptor *descriptor;
	struct usb_tt tt;
	unsigned int mA_per_port;
	unsigned int wakeup_enabled_descendants;
	unsigned int limited_power: 1;
	unsigned int quiescing: 1;
	unsigned int disconnected: 1;
	unsigned int in_reset: 1;
	unsigned int quirk_disable_autosuspend: 1;
	unsigned int quirk_check_port_auto_suspend: 1;
	unsigned int has_indicators: 1;
	u8 indicator[31];
	struct delayed_work leds;
	struct delayed_work init_work;
	struct work_struct events;
	spinlock_t irq_urb_lock;
	struct timer_list irq_urb_retry;
	struct usb_port **ports;
};

struct usb_dev_state;

struct usb_port {
	struct usb_device *child;
	struct device dev;
	struct usb_dev_state *port_owner;
	struct usb_port *peer;
	struct dev_pm_qos_request *req;
	enum usb_port_connect_type connect_type;
	usb_port_location_t location;
	struct mutex status_lock;
	u32 over_current_count;
	u8 portnum;
	u32 quirks;
	unsigned int is_superspeed: 1;
	unsigned int usb3_lpm_u1_permit: 1;
	unsigned int usb3_lpm_u2_permit: 1;
};

struct find_interface_arg {
	int minor;
	struct device_driver *drv;
};

struct each_dev_arg {
	void *data;
	int (*fn)(struct usb_device *, void *);
};

struct usb_qualifier_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__u8 bNumConfigurations;
	__u8 bRESERVED;
};

struct usb_set_sel_req {
	__u8 u1_sel;
	__u8 u1_pel;
	__le16 u2_sel;
	__le16 u2_pel;
};

struct usbdevfs_hub_portinfo {
	char nports;
	char port[127];
};

enum hub_led_mode {
	INDICATOR_AUTO = 0,
	INDICATOR_CYCLE = 1,
	INDICATOR_GREEN_BLINK = 2,
	INDICATOR_GREEN_BLINK_OFF = 3,
	INDICATOR_AMBER_BLINK = 4,
	INDICATOR_AMBER_BLINK_OFF = 5,
	INDICATOR_ALT_BLINK = 6,
	INDICATOR_ALT_BLINK_OFF = 7,
};

struct usb_tt_clear {
	struct list_head clear_list;
	unsigned int tt;
	u16 devinfo;
	struct usb_hcd *hcd;
	struct usb_host_endpoint *ep;
};

enum hub_activation_type {
	HUB_INIT = 0,
	HUB_INIT2 = 1,
	HUB_INIT3 = 2,
	HUB_POST_RESET = 3,
	HUB_RESUME = 4,
	HUB_RESET_RESUME = 5,
};

enum hub_quiescing_type {
	HUB_DISCONNECT = 0,
	HUB_PRE_RESET = 1,
	HUB_SUSPEND = 2,
};

struct usb_ctrlrequest {
	__u8 bRequestType;
	__u8 bRequest;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

enum usb_led_event {
	USB_LED_EVENT_HOST = 0,
	USB_LED_EVENT_GADGET = 1,
};

struct usb_sg_request {
	int status;
	size_t bytes;
	spinlock_t lock;
	struct usb_device *dev;
	int pipe;
	int entries;
	struct urb **urbs;
	int count;
	struct completion complete;
};

struct usb_cdc_header_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdCDC;
} __attribute__((packed));

struct usb_cdc_call_mgmt_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
	__u8 bDataInterface;
};

struct usb_cdc_acm_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
};

struct usb_cdc_union_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bMasterInterface0;
	__u8 bSlaveInterface0;
};

struct usb_cdc_country_functional_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iCountryCodeRelDate;
	__le16 wCountyCode0;
};

struct usb_cdc_network_terminal_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bEntityId;
	__u8 iName;
	__u8 bChannelIndex;
	__u8 bPhysicalInterface;
};

struct usb_cdc_ether_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iMACAddress;
	__le32 bmEthernetStatistics;
	__le16 wMaxSegmentSize;
	__le16 wNumberMCFilters;
	__u8 bNumberPowerFilters;
} __attribute__((packed));

struct usb_cdc_dmm_desc {
	__u8 bFunctionLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u16 bcdVersion;
	__le16 wMaxCommand;
} __attribute__((packed));

struct usb_cdc_mdlm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
	__u8 bGUID[16];
} __attribute__((packed));

struct usb_cdc_mdlm_detail_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bGuidDescriptorType;
	__u8 bDetailData[0];
};

struct usb_cdc_obex_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
} __attribute__((packed));

struct usb_cdc_ncm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdNcmVersion;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMVersion;
	__le16 wMaxControlMessage;
	__u8 bNumberFilters;
	__u8 bMaxFilterSize;
	__le16 wMaxSegmentSize;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_extended_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMExtendedVersion;
	__u8 bMaxOutstandingCommandMessages;
	__le16 wMTU;
} __attribute__((packed));

struct usb_cdc_parsed_header {
	struct usb_cdc_union_desc *usb_cdc_union_desc;
	struct usb_cdc_header_desc *usb_cdc_header_desc;
	struct usb_cdc_call_mgmt_descriptor *usb_cdc_call_mgmt_descriptor;
	struct usb_cdc_acm_descriptor *usb_cdc_acm_descriptor;
	struct usb_cdc_country_functional_desc *usb_cdc_country_functional_desc;
	struct usb_cdc_network_terminal_desc *usb_cdc_network_terminal_desc;
	struct usb_cdc_ether_desc *usb_cdc_ether_desc;
	struct usb_cdc_dmm_desc *usb_cdc_dmm_desc;
	struct usb_cdc_mdlm_desc *usb_cdc_mdlm_desc;
	struct usb_cdc_mdlm_detail_desc *usb_cdc_mdlm_detail_desc;
	struct usb_cdc_obex_desc *usb_cdc_obex_desc;
	struct usb_cdc_ncm_desc *usb_cdc_ncm_desc;
	struct usb_cdc_mbim_desc *usb_cdc_mbim_desc;
	struct usb_cdc_mbim_extended_desc *usb_cdc_mbim_extended_desc;
	bool phonet_magic_present;
};

struct api_context {
	struct completion done;
	int status;
};

struct set_config_request {
	struct usb_device *udev;
	int config;
	struct work_struct work;
	struct list_head node;
};

struct usb_dynid {
	struct list_head node;
	struct usb_device_id id;
};

struct usb_dev_cap_header {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

struct usb_class_driver {
	char *name;
	char * (*devnode)(struct device *, umode_t *);
	const struct file_operations *fops;
	int minor_base;
};

struct usb_class {
	struct kref kref;
	struct class *class;
};

struct ep_device {
	struct usb_endpoint_descriptor *desc;
	struct usb_device *udev;
	struct device dev;
};

struct usbdevfs_ctrltransfer {
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	__u32 timeout;
	void *data;
};

struct usbdevfs_bulktransfer {
	unsigned int ep;
	unsigned int len;
	unsigned int timeout;
	void *data;
};

struct usbdevfs_setinterface {
	unsigned int interface;
	unsigned int altsetting;
};

struct usbdevfs_disconnectsignal {
	unsigned int signr;
	void *context;
};

struct usbdevfs_getdriver {
	unsigned int interface;
	char driver[256];
};

struct usbdevfs_connectinfo {
	unsigned int devnum;
	unsigned char slow;
};

struct usbdevfs_conninfo_ex {
	__u32 size;
	__u32 busnum;
	__u32 devnum;
	__u32 speed;
	__u8 num_ports;
	__u8 ports[7];
};

struct usbdevfs_iso_packet_desc {
	unsigned int length;
	unsigned int actual_length;
	unsigned int status;
};

struct usbdevfs_urb {
	unsigned char type;
	unsigned char endpoint;
	int status;
	unsigned int flags;
	void *buffer;
	int buffer_length;
	int actual_length;
	int start_frame;
	union {
		int number_of_packets;
		unsigned int stream_id;
	};
	int error_count;
	unsigned int signr;
	void *usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_ioctl {
	int ifno;
	int ioctl_code;
	void *data;
};

struct usbdevfs_disconnect_claim {
	unsigned int interface;
	unsigned int flags;
	char driver[256];
};

struct usbdevfs_streams {
	unsigned int num_streams;
	unsigned int num_eps;
	unsigned char eps[0];
};

struct usbdevfs_ctrltransfer32 {
	u8 bRequestType;
	u8 bRequest;
	u16 wValue;
	u16 wIndex;
	u16 wLength;
	u32 timeout;
	compat_caddr_t data;
};

struct usbdevfs_bulktransfer32 {
	compat_uint_t ep;
	compat_uint_t len;
	compat_uint_t timeout;
	compat_caddr_t data;
};

struct usbdevfs_disconnectsignal32 {
	compat_int_t signr;
	compat_caddr_t context;
};

struct usbdevfs_urb32 {
	unsigned char type;
	unsigned char endpoint;
	compat_int_t status;
	compat_uint_t flags;
	compat_caddr_t buffer;
	compat_int_t buffer_length;
	compat_int_t actual_length;
	compat_int_t start_frame;
	compat_int_t number_of_packets;
	compat_int_t error_count;
	compat_uint_t signr;
	compat_caddr_t usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_ioctl32 {
	s32 ifno;
	s32 ioctl_code;
	compat_caddr_t data;
};

struct usb_dev_state {
	struct list_head list;
	struct usb_device *dev;
	struct file *file;
	spinlock_t lock;
	struct list_head async_pending;
	struct list_head async_completed;
	struct list_head memory_list;
	wait_queue_head_t wait;
	wait_queue_head_t wait_for_resume;
	unsigned int discsignr;
	struct pid *disc_pid;
	const struct cred *cred;
	sigval_t disccontext;
	long unsigned int ifclaimed;
	u32 disabled_bulk_eps;
	long unsigned int interface_allowed_mask;
	int not_yet_resumed;
	bool suspend_allowed;
	bool privileges_dropped;
};

struct usb_memory {
	struct list_head memlist;
	int vma_use_count;
	int urb_use_count;
	u32 size;
	void *mem;
	dma_addr_t dma_handle;
	long unsigned int vm_start;
	struct usb_dev_state *ps;
};

struct async {
	struct list_head asynclist;
	struct usb_dev_state *ps;
	struct pid *pid;
	const struct cred *cred;
	unsigned int signr;
	unsigned int ifnum;
	void *userbuffer;
	void *userurb;
	sigval_t userurb_sigval;
	struct urb *urb;
	struct usb_memory *usbm;
	unsigned int mem_usage;
	int status;
	u8 bulk_addr;
	u8 bulk_status;
};

enum snoop_when {
	SUBMIT = 0,
	COMPLETE = 1,
};

struct quirk_entry {
	u16 vid;
	u16 pid;
	u32 flags;
};

struct device_connect_event {
	atomic_t count;
	wait_queue_head_t wait;
};

struct class_info {
	int class;
	char *class_name;
};

struct usb_phy_roothub {
	struct phy *phy;
	struct list_head list;
};

typedef void (*companion_fn)(struct pci_dev *, struct usb_hcd *, struct pci_dev *, struct usb_hcd *);

enum amd_chipset_gen {
	NOT_AMD_CHIPSET = 0,
	AMD_CHIPSET_SB600 = 1,
	AMD_CHIPSET_SB700 = 2,
	AMD_CHIPSET_SB800 = 3,
	AMD_CHIPSET_HUDSON2 = 4,
	AMD_CHIPSET_BOLTON = 5,
	AMD_CHIPSET_YANGTZE = 6,
	AMD_CHIPSET_TAISHAN = 7,
	AMD_CHIPSET_UNKNOWN = 8,
};

struct amd_chipset_type {
	enum amd_chipset_gen gen;
	u8 rev;
};

struct amd_chipset_info {
	struct pci_dev *nb_dev;
	struct pci_dev *smbus_dev;
	int nb_type;
	struct amd_chipset_type sb_type;
	int isoc_reqs;
	int probe_count;
	bool need_pll_quirk;
};

struct ehci_stats {
	long unsigned int normal;
	long unsigned int error;
	long unsigned int iaa;
	long unsigned int lost_iaa;
	long unsigned int complete;
	long unsigned int unlink;
};

struct ehci_per_sched {
	struct usb_device *udev;
	struct usb_host_endpoint *ep;
	struct list_head ps_list;
	u16 tt_usecs;
	u16 cs_mask;
	u16 period;
	u16 phase;
	u8 bw_phase;
	u8 phase_uf;
	u8 usecs;
	u8 c_usecs;
	u8 bw_uperiod;
	u8 bw_period;
};

enum ehci_rh_state {
	EHCI_RH_HALTED = 0,
	EHCI_RH_SUSPENDED = 1,
	EHCI_RH_RUNNING = 2,
	EHCI_RH_STOPPING = 3,
};

enum ehci_hrtimer_event {
	EHCI_HRTIMER_POLL_ASS = 0,
	EHCI_HRTIMER_POLL_PSS = 1,
	EHCI_HRTIMER_POLL_DEAD = 2,
	EHCI_HRTIMER_UNLINK_INTR = 3,
	EHCI_HRTIMER_FREE_ITDS = 4,
	EHCI_HRTIMER_ACTIVE_UNLINK = 5,
	EHCI_HRTIMER_START_UNLINK_INTR = 6,
	EHCI_HRTIMER_ASYNC_UNLINKS = 7,
	EHCI_HRTIMER_IAA_WATCHDOG = 8,
	EHCI_HRTIMER_DISABLE_PERIODIC = 9,
	EHCI_HRTIMER_DISABLE_ASYNC = 10,
	EHCI_HRTIMER_IO_WATCHDOG = 11,
	EHCI_HRTIMER_NUM_EVENTS = 12,
};

struct ehci_caps;

struct ehci_regs;

struct ehci_dbg_port;

struct ehci_qh;

union ehci_shadow;

struct ehci_itd;

struct ehci_sitd;

struct ehci_hcd {
	enum ehci_hrtimer_event next_hrtimer_event;
	unsigned int enabled_hrtimer_events;
	ktime_t hr_timeouts[12];
	struct hrtimer hrtimer;
	int PSS_poll_count;
	int ASS_poll_count;
	int died_poll_count;
	struct ehci_caps *caps;
	struct ehci_regs *regs;
	struct ehci_dbg_port *debug;
	__u32 hcs_params;
	spinlock_t lock;
	enum ehci_rh_state rh_state;
	bool scanning: 1;
	bool need_rescan: 1;
	bool intr_unlinking: 1;
	bool iaa_in_progress: 1;
	bool async_unlinking: 1;
	bool shutdown: 1;
	struct ehci_qh *qh_scan_next;
	struct ehci_qh *async;
	struct ehci_qh *dummy;
	struct list_head async_unlink;
	struct list_head async_idle;
	unsigned int async_unlink_cycle;
	unsigned int async_count;
	__le32 old_current;
	__le32 old_token;
	unsigned int periodic_size;
	__le32 *periodic;
	dma_addr_t periodic_dma;
	struct list_head intr_qh_list;
	unsigned int i_thresh;
	union ehci_shadow *pshadow;
	struct list_head intr_unlink_wait;
	struct list_head intr_unlink;
	unsigned int intr_unlink_wait_cycle;
	unsigned int intr_unlink_cycle;
	unsigned int now_frame;
	unsigned int last_iso_frame;
	unsigned int intr_count;
	unsigned int isoc_count;
	unsigned int periodic_count;
	unsigned int uframe_periodic_max;
	struct list_head cached_itd_list;
	struct ehci_itd *last_itd_to_free;
	struct list_head cached_sitd_list;
	struct ehci_sitd *last_sitd_to_free;
	long unsigned int reset_done[15];
	long unsigned int bus_suspended;
	long unsigned int companion_ports;
	long unsigned int owned_ports;
	long unsigned int port_c_suspend;
	long unsigned int suspended_ports;
	long unsigned int resuming_ports;
	struct dma_pool *qh_pool;
	struct dma_pool *qtd_pool;
	struct dma_pool *itd_pool;
	struct dma_pool *sitd_pool;
	unsigned int random_frame;
	long unsigned int next_statechange;
	ktime_t last_periodic_enable;
	u32 command;
	unsigned int no_selective_suspend: 1;
	unsigned int has_fsl_port_bug: 1;
	unsigned int has_fsl_hs_errata: 1;
	unsigned int has_fsl_susp_errata: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int big_endian_desc: 1;
	unsigned int big_endian_capbase: 1;
	unsigned int has_amcc_usb23: 1;
	unsigned int need_io_watchdog: 1;
	unsigned int amd_pll_fix: 1;
	unsigned int use_dummy_qh: 1;
	unsigned int has_synopsys_hc_bug: 1;
	unsigned int frame_index_bug: 1;
	unsigned int need_oc_pp_cycle: 1;
	unsigned int imx28_write_fix: 1;
	__le32 *ohci_hcctrl_reg;
	unsigned int has_hostpc: 1;
	unsigned int has_tdi_phy_lpm: 1;
	unsigned int has_ppcd: 1;
	u8 sbrn;
	struct ehci_stats stats;
	struct dentry *debug_dir;
	u8 bandwidth[64];
	u8 tt_budget[64];
	struct list_head tt_list;
	long unsigned int priv[0];
};

struct ehci_caps {
	u32 hc_capbase;
	u32 hcs_params;
	u32 hcc_params;
	u8 portroute[8];
};

struct ehci_regs {
	u32 command;
	u32 status;
	u32 intr_enable;
	u32 frame_index;
	u32 segment;
	u32 frame_list;
	u32 async_next;
	u32 reserved1[2];
	u32 txfill_tuning;
	u32 reserved2[6];
	u32 configured_flag;
	u32 port_status[0];
	u32 reserved3[9];
	u32 usbmode;
	u32 reserved4[6];
	u32 hostpc[0];
	u32 reserved5[17];
	u32 usbmode_ex;
};

struct ehci_dbg_port {
	u32 control;
	u32 pids;
	u32 data03;
	u32 data47;
	u32 address;
};

struct ehci_fstn;

union ehci_shadow {
	struct ehci_qh *qh;
	struct ehci_itd *itd;
	struct ehci_sitd *sitd;
	struct ehci_fstn *fstn;
	__le32 *hw_next;
	void *ptr;
};

struct ehci_qh_hw;

struct ehci_qtd;

struct ehci_qh {
	struct ehci_qh_hw *hw;
	dma_addr_t qh_dma;
	union ehci_shadow qh_next;
	struct list_head qtd_list;
	struct list_head intr_node;
	struct ehci_qtd *dummy;
	struct list_head unlink_node;
	struct ehci_per_sched ps;
	unsigned int unlink_cycle;
	u8 qh_state;
	u8 xacterrs;
	u8 unlink_reason;
	u8 gap_uf;
	unsigned int is_out: 1;
	unsigned int clearing_tt: 1;
	unsigned int dequeue_during_giveback: 1;
	unsigned int should_be_inactive: 1;
};

struct ehci_iso_stream;

struct ehci_itd {
	__le32 hw_next;
	__le32 hw_transaction[8];
	__le32 hw_bufp[7];
	__le32 hw_bufp_hi[7];
	dma_addr_t itd_dma;
	union ehci_shadow itd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head itd_list;
	unsigned int frame;
	unsigned int pg;
	unsigned int index[8];
	long: 64;
};

struct ehci_sitd {
	__le32 hw_next;
	__le32 hw_fullspeed_ep;
	__le32 hw_uframe;
	__le32 hw_results;
	__le32 hw_buf[2];
	__le32 hw_backpointer;
	__le32 hw_buf_hi[2];
	dma_addr_t sitd_dma;
	union ehci_shadow sitd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head sitd_list;
	unsigned int frame;
	unsigned int index;
};

struct ehci_qtd {
	__le32 hw_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	dma_addr_t qtd_dma;
	struct list_head qtd_list;
	struct urb *urb;
	size_t length;
};

struct ehci_fstn {
	__le32 hw_next;
	__le32 hw_prev;
	dma_addr_t fstn_dma;
	union ehci_shadow fstn_next;
	long: 64;
};

struct ehci_qh_hw {
	__le32 hw_next;
	__le32 hw_info1;
	__le32 hw_info2;
	__le32 hw_current;
	__le32 hw_qtd_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	long: 32;
	long: 64;
	long: 64;
	long: 64;
};

struct ehci_iso_packet {
	u64 bufp;
	__le32 transaction;
	u8 cross;
	u32 buf1;
};

struct ehci_iso_sched {
	struct list_head td_list;
	unsigned int span;
	unsigned int first_packet;
	struct ehci_iso_packet packet[0];
};

struct ehci_iso_stream {
	struct ehci_qh_hw *hw;
	u8 bEndpointAddress;
	u8 highspeed;
	struct list_head td_list;
	struct list_head free_list;
	struct ehci_per_sched ps;
	unsigned int next_uframe;
	__le32 splits;
	u16 uperiod;
	u16 maxp;
	unsigned int bandwidth;
	__le32 buf0;
	__le32 buf1;
	__le32 buf2;
	__le32 address;
};

struct ehci_tt {
	u16 bandwidth[8];
	struct list_head tt_list;
	struct list_head ps_list;
	struct usb_tt *usb_tt;
	int tt_port;
};

struct ehci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*port_power)(struct usb_hcd *, int, bool);
};

struct debug_buffer {
	ssize_t (*fill_func)(struct debug_buffer *);
	struct usb_bus *bus;
	struct mutex mutex;
	size_t count;
	char *output_buf;
	size_t alloc_size;
};

typedef __u32 __hc32;

typedef __u16 __hc16;

struct td;

struct ed {
	__hc32 hwINFO;
	__hc32 hwTailP;
	__hc32 hwHeadP;
	__hc32 hwNextED;
	dma_addr_t dma;
	struct td *dummy;
	struct ed *ed_next;
	struct ed *ed_prev;
	struct list_head td_list;
	struct list_head in_use_list;
	u8 state;
	u8 type;
	u8 branch;
	u16 interval;
	u16 load;
	u16 last_iso;
	u16 tick;
	unsigned int takeback_wdh_cnt;
	struct td *pending_td;
	long: 64;
};

struct td {
	__hc32 hwINFO;
	__hc32 hwCBP;
	__hc32 hwNextTD;
	__hc32 hwBE;
	__hc16 hwPSW[2];
	__u8 index;
	struct ed *ed;
	struct td *td_hash;
	struct td *next_dl_td;
	struct urb *urb;
	dma_addr_t td_dma;
	dma_addr_t data_dma;
	struct list_head td_list;
	long: 64;
};

struct ohci_hcca {
	__hc32 int_table[32];
	__hc32 frame_no;
	__hc32 done_head;
	u8 reserved_for_hc[116];
	u8 what[4];
};

struct ohci_roothub_regs {
	__hc32 a;
	__hc32 b;
	__hc32 status;
	__hc32 portstatus[15];
};

struct ohci_regs {
	__hc32 revision;
	__hc32 control;
	__hc32 cmdstatus;
	__hc32 intrstatus;
	__hc32 intrenable;
	__hc32 intrdisable;
	__hc32 hcca;
	__hc32 ed_periodcurrent;
	__hc32 ed_controlhead;
	__hc32 ed_controlcurrent;
	__hc32 ed_bulkhead;
	__hc32 ed_bulkcurrent;
	__hc32 donehead;
	__hc32 fminterval;
	__hc32 fmremaining;
	__hc32 fmnumber;
	__hc32 periodicstart;
	__hc32 lsthresh;
	struct ohci_roothub_regs roothub;
	long: 64;
	long: 64;
};

struct urb_priv {
	struct ed *ed;
	u16 length;
	u16 td_cnt;
	struct list_head pending;
	struct td *td[0];
};

typedef struct urb_priv urb_priv_t;

enum ohci_rh_state {
	OHCI_RH_HALTED = 0,
	OHCI_RH_SUSPENDED = 1,
	OHCI_RH_RUNNING = 2,
};

struct ohci_hcd {
	spinlock_t lock;
	struct ohci_regs *regs;
	struct ohci_hcca *hcca;
	dma_addr_t hcca_dma;
	struct ed *ed_rm_list;
	struct ed *ed_bulktail;
	struct ed *ed_controltail;
	struct ed *periodic[32];
	void (*start_hnp)(struct ohci_hcd *);
	struct dma_pool *td_cache;
	struct dma_pool *ed_cache;
	struct td *td_hash[64];
	struct td *dl_start;
	struct td *dl_end;
	struct list_head pending;
	struct list_head eds_in_use;
	enum ohci_rh_state rh_state;
	int num_ports;
	int load[32];
	u32 hc_control;
	long unsigned int next_statechange;
	u32 fminterval;
	unsigned int autostop: 1;
	unsigned int working: 1;
	unsigned int restart_work: 1;
	long unsigned int flags;
	unsigned int prev_frame_no;
	unsigned int wdh_cnt;
	unsigned int prev_wdh_cnt;
	u32 prev_donehead;
	struct timer_list io_watchdog;
	struct work_struct nec_work;
	struct dentry *debug_dir;
	long unsigned int priv[0];
};

struct ohci_driver_overrides {
	const char *product_desc;
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
};

struct debug_buffer___2 {
	ssize_t (*fill_func)(struct debug_buffer___2 *);
	struct ohci_hcd *ohci;
	struct mutex mutex;
	size_t count;
	char *page;
};

struct uhci_td;

struct uhci_qh {
	__le32 link;
	__le32 element;
	dma_addr_t dma_handle;
	struct list_head node;
	struct usb_host_endpoint *hep;
	struct usb_device *udev;
	struct list_head queue;
	struct uhci_td *dummy_td;
	struct uhci_td *post_td;
	struct usb_iso_packet_descriptor *iso_packet_desc;
	long unsigned int advance_jiffies;
	unsigned int unlink_frame;
	unsigned int period;
	short int phase;
	short int load;
	unsigned int iso_frame;
	int state;
	int type;
	int skel;
	unsigned int initial_toggle: 1;
	unsigned int needs_fixup: 1;
	unsigned int is_stopped: 1;
	unsigned int wait_expired: 1;
	unsigned int bandwidth_reserved: 1;
};

struct uhci_td {
	__le32 link;
	__le32 status;
	__le32 token;
	__le32 buffer;
	dma_addr_t dma_handle;
	struct list_head list;
	int frame;
	struct list_head fl_list;
};

enum uhci_rh_state {
	UHCI_RH_RESET = 0,
	UHCI_RH_SUSPENDED = 1,
	UHCI_RH_AUTO_STOPPED = 2,
	UHCI_RH_RESUMING = 3,
	UHCI_RH_SUSPENDING = 4,
	UHCI_RH_RUNNING = 5,
	UHCI_RH_RUNNING_NODEVS = 6,
};

struct uhci_hcd {
	struct dentry *dentry;
	long unsigned int io_addr;
	void *regs;
	struct dma_pool *qh_pool;
	struct dma_pool *td_pool;
	struct uhci_td *term_td;
	struct uhci_qh *skelqh[11];
	struct uhci_qh *next_qh;
	spinlock_t lock;
	dma_addr_t frame_dma_handle;
	__le32 *frame;
	void **frame_cpu;
	enum uhci_rh_state rh_state;
	long unsigned int auto_stop_time;
	unsigned int frame_number;
	unsigned int is_stopped;
	unsigned int last_iso_frame;
	unsigned int cur_iso_frame;
	unsigned int scan_in_progress: 1;
	unsigned int need_rescan: 1;
	unsigned int dead: 1;
	unsigned int RD_enable: 1;
	unsigned int is_initialized: 1;
	unsigned int fsbr_is_on: 1;
	unsigned int fsbr_is_wanted: 1;
	unsigned int fsbr_expiring: 1;
	struct timer_list fsbr_timer;
	unsigned int oc_low: 1;
	unsigned int wait_for_hp: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int big_endian_desc: 1;
	unsigned int is_aspeed: 1;
	long unsigned int port_c_suspend;
	long unsigned int resuming_ports;
	long unsigned int ports_timeout;
	struct list_head idle_qh_list;
	int rh_numports;
	wait_queue_head_t waitqh;
	int num_waiting;
	int total_load;
	short int load[32];
	struct clk *clk;
	void (*reset_hc)(struct uhci_hcd *);
	int (*check_and_reset_hc)(struct uhci_hcd *);
	void (*configure_hc)(struct uhci_hcd *);
	int (*resume_detect_interrupts_are_broken)(struct uhci_hcd *);
	int (*global_suspend_mode_is_broken)(struct uhci_hcd *);
};

struct urb_priv___2 {
	struct list_head node;
	struct urb *urb;
	struct uhci_qh *qh;
	struct list_head td_list;
	unsigned int fsbr: 1;
};

struct uhci_debug {
	int size;
	char *data;
};

struct xhci_cap_regs {
	__le32 hc_capbase;
	__le32 hcs_params1;
	__le32 hcs_params2;
	__le32 hcs_params3;
	__le32 hcc_params;
	__le32 db_off;
	__le32 run_regs_off;
	__le32 hcc_params2;
};

struct xhci_op_regs {
	__le32 command;
	__le32 status;
	__le32 page_size;
	__le32 reserved1;
	__le32 reserved2;
	__le32 dev_notification;
	__le64 cmd_ring;
	__le32 reserved3[4];
	__le64 dcbaa_ptr;
	__le32 config_reg;
	__le32 reserved4[241];
	__le32 port_status_base;
	__le32 port_power_base;
	__le32 port_link_base;
	__le32 reserved5;
	__le32 reserved6[1016];
};

struct xhci_intr_reg {
	__le32 irq_pending;
	__le32 irq_control;
	__le32 erst_size;
	__le32 rsvd;
	__le64 erst_base;
	__le64 erst_dequeue;
};

struct xhci_run_regs {
	__le32 microframe_index;
	__le32 rsvd[7];
	struct xhci_intr_reg ir_set[128];
};

struct xhci_doorbell_array {
	__le32 doorbell[256];
};

struct xhci_container_ctx {
	unsigned int type;
	int size;
	u8 *bytes;
	dma_addr_t dma;
};

struct xhci_slot_ctx {
	__le32 dev_info;
	__le32 dev_info2;
	__le32 tt_info;
	__le32 dev_state;
	__le32 reserved[4];
};

struct xhci_ep_ctx {
	__le32 ep_info;
	__le32 ep_info2;
	__le64 deq;
	__le32 tx_info;
	__le32 reserved[3];
};

struct xhci_input_control_ctx {
	__le32 drop_flags;
	__le32 add_flags;
	__le32 rsvd2[6];
};

union xhci_trb;

struct xhci_command {
	struct xhci_container_ctx *in_ctx;
	u32 status;
	int slot_id;
	struct completion *completion;
	union xhci_trb *command_trb;
	struct list_head cmd_list;
};

struct xhci_link_trb {
	__le64 segment_ptr;
	__le32 intr_target;
	__le32 control;
};

struct xhci_transfer_event {
	__le64 buffer;
	__le32 transfer_len;
	__le32 flags;
};

struct xhci_event_cmd {
	__le64 cmd_trb;
	__le32 status;
	__le32 flags;
};

struct xhci_generic_trb {
	__le32 field[4];
};

union xhci_trb {
	struct xhci_link_trb link;
	struct xhci_transfer_event trans_event;
	struct xhci_event_cmd event_cmd;
	struct xhci_generic_trb generic;
};

struct xhci_stream_ctx {
	__le64 stream_ring;
	__le32 reserved[2];
};

struct xhci_ring;

struct xhci_stream_info {
	struct xhci_ring **stream_rings;
	unsigned int num_streams;
	struct xhci_stream_ctx *stream_ctx_array;
	unsigned int num_stream_ctxs;
	dma_addr_t ctx_array_dma;
	struct xarray trb_address_map;
	struct xhci_command *free_streams_command;
};

enum xhci_ring_type {
	TYPE_CTRL = 0,
	TYPE_ISOC = 1,
	TYPE_BULK = 2,
	TYPE_INTR = 3,
	TYPE_STREAM = 4,
	TYPE_COMMAND = 5,
	TYPE_EVENT = 6,
};

struct xhci_segment;

struct xhci_ring {
	struct xhci_segment *first_seg;
	struct xhci_segment *last_seg;
	union xhci_trb *enqueue;
	struct xhci_segment *enq_seg;
	union xhci_trb *dequeue;
	struct xhci_segment *deq_seg;
	struct list_head td_list;
	u32 cycle_state;
	unsigned int err_count;
	unsigned int stream_id;
	unsigned int num_segs;
	unsigned int num_trbs_free;
	unsigned int num_trbs_free_temp;
	unsigned int bounce_buf_len;
	enum xhci_ring_type type;
	bool last_td_was_short;
	struct xarray *trb_address_map;
};

struct xhci_bw_info {
	unsigned int ep_interval;
	unsigned int mult;
	unsigned int num_packets;
	unsigned int max_packet_size;
	unsigned int max_esit_payload;
	unsigned int type;
};

struct xhci_hcd;

struct xhci_virt_ep {
	struct xhci_ring *ring;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *new_ring;
	unsigned int ep_state;
	struct list_head cancelled_td_list;
	struct timer_list stop_cmd_timer;
	struct xhci_hcd *xhci;
	struct xhci_segment *queued_deq_seg;
	union xhci_trb *queued_deq_ptr;
	bool skip;
	struct xhci_bw_info bw_info;
	struct list_head bw_endpoint_list;
	int next_frame_id;
	bool use_extended_tbc;
};

struct xhci_erst_entry;

struct xhci_erst {
	struct xhci_erst_entry *entries;
	unsigned int num_entries;
	dma_addr_t erst_dma_addr;
	unsigned int erst_size;
};

struct s3_save {
	u32 command;
	u32 dev_nt;
	u64 dcbaa_ptr;
	u32 config_reg;
	u32 irq_pending;
	u32 irq_control;
	u32 erst_size;
	u64 erst_base;
	u64 erst_dequeue;
};

struct xhci_bus_state {
	long unsigned int bus_suspended;
	long unsigned int next_statechange;
	u32 port_c_suspend;
	u32 suspended_ports;
	u32 port_remote_wakeup;
	long unsigned int resume_done[31];
	long unsigned int resuming_ports;
	long unsigned int rexit_ports;
	struct completion rexit_done[31];
	struct completion u3exit_done[31];
};

struct xhci_port;

struct xhci_hub {
	struct xhci_port **ports;
	unsigned int num_ports;
	struct usb_hcd *hcd;
	struct xhci_bus_state bus_state;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_device_context_array;

struct xhci_scratchpad;

struct xhci_virt_device;

struct xhci_root_port_bw_info;

struct xhci_port_cap;

struct xhci_hcd {
	struct usb_hcd *main_hcd;
	struct usb_hcd *shared_hcd;
	struct xhci_cap_regs *cap_regs;
	struct xhci_op_regs *op_regs;
	struct xhci_run_regs *run_regs;
	struct xhci_doorbell_array *dba;
	struct xhci_intr_reg *ir_set;
	__u32 hcs_params1;
	__u32 hcs_params2;
	__u32 hcs_params3;
	__u32 hcc_params;
	__u32 hcc_params2;
	spinlock_t lock;
	u8 sbrn;
	u16 hci_version;
	u8 max_slots;
	u8 max_interrupters;
	u8 max_ports;
	u8 isoc_threshold;
	u32 imod_interval;
	int event_ring_max;
	int page_size;
	int page_shift;
	int msix_count;
	struct clk *clk;
	struct clk *reg_clk;
	struct xhci_device_context_array *dcbaa;
	struct xhci_ring *cmd_ring;
	unsigned int cmd_ring_state;
	struct list_head cmd_list;
	unsigned int cmd_ring_reserved_trbs;
	struct delayed_work cmd_timer;
	struct completion cmd_ring_stop_completion;
	struct xhci_command *current_cmd;
	struct xhci_ring *event_ring;
	struct xhci_erst erst;
	struct xhci_scratchpad *scratchpad;
	struct list_head lpm_failed_devs;
	struct mutex mutex;
	struct xhci_command *lpm_command;
	struct xhci_virt_device *devs[256];
	struct xhci_root_port_bw_info *rh_bw;
	struct dma_pool *device_pool;
	struct dma_pool *segment_pool;
	struct dma_pool *small_streams_pool;
	struct dma_pool *medium_streams_pool;
	unsigned int xhc_state;
	u32 command;
	struct s3_save s3;
	long long unsigned int quirks;
	unsigned int num_active_eps;
	unsigned int limit_active_eps;
	struct xhci_port *hw_ports;
	struct xhci_hub usb2_rhub;
	struct xhci_hub usb3_rhub;
	unsigned int hw_lpm_support: 1;
	unsigned int broken_suspend: 1;
	u32 *ext_caps;
	unsigned int num_ext_caps;
	struct xhci_port_cap *port_caps;
	unsigned int num_port_caps;
	struct timer_list comp_mode_recovery_timer;
	u32 port_status_u0;
	u16 test_mode;
	struct dentry *debugfs_root;
	struct dentry *debugfs_slots;
	struct list_head regset_list;
	void *dbc;
	long unsigned int priv[0];
};

struct xhci_segment {
	union xhci_trb *trbs;
	struct xhci_segment *next;
	dma_addr_t dma;
	dma_addr_t bounce_dma;
	void *bounce_buf;
	unsigned int bounce_offs;
	unsigned int bounce_len;
};

enum xhci_overhead_type {
	LS_OVERHEAD_TYPE = 0,
	FS_OVERHEAD_TYPE = 1,
	HS_OVERHEAD_TYPE = 2,
};

struct xhci_interval_bw {
	unsigned int num_packets;
	struct list_head endpoints;
	unsigned int overhead[3];
};

struct xhci_interval_bw_table {
	unsigned int interval0_esit_payload;
	struct xhci_interval_bw interval_bw[16];
	unsigned int bw_used;
	unsigned int ss_bw_in;
	unsigned int ss_bw_out;
};

struct xhci_tt_bw_info;

struct xhci_virt_device {
	struct usb_device *udev;
	struct xhci_container_ctx *out_ctx;
	struct xhci_container_ctx *in_ctx;
	struct xhci_virt_ep eps[31];
	u8 fake_port;
	u8 real_port;
	struct xhci_interval_bw_table *bw_table;
	struct xhci_tt_bw_info *tt_info;
	long unsigned int flags;
	u16 current_mel;
	void *debugfs_private;
};

struct xhci_tt_bw_info {
	struct list_head tt_list;
	int slot_id;
	int ttport;
	struct xhci_interval_bw_table bw_table;
	int active_eps;
};

struct xhci_root_port_bw_info {
	struct list_head tts;
	unsigned int num_active_tts;
	struct xhci_interval_bw_table bw_table;
};

struct xhci_device_context_array {
	__le64 dev_context_ptrs[256];
	dma_addr_t dma;
};

enum xhci_setup_dev {
	SETUP_CONTEXT_ONLY = 0,
	SETUP_CONTEXT_ADDRESS = 1,
};

struct xhci_td {
	struct list_head td_list;
	struct list_head cancelled_td_list;
	struct urb *urb;
	struct xhci_segment *start_seg;
	union xhci_trb *first_trb;
	union xhci_trb *last_trb;
	struct xhci_segment *bounce_seg;
	bool urb_length_set;
};

struct xhci_dequeue_state {
	struct xhci_segment *new_deq_seg;
	union xhci_trb *new_deq_ptr;
	int new_cycle_state;
	unsigned int stream_id;
};

struct xhci_erst_entry {
	__le64 seg_addr;
	__le32 seg_size;
	__le32 rsvd;
};

struct xhci_scratchpad {
	u64 *sp_array;
	dma_addr_t sp_dma;
	void **sp_buffers;
};

struct urb_priv___3 {
	int num_tds;
	int num_tds_done;
	struct xhci_td td[0];
};

struct xhci_port_cap {
	u32 *psi;
	u8 psi_count;
	u8 psi_uid_count;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_port {
	__le32 *addr;
	int hw_portnum;
	int hcd_portnum;
	struct xhci_hub *rhub;
	struct xhci_port_cap *port_cap;
};

struct xhci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
};

typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);

enum xhci_ep_reset_type {
	EP_HARD_RESET = 0,
	EP_SOFT_RESET = 1,
};

struct dbc_regs {
	__le32 capability;
	__le32 doorbell;
	__le32 ersts;
	__le32 __reserved_0;
	__le64 erstba;
	__le64 erdp;
	__le32 control;
	__le32 status;
	__le32 portsc;
	__le32 __reserved_1;
	__le64 dccp;
	__le32 devinfo1;
	__le32 devinfo2;
};

struct dbc_str_descs {
	char string0[64];
	char manufacturer[64];
	char product[64];
	char serial[64];
};

enum dbc_state {
	DS_DISABLED = 0,
	DS_INITIALIZED = 1,
	DS_ENABLED = 2,
	DS_CONNECTED = 3,
	DS_CONFIGURED = 4,
	DS_STALLED = 5,
};

struct dbc_ep;

struct dbc_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	void (*complete)(struct xhci_hcd *, struct dbc_request *);
	struct list_head list_pool;
	int status;
	unsigned int actual;
	struct dbc_ep *dep;
	struct list_head list_pending;
	dma_addr_t trb_dma;
	union xhci_trb *trb;
	unsigned int direction: 1;
};

struct xhci_dbc;

struct dbc_ep {
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	struct xhci_ring *ring;
	unsigned int direction: 1;
};

struct dbc_port {
	struct tty_port port;
	spinlock_t port_lock;
	struct list_head read_pool;
	struct list_head read_queue;
	unsigned int n_read;
	struct tasklet_struct push;
	struct list_head write_pool;
	struct kfifo write_fifo;
	bool registered;
	struct dbc_ep *in;
	struct dbc_ep *out;
};

struct xhci_dbc {
	spinlock_t lock;
	struct xhci_hcd *xhci;
	struct dbc_regs *regs;
	struct xhci_ring *ring_evt;
	struct xhci_ring *ring_in;
	struct xhci_ring *ring_out;
	struct xhci_erst erst;
	struct xhci_container_ctx *ctx;
	struct dbc_str_descs *string;
	dma_addr_t string_dma;
	size_t string_size;
	enum dbc_state state;
	struct delayed_work event_work;
	unsigned int resume_required: 1;
	struct dbc_ep eps[2];
	struct dbc_port port;
};

struct trace_event_raw_xhci_log_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctx {
	struct trace_entry ent;
	int ctx_64;
	unsigned int ctx_type;
	dma_addr_t ctx_dma;
	u8 *ctx_va;
	unsigned int ctx_ep_num;
	int slot_id;
	u32 __data_loc_ctx_data;
	char __data[0];
};

struct trace_event_raw_xhci_log_trb {
	struct trace_entry ent;
	u32 type;
	u32 field0;
	u32 field1;
	u32 field2;
	u32 field3;
	char __data[0];
};

struct trace_event_raw_xhci_log_free_virt_dev {
	struct trace_entry ent;
	void *vdev;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	u8 fake_port;
	u8 real_port;
	u16 current_mel;
	char __data[0];
};

struct trace_event_raw_xhci_log_virt_dev {
	struct trace_entry ent;
	void *vdev;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	int devnum;
	int state;
	int speed;
	u8 portnum;
	u8 level;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_urb {
	struct trace_entry ent;
	void *urb;
	unsigned int pipe;
	unsigned int stream;
	int status;
	unsigned int flags;
	int num_mapped_sgs;
	int num_sgs;
	int length;
	int actual;
	int epnum;
	int dir_in;
	int type;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_ep_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u64 deq;
	u32 tx_info;
	char __data[0];
};

struct trace_event_raw_xhci_log_slot_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u32 tt_info;
	u32 state;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctrl_ctx {
	struct trace_entry ent;
	u32 drop;
	u32 add;
	char __data[0];
};

struct trace_event_raw_xhci_log_ring {
	struct trace_entry ent;
	u32 type;
	void *ring;
	dma_addr_t enq;
	dma_addr_t deq;
	dma_addr_t enq_seg;
	dma_addr_t deq_seg;
	unsigned int num_segs;
	unsigned int stream_id;
	unsigned int cycle_state;
	unsigned int num_trbs_free;
	unsigned int bounce_buf_len;
	char __data[0];
};

struct trace_event_raw_xhci_log_portsc {
	struct trace_entry ent;
	u32 portnum;
	u32 portsc;
	char __data[0];
};

struct trace_event_raw_xhci_dbc_log_request {
	struct trace_entry ent;
	struct dbc_request *req;
	bool dir;
	unsigned int actual;
	unsigned int length;
	int status;
	char __data[0];
};

struct trace_event_data_offsets_xhci_log_msg {
	u32 msg;
};

struct trace_event_data_offsets_xhci_log_ctx {
	u32 ctx_data;
};

struct trace_event_data_offsets_xhci_log_trb {};

struct trace_event_data_offsets_xhci_log_free_virt_dev {};

struct trace_event_data_offsets_xhci_log_virt_dev {};

struct trace_event_data_offsets_xhci_log_urb {};

struct trace_event_data_offsets_xhci_log_ep_ctx {};

struct trace_event_data_offsets_xhci_log_slot_ctx {};

struct trace_event_data_offsets_xhci_log_ctrl_ctx {};

struct trace_event_data_offsets_xhci_log_ring {};

struct trace_event_data_offsets_xhci_log_portsc {};

struct trace_event_data_offsets_xhci_dbc_log_request {};

typedef void (*btf_trace_xhci_dbg_address)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_context_change)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_quirks)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_reset_ep)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_cancel_urb)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_init)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_ring_expansion)(void *, struct va_format *);

typedef void (*btf_trace_xhci_address_ctx)(void *, struct xhci_hcd *, struct xhci_container_ctx *, unsigned int);

typedef void (*btf_trace_xhci_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_command)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_queue_trb)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_gadget_ep_queue)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_free_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_alloc_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_addressable_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_stop_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_urb_enqueue)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_giveback)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_dequeue)(void *, struct urb *);

typedef void (*btf_trace_xhci_handle_cmd_stop_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_config_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_add_endpoint)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_alloc_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_free_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_disable_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_discover_or_reset_device)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_setup_device_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_addr_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_address_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_ring_alloc)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_free)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_expansion)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_enq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_deq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_handle_port_status)(void *, u32, u32);

typedef void (*btf_trace_xhci_get_port_status)(void *, u32, u32);

typedef void (*btf_trace_xhci_hub_status_data)(void *, u32, u32);

typedef void (*btf_trace_xhci_dbc_alloc_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_free_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_queue_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_giveback_request)(void *, struct dbc_request *);

struct xhci_regset {
	char name[32];
	struct debugfs_regset32 regset;
	size_t nregs;
	struct list_head list;
};

struct xhci_file_map {
	const char *name;
	int (*show)(struct seq_file___2 *, void *);
};

struct xhci_ep_priv {
	char name[32];
	struct dentry___2 *root;
};

struct xhci_slot_priv {
	char name[32];
	struct dentry___2 *root;
	struct xhci_ep_priv *eps[31];
	struct xhci_virt_device *dev;
};

struct usb_debug_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDebugInEndpoint;
	__u8 bDebugOutEndpoint;
};

struct ehci_dev {
	u32 bus;
	u32 slot;
	u32 func;
};

typedef void (*set_debug_port_t)(int);

struct usb_hcd;

struct serio_device_id {
	__u8 type;
	__u8 extra;
	__u8 id;
	__u8 proto;
};

struct serio_driver;

struct serio {
	void *port_data;
	char name[32];
	char phys[32];
	char firmware_id[128];
	bool manual_bind;
	struct serio_device_id id;
	spinlock_t lock;
	int (*write)(struct serio *, unsigned char);
	int (*open)(struct serio *);
	void (*close)(struct serio *);
	int (*start)(struct serio *);
	void (*stop)(struct serio *);
	struct serio *parent;
	struct list_head child_node;
	struct list_head children;
	unsigned int depth;
	struct serio_driver *drv;
	struct mutex drv_mutex;
	struct device___2 dev;
	struct list_head node;
	struct mutex *ps2_cmd_mutex;
};

struct serio_driver {
	const char *description;
	const struct serio_device_id *id_table;
	bool manual_bind;
	void (*write_wakeup)(struct serio *);
	irqreturn_t (*interrupt)(struct serio *, unsigned char, unsigned int);
	int (*connect)(struct serio *, struct serio_driver *);
	int (*reconnect)(struct serio *);
	int (*fast_reconnect)(struct serio *);
	void (*disconnect)(struct serio *);
	void (*cleanup)(struct serio *);
	struct device_driver___2 driver;
};

enum serio_event_type {
	SERIO_RESCAN_PORT = 0,
	SERIO_RECONNECT_PORT = 1,
	SERIO_RECONNECT_SUBTREE = 2,
	SERIO_REGISTER_PORT = 3,
	SERIO_ATTACH_DRIVER = 4,
};

struct serio_event {
	enum serio_event_type type;
	void *object;
	struct module___2 *owner;
	struct list_head node;
};

enum i8042_controller_reset_mode {
	I8042_RESET_NEVER = 0,
	I8042_RESET_ALWAYS = 1,
	I8042_RESET_ON_S2RAM = 2,
};

struct i8042_port {
	struct serio *serio;
	int irq;
	bool exists;
	bool driver_bound;
	signed char mux;
};

struct serport {
	struct tty_struct *tty;
	wait_queue_head_t wait;
	struct serio *serio;
	struct serio_device_id id;
	spinlock_t lock;
	long unsigned int flags;
};

struct ps2dev {
	struct serio *serio;
	struct mutex cmd_mutex;
	wait_queue_head_t wait;
	long unsigned int flags;
	u8 cmdbuf[8];
	u8 cmdcnt;
	u8 nak;
};

struct serio_raw {
	unsigned char queue[64];
	unsigned int tail;
	unsigned int head;
	char name[16];
	struct kref kref;
	struct serio *serio;
	struct miscdevice dev;
	wait_queue_head_t wait;
	struct list_head client_list;
	struct list_head node;
	bool dead;
};

struct serio_raw_client {
	struct fasync_struct___2 *fasync;
	struct serio_raw *serio_raw;
	struct list_head node;
};

struct ps2if {
	struct serio *io;
	void *base;
};

struct arc_ps2_port {
	void *data_addr;
	void *status_addr;
	struct serio *io;
};

struct arc_ps2_data {
	struct arc_ps2_port port[2];
	void *addr;
	unsigned int frame_error;
	unsigned int buf_overflow;
	unsigned int total_int;
};

struct input_mt_slot {
	int abs[14];
	unsigned int frame;
	unsigned int key;
};

struct input_mt {
	int trkid;
	int num_slots;
	int slot;
	unsigned int flags;
	unsigned int frame;
	int *red;
	struct input_mt_slot slots[0];
};

union input_seq_state {
	struct {
		short unsigned int pos;
		bool mutex_acquired;
	};
	void *p;
};

struct input_devres {
	struct input_dev *input;
};

struct input_event {
	__kernel_ulong_t __sec;
	__kernel_ulong_t __usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct input_event_compat {
	compat_ulong_t sec;
	compat_ulong_t usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct ff_periodic_effect_compat {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	compat_uptr_t custom_data;
};

struct ff_effect_compat {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect_compat periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_mt_pos {
	s16 x;
	s16 y;
};

struct input_dev_poller {
	void (*poll)(struct input_dev *);
	unsigned int poll_interval;
	unsigned int poll_interval_max;
	unsigned int poll_interval_min;
	struct input_dev *input;
	struct delayed_work work;
};

struct ml_effect_state {
	struct ff_effect *effect;
	long unsigned int flags;
	int count;
	long unsigned int play_at;
	long unsigned int stop_at;
	long unsigned int adj_at;
};

struct ml_device {
	void *private;
	struct ml_effect_state states[16];
	int gain;
	struct timer_list timer;
	struct input_dev *dev;
	int (*play_effect)(struct input_dev *, void *, struct ff_effect *);
};

struct mousedev_hw_data {
	int dx;
	int dy;
	int dz;
	int x;
	int y;
	int abs_event;
	long unsigned int buttons;
};

struct mousedev {
	int open;
	struct input_handle handle;
	wait_queue_head_t wait;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device___2 dev;
	struct cdev cdev;
	bool exist;
	struct list_head mixdev_node;
	bool opened_by_mixdev;
	struct mousedev_hw_data packet;
	unsigned int pkt_count;
	int old_x[4];
	int old_y[4];
	int frac_dx;
	int frac_dy;
	long unsigned int touch;
	int (*open_device)(struct mousedev *);
	void (*close_device)(struct mousedev *);
};

enum mousedev_emul {
	MOUSEDEV_EMUL_PS2 = 0,
	MOUSEDEV_EMUL_IMPS = 1,
	MOUSEDEV_EMUL_EXPS = 2,
};

struct mousedev_motion {
	int dx;
	int dy;
	int dz;
	long unsigned int buttons;
};

struct mousedev_client {
	struct fasync_struct___2 *fasync;
	struct mousedev *mousedev;
	struct list_head node;
	struct mousedev_motion packets[16];
	unsigned int head;
	unsigned int tail;
	spinlock_t packet_lock;
	int pos_x;
	int pos_y;
	u8 ps2[6];
	unsigned char ready;
	unsigned char buffer;
	unsigned char bufsiz;
	unsigned char imexseq;
	unsigned char impsseq;
	enum mousedev_emul mode;
	long unsigned int last_buttons;
};

enum {
	FRACTION_DENOM = 128,
};

struct input_mask {
	__u32 type;
	__u32 codes_size;
	__u64 codes_ptr;
};

struct evdev_client;

struct evdev {
	int open;
	struct input_handle handle;
	wait_queue_head_t wait;
	struct evdev_client *grab;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device___2 dev;
	struct cdev cdev;
	bool exist;
};

struct evdev_client {
	unsigned int head;
	unsigned int tail;
	unsigned int packet_head;
	spinlock_t buffer_lock;
	struct fasync_struct___2 *fasync;
	struct evdev *evdev;
	struct list_head node;
	enum input_clock_type clk_type;
	bool revoked;
	long unsigned int *evmasks[32];
	unsigned int bufsize;
	struct input_event buffer[0];
};

struct atkbd {
	struct ps2dev ps2dev;
	struct input_dev *dev;
	char name[64];
	char phys[32];
	short unsigned int id;
	short unsigned int keycode[512];
	long unsigned int force_release_mask[8];
	unsigned char set;
	bool translated;
	bool extra;
	bool write;
	bool softrepeat;
	bool softraw;
	bool scroll;
	bool enabled;
	unsigned char emul;
	bool resend;
	bool release;
	long unsigned int xl_bit;
	unsigned int last;
	long unsigned int time;
	long unsigned int err_count;
	struct delayed_work event_work;
	long unsigned int event_jiffies;
	long unsigned int event_mask;
	struct mutex mutex;
};

struct sunkbd {
	unsigned char keycode[128];
	struct input_dev *dev;
	struct serio *serio;
	struct work_struct tq;
	wait_queue_head_t wait;
	char name[64];
	char phys[32];
	char type;
	bool enabled;
	volatile s8 reset;
	volatile s8 layout;
};

struct xtkbd {
	unsigned char keycode[256];
	struct input_dev *dev;
	struct serio *serio;
	char phys[32];
};

enum psmouse_state {
	PSMOUSE_IGNORE = 0,
	PSMOUSE_INITIALIZING = 1,
	PSMOUSE_RESYNCING = 2,
	PSMOUSE_CMD_MODE = 3,
	PSMOUSE_ACTIVATED = 4,
};

typedef enum {
	PSMOUSE_BAD_DATA = 0,
	PSMOUSE_GOOD_DATA = 1,
	PSMOUSE_FULL_PACKET = 2,
} psmouse_ret_t;

enum psmouse_scale {
	PSMOUSE_SCALE11 = 0,
	PSMOUSE_SCALE21 = 1,
};

enum psmouse_type {
	PSMOUSE_NONE = 0,
	PSMOUSE_PS2 = 1,
	PSMOUSE_PS2PP = 2,
	PSMOUSE_THINKPS = 3,
	PSMOUSE_GENPS = 4,
	PSMOUSE_IMPS = 5,
	PSMOUSE_IMEX = 6,
	PSMOUSE_SYNAPTICS = 7,
	PSMOUSE_ALPS = 8,
	PSMOUSE_LIFEBOOK = 9,
	PSMOUSE_TRACKPOINT = 10,
	PSMOUSE_TOUCHKIT_PS2 = 11,
	PSMOUSE_CORTRON = 12,
	PSMOUSE_HGPK = 13,
	PSMOUSE_ELANTECH = 14,
	PSMOUSE_FSP = 15,
	PSMOUSE_SYNAPTICS_RELATIVE = 16,
	PSMOUSE_CYPRESS = 17,
	PSMOUSE_FOCALTECH = 18,
	PSMOUSE_VMMOUSE = 19,
	PSMOUSE_BYD = 20,
	PSMOUSE_SYNAPTICS_SMBUS = 21,
	PSMOUSE_ELANTECH_SMBUS = 22,
	PSMOUSE_AUTO = 23,
};

struct psmouse;

struct psmouse_protocol {
	enum psmouse_type type;
	bool maxproto;
	bool ignore_parity;
	bool try_passthru;
	bool smbus_companion;
	const char *name;
	const char *alias;
	int (*detect)(struct psmouse *, bool);
	int (*init)(struct psmouse *);
};

struct psmouse {
	void *private;
	struct input_dev *dev;
	struct ps2dev ps2dev;
	struct delayed_work resync_work;
	const char *vendor;
	const char *name;
	const struct psmouse_protocol *protocol;
	unsigned char packet[8];
	unsigned char badbyte;
	unsigned char pktcnt;
	unsigned char pktsize;
	unsigned char oob_data_type;
	unsigned char extra_buttons;
	bool acks_disable_command;
	unsigned int model;
	long unsigned int last;
	long unsigned int out_of_sync_cnt;
	long unsigned int num_resyncs;
	enum psmouse_state state;
	char devname[64];
	char phys[32];
	unsigned int rate;
	unsigned int resolution;
	unsigned int resetafter;
	unsigned int resync_time;
	bool smartscroll;
	psmouse_ret_t (*protocol_handler)(struct psmouse *);
	void (*set_rate)(struct psmouse *, unsigned int);
	void (*set_resolution)(struct psmouse *, unsigned int);
	void (*set_scale)(struct psmouse *, enum psmouse_scale);
	int (*reconnect)(struct psmouse *);
	int (*fast_reconnect)(struct psmouse *);
	void (*disconnect)(struct psmouse *);
	void (*cleanup)(struct psmouse *);
	int (*poll)(struct psmouse *);
	void (*pt_activate)(struct psmouse *);
	void (*pt_deactivate)(struct psmouse *);
};

struct psmouse_attribute {
	struct device_attribute___2 dattr;
	void *data;
	ssize_t (*show)(struct psmouse *, void *, char *);
	ssize_t (*set)(struct psmouse *, void *, const char *, size_t);
	bool protect;
};

struct vmmouse_data {
	struct input_dev *abs_dev;
	char phys[32];
	char dev_name[128];
};

struct trace_event_raw_rtc_time_alarm_class {
	struct trace_entry ent;
	time64_t secs;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_freq {
	struct trace_entry ent;
	int freq;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_state {
	struct trace_entry ent;
	int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_alarm_irq_enable {
	struct trace_entry ent;
	unsigned int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_offset_class {
	struct trace_entry ent;
	long int offset;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_timer_class {
	struct trace_entry ent;
	struct rtc_timer *timer;
	ktime_t expires;
	ktime_t period;
	char __data[0];
};

struct trace_event_data_offsets_rtc_time_alarm_class {};

struct trace_event_data_offsets_rtc_irq_set_freq {};

struct trace_event_data_offsets_rtc_irq_set_state {};

struct trace_event_data_offsets_rtc_alarm_irq_enable {};

struct trace_event_data_offsets_rtc_offset_class {};

struct trace_event_data_offsets_rtc_timer_class {};

typedef void (*btf_trace_rtc_set_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_irq_set_freq)(void *, int, int);

typedef void (*btf_trace_rtc_irq_set_state)(void *, int, int);

typedef void (*btf_trace_rtc_alarm_irq_enable)(void *, unsigned int, int);

typedef void (*btf_trace_rtc_set_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_read_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_timer_enqueue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_dequeue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_fired)(void *, struct rtc_timer *);

enum {
	none = 0,
	day = 1,
	month = 2,
	year = 3,
};

struct nvmem_cell_info {
	const char *name;
	unsigned int offset;
	unsigned int bytes;
	unsigned int bit_offset;
	unsigned int nbits;
};

typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);

enum nvmem_type {
	NVMEM_TYPE_UNKNOWN = 0,
	NVMEM_TYPE_EEPROM = 1,
	NVMEM_TYPE_OTP = 2,
	NVMEM_TYPE_BATTERY_BACKED = 3,
};

struct nvmem_config {
	struct device___2 *dev;
	const char *name;
	int id;
	struct module *owner;
	const struct nvmem_cell_info *cells;
	int ncells;
	enum nvmem_type type;
	bool read_only;
	bool root_only;
	bool no_of_node;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	int size;
	int word_size;
	int stride;
	void *priv;
	bool compat;
	struct device___2 *base_dev;
};

struct nvmem_device;

struct cmos_rtc_board_info {
	void (*wake_on)(struct device___2 *);
	void (*wake_off)(struct device___2 *);
	u32 flags;
	int address_space;
	u8 rtc_day_alarm;
	u8 rtc_mon_alarm;
	u8 rtc_century;
};

struct cmos_rtc {
	struct rtc_device *rtc;
	struct device___2 *dev;
	int irq;
	struct resource *iomem;
	time64_t alarm_expires;
	void (*wake_on)(struct device___2 *);
	void (*wake_off)(struct device___2 *);
	u8 enabled_wake;
	u8 suspend_ctrl;
	u8 day_alrm;
	u8 mon_alrm;
	u8 century;
	struct rtc_wkalrm saved_wkalrm;
};

struct i2c_board_info {
	char type[20];
	short unsigned int flags;
	short unsigned int addr;
	const char *dev_name;
	void *platform_data;
	struct device_node *of_node;
	struct fwnode_handle___2 *fwnode;
	const struct property_entry *properties;
	const struct resource *resources;
	unsigned int num_resources;
	int irq;
};

struct i2c_devinfo {
	struct list_head list;
	int busnum;
	struct i2c_board_info board_info;
};

enum rc_proto {
	RC_PROTO_UNKNOWN = 0,
	RC_PROTO_OTHER = 1,
	RC_PROTO_RC5 = 2,
	RC_PROTO_RC5X_20 = 3,
	RC_PROTO_RC5_SZ = 4,
	RC_PROTO_JVC = 5,
	RC_PROTO_SONY12 = 6,
	RC_PROTO_SONY15 = 7,
	RC_PROTO_SONY20 = 8,
	RC_PROTO_NEC = 9,
	RC_PROTO_NECX = 10,
	RC_PROTO_NEC32 = 11,
	RC_PROTO_SANYO = 12,
	RC_PROTO_MCIR2_KBD = 13,
	RC_PROTO_MCIR2_MSE = 14,
	RC_PROTO_RC6_0 = 15,
	RC_PROTO_RC6_6A_20 = 16,
	RC_PROTO_RC6_6A_24 = 17,
	RC_PROTO_RC6_6A_32 = 18,
	RC_PROTO_RC6_MCE = 19,
	RC_PROTO_SHARP = 20,
	RC_PROTO_XMP = 21,
	RC_PROTO_CEC = 22,
	RC_PROTO_IMON = 23,
	RC_PROTO_RCMM12 = 24,
	RC_PROTO_RCMM24 = 25,
	RC_PROTO_RCMM32 = 26,
	RC_PROTO_XBOX_DVD = 27,
};

struct rc_map_table {
	u32 scancode;
	u32 keycode;
};

struct rc_map {
	struct rc_map_table *scan;
	unsigned int size;
	unsigned int len;
	unsigned int alloc;
	enum rc_proto rc_proto;
	const char *name;
	spinlock_t lock;
};

struct rc_map_list {
	struct list_head list;
	struct rc_map map;
};

struct lirc_scancode {
	__u64 timestamp;
	__u16 flags;
	__u16 rc_proto;
	__u32 keycode;
	__u64 scancode;
};

enum rc_driver_type {
	RC_DRIVER_SCANCODE = 0,
	RC_DRIVER_IR_RAW = 1,
	RC_DRIVER_IR_RAW_TX = 2,
};

struct rc_scancode_filter {
	u32 data;
	u32 mask;
};

enum rc_filter_type {
	RC_FILTER_NORMAL = 0,
	RC_FILTER_WAKEUP = 1,
	RC_FILTER_MAX = 2,
};

struct ir_raw_event_ctrl;

struct rc_dev {
	struct device___2 dev;
	bool managed_alloc;
	const struct attribute_group___2 *sysfs_groups[5];
	const char *device_name;
	const char *input_phys;
	struct input_id input_id;
	const char *driver_name;
	const char *map_name;
	struct rc_map rc_map;
	struct mutex lock;
	unsigned int minor;
	struct ir_raw_event_ctrl *raw;
	struct input_dev *input_dev;
	enum rc_driver_type driver_type;
	bool idle;
	bool encode_wakeup;
	u64 allowed_protocols;
	u64 enabled_protocols;
	u64 allowed_wakeup_protocols;
	enum rc_proto wakeup_protocol;
	struct rc_scancode_filter scancode_filter;
	struct rc_scancode_filter scancode_wakeup_filter;
	u32 scancode_mask;
	u32 users;
	void *priv;
	spinlock_t keylock;
	bool keypressed;
	long unsigned int keyup_jiffies;
	struct timer_list timer_keyup;
	struct timer_list timer_repeat;
	u32 last_keycode;
	enum rc_proto last_protocol;
	u32 last_scancode;
	u8 last_toggle;
	u32 timeout;
	u32 min_timeout;
	u32 max_timeout;
	u32 rx_resolution;
	u32 tx_resolution;
	bool registered;
	int (*change_protocol)(struct rc_dev *, u64 *);
	int (*open)(struct rc_dev *);
	void (*close)(struct rc_dev *);
	int (*s_tx_mask)(struct rc_dev *, u32);
	int (*s_tx_carrier)(struct rc_dev *, u32);
	int (*s_tx_duty_cycle)(struct rc_dev *, u32);
	int (*s_rx_carrier_range)(struct rc_dev *, u32, u32);
	int (*tx_ir)(struct rc_dev *, unsigned int *, unsigned int);
	void (*s_idle)(struct rc_dev *, bool);
	int (*s_learning_mode)(struct rc_dev *, int);
	int (*s_carrier_report)(struct rc_dev *, int);
	int (*s_filter)(struct rc_dev *, struct rc_scancode_filter *);
	int (*s_wakeup_filter)(struct rc_dev *, struct rc_scancode_filter *);
	int (*s_timeout)(struct rc_dev *, unsigned int);
};

struct ir_raw_event {
	union {
		u32 duration;
		u32 carrier;
	};
	u8 duty_cycle;
	unsigned int pulse: 1;
	unsigned int reset: 1;
	unsigned int timeout: 1;
	unsigned int carrier_report: 1;
};

struct nec_dec {
	int state;
	unsigned int count;
	u32 bits;
	bool is_nec_x;
	bool necx_repeat;
};

struct rc5_dec {
	int state;
	u32 bits;
	unsigned int count;
	bool is_rc5x;
};

struct rc6_dec {
	int state;
	u8 header;
	u32 body;
	bool toggle;
	unsigned int count;
	unsigned int wanted_bits;
};

struct sony_dec {
	int state;
	u32 bits;
	unsigned int count;
};

struct jvc_dec {
	int state;
	u16 bits;
	u16 old_bits;
	unsigned int count;
	bool first;
	bool toggle;
};

struct sanyo_dec {
	int state;
	unsigned int count;
	u64 bits;
};

struct sharp_dec {
	int state;
	unsigned int count;
	u32 bits;
	unsigned int pulse_len;
};

struct mce_kbd_dec {
	spinlock_t keylock;
	struct timer_list rx_timeout;
	int state;
	u8 header;
	u32 body;
	unsigned int count;
	unsigned int wanted_bits;
};

struct xmp_dec {
	int state;
	unsigned int count;
	u32 durations[16];
};

struct imon_dec {
	int state;
	int count;
	int last_chk;
	unsigned int bits;
	bool stick_keyboard;
};

struct rcmm_dec {
	int state;
	unsigned int count;
	u32 bits;
};

struct ir_raw_event_ctrl {
	struct list_head list;
	struct task_struct___2 *thread;
	struct {
		union {
			struct __kfifo kfifo;
			struct ir_raw_event *type;
			const struct ir_raw_event *const_type;
			char (*rectype)[0];
			struct ir_raw_event *ptr;
			const struct ir_raw_event *ptr_const;
		};
		struct ir_raw_event buf[512];
	} kfifo;
	ktime_t last_event;
	struct rc_dev *dev;
	spinlock_t edge_spinlock;
	struct timer_list edge_handle;
	struct ir_raw_event prev_ev;
	struct ir_raw_event this_ev;
	struct nec_dec nec;
	struct rc5_dec rc5;
	struct rc6_dec rc6;
	struct sony_dec sony;
	struct jvc_dec jvc;
	struct sanyo_dec sanyo;
	struct sharp_dec sharp;
	struct mce_kbd_dec mce_kbd;
	struct xmp_dec xmp;
	struct imon_dec imon;
	struct rcmm_dec rcmm;
};

enum led_brightness {
	LED_OFF___2 = 0,
	LED_ON___2 = 1,
	LED_HALF = 127,
	LED_FULL = 255,
};

struct led_trigger {};

struct rc_filter_attribute {
	struct device_attribute___2 attr;
	enum rc_filter_type type;
	bool mask;
};

struct ir_raw_handler {
	struct list_head list;
	u64 protocols;
	int (*decode)(struct rc_dev *, struct ir_raw_event);
	int (*encode)(enum rc_proto, u32, struct ir_raw_event *, unsigned int);
	u32 carrier;
	u32 min_timeout;
	int (*raw_register)(struct rc_dev *);
	int (*raw_unregister)(struct rc_dev *);
};

struct ir_raw_timings_manchester {
	unsigned int leader_pulse;
	unsigned int leader_space;
	unsigned int clock;
	unsigned int invert: 1;
	unsigned int trailer_space;
};

struct ir_raw_timings_pd {
	unsigned int header_pulse;
	unsigned int header_space;
	unsigned int bit_pulse;
	unsigned int bit_space[2];
	unsigned int trailer_pulse;
	unsigned int trailer_space;
	unsigned int msb_first: 1;
};

struct ir_raw_timings_pl {
	unsigned int header_pulse;
	unsigned int bit_space;
	unsigned int bit_pulse[2];
	unsigned int trailer_space;
	unsigned int msb_first: 1;
};

enum nec_state {
	STATE_INACTIVE = 0,
	STATE_HEADER_SPACE = 1,
	STATE_BIT_PULSE = 2,
	STATE_BIT_SPACE = 3,
	STATE_TRAILER_PULSE = 4,
	STATE_TRAILER_SPACE = 5,
};

enum rc5_state {
	STATE_INACTIVE___2 = 0,
	STATE_BIT_START = 1,
	STATE_BIT_END = 2,
	STATE_CHECK_RC5X = 3,
	STATE_FINISHED = 4,
};

enum rc6_mode {
	RC6_MODE_0 = 0,
	RC6_MODE_6A = 1,
	RC6_MODE_UNKNOWN = 2,
};

enum rc6_state {
	STATE_INACTIVE___3 = 0,
	STATE_PREFIX_SPACE = 1,
	STATE_HEADER_BIT_START = 2,
	STATE_HEADER_BIT_END = 3,
	STATE_TOGGLE_START = 4,
	STATE_TOGGLE_END = 5,
	STATE_BODY_BIT_START = 6,
	STATE_BODY_BIT_END = 7,
	STATE_FINISHED___2 = 8,
};

enum jvc_state {
	STATE_INACTIVE___4 = 0,
	STATE_HEADER_SPACE___2 = 1,
	STATE_BIT_PULSE___2 = 2,
	STATE_BIT_SPACE___2 = 3,
	STATE_TRAILER_PULSE___2 = 4,
	STATE_TRAILER_SPACE___2 = 5,
	STATE_CHECK_REPEAT = 6,
};

enum sony_state {
	STATE_INACTIVE___5 = 0,
	STATE_HEADER_SPACE___3 = 1,
	STATE_BIT_PULSE___3 = 2,
	STATE_BIT_SPACE___3 = 3,
	STATE_FINISHED___3 = 4,
};

enum sanyo_state {
	STATE_INACTIVE___6 = 0,
	STATE_HEADER_SPACE___4 = 1,
	STATE_BIT_PULSE___4 = 2,
	STATE_BIT_SPACE___4 = 3,
	STATE_TRAILER_PULSE___3 = 4,
	STATE_TRAILER_SPACE___3 = 5,
};

enum sharp_state {
	STATE_INACTIVE___7 = 0,
	STATE_BIT_PULSE___5 = 1,
	STATE_BIT_SPACE___5 = 2,
	STATE_TRAILER_PULSE___4 = 3,
	STATE_ECHO_SPACE = 4,
	STATE_TRAILER_SPACE___4 = 5,
};

enum mce_kbd_mode {
	MCIR2_MODE_KEYBOARD = 0,
	MCIR2_MODE_MOUSE = 1,
	MCIR2_MODE_UNKNOWN = 2,
};

enum mce_kbd_state {
	STATE_INACTIVE___8 = 0,
	STATE_HEADER_BIT_START___2 = 1,
	STATE_HEADER_BIT_END___2 = 2,
	STATE_BODY_BIT_START___2 = 3,
	STATE_BODY_BIT_END___2 = 4,
	STATE_FINISHED___4 = 5,
};

enum xmp_state {
	STATE_INACTIVE___9 = 0,
	STATE_LEADER_PULSE = 1,
	STATE_NIBBLE_SPACE = 2,
};

enum power_supply_property {
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
	POWER_SUPPLY_PROP_HEALTH = 2,
	POWER_SUPPLY_PROP_PRESENT = 3,
	POWER_SUPPLY_PROP_ONLINE = 4,
	POWER_SUPPLY_PROP_AUTHENTIC = 5,
	POWER_SUPPLY_PROP_TECHNOLOGY = 6,
	POWER_SUPPLY_PROP_CYCLE_COUNT = 7,
	POWER_SUPPLY_PROP_VOLTAGE_MAX = 8,
	POWER_SUPPLY_PROP_VOLTAGE_MIN = 9,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 10,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 11,
	POWER_SUPPLY_PROP_VOLTAGE_NOW = 12,
	POWER_SUPPLY_PROP_VOLTAGE_AVG = 13,
	POWER_SUPPLY_PROP_VOLTAGE_OCV = 14,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 15,
	POWER_SUPPLY_PROP_CURRENT_MAX = 16,
	POWER_SUPPLY_PROP_CURRENT_NOW = 17,
	POWER_SUPPLY_PROP_CURRENT_AVG = 18,
	POWER_SUPPLY_PROP_CURRENT_BOOT = 19,
	POWER_SUPPLY_PROP_POWER_NOW = 20,
	POWER_SUPPLY_PROP_POWER_AVG = 21,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 22,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 23,
	POWER_SUPPLY_PROP_CHARGE_FULL = 24,
	POWER_SUPPLY_PROP_CHARGE_EMPTY = 25,
	POWER_SUPPLY_PROP_CHARGE_NOW = 26,
	POWER_SUPPLY_PROP_CHARGE_AVG = 27,
	POWER_SUPPLY_PROP_CHARGE_COUNTER = 28,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 29,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 30,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 31,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 32,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 33,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 34,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 35,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 36,
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 37,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 38,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 39,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 40,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 41,
	POWER_SUPPLY_PROP_ENERGY_FULL = 42,
	POWER_SUPPLY_PROP_ENERGY_EMPTY = 43,
	POWER_SUPPLY_PROP_ENERGY_NOW = 44,
	POWER_SUPPLY_PROP_ENERGY_AVG = 45,
	POWER_SUPPLY_PROP_CAPACITY = 46,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 47,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 48,
	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 49,
	POWER_SUPPLY_PROP_TEMP = 50,
	POWER_SUPPLY_PROP_TEMP_MAX = 51,
	POWER_SUPPLY_PROP_TEMP_MIN = 52,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 53,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 54,
	POWER_SUPPLY_PROP_TEMP_AMBIENT = 55,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 56,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 57,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 58,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 59,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 60,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 61,
	POWER_SUPPLY_PROP_TYPE = 62,
	POWER_SUPPLY_PROP_USB_TYPE = 63,
	POWER_SUPPLY_PROP_SCOPE = 64,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 65,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 66,
	POWER_SUPPLY_PROP_CALIBRATE = 67,
	POWER_SUPPLY_PROP_MODEL_NAME = 68,
	POWER_SUPPLY_PROP_MANUFACTURER = 69,
	POWER_SUPPLY_PROP_SERIAL_NUMBER = 70,
};

enum power_supply_type {
	POWER_SUPPLY_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_TYPE_BATTERY = 1,
	POWER_SUPPLY_TYPE_UPS = 2,
	POWER_SUPPLY_TYPE_MAINS = 3,
	POWER_SUPPLY_TYPE_USB = 4,
	POWER_SUPPLY_TYPE_USB_DCP = 5,
	POWER_SUPPLY_TYPE_USB_CDP = 6,
	POWER_SUPPLY_TYPE_USB_ACA = 7,
	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
	POWER_SUPPLY_TYPE_USB_PD = 9,
	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
};

enum power_supply_usb_type {
	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_USB_TYPE_SDP = 1,
	POWER_SUPPLY_USB_TYPE_DCP = 2,
	POWER_SUPPLY_USB_TYPE_CDP = 3,
	POWER_SUPPLY_USB_TYPE_ACA = 4,
	POWER_SUPPLY_USB_TYPE_C = 5,
	POWER_SUPPLY_USB_TYPE_PD = 6,
	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
};

enum power_supply_notifier_events {
	PSY_EVENT_PROP_CHANGED = 0,
};

union power_supply_propval {
	int intval;
	const char *strval;
};

struct power_supply_config {
	struct device_node___2 *of_node;
	struct fwnode_handle___2 *fwnode;
	void *drv_data;
	const struct attribute_group___2 **attr_grp;
	char **supplied_to;
	size_t num_supplicants;
};

struct power_supply;

struct power_supply_desc {
	const char *name;
	enum power_supply_type type;
	enum power_supply_usb_type *usb_types;
	size_t num_usb_types;
	enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
	void (*external_power_changed)(struct power_supply *);
	void (*set_charged)(struct power_supply *);
	bool no_thermal;
	int use_for_apm;
};

struct power_supply {
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;
	char **supplied_from;
	size_t num_supplies;
	struct device_node___2 *of_node;
	void *drv_data;
	struct device___2 dev;
	struct work_struct changed_work;
	struct delayed_work deferred_register_work;
	spinlock_t changed_lock;
	bool changed;
	bool initialized;
	bool removing;
	atomic_t use_cnt;
	struct thermal_zone_device *tzd;
	struct thermal_cooling_device *tcd;
};

struct power_supply_battery_ocv_table {
	int ocv;
	int capacity;
};

struct power_supply_battery_info {
	int energy_full_design_uwh;
	int charge_full_design_uah;
	int voltage_min_design_uv;
	int voltage_max_design_uv;
	int precharge_current_ua;
	int charge_term_current_ua;
	int constant_charge_current_max_ua;
	int constant_charge_voltage_max_uv;
	int factory_internal_resistance_uohm;
	int ocv_temp[20];
	struct power_supply_battery_ocv_table *ocv_table[20];
	int ocv_table_size[20];
};

struct psy_am_i_supplied_data {
	struct power_supply *psy;
	unsigned int count;
};

enum hwmon_sensor_types {
	hwmon_chip = 0,
	hwmon_temp = 1,
	hwmon_in = 2,
	hwmon_curr = 3,
	hwmon_power = 4,
	hwmon_energy = 5,
	hwmon_humidity = 6,
	hwmon_fan = 7,
	hwmon_pwm = 8,
	hwmon_max = 9,
};

enum hwmon_temp_attributes {
	hwmon_temp_input = 0,
	hwmon_temp_type = 1,
	hwmon_temp_lcrit = 2,
	hwmon_temp_lcrit_hyst = 3,
	hwmon_temp_min = 4,
	hwmon_temp_min_hyst = 5,
	hwmon_temp_max = 6,
	hwmon_temp_max_hyst = 7,
	hwmon_temp_crit = 8,
	hwmon_temp_crit_hyst = 9,
	hwmon_temp_emergency = 10,
	hwmon_temp_emergency_hyst = 11,
	hwmon_temp_alarm = 12,
	hwmon_temp_lcrit_alarm = 13,
	hwmon_temp_min_alarm = 14,
	hwmon_temp_max_alarm = 15,
	hwmon_temp_crit_alarm = 16,
	hwmon_temp_emergency_alarm = 17,
	hwmon_temp_fault = 18,
	hwmon_temp_offset = 19,
	hwmon_temp_label = 20,
	hwmon_temp_lowest = 21,
	hwmon_temp_highest = 22,
	hwmon_temp_reset_history = 23,
};

enum hwmon_in_attributes {
	hwmon_in_input = 0,
	hwmon_in_min = 1,
	hwmon_in_max = 2,
	hwmon_in_lcrit = 3,
	hwmon_in_crit = 4,
	hwmon_in_average = 5,
	hwmon_in_lowest = 6,
	hwmon_in_highest = 7,
	hwmon_in_reset_history = 8,
	hwmon_in_label = 9,
	hwmon_in_alarm = 10,
	hwmon_in_min_alarm = 11,
	hwmon_in_max_alarm = 12,
	hwmon_in_lcrit_alarm = 13,
	hwmon_in_crit_alarm = 14,
	hwmon_in_enable = 15,
};

enum hwmon_curr_attributes {
	hwmon_curr_input = 0,
	hwmon_curr_min = 1,
	hwmon_curr_max = 2,
	hwmon_curr_lcrit = 3,
	hwmon_curr_crit = 4,
	hwmon_curr_average = 5,
	hwmon_curr_lowest = 6,
	hwmon_curr_highest = 7,
	hwmon_curr_reset_history = 8,
	hwmon_curr_label = 9,
	hwmon_curr_alarm = 10,
	hwmon_curr_min_alarm = 11,
	hwmon_curr_max_alarm = 12,
	hwmon_curr_lcrit_alarm = 13,
	hwmon_curr_crit_alarm = 14,
};

struct hwmon_ops {
	umode_t (*is_visible)(const void *, enum hwmon_sensor_types, u32, int);
	int (*read)(struct device___2 *, enum hwmon_sensor_types, u32, int, long int *);
	int (*read_string)(struct device___2 *, enum hwmon_sensor_types, u32, int, const char **);
	int (*write)(struct device___2 *, enum hwmon_sensor_types, u32, int, long int);
};

struct hwmon_channel_info {
	enum hwmon_sensor_types type;
	const u32 *config;
};

struct hwmon_chip_info {
	const struct hwmon_ops *ops;
	const struct hwmon_channel_info **info;
};

struct power_supply_hwmon {
	struct power_supply *psy;
	long unsigned int *props;
};

enum hwmon_chip_attributes {
	hwmon_chip_temp_reset_history = 0,
	hwmon_chip_in_reset_history = 1,
	hwmon_chip_curr_reset_history = 2,
	hwmon_chip_power_reset_history = 3,
	hwmon_chip_register_tz = 4,
	hwmon_chip_update_interval = 5,
	hwmon_chip_alarms = 6,
	hwmon_chip_samples = 7,
	hwmon_chip_curr_samples = 8,
	hwmon_chip_in_samples = 9,
	hwmon_chip_power_samples = 10,
	hwmon_chip_temp_samples = 11,
};

enum hwmon_power_attributes {
	hwmon_power_average = 0,
	hwmon_power_average_interval = 1,
	hwmon_power_average_interval_max = 2,
	hwmon_power_average_interval_min = 3,
	hwmon_power_average_highest = 4,
	hwmon_power_average_lowest = 5,
	hwmon_power_average_max = 6,
	hwmon_power_average_min = 7,
	hwmon_power_input = 8,
	hwmon_power_input_highest = 9,
	hwmon_power_input_lowest = 10,
	hwmon_power_reset_history = 11,
	hwmon_power_accuracy = 12,
	hwmon_power_cap = 13,
	hwmon_power_cap_hyst = 14,
	hwmon_power_cap_max = 15,
	hwmon_power_cap_min = 16,
	hwmon_power_min = 17,
	hwmon_power_max = 18,
	hwmon_power_crit = 19,
	hwmon_power_lcrit = 20,
	hwmon_power_label = 21,
	hwmon_power_alarm = 22,
	hwmon_power_cap_alarm = 23,
	hwmon_power_min_alarm = 24,
	hwmon_power_max_alarm = 25,
	hwmon_power_lcrit_alarm = 26,
	hwmon_power_crit_alarm = 27,
};

enum hwmon_energy_attributes {
	hwmon_energy_input = 0,
	hwmon_energy_label = 1,
};

enum hwmon_humidity_attributes {
	hwmon_humidity_input = 0,
	hwmon_humidity_label = 1,
	hwmon_humidity_min = 2,
	hwmon_humidity_min_hyst = 3,
	hwmon_humidity_max = 4,
	hwmon_humidity_max_hyst = 5,
	hwmon_humidity_alarm = 6,
	hwmon_humidity_fault = 7,
};

enum hwmon_fan_attributes {
	hwmon_fan_input = 0,
	hwmon_fan_label = 1,
	hwmon_fan_min = 2,
	hwmon_fan_max = 3,
	hwmon_fan_div = 4,
	hwmon_fan_pulses = 5,
	hwmon_fan_target = 6,
	hwmon_fan_alarm = 7,
	hwmon_fan_min_alarm = 8,
	hwmon_fan_max_alarm = 9,
	hwmon_fan_fault = 10,
};

enum hwmon_pwm_attributes {
	hwmon_pwm_input = 0,
	hwmon_pwm_enable = 1,
	hwmon_pwm_mode = 2,
	hwmon_pwm_freq = 3,
};

struct trace_event_raw_hwmon_attr_class {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	long int val;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_show_string {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	u32 __data_loc_label;
	char __data[0];
};

struct trace_event_data_offsets_hwmon_attr_class {
	u32 attr_name;
};

struct trace_event_data_offsets_hwmon_attr_show_string {
	u32 attr_name;
	u32 label;
};

typedef void (*btf_trace_hwmon_attr_show)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_store)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_show_string)(void *, int, const char *, const char *);

struct hwmon_device {
	const char *name;
	struct device___2 dev;
	const struct hwmon_chip_info *chip;
	struct attribute_group___2 group;
	const struct attribute_group___2 **groups;
};

struct hwmon_device_attribute {
	struct device_attribute___2 dev_attr;
	const struct hwmon_ops *ops;
	enum hwmon_sensor_types type;
	u32 attr;
	int index;
	char name[32];
};

enum events {
	THERMAL_AUX0 = 0,
	THERMAL_AUX1 = 1,
	THERMAL_CRITICAL = 2,
	THERMAL_DEV_FAULT = 3,
};

enum {
	THERMAL_GENL_ATTR_UNSPEC = 0,
	THERMAL_GENL_ATTR_EVENT = 1,
	__THERMAL_GENL_ATTR_MAX = 2,
};

enum {
	THERMAL_GENL_CMD_UNSPEC = 0,
	THERMAL_GENL_CMD_EVENT = 1,
	__THERMAL_GENL_CMD_MAX = 2,
};

struct thermal_genl_event {
	u32 orig;
	enum events event;
};

struct trace_event_raw_thermal_temperature {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int temp_prev;
	int temp;
	char __data[0];
};

struct trace_event_raw_cdev_update {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int target;
	char __data[0];
};

struct trace_event_raw_thermal_zone_trip {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int trip;
	enum thermal_trip_type trip_type;
	char __data[0];
};

struct trace_event_data_offsets_thermal_temperature {
	u32 thermal_zone;
};

struct trace_event_data_offsets_cdev_update {
	u32 type;
};

struct trace_event_data_offsets_thermal_zone_trip {
	u32 thermal_zone;
};

typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);

typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, long unsigned int);

typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);

struct thermal_instance {
	int id;
	char name[20];
	struct thermal_zone_device *tz;
	struct thermal_cooling_device *cdev;
	int trip;
	bool initialized;
	long unsigned int upper;
	long unsigned int lower;
	long unsigned int target;
	char attr_name[20];
	struct device_attribute___2 attr;
	char weight_attr_name[20];
	struct device_attribute___2 weight_attr;
	struct list_head tz_node;
	struct list_head cdev_node;
	unsigned int weight;
};

struct thermal_hwmon_device {
	char type[20];
	struct device___2 *device;
	int count;
	struct list_head tz_list;
	struct list_head node;
};

struct thermal_hwmon_attr {
	struct device_attribute___2 attr;
	char name[16];
};

struct thermal_hwmon_temp {
	struct list_head hwmon_node;
	struct thermal_zone_device *tz;
	struct thermal_hwmon_attr temp_input;
	struct thermal_hwmon_attr temp_crit;
};

struct md_cluster_info;

struct md_personality;

struct md_thread;

struct bitmap;

struct md_rdev;

struct mddev {
	void *private;
	struct md_personality *pers;
	dev_t unit;
	int md_minor;
	struct list_head disks;
	long unsigned int flags;
	long unsigned int sb_flags;
	int suspended;
	atomic_t active_io;
	int ro;
	int sysfs_active;
	struct gendisk *gendisk;
	struct kobject___2 kobj;
	int hold_active;
	int major_version;
	int minor_version;
	int patch_version;
	int persistent;
	int external;
	char metadata_type[17];
	int chunk_sectors;
	time64_t ctime;
	time64_t utime;
	int level;
	int layout;
	char clevel[16];
	int raid_disks;
	int max_disks;
	sector_t dev_sectors;
	sector_t array_sectors;
	int external_size;
	__u64 events;
	int can_decrease_events;
	char uuid[16];
	sector_t reshape_position;
	int delta_disks;
	int new_level;
	int new_layout;
	int new_chunk_sectors;
	int reshape_backwards;
	struct md_thread *thread;
	struct md_thread *sync_thread;
	char *last_sync_action;
	sector_t curr_resync;
	sector_t curr_resync_completed;
	long unsigned int resync_mark;
	sector_t resync_mark_cnt;
	sector_t curr_mark_cnt;
	sector_t resync_max_sectors;
	atomic64_t resync_mismatches;
	sector_t suspend_lo;
	sector_t suspend_hi;
	int sync_speed_min;
	int sync_speed_max;
	int parallel_resync;
	int ok_start_degraded;
	long unsigned int recovery;
	int recovery_disabled;
	int in_sync;
	struct mutex open_mutex;
	struct mutex reconfig_mutex;
	atomic_t active;
	atomic_t openers;
	int changed;
	int degraded;
	atomic_t recovery_active;
	wait_queue_head_t recovery_wait;
	sector_t recovery_cp;
	sector_t resync_min;
	sector_t resync_max;
	struct kernfs_node___2 *sysfs_state;
	struct kernfs_node___2 *sysfs_action;
	struct work_struct del_work;
	spinlock_t lock;
	wait_queue_head_t sb_wait;
	atomic_t pending_writes;
	unsigned int safemode;
	unsigned int safemode_delay;
	struct timer_list safemode_timer;
	struct percpu_ref writes_pending;
	int sync_checkers;
	struct request_queue *queue;
	struct bitmap *bitmap;
	struct {
		struct file___2 *file;
		loff_t offset;
		long unsigned int space;
		loff_t default_offset;
		long unsigned int default_space;
		struct mutex mutex;
		long unsigned int chunksize;
		long unsigned int daemon_sleep;
		long unsigned int max_write_behind;
		int external;
		int nodes;
		char cluster_name[64];
	} bitmap_info;
	atomic_t max_corr_read_errors;
	struct list_head all_mddevs;
	struct attribute_group___2 *to_remove;
	struct bio_set bio_set;
	struct bio_set sync_set;
	struct bio *flush_bio;
	atomic_t flush_pending;
	ktime_t start_flush;
	ktime_t last_flush;
	struct work_struct flush_work;
	struct work_struct event_work;
	mempool_t *wb_info_pool;
	void (*sync_super)(struct mddev *, struct md_rdev *);
	struct md_cluster_info *cluster_info;
	unsigned int good_device_nr;
	bool has_superblocks: 1;
	bool fail_last_dev: 1;
};

struct md_rdev {
	struct list_head same_set;
	sector_t sectors;
	struct mddev *mddev;
	int last_events;
	struct block_device *meta_bdev;
	struct block_device *bdev;
	struct page___2 *sb_page;
	struct page___2 *bb_page;
	int sb_loaded;
	__u64 sb_events;
	sector_t data_offset;
	sector_t new_data_offset;
	sector_t sb_start;
	int sb_size;
	int preferred_minor;
	struct kobject___2 kobj;
	long unsigned int flags;
	wait_queue_head_t blocked_wait;
	int desc_nr;
	int raid_disk;
	int new_raid_disk;
	int saved_raid_disk;
	union {
		sector_t recovery_offset;
		sector_t journal_tail;
	};
	atomic_t nr_pending;
	atomic_t read_errors;
	time64_t last_read_error;
	atomic_t corrected_errors;
	struct list_head wb_list;
	spinlock_t wb_list_lock;
	wait_queue_head_t wb_io_wait;
	struct work_struct del_work;
	struct kernfs_node___2 *sysfs_state;
	struct badblocks badblocks;
	struct {
		short int offset;
		unsigned int size;
		sector_t sector;
	} ppl;
};

enum mddev_flags {
	MD_ARRAY_FIRST_USE = 0,
	MD_CLOSING = 1,
	MD_JOURNAL_CLEAN = 2,
	MD_HAS_JOURNAL = 3,
	MD_CLUSTER_RESYNC_LOCKED = 4,
	MD_FAILFAST_SUPPORTED = 5,
	MD_HAS_PPL = 6,
	MD_HAS_MULTIPLE_PPLS = 7,
	MD_ALLOW_SB_UPDATE = 8,
	MD_UPDATING_SB = 9,
	MD_NOT_READY = 10,
	MD_BROKEN = 11,
};

struct md_personality {
	char *name;
	int level;
	struct list_head list;
	struct module___2 *owner;
	bool (*make_request)(struct mddev *, struct bio *);
	int (*run)(struct mddev *);
	int (*start)(struct mddev *);
	void (*free)(struct mddev *, void *);
	void (*status)(struct seq_file___2 *, struct mddev *);
	void (*error_handler)(struct mddev *, struct md_rdev *);
	int (*hot_add_disk)(struct mddev *, struct md_rdev *);
	int (*hot_remove_disk)(struct mddev *, struct md_rdev *);
	int (*spare_active)(struct mddev *);
	sector_t (*sync_request)(struct mddev *, sector_t, int *);
	int (*resize)(struct mddev *, sector_t);
	sector_t (*size)(struct mddev *, sector_t, int);
	int (*check_reshape)(struct mddev *);
	int (*start_reshape)(struct mddev *);
	void (*finish_reshape)(struct mddev *);
	void (*update_reshape_pos)(struct mddev *);
	void (*quiesce)(struct mddev *, int);
	void * (*takeover)(struct mddev *);
	int (*congested)(struct mddev *, int);
	int (*change_consistency_policy)(struct mddev *, const char *);
};

struct md_thread {
	void (*run)(struct md_thread *);
	struct mddev *mddev;
	wait_queue_head_t wqueue;
	long unsigned int flags;
	struct task_struct___2 *tsk;
	long unsigned int timeout;
	void *private;
};

struct dev_info {
	struct md_rdev *rdev;
	sector_t end_sector;
};

struct linear_conf {
	struct callback_head rcu;
	sector_t array_sectors;
	int raid_disks;
	struct dev_info disks[0];
};

struct strip_zone {
	sector_t zone_end;
	sector_t dev_start;
	int nb_dev;
};

enum r0layout {
	RAID0_ORIG_LAYOUT = 1,
	RAID0_ALT_MULTIZONE_LAYOUT = 2,
};

struct r0conf {
	struct strip_zone *strip_zone;
	struct md_rdev **devlist;
	int nr_strip_zones;
	enum r0layout layout;
};

struct md_cluster_operations {
	int (*join)(struct mddev *, int);
	int (*leave)(struct mddev *);
	int (*slot_number)(struct mddev *);
	int (*resync_info_update)(struct mddev *, sector_t, sector_t);
	void (*resync_info_get)(struct mddev *, sector_t *, sector_t *);
	int (*metadata_update_start)(struct mddev *);
	int (*metadata_update_finish)(struct mddev *);
	void (*metadata_update_cancel)(struct mddev *);
	int (*resync_start)(struct mddev *);
	int (*resync_finish)(struct mddev *);
	int (*area_resyncing)(struct mddev *, int, sector_t, sector_t);
	int (*add_new_disk)(struct mddev *, struct md_rdev *);
	void (*add_new_disk_cancel)(struct mddev *);
	int (*new_disk_ack)(struct mddev *, bool);
	int (*remove_disk)(struct mddev *, struct md_rdev *);
	void (*load_bitmaps)(struct mddev *, int);
	int (*gather_bitmaps)(struct md_rdev *);
	int (*resize_bitmaps)(struct mddev *, sector_t, sector_t);
	int (*lock_all_bitmaps)(struct mddev *);
	void (*unlock_all_bitmaps)(struct mddev *);
	void (*update_size)(struct mddev *, sector_t);
};

enum flag_bits {
	Faulty = 0,
	In_sync = 1,
	Bitmap_sync = 2,
	WriteMostly = 3,
	AutoDetected = 4,
	Blocked = 5,
	WriteErrorSeen = 6,
	FaultRecorded = 7,
	BlockedBadBlocks = 8,
	WantReplacement = 9,
	Replacement = 10,
	Candidate = 11,
	Journal = 12,
	ClusterRemove = 13,
	RemoveSynchronized = 14,
	ExternalBbl = 15,
	FailFast = 16,
	LastDev = 17,
	WBCollisionCheck = 18,
};

enum mddev_sb_flags {
	MD_SB_CHANGE_DEVS = 0,
	MD_SB_CHANGE_CLEAN = 1,
	MD_SB_CHANGE_PENDING = 2,
	MD_SB_NEED_REWRITE = 3,
};

struct wb_info {
	sector_t lo;
	sector_t hi;
	struct list_head list;
};

struct bitmap_page;

struct bitmap_counts {
	spinlock_t lock;
	struct bitmap_page *bp;
	long unsigned int pages;
	long unsigned int missing_pages;
	long unsigned int chunkshift;
	long unsigned int chunks;
};

struct bitmap_storage {
	struct file___2 *file;
	struct page___2 *sb_page;
	struct page___2 **filemap;
	long unsigned int *filemap_attr;
	long unsigned int file_pages;
	long unsigned int bytes;
};

struct bitmap {
	struct bitmap_counts counts;
	struct mddev *mddev;
	__u64 events_cleared;
	int need_sync;
	struct bitmap_storage storage;
	long unsigned int flags;
	int allclean;
	atomic_t behind_writes;
	long unsigned int behind_writes_used;
	long unsigned int daemon_lastrun;
	long unsigned int last_end_sync;
	atomic_t pending_writes;
	wait_queue_head_t write_wait;
	wait_queue_head_t overflow_wait;
	wait_queue_head_t behind_wait;
	struct kernfs_node___2 *sysfs_can_clear;
	int cluster_slot;
};

enum recovery_flags {
	MD_RECOVERY_RUNNING = 0,
	MD_RECOVERY_SYNC = 1,
	MD_RECOVERY_RECOVER = 2,
	MD_RECOVERY_INTR = 3,
	MD_RECOVERY_DONE = 4,
	MD_RECOVERY_NEEDED = 5,
	MD_RECOVERY_REQUESTED = 6,
	MD_RECOVERY_CHECK = 7,
	MD_RECOVERY_RESHAPE = 8,
	MD_RECOVERY_FROZEN = 9,
	MD_RECOVERY_ERROR = 10,
	MD_RECOVERY_WAIT = 11,
	MD_RESYNCING_REMOTE = 12,
};

struct raid1_info {
	struct md_rdev *rdev;
	sector_t head_position;
	sector_t next_seq_sect;
	sector_t seq_start;
};

struct pool_info {
	struct mddev *mddev;
	int raid_disks;
};

struct r1conf {
	struct mddev *mddev;
	struct raid1_info *mirrors;
	int raid_disks;
	spinlock_t device_lock;
	struct list_head retry_list;
	struct list_head bio_end_io_list;
	struct bio_list pending_bio_list;
	int pending_count;
	wait_queue_head_t wait_barrier;
	spinlock_t resync_lock;
	atomic_t nr_sync_pending;
	atomic_t *nr_pending;
	atomic_t *nr_waiting;
	atomic_t *nr_queued;
	atomic_t *barrier;
	int array_frozen;
	int fullsync;
	int recovery_disabled;
	struct pool_info *poolinfo;
	mempool_t r1bio_pool;
	mempool_t r1buf_pool;
	struct bio_set bio_split;
	struct page___2 *tmppage;
	struct md_thread *thread;
	sector_t cluster_sync_low;
	sector_t cluster_sync_high;
};

struct r1bio {
	atomic_t remaining;
	atomic_t behind_remaining;
	sector_t sector;
	int sectors;
	long unsigned int state;
	struct mddev *mddev;
	struct bio *master_bio;
	int read_disk;
	struct list_head retry_list;
	struct bio *behind_master_bio;
	struct bio *bios[0];
};

enum r1bio_state {
	R1BIO_Uptodate = 0,
	R1BIO_IsSync = 1,
	R1BIO_Degraded = 2,
	R1BIO_BehindIO = 3,
	R1BIO_ReadError = 4,
	R1BIO_Returned = 5,
	R1BIO_MadeGood = 6,
	R1BIO_WriteError = 7,
	R1BIO_FailFast = 8,
};

struct bitmap_page {
	char *map;
	unsigned int hijacked: 1;
	unsigned int pending: 1;
	unsigned int count: 30;
};

struct resync_pages {
	void *raid_bio;
	struct page___2 *pages[16];
};

struct raid1_plug_cb {
	struct blk_plug_cb cb;
	struct bio_list pending;
	int pending_cnt;
};

struct mdp_superblock_1 {
	__le32 magic;
	__le32 major_version;
	__le32 feature_map;
	__le32 pad0;
	__u8 set_uuid[16];
	char set_name[32];
	__le64 ctime;
	__le32 level;
	__le32 layout;
	__le64 size;
	__le32 chunksize;
	__le32 raid_disks;
	union {
		__le32 bitmap_offset;
		struct {
			__le16 offset;
			__le16 size;
		} ppl;
	};
	__le32 new_level;
	__le64 reshape_position;
	__le32 delta_disks;
	__le32 new_layout;
	__le32 new_chunk;
	__le32 new_offset;
	__le64 data_offset;
	__le64 data_size;
	__le64 super_offset;
	union {
		__le64 recovery_offset;
		__le64 journal_tail;
	};
	__le32 dev_number;
	__le32 cnt_corrected_read;
	__u8 device_uuid[16];
	__u8 devflags;
	__u8 bblog_shift;
	__le16 bblog_size;
	__le32 bblog_offset;
	__le64 utime;
	__le64 events;
	__le64 resync_offset;
	__le32 sb_csum;
	__le32 max_dev;
	__u8 pad3[32];
	__le16 dev_roles[0];
};

struct raid10_info {
	struct md_rdev *rdev;
	struct md_rdev *replacement;
	sector_t head_position;
	int recovery_disabled;
};

struct geom {
	int raid_disks;
	int near_copies;
	int far_copies;
	int far_offset;
	sector_t stride;
	int far_set_size;
	int chunk_shift;
	sector_t chunk_mask;
};

struct r10conf {
	struct mddev *mddev;
	struct raid10_info *mirrors;
	struct raid10_info *mirrors_new;
	struct raid10_info *mirrors_old;
	spinlock_t device_lock;
	struct geom prev;
	struct geom geo;
	int copies;
	sector_t dev_sectors;
	sector_t reshape_progress;
	sector_t reshape_safe;
	long unsigned int reshape_checkpoint;
	sector_t offset_diff;
	struct list_head retry_list;
	struct list_head bio_end_io_list;
	struct bio_list pending_bio_list;
	int pending_count;
	spinlock_t resync_lock;
	atomic_t nr_pending;
	int nr_waiting;
	int nr_queued;
	int barrier;
	int array_freeze_pending;
	sector_t next_resync;
	int fullsync;
	int have_replacement;
	wait_queue_head_t wait_barrier;
	mempool_t r10bio_pool;
	mempool_t r10buf_pool;
	struct page___2 *tmppage;
	struct bio_set bio_split;
	struct md_thread *thread;
	sector_t cluster_sync_low;
	sector_t cluster_sync_high;
};

struct r10dev {
	struct bio *bio;
	union {
		struct bio *repl_bio;
		struct md_rdev *rdev;
	};
	sector_t addr;
	int devnum;
};

struct r10bio {
	atomic_t remaining;
	sector_t sector;
	int sectors;
	long unsigned int state;
	struct mddev *mddev;
	struct bio *master_bio;
	int read_slot;
	struct list_head retry_list;
	struct r10dev devs[0];
};

enum r10bio_state {
	R10BIO_Uptodate = 0,
	R10BIO_IsSync = 1,
	R10BIO_IsRecover = 2,
	R10BIO_IsReshape = 3,
	R10BIO_Degraded = 4,
	R10BIO_ReadError = 5,
	R10BIO_MadeGood = 6,
	R10BIO_WriteError = 7,
	R10BIO_Previous = 8,
	R10BIO_FailFast = 9,
};

struct raid10_plug_cb {
	struct blk_plug_cb cb;
	struct bio_list pending;
	int pending_cnt;
};

enum geo_type {
	geo_new = 0,
	geo_old = 1,
	geo_start = 2,
};

struct rsync_pages;

struct md_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct mddev *, char *);
	ssize_t (*store)(struct mddev *, const char *, size_t);
};

enum check_states {
	check_state_idle = 0,
	check_state_run = 1,
	check_state_run_q = 2,
	check_state_run_pq = 3,
	check_state_check_result = 4,
	check_state_compute_run = 5,
	check_state_compute_result = 6,
};

enum reconstruct_states {
	reconstruct_state_idle = 0,
	reconstruct_state_prexor_drain_run = 1,
	reconstruct_state_drain_run = 2,
	reconstruct_state_run = 3,
	reconstruct_state_prexor_drain_result = 4,
	reconstruct_state_drain_result = 5,
	reconstruct_state_result = 6,
};

struct stripe_operations {
	int target;
	int target2;
	enum sum_check_flags zero_sum_result;
};

struct r5dev {
	struct bio req;
	struct bio rreq;
	struct bio_vec vec;
	struct bio_vec rvec;
	struct page___2 *page;
	struct page___2 *orig_page;
	struct bio *toread;
	struct bio *read;
	struct bio *towrite;
	struct bio *written;
	sector_t sector;
	long unsigned int flags;
	u32 log_checksum;
	short unsigned int write_hint;
};

struct r5conf;

struct r5worker_group;

struct r5l_io_unit;

struct ppl_io_unit;

struct stripe_head {
	struct hlist_node hash;
	struct list_head lru;
	struct llist_node release_list;
	struct r5conf *raid_conf;
	short int generation;
	sector_t sector;
	short int pd_idx;
	short int qd_idx;
	short int ddf_layout;
	short int hash_lock_index;
	long unsigned int state;
	atomic_t count;
	int bm_seq;
	int disks;
	int overwrite_disks;
	enum check_states check_state;
	enum reconstruct_states reconstruct_state;
	spinlock_t stripe_lock;
	int cpu;
	struct r5worker_group *group;
	struct stripe_head *batch_head;
	spinlock_t batch_lock;
	struct list_head batch_list;
	union {
		struct r5l_io_unit *log_io;
		struct ppl_io_unit *ppl_io;
	};
	struct list_head log_list;
	sector_t log_start;
	struct list_head r5c;
	struct page___2 *ppl_page;
	struct stripe_operations ops;
	struct r5dev dev[1];
};

struct raid5_percpu;

struct disk_info;

struct r5l_log;

struct r5pending_data;

struct r5conf {
	struct hlist_head *stripe_hashtbl;
	spinlock_t hash_locks[8];
	struct mddev *mddev;
	int chunk_sectors;
	int level;
	int algorithm;
	int rmw_level;
	int max_degraded;
	int raid_disks;
	int max_nr_stripes;
	int min_nr_stripes;
	sector_t reshape_progress;
	sector_t reshape_safe;
	int previous_raid_disks;
	int prev_chunk_sectors;
	int prev_algo;
	short int generation;
	seqcount_t gen_lock;
	long unsigned int reshape_checkpoint;
	long long int min_offset_diff;
	struct list_head handle_list;
	struct list_head loprio_list;
	struct list_head hold_list;
	struct list_head delayed_list;
	struct list_head bitmap_list;
	struct bio *retry_read_aligned;
	unsigned int retry_read_offset;
	struct bio *retry_read_aligned_list;
	atomic_t preread_active_stripes;
	atomic_t active_aligned_reads;
	atomic_t pending_full_writes;
	int bypass_count;
	int bypass_threshold;
	int skip_copy;
	struct list_head *last_hold;
	atomic_t reshape_stripes;
	int active_name;
	char cache_name[64];
	struct kmem_cache *slab_cache;
	struct mutex cache_size_mutex;
	int seq_flush;
	int seq_write;
	int quiesce;
	int fullsync;
	int recovery_disabled;
	struct raid5_percpu *percpu;
	int scribble_disks;
	int scribble_sectors;
	struct hlist_node node;
	atomic_t active_stripes;
	struct list_head inactive_list[8];
	atomic_t r5c_cached_full_stripes;
	struct list_head r5c_full_stripe_list;
	atomic_t r5c_cached_partial_stripes;
	struct list_head r5c_partial_stripe_list;
	atomic_t r5c_flushing_full_stripes;
	atomic_t r5c_flushing_partial_stripes;
	atomic_t empty_inactive_list_nr;
	struct llist_head released_stripes;
	wait_queue_head_t wait_for_quiescent;
	wait_queue_head_t wait_for_stripe;
	wait_queue_head_t wait_for_overlap;
	long unsigned int cache_state;
	struct shrinker shrinker;
	int pool_size;
	spinlock_t device_lock;
	struct disk_info *disks;
	struct bio_set bio_split;
	struct md_thread *thread;
	struct list_head temp_inactive_list[8];
	struct r5worker_group *worker_groups;
	int group_cnt;
	int worker_cnt_per_group;
	struct r5l_log *log;
	void *log_private;
	spinlock_t pending_bios_lock;
	bool batch_bio_dispatch;
	struct r5pending_data *pending_data;
	struct list_head free_list;
	struct list_head pending_list;
	int pending_data_cnt;
	struct r5pending_data *next_pending_data;
};

struct r5worker;

struct r5worker_group {
	struct list_head handle_list;
	struct list_head loprio_list;
	struct r5conf *conf;
	struct r5worker *workers;
	int stripes_cnt;
};

struct stripe_head_state {
	int syncing;
	int expanding;
	int expanded;
	int replacing;
	int locked;
	int uptodate;
	int to_read;
	int to_write;
	int failed;
	int written;
	int to_fill;
	int compute;
	int req_compute;
	int non_overwrite;
	int injournal;
	int just_cached;
	int failed_num[2];
	int p_failed;
	int q_failed;
	int dec_preread_active;
	long unsigned int ops_request;
	struct md_rdev *blocked_rdev;
	int handle_bad_blocks;
	int log_failed;
	int waiting_extra_page;
};

enum r5dev_flags {
	R5_UPTODATE = 0,
	R5_LOCKED = 1,
	R5_DOUBLE_LOCKED = 2,
	R5_OVERWRITE = 3,
	R5_Insync = 4,
	R5_Wantread = 5,
	R5_Wantwrite = 6,
	R5_Overlap = 7,
	R5_ReadNoMerge = 8,
	R5_ReadError = 9,
	R5_ReWrite = 10,
	R5_Expanded = 11,
	R5_Wantcompute = 12,
	R5_Wantfill = 13,
	R5_Wantdrain = 14,
	R5_WantFUA = 15,
	R5_SyncIO = 16,
	R5_WriteError = 17,
	R5_MadeGood = 18,
	R5_ReadRepl = 19,
	R5_MadeGoodRepl = 20,
	R5_NeedReplace = 21,
	R5_WantReplace = 22,
	R5_Discard = 23,
	R5_SkipCopy = 24,
	R5_InJournal = 25,
	R5_OrigPageUPTDODATE = 26,
};

enum {
	STRIPE_ACTIVE = 0,
	STRIPE_HANDLE = 1,
	STRIPE_SYNC_REQUESTED = 2,
	STRIPE_SYNCING = 3,
	STRIPE_INSYNC = 4,
	STRIPE_REPLACED = 5,
	STRIPE_PREREAD_ACTIVE = 6,
	STRIPE_DELAYED = 7,
	STRIPE_DEGRADED = 8,
	STRIPE_BIT_DELAY = 9,
	STRIPE_EXPANDING = 10,
	STRIPE_EXPAND_SOURCE = 11,
	STRIPE_EXPAND_READY = 12,
	STRIPE_IO_STARTED = 13,
	STRIPE_FULL_WRITE = 14,
	STRIPE_BIOFILL_RUN = 15,
	STRIPE_COMPUTE_RUN = 16,
	STRIPE_ON_UNPLUG_LIST = 17,
	STRIPE_DISCARD = 18,
	STRIPE_ON_RELEASE_LIST = 19,
	STRIPE_BATCH_READY = 20,
	STRIPE_BATCH_ERR = 21,
	STRIPE_BITMAP_PENDING = 22,
	STRIPE_LOG_TRAPPED = 23,
	STRIPE_R5C_CACHING = 24,
	STRIPE_R5C_PARTIAL_STRIPE = 25,
	STRIPE_R5C_FULL_STRIPE = 26,
	STRIPE_R5C_PREFLUSH = 27,
};

enum {
	STRIPE_OP_BIOFILL = 0,
	STRIPE_OP_COMPUTE_BLK = 1,
	STRIPE_OP_PREXOR = 2,
	STRIPE_OP_BIODRAIN = 3,
	STRIPE_OP_RECONSTRUCT = 4,
	STRIPE_OP_CHECK = 5,
	STRIPE_OP_PARTIAL_PARITY = 6,
};

enum {
	PARITY_DISABLE_RMW = 0,
	PARITY_ENABLE_RMW = 1,
	PARITY_PREFER_RMW = 2,
};

enum {
	SYNDROME_SRC_ALL = 0,
	SYNDROME_SRC_WANT_DRAIN = 1,
	SYNDROME_SRC_WRITTEN = 2,
};

struct disk_info {
	struct md_rdev *rdev;
	struct md_rdev *replacement;
	struct page___2 *extra_page;
};

struct r5worker {
	struct work_struct work;
	struct r5worker_group *group;
	struct list_head temp_inactive_list[8];
	bool working;
};

enum r5_cache_state {
	R5_INACTIVE_BLOCKED = 0,
	R5_ALLOC_MORE = 1,
	R5_DID_ALLOC = 2,
	R5C_LOG_TIGHT = 3,
	R5C_LOG_CRITICAL = 4,
	R5C_EXTRA_PAGE_IN_USE = 5,
};

struct r5pending_data {
	struct list_head sibling;
	sector_t sector;
	struct bio_list bios;
};

struct raid5_percpu {
	struct page___2 *spare_page;
	void *scribble;
	int scribble_obj_size;
};

struct raid5_plug_cb {
	struct blk_plug_cb cb;
	struct list_head list;
	struct list_head temp_inactive_list[8];
};

struct r5l_payload_header {
	__le16 type;
	__le16 flags;
};

enum r5l_payload_type {
	R5LOG_PAYLOAD_DATA = 0,
	R5LOG_PAYLOAD_PARITY = 1,
	R5LOG_PAYLOAD_FLUSH = 2,
};

struct r5l_payload_data_parity {
	struct r5l_payload_header header;
	__le32 size;
	__le64 location;
	__le32 checksum[0];
};

struct r5l_payload_flush {
	struct r5l_payload_header header;
	__le32 size;
	__le64 flush_stripes[0];
};

struct r5l_meta_block {
	__le32 magic;
	__le32 checksum;
	__u8 version;
	__u8 __zero_pading_1;
	__le16 __zero_pading_2;
	__le32 meta_size;
	__le64 seq;
	__le64 position;
	struct r5l_payload_header payloads[0];
};

struct r5l_io_unit {
	struct r5l_log *log;
	struct page___2 *meta_page;
	int meta_offset;
	struct bio *current_bio;
	atomic_t pending_stripe;
	u64 seq;
	sector_t log_start;
	sector_t log_end;
	struct list_head log_sibling;
	struct list_head stripe_list;
	int state;
	bool need_split_bio;
	struct bio *split_bio;
	unsigned int has_flush: 1;
	unsigned int has_fua: 1;
	unsigned int has_null_flush: 1;
	unsigned int has_flush_payload: 1;
	unsigned int io_deferred: 1;
	struct bio_list flush_barriers;
};

enum r5c_journal_mode {
	R5C_JOURNAL_MODE_WRITE_THROUGH = 0,
	R5C_JOURNAL_MODE_WRITE_BACK = 1,
};

struct r5l_log {
	struct md_rdev *rdev;
	u32 uuid_checksum;
	sector_t device_size;
	sector_t max_free_space;
	sector_t last_checkpoint;
	u64 last_cp_seq;
	sector_t log_start;
	u64 seq;
	sector_t next_checkpoint;
	struct mutex io_mutex;
	struct r5l_io_unit *current_io;
	spinlock_t io_list_lock;
	struct list_head running_ios;
	struct list_head io_end_ios;
	struct list_head flushing_ios;
	struct list_head finished_ios;
	struct bio flush_bio;
	struct list_head no_mem_stripes;
	struct kmem_cache *io_kc;
	mempool_t io_pool;
	struct bio_set bs;
	mempool_t meta_pool;
	struct md_thread *reclaim_thread;
	long unsigned int reclaim_target;
	wait_queue_head_t iounit_wait;
	struct list_head no_space_stripes;
	spinlock_t no_space_stripes_lock;
	bool need_cache_flush;
	enum r5c_journal_mode r5c_journal_mode;
	struct list_head stripe_in_journal_list;
	spinlock_t stripe_in_journal_lock;
	atomic_t stripe_in_journal_count;
	struct work_struct deferred_io_work;
	struct work_struct disable_writeback_work;
	spinlock_t tree_lock;
	struct xarray big_stripe_tree;
};

enum r5l_io_unit_state {
	IO_UNIT_RUNNING = 0,
	IO_UNIT_IO_START = 1,
	IO_UNIT_IO_END = 2,
	IO_UNIT_STRIPE_END = 3,
};

struct r5l_recovery_ctx {
	struct page___2 *meta_page;
	sector_t meta_total_blocks;
	sector_t pos;
	u64 seq;
	int data_parity_stripes;
	int data_only_stripes;
	struct list_head cached_list;
	struct page___2 *ra_pool[256];
	sector_t pool_offset;
	int total_pages;
	int valid_pages;
	struct bio *ra_bio;
};

struct ppl_header_entry {
	__le64 data_sector;
	__le32 pp_size;
	__le32 data_size;
	__le32 parity_disk;
	__le32 checksum;
};

struct ppl_header {
	__u8 reserved[512];
	__le32 signature;
	__le32 padding;
	__le64 generation;
	__le32 entries_count;
	__le32 checksum;
	struct ppl_header_entry entries[148];
};

struct ppl_log;

struct ppl_io_unit {
	struct ppl_log *log;
	struct page___2 *header_page;
	unsigned int entries_count;
	unsigned int pp_size;
	u64 seq;
	struct list_head log_sibling;
	struct list_head stripe_list;
	atomic_t pending_stripes;
	atomic_t pending_flushes;
	bool submitted;
	struct bio bio;
	struct bio_vec biovec[32];
};

struct ppl_conf {
	struct mddev *mddev;
	struct ppl_log *child_logs;
	int count;
	int block_size;
	u32 signature;
	atomic64_t seq;
	struct kmem_cache *io_kc;
	mempool_t io_pool;
	struct bio_set bs;
	struct bio_set flush_bs;
	int recovered_entries;
	int mismatch_count;
	struct list_head no_mem_stripes;
	spinlock_t no_mem_stripes_lock;
	short unsigned int write_hint;
};

struct ppl_log {
	struct ppl_conf *ppl_conf;
	struct md_rdev *rdev;
	struct mutex io_mutex;
	struct ppl_io_unit *current_io;
	spinlock_t io_list_lock;
	struct list_head io_list;
	sector_t next_io_sector;
	unsigned int entry_space;
	bool use_multippl;
	bool wb_cache_on;
	long unsigned int disk_flush_bitmap;
};

struct mdp_device_descriptor_s {
	__u32 number;
	__u32 major;
	__u32 minor;
	__u32 raid_disk;
	__u32 state;
	__u32 reserved[27];
};

typedef struct mdp_device_descriptor_s mdp_disk_t;

struct mdp_superblock_s {
	__u32 md_magic;
	__u32 major_version;
	__u32 minor_version;
	__u32 patch_version;
	__u32 gvalid_words;
	__u32 set_uuid0;
	__u32 ctime;
	__u32 level;
	__u32 size;
	__u32 nr_disks;
	__u32 raid_disks;
	__u32 md_minor;
	__u32 not_persistent;
	__u32 set_uuid1;
	__u32 set_uuid2;
	__u32 set_uuid3;
	__u32 gstate_creserved[16];
	__u32 utime;
	__u32 state;
	__u32 active_disks;
	__u32 working_disks;
	__u32 failed_disks;
	__u32 spare_disks;
	__u32 sb_csum;
	__u32 events_lo;
	__u32 events_hi;
	__u32 cp_events_lo;
	__u32 cp_events_hi;
	__u32 recovery_cp;
	__u64 reshape_position;
	__u32 new_level;
	__u32 delta_disks;
	__u32 new_layout;
	__u32 new_chunk;
	__u32 gstate_sreserved[14];
	__u32 layout;
	__u32 chunk_size;
	__u32 root_pv;
	__u32 root_block;
	__u32 pstate_reserved[60];
	mdp_disk_t disks[27];
	__u32 reserved[0];
	mdp_disk_t this_disk;
};

typedef struct mdp_superblock_s mdp_super_t;

struct mdu_version_s {
	int major;
	int minor;
	int patchlevel;
};

typedef struct mdu_version_s mdu_version_t;

struct mdu_bitmap_file_s {
	char pathname[4096];
};

typedef struct mdu_bitmap_file_s mdu_bitmap_file_t;

struct super_type {
	char *name;
	struct module___2 *owner;
	int (*load_super)(struct md_rdev *, struct md_rdev *, int);
	int (*validate_super)(struct mddev *, struct md_rdev *);
	void (*sync_super)(struct mddev *, struct md_rdev *);
	long long unsigned int (*rdev_size_change)(struct md_rdev *, sector_t);
	int (*allow_new_offset)(struct md_rdev *, long long unsigned int);
};

struct rdev_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct md_rdev *, char *);
	ssize_t (*store)(struct md_rdev *, const char *, size_t);
};

enum array_state {
	clear = 0,
	inactive = 1,
	suspended = 2,
	readonly = 3,
	read_auto = 4,
	clean = 5,
	active = 6,
	write_pending = 7,
	active_idle = 8,
	broken = 9,
	bad_word = 10,
};

struct detected_devices_node {
	struct list_head list;
	dev_t dev;
};

typedef __u16 bitmap_counter_t;

enum bitmap_state {
	BITMAP_STALE = 1,
	BITMAP_WRITE_ERROR = 2,
	BITMAP_HOSTENDIAN = 15,
};

struct bitmap_super_s {
	__le32 magic;
	__le32 version;
	__u8 uuid[16];
	__le64 events;
	__le64 events_cleared;
	__le64 sync_size;
	__le32 state;
	__le32 chunksize;
	__le32 daemon_sleep;
	__le32 write_behind;
	__le32 sectors_reserved;
	__le32 nodes;
	__u8 cluster_name[64];
	__u8 pad[120];
};

typedef struct bitmap_super_s bitmap_super_t;

enum bitmap_page_attr {
	BITMAP_PAGE_DIRTY = 0,
	BITMAP_PAGE_PENDING = 1,
	BITMAP_PAGE_NEEDWRITE = 2,
};

typedef enum {
	STATUSTYPE_INFO = 0,
	STATUSTYPE_TABLE = 1,
} status_type_t;

union map_info___2 {
	void *ptr;
};

struct dm_target;

typedef int (*dm_ctr_fn)(struct dm_target *, unsigned int, char **);

struct dm_table;

struct target_type;

struct dm_target {
	struct dm_table *table;
	struct target_type *type;
	sector_t begin;
	sector_t len;
	uint32_t max_io_len;
	unsigned int num_flush_bios;
	unsigned int num_discard_bios;
	unsigned int num_secure_erase_bios;
	unsigned int num_write_same_bios;
	unsigned int num_write_zeroes_bios;
	unsigned int per_io_data_size;
	void *private;
	char *error;
	bool flush_supported: 1;
	bool discards_supported: 1;
	bool limit_swap_bios: 1;
};

typedef void (*dm_dtr_fn)(struct dm_target *);

typedef int (*dm_map_fn)(struct dm_target *, struct bio *);

typedef int (*dm_clone_and_map_request_fn)(struct dm_target *, struct request *, union map_info___2 *, struct request **);

typedef void (*dm_release_clone_request_fn)(struct request *, union map_info___2 *);

typedef int (*dm_endio_fn)(struct dm_target *, struct bio *, blk_status_t *);

typedef int (*dm_request_endio_fn)(struct dm_target *, struct request *, blk_status_t, union map_info___2 *);

typedef void (*dm_presuspend_fn)(struct dm_target *);

typedef void (*dm_presuspend_undo_fn)(struct dm_target *);

typedef void (*dm_postsuspend_fn)(struct dm_target *);

typedef int (*dm_preresume_fn)(struct dm_target *);

typedef void (*dm_resume_fn)(struct dm_target *);

typedef void (*dm_status_fn)(struct dm_target *, status_type_t, unsigned int, char *, unsigned int);

typedef int (*dm_message_fn)(struct dm_target *, unsigned int, char **, char *, unsigned int);

typedef int (*dm_prepare_ioctl_fn)(struct dm_target *, struct block_device **);

struct dm_dev;

typedef int (*iterate_devices_callout_fn)(struct dm_target *, struct dm_dev *, sector_t, sector_t, void *);

struct dm_dev {
	struct block_device *bdev;
	struct dax_device *dax_dev;
	fmode_t mode;
	char name[16];
};

typedef int (*dm_iterate_devices_fn)(struct dm_target *, iterate_devices_callout_fn, void *);

typedef void (*dm_io_hints_fn)(struct dm_target *, struct queue_limits *);

typedef int (*dm_busy_fn)(struct dm_target *);

typedef long int (*dm_dax_direct_access_fn)(struct dm_target *, long unsigned int, long int, void **, pfn_t *);

typedef size_t (*dm_dax_copy_iter_fn)(struct dm_target *, long unsigned int, void *, size_t, struct iov_iter *);

struct target_type {
	uint64_t features;
	const char *name;
	struct module___2 *module;
	unsigned int version[3];
	dm_ctr_fn ctr;
	dm_dtr_fn dtr;
	dm_map_fn map;
	dm_clone_and_map_request_fn clone_and_map_rq;
	dm_release_clone_request_fn release_clone_rq;
	dm_endio_fn end_io;
	dm_request_endio_fn rq_end_io;
	dm_presuspend_fn presuspend;
	dm_presuspend_undo_fn presuspend_undo;
	dm_postsuspend_fn postsuspend;
	dm_preresume_fn preresume;
	dm_resume_fn resume;
	dm_status_fn status;
	dm_message_fn message;
	dm_prepare_ioctl_fn prepare_ioctl;
	dm_busy_fn busy;
	dm_iterate_devices_fn iterate_devices;
	dm_io_hints_fn io_hints;
	dm_dax_direct_access_fn direct_access;
	dm_dax_copy_iter_fn dax_copy_from_iter;
	dm_dax_copy_iter_fn dax_copy_to_iter;
	struct list_head list;
};

enum dm_uevent_type {
	DM_UEVENT_PATH_FAILED = 0,
	DM_UEVENT_PATH_REINSTATED = 1,
};

struct mapped_device;

struct dm_uevent {
	struct mapped_device *md;
	enum kobject_action action;
	struct kobj_uevent_env ku_env;
	struct list_head elist;
	char name[128];
	char uuid[129];
};

enum dm_queue_mode {
	DM_TYPE_NONE = 0,
	DM_TYPE_BIO_BASED = 1,
	DM_TYPE_REQUEST_BASED = 2,
	DM_TYPE_DAX_BIO_BASED = 3,
	DM_TYPE_NVME_BIO_BASED = 4,
};

struct dm_stats_last_position;

struct dm_stats {
	struct mutex mutex;
	struct list_head list;
	struct dm_stats_last_position *last;
	sector_t last_sector;
	unsigned int last_rw;
};

struct dm_stats_aux {
	bool merged;
	long long unsigned int duration_ns;
};

struct dm_kobject_holder {
	struct kobject___2 kobj;
	struct completion completion;
};

struct mapped_device {
	struct mutex suspend_lock;
	struct mutex table_devices_lock;
	struct list_head table_devices;
	void *map;
	long unsigned int flags;
	struct mutex type_lock;
	enum dm_queue_mode type;
	int numa_node_id;
	struct request_queue *queue;
	atomic_t holders;
	atomic_t open_count;
	struct dm_target *immutable_target;
	struct target_type *immutable_target_type;
	char name[16];
	struct gendisk *disk;
	struct dax_device *dax_dev;
	struct work_struct work;
	wait_queue_head_t wait;
	spinlock_t deferred_lock;
	struct bio_list deferred;
	void *interface_ptr;
	wait_queue_head_t eventq;
	atomic_t event_nr;
	atomic_t uevent_seq;
	struct list_head uevent_list;
	spinlock_t uevent_lock;
	unsigned int internal_suspend_count;
	struct bio_set io_bs;
	struct bio_set bs;
	struct workqueue_struct *wq;
	struct super_block *frozen_sb;
	struct hd_geometry geometry;
	struct dm_kobject_holder kobj_holder;
	struct block_device *bdev;
	int swap_bios;
	struct semaphore swap_bios_semaphore;
	struct mutex swap_bios_lock;
	struct dm_stats stats;
	struct blk_mq_tag_set *tag_set;
	bool init_tio_pdu: 1;
	struct srcu_struct io_barrier;
};

struct dm_io;

struct clone_info {
	struct dm_table *map;
	struct bio *bio;
	struct dm_io *io;
	sector_t sector;
	unsigned int sector_count;
};

struct dm_target_io {
	unsigned int magic;
	struct dm_io *io;
	struct dm_target *ti;
	unsigned int target_bio_nr;
	unsigned int *len_ptr;
	bool inside_dm_io;
	struct bio clone;
};

struct dm_io {
	unsigned int magic;
	struct mapped_device *md;
	blk_status_t status;
	atomic_t io_count;
	struct bio *orig_bio;
	long unsigned int start_time;
	spinlock_t endio_lock;
	struct dm_stats_aux stats_aux;
	struct dm_target_io tio;
};

struct dm_md_mempools {
	struct bio_set bs;
	struct bio_set io_bs;
};

struct table_device {
	struct list_head list;
	refcount_t count;
	struct dm_dev dm_dev;
};

struct dm_pr {
	u64 old_key;
	u64 new_key;
	u32 flags;
	bool fail_early;
};

struct dm_md_mempools;

struct dm_table {
	struct mapped_device *md;
	enum dm_queue_mode type;
	unsigned int depth;
	unsigned int counts[16];
	sector_t *index[16];
	unsigned int num_targets;
	unsigned int num_allocated;
	sector_t *highs;
	struct dm_target *targets;
	struct target_type *immutable_target_type;
	bool integrity_supported: 1;
	bool singleton: 1;
	unsigned int integrity_added: 1;
	fmode_t mode;
	struct list_head devices;
	void (*event_fn)(void *);
	void *event_context;
	struct dm_md_mempools *mempools;
	struct list_head target_callbacks;
};

struct dm_target_callbacks {
	struct list_head list;
	int (*congested_fn)(struct dm_target_callbacks *, int);
};

struct dm_arg_set {
	unsigned int argc;
	char **argv;
};

struct dm_arg {
	unsigned int min;
	unsigned int max;
	char *error;
};

struct dm_dev_internal {
	struct list_head list;
	refcount_t count;
	struct dm_dev *dm_dev;
};

enum suspend_mode {
	PRESUSPEND = 0,
	PRESUSPEND_UNDO = 1,
	POSTSUSPEND = 2,
};

struct linear_c {
	struct dm_dev *dev;
	sector_t start;
};

struct stripe {
	struct dm_dev *dev;
	sector_t physical_start;
	atomic_t error_count;
};

struct stripe_c {
	uint32_t stripes;
	int stripes_shift;
	sector_t stripe_width;
	uint32_t chunk_size;
	int chunk_size_shift;
	struct dm_target *ti;
	struct work_struct trigger_event;
	struct stripe stripe[0];
};

struct dm_ioctl {
	__u32 version[3];
	__u32 data_size;
	__u32 data_start;
	__u32 target_count;
	__s32 open_count;
	__u32 flags;
	__u32 event_nr;
	__u32 padding;
	__u64 dev;
	char name[128];
	char uuid[129];
	char data[7];
};

struct dm_target_spec {
	__u64 sector_start;
	__u64 length;
	__s32 status;
	__u32 next;
	char target_type[16];
};

struct dm_target_deps {
	__u32 count;
	__u32 padding;
	__u64 dev[0];
};

struct dm_name_list {
	__u64 dev;
	__u32 next;
	char name[0];
};

struct dm_target_versions {
	__u32 next;
	__u32 version[3];
	char name[0];
};

struct dm_target_msg {
	__u64 sector;
	char message[0];
};

enum {
	DM_VERSION_CMD = 0,
	DM_REMOVE_ALL_CMD = 1,
	DM_LIST_DEVICES_CMD = 2,
	DM_DEV_CREATE_CMD = 3,
	DM_DEV_REMOVE_CMD = 4,
	DM_DEV_RENAME_CMD = 5,
	DM_DEV_SUSPEND_CMD = 6,
	DM_DEV_STATUS_CMD = 7,
	DM_DEV_WAIT_CMD = 8,
	DM_TABLE_LOAD_CMD = 9,
	DM_TABLE_CLEAR_CMD = 10,
	DM_TABLE_DEPS_CMD = 11,
	DM_TABLE_STATUS_CMD = 12,
	DM_LIST_VERSIONS_CMD = 13,
	DM_TARGET_MSG_CMD = 14,
	DM_DEV_SET_GEOMETRY_CMD = 15,
	DM_DEV_ARM_POLL_CMD = 16,
	DM_GET_TARGET_VERSION_CMD = 17,
};

struct dm_file {
	volatile unsigned int global_event_nr;
};

struct hash_cell {
	struct list_head name_list;
	struct list_head uuid_list;
	char *name;
	char *uuid;
	struct mapped_device *md;
	struct dm_table *new_map;
};

struct vers_iter {
	size_t param_size;
	struct dm_target_versions *vers;
	struct dm_target_versions *old_vers;
	char *end;
	uint32_t flags;
};

typedef int (*ioctl_fn___2)(struct file___2 *, struct dm_ioctl *, size_t);

struct dm_io_region {
	struct block_device *bdev;
	sector_t sector;
	sector_t count;
};

struct page_list {
	struct page_list *next;
	struct page___2 *page;
};

typedef void (*io_notify_fn)(long unsigned int, void *);

enum dm_io_mem_type {
	DM_IO_PAGE_LIST = 0,
	DM_IO_BIO = 1,
	DM_IO_VMA = 2,
	DM_IO_KMEM = 3,
};

struct dm_io_memory {
	enum dm_io_mem_type type;
	unsigned int offset;
	union {
		struct page_list *pl;
		struct bio *bio;
		void *vma;
		void *addr;
	} ptr;
};

struct dm_io_notify {
	io_notify_fn fn;
	void *context;
};

struct dm_io_client;

struct dm_io_request {
	int bi_op;
	int bi_op_flags;
	struct dm_io_memory mem;
	struct dm_io_notify notify;
	struct dm_io_client *client;
};

struct dm_io_client {
	mempool_t pool;
	struct bio_set bios;
};

struct io {
	long unsigned int error_bits;
	atomic_t count;
	struct dm_io_client *client;
	io_notify_fn callback;
	void *context;
	void *vma_invalidate_address;
	long unsigned int vma_invalidate_size;
	long: 64;
};

struct dpages {
	void (*get_page)(struct dpages *, struct page___2 **, long unsigned int *, unsigned int *);
	void (*next_page)(struct dpages *);
	union {
		unsigned int context_u;
		struct bvec_iter context_bi;
	};
	void *context_ptr;
	void *vma_invalidate_address;
	long unsigned int vma_invalidate_size;
};

struct sync_io {
	long unsigned int error_bits;
	struct completion wait;
};

struct dm_kcopyd_throttle {
	unsigned int throttle;
	unsigned int num_io_jobs;
	unsigned int io_period;
	unsigned int total_period;
	unsigned int last_jiffies;
};

typedef void (*dm_kcopyd_notify_fn)(int, long unsigned int, void *);

struct dm_kcopyd_client {
	struct page_list *pages;
	unsigned int nr_reserved_pages;
	unsigned int nr_free_pages;
	unsigned int sub_job_size;
	struct dm_io_client *io_client;
	wait_queue_head_t destroyq;
	mempool_t job_pool;
	struct workqueue_struct *kcopyd_wq;
	struct work_struct kcopyd_work;
	struct dm_kcopyd_throttle *throttle;
	atomic_t nr_jobs;
	spinlock_t job_lock;
	struct list_head callback_jobs;
	struct list_head complete_jobs;
	struct list_head io_jobs;
	struct list_head pages_jobs;
};

struct kcopyd_job {
	struct dm_kcopyd_client *kc;
	struct list_head list;
	long unsigned int flags;
	int read_err;
	long unsigned int write_err;
	int rw;
	struct dm_io_region source;
	unsigned int num_dests;
	struct dm_io_region dests[8];
	struct page_list *pages;
	dm_kcopyd_notify_fn fn;
	void *context;
	struct mutex lock;
	atomic_t sub_jobs;
	sector_t progress;
	sector_t write_offset;
	struct kcopyd_job *master_job;
};

struct dm_sysfs_attr {
	struct attribute attr;
	ssize_t (*show)(struct mapped_device *, char *);
	ssize_t (*store)(struct mapped_device *, const char *, size_t);
};

struct dm_stats_last_position {
	sector_t last_sector;
	unsigned int last_rw;
};

struct dm_stat_percpu {
	long long unsigned int sectors[2];
	long long unsigned int ios[2];
	long long unsigned int merges[2];
	long long unsigned int ticks[2];
	long long unsigned int io_ticks[2];
	long long unsigned int io_ticks_total;
	long long unsigned int time_in_queue;
	long long unsigned int *histogram;
};

struct dm_stat_shared {
	atomic_t in_flight[2];
	long long unsigned int stamp;
	struct dm_stat_percpu tmp;
};

struct dm_stat {
	struct list_head list_entry;
	int id;
	unsigned int stat_flags;
	size_t n_entries;
	sector_t start;
	sector_t end;
	sector_t step;
	unsigned int n_histogram_entries;
	long long unsigned int *histogram_boundaries;
	const char *program_id;
	const char *aux_data;
	struct callback_head callback_head;
	size_t shared_alloc_size;
	size_t percpu_alloc_size;
	size_t histogram_alloc_size;
	struct dm_stat_percpu *stat_percpu[8192];
	struct dm_stat_shared stat_shared[0];
};

struct dm_rq_target_io;

struct dm_rq_clone_bio_info {
	struct bio *orig;
	struct dm_rq_target_io *tio;
	struct bio clone;
};

struct dm_rq_target_io {
	struct mapped_device *md;
	struct dm_target *ti;
	struct request *orig;
	struct request *clone;
	struct kthread_work work;
	blk_status_t error;
	union map_info___2 info;
	struct dm_stats_aux stats_aux;
	long unsigned int duration_jiffies;
	unsigned int n_sectors;
	unsigned int completed;
};

struct dm_buffer;

struct dm_bufio_client {
	struct mutex lock;
	struct list_head lru[2];
	long unsigned int n_buffers[2];
	struct block_device *bdev;
	unsigned int block_size;
	s8 sectors_per_block_bits;
	void (*alloc_callback)(struct dm_buffer *);
	void (*write_callback)(struct dm_buffer *);
	struct kmem_cache *slab_buffer;
	struct kmem_cache *slab_cache;
	struct dm_io_client *dm_io;
	struct list_head reserved_buffers;
	unsigned int need_reserved_buffers;
	unsigned int minimum_buffers;
	struct rb_root buffer_tree;
	wait_queue_head_t free_buffer_wait;
	sector_t start;
	int async_write_error;
	struct list_head client_list;
	struct shrinker shrinker;
};

struct dm_buffer {
	struct rb_node node;
	struct list_head lru_list;
	struct list_head global_list;
	sector_t block;
	void *data;
	unsigned char data_mode;
	unsigned char list_mode;
	blk_status_t read_error;
	blk_status_t write_error;
	unsigned int accessed;
	unsigned int hold_count;
	long unsigned int state;
	long unsigned int last_accessed;
	unsigned int dirty_start;
	unsigned int dirty_end;
	unsigned int write_start;
	unsigned int write_end;
	struct dm_bufio_client *c;
	struct list_head write_list;
	void (*end_io)(struct dm_buffer *, blk_status_t);
};

enum data_mode {
	DATA_MODE_SLAB = 0,
	DATA_MODE_GET_FREE_PAGES = 1,
	DATA_MODE_VMALLOC = 2,
	DATA_MODE_LIMIT = 3,
};

enum new_flag {
	NF_FRESH = 0,
	NF_READ = 1,
	NF_GET = 2,
	NF_PREFETCH = 3,
};

typedef sector_t chunk_t;

struct dm_exception {
	struct hlist_bl_node hash_list;
	chunk_t old_chunk;
	chunk_t new_chunk;
};

struct dm_exception_store;

struct dm_exception_store_type {
	const char *name;
	struct module___2 *module;
	int (*ctr)(struct dm_exception_store *, char *);
	void (*dtr)(struct dm_exception_store *);
	int (*read_metadata)(struct dm_exception_store *, int (*)(void *, chunk_t, chunk_t), void *);
	int (*prepare_exception)(struct dm_exception_store *, struct dm_exception *);
	void (*commit_exception)(struct dm_exception_store *, struct dm_exception *, int, void (*)(void *, int), void *);
	int (*prepare_merge)(struct dm_exception_store *, chunk_t *, chunk_t *);
	int (*commit_merge)(struct dm_exception_store *, int);
	void (*drop_snapshot)(struct dm_exception_store *);
	unsigned int (*status)(struct dm_exception_store *, status_type_t, char *, unsigned int);
	void (*usage)(struct dm_exception_store *, sector_t *, sector_t *, sector_t *);
	struct list_head list;
};

struct dm_snapshot;

struct dm_exception_store {
	struct dm_exception_store_type *type;
	struct dm_snapshot *snap;
	unsigned int chunk_size;
	unsigned int chunk_mask;
	unsigned int chunk_shift;
	void *context;
	bool userspace_supports_overflow;
};

struct dm_exception_table {
	uint32_t hash_mask;
	unsigned int hash_shift;
	struct hlist_bl_head *table;
};

struct dm_kcopyd_client;

struct dm_snapshot {
	struct rw_semaphore lock;
	struct dm_dev *origin;
	struct dm_dev *cow;
	struct dm_target *ti;
	struct list_head list;
	int valid;
	int snapshot_overflowed;
	int active;
	atomic_t pending_exceptions_count;
	spinlock_t pe_allocation_lock;
	sector_t exception_start_sequence;
	sector_t exception_complete_sequence;
	struct rb_root out_of_order_tree;
	mempool_t pending_pool;
	struct dm_exception_table pending;
	struct dm_exception_table complete;
	spinlock_t pe_lock;
	spinlock_t tracked_chunk_lock;
	struct hlist_head tracked_chunk_hash[16];
	struct dm_exception_store *store;
	unsigned int in_progress;
	struct wait_queue_head in_progress_wait;
	struct dm_kcopyd_client *kcopyd_client;
	long unsigned int state_bits;
	chunk_t first_merging_chunk;
	int num_merging_chunks;
	bool merge_failed: 1;
	bool discard_zeroes_cow: 1;
	bool discard_passdown_origin: 1;
	struct bio_list bios_queued_during_merge;
	struct bio flush_bio;
};

struct dm_snap_pending_exception {
	struct dm_exception e;
	struct bio_list origin_bios;
	struct bio_list snapshot_bios;
	struct dm_snapshot *snap;
	int started;
	int copy_error;
	sector_t exception_sequence;
	struct rb_node out_of_order_node;
	struct bio *full_bio;
	bio_end_io_t *full_bio_end_io;
};

struct dm_snap_tracked_chunk {
	struct hlist_node node;
	chunk_t chunk;
};

struct origin {
	struct block_device *bdev;
	struct list_head hash_list;
	struct list_head snapshots;
};

struct dm_origin {
	struct dm_dev *dev;
	struct dm_target *ti;
	unsigned int split_boundary;
	struct list_head hash_list;
};

struct dm_exception_table_lock {
	struct hlist_bl_head *complete_slot;
	struct hlist_bl_head *pending_slot;
};

struct transient_c {
	sector_t next_free;
};

struct disk_header {
	__le32 magic;
	__le32 valid;
	__le32 version;
	__le32 chunk_size;
};

struct disk_exception {
	__le64 old_chunk;
	__le64 new_chunk;
};

struct core_exception {
	uint64_t old_chunk;
	uint64_t new_chunk;
};

struct commit_callback {
	void (*callback)(void *, int);
	void *context;
};

struct pstore {
	struct dm_exception_store *store;
	int version;
	int valid;
	uint32_t exceptions_per_area;
	void *area;
	void *zero_area;
	void *header_area;
	chunk_t current_area;
	chunk_t next_free;
	uint32_t current_committed;
	atomic_t pending_count;
	uint32_t callback_count;
	struct commit_callback *callbacks;
	struct dm_io_client *io_client;
	struct workqueue_struct *metadata_wq;
};

struct mdata_req {
	struct dm_io_region *where;
	struct dm_io_request *io_req;
	struct work_struct work;
	int result;
};

struct dm_bufio_client;

struct dm_buffer;

enum opp_table_access {
	OPP_TABLE_ACCESS_UNKNOWN = 0,
	OPP_TABLE_ACCESS_EXCLUSIVE = 1,
	OPP_TABLE_ACCESS_SHARED = 2,
};

struct dev_pm_opp;

struct dev_pm_set_opp_data;

struct opp_table {
	struct list_head node;
	struct blocking_notifier_head head;
	struct list_head dev_list;
	struct list_head opp_list;
	struct kref kref;
	struct mutex lock;
	struct device_node___2 *np;
	long unsigned int clock_latency_ns_max;
	unsigned int voltage_tolerance_v1;
	unsigned int parsed_static_opps;
	enum opp_table_access shared_opp;
	struct dev_pm_opp *suspend_opp;
	struct mutex genpd_virt_dev_lock;
	struct device___2 **genpd_virt_devs;
	struct opp_table **required_opp_tables;
	unsigned int required_opp_count;
	unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char *prop_name;
	struct clk *clk;
	struct regulator **regulators;
	int regulator_count;
	bool genpd_performance_state;
	bool is_genpd;
	int (*set_opp)(struct dev_pm_set_opp_data *);
	struct dev_pm_set_opp_data *set_opp_data;
	struct dentry *dentry;
	char dentry_name[255];
};

struct dev_pm_opp_supply;

struct dev_pm_opp {
	struct list_head node;
	struct kref kref;
	bool available;
	bool dynamic;
	bool turbo;
	bool suspend;
	unsigned int pstate;
	long unsigned int rate;
	unsigned int level;
	struct dev_pm_opp_supply *supplies;
	long unsigned int clock_latency_ns;
	struct dev_pm_opp **required_opps;
	struct opp_table *opp_table;
	struct device_node___2 *np;
	struct dentry *dentry;
};

enum dev_pm_opp_event {
	OPP_EVENT_ADD = 0,
	OPP_EVENT_REMOVE = 1,
	OPP_EVENT_ENABLE = 2,
	OPP_EVENT_DISABLE = 3,
};

struct dev_pm_opp_supply {
	long unsigned int u_volt;
	long unsigned int u_volt_min;
	long unsigned int u_volt_max;
	long unsigned int u_amp;
};

struct dev_pm_opp_info {
	long unsigned int rate;
	struct dev_pm_opp_supply *supplies;
};

struct dev_pm_set_opp_data {
	struct dev_pm_opp_info old_opp;
	struct dev_pm_opp_info new_opp;
	struct regulator **regulators;
	unsigned int regulator_count;
	struct clk *clk;
	struct device___2 *dev;
};

struct opp_device {
	struct list_head node;
	const struct device___2 *dev;
	struct dentry *dentry;
};

struct cpufreq_policy_data {
	struct cpufreq_cpuinfo cpuinfo;
	struct cpufreq_frequency_table *freq_table;
	unsigned int cpu;
	unsigned int min;
	unsigned int max;
};

struct freq_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpufreq_policy *, char *);
	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t);
};

struct cpufreq_driver {
	char name[16];
	u8 flags;
	void *driver_data;
	int (*init)(struct cpufreq_policy *);
	int (*verify)(struct cpufreq_policy_data *);
	int (*setpolicy)(struct cpufreq_policy *);
	int (*target)(struct cpufreq_policy *, unsigned int, unsigned int);
	int (*target_index)(struct cpufreq_policy *, unsigned int);
	unsigned int (*fast_switch)(struct cpufreq_policy *, unsigned int);
	unsigned int (*resolve_freq)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get)(unsigned int);
	void (*update_limits)(unsigned int);
	int (*bios_limit)(int, unsigned int *);
	int (*online)(struct cpufreq_policy *);
	int (*offline)(struct cpufreq_policy *);
	int (*exit)(struct cpufreq_policy *);
	void (*stop_cpu)(struct cpufreq_policy *);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
	void (*ready)(struct cpufreq_policy *);
	struct freq_attr **attr;
	bool boost_enabled;
	int (*set_boost)(int);
};

enum {
	OD_NORMAL_SAMPLE = 0,
	OD_SUB_SAMPLE = 1,
};

struct dbs_data {
	struct gov_attr_set attr_set;
	void *tuners;
	unsigned int ignore_nice_load;
	unsigned int sampling_rate;
	unsigned int sampling_down_factor;
	unsigned int up_threshold;
	unsigned int io_is_busy;
};

struct policy_dbs_info {
	struct cpufreq_policy *policy;
	struct mutex update_mutex;
	u64 last_sample_time;
	s64 sample_delay_ns;
	atomic_t work_count;
	struct irq_work irq_work;
	struct work_struct work;
	struct dbs_data *dbs_data;
	struct list_head list;
	unsigned int rate_mult;
	unsigned int idle_periods;
	bool is_shared;
	bool work_in_progress;
};

struct dbs_governor {
	struct cpufreq_governor gov;
	struct kobj_type___2 kobj_type;
	struct dbs_data *gdbs_data;
	unsigned int (*gov_dbs_update)(struct cpufreq_policy *);
	struct policy_dbs_info * (*alloc)();
	void (*free)(struct policy_dbs_info *);
	int (*init)(struct dbs_data *);
	void (*exit)(struct dbs_data *);
	void (*start)(struct cpufreq_policy *);
};

struct od_ops {
	unsigned int (*powersave_bias_target)(struct cpufreq_policy *, unsigned int, unsigned int);
};

struct od_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int freq_lo;
	unsigned int freq_lo_delay_us;
	unsigned int freq_hi_delay_us;
	unsigned int sample_type: 1;
};

struct od_dbs_tuners {
	unsigned int powersave_bias;
};

struct cs_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int down_skip;
	unsigned int requested_freq;
};

struct cs_dbs_tuners {
	unsigned int down_threshold;
	unsigned int freq_step;
};

struct cpu_dbs_info {
	u64 prev_cpu_idle;
	u64 prev_update_time;
	u64 prev_cpu_nice;
	unsigned int prev_load;
	struct update_util_data update_util;
	struct policy_dbs_info *policy_dbs;
};

enum acpi_preferred_pm_profiles {
	PM_UNSPECIFIED = 0,
	PM_DESKTOP = 1,
	PM_MOBILE = 2,
	PM_WORKSTATION = 3,
	PM_ENTERPRISE_SERVER = 4,
	PM_SOHO_SERVER = 5,
	PM_APPLIANCE_PC = 6,
	PM_PERFORMANCE_SERVER = 7,
	PM_TABLET = 8,
};

struct sample {
	int32_t core_avg_perf;
	int32_t busy_scaled;
	u64 aperf;
	u64 mperf;
	u64 tsc;
	u64 time;
};

struct pstate_data {
	int current_pstate;
	int min_pstate;
	int max_pstate;
	int max_pstate_physical;
	int scaling;
	int turbo_pstate;
	unsigned int max_freq;
	unsigned int turbo_freq;
};

struct vid_data {
	int min;
	int max;
	int turbo;
	int32_t ratio;
};

struct global_params {
	bool no_turbo;
	bool turbo_disabled;
	bool turbo_disabled_mf;
	int max_perf_pct;
	int min_perf_pct;
};

struct cpudata {
	int cpu;
	unsigned int policy;
	struct update_util_data update_util;
	bool update_util_set;
	struct pstate_data pstate;
	struct vid_data vid;
	u64 last_update;
	u64 last_sample_time;
	u64 aperf_mperf_shift;
	u64 prev_aperf;
	u64 prev_mperf;
	u64 prev_tsc;
	u64 prev_cummulative_iowait;
	struct sample sample;
	int32_t min_perf_ratio;
	int32_t max_perf_ratio;
	struct acpi_processor_performance acpi_perf_data;
	bool valid_pss_table;
	unsigned int iowait_boost;
	s16 epp_powersave;
	s16 epp_policy;
	s16 epp_default;
	s16 epp_saved;
	u64 hwp_req_cached;
	u64 hwp_cap_cached;
	u64 last_io_update;
	unsigned int sched_flags;
	u32 hwp_boost_min;
};

struct pstate_funcs {
	int (*get_max)();
	int (*get_max_physical)();
	int (*get_min)();
	int (*get_turbo)();
	int (*get_scaling)();
	int (*get_aperf_mperf_shift)();
	u64 (*get_val)(struct cpudata *, int);
	void (*get_vid)(struct cpudata *);
};

enum {
	PSS = 0,
	PPC = 1,
};

struct cpuidle_governor {
	char name[16];
	struct list_head governor_list;
	unsigned int rating;
	int (*enable)(struct cpuidle_driver *, struct cpuidle_device *);
	void (*disable)(struct cpuidle_driver *, struct cpuidle_device *);
	int (*select)(struct cpuidle_driver *, struct cpuidle_device *, bool *);
	void (*reflect)(struct cpuidle_device *, int);
};

struct cpuidle_state_kobj {
	struct cpuidle_state *state;
	struct cpuidle_state_usage *state_usage;
	struct completion kobj_unregister;
	struct kobject___2 kobj;
	struct cpuidle_device *device;
};

struct cpuidle_device_kobj {
	struct cpuidle_device *dev;
	struct completion kobj_unregister;
	struct kobject___2 kobj;
};

struct cpuidle_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_device *, char *);
	ssize_t (*store)(struct cpuidle_device *, const char *, size_t);
};

struct cpuidle_state_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_state *, struct cpuidle_state_usage *, char *);
	ssize_t (*store)(struct cpuidle_state *, struct cpuidle_state_usage *, const char *, size_t);
};

struct ladder_device_state {
	struct {
		u32 promotion_count;
		u32 demotion_count;
		u32 promotion_time;
		u32 demotion_time;
	} threshold;
	struct {
		int promotion_count;
		int demotion_count;
	} stats;
};

struct ladder_device {
	struct ladder_device_state states[10];
};

struct menu_device {
	int needs_update;
	int tick_wakeup;
	unsigned int next_timer_us;
	unsigned int bucket;
	unsigned int correction_factor[12];
	unsigned int intervals[8];
	int interval_ptr;
};

enum dmi_entry_type {
	DMI_ENTRY_BIOS = 0,
	DMI_ENTRY_SYSTEM = 1,
	DMI_ENTRY_BASEBOARD = 2,
	DMI_ENTRY_CHASSIS = 3,
	DMI_ENTRY_PROCESSOR = 4,
	DMI_ENTRY_MEM_CONTROLLER = 5,
	DMI_ENTRY_MEM_MODULE = 6,
	DMI_ENTRY_CACHE = 7,
	DMI_ENTRY_PORT_CONNECTOR = 8,
	DMI_ENTRY_SYSTEM_SLOT = 9,
	DMI_ENTRY_ONBOARD_DEVICE = 10,
	DMI_ENTRY_OEMSTRINGS = 11,
	DMI_ENTRY_SYSCONF = 12,
	DMI_ENTRY_BIOS_LANG = 13,
	DMI_ENTRY_GROUP_ASSOC = 14,
	DMI_ENTRY_SYSTEM_EVENT_LOG = 15,
	DMI_ENTRY_PHYS_MEM_ARRAY = 16,
	DMI_ENTRY_MEM_DEVICE = 17,
	DMI_ENTRY_32_MEM_ERROR = 18,
	DMI_ENTRY_MEM_ARRAY_MAPPED_ADDR = 19,
	DMI_ENTRY_MEM_DEV_MAPPED_ADDR = 20,
	DMI_ENTRY_BUILTIN_POINTING_DEV = 21,
	DMI_ENTRY_PORTABLE_BATTERY = 22,
	DMI_ENTRY_SYSTEM_RESET = 23,
	DMI_ENTRY_HW_SECURITY = 24,
	DMI_ENTRY_SYSTEM_POWER_CONTROLS = 25,
	DMI_ENTRY_VOLTAGE_PROBE = 26,
	DMI_ENTRY_COOLING_DEV = 27,
	DMI_ENTRY_TEMP_PROBE = 28,
	DMI_ENTRY_ELECTRICAL_CURRENT_PROBE = 29,
	DMI_ENTRY_OOB_REMOTE_ACCESS = 30,
	DMI_ENTRY_BIS_ENTRY = 31,
	DMI_ENTRY_SYSTEM_BOOT = 32,
	DMI_ENTRY_MGMT_DEV = 33,
	DMI_ENTRY_MGMT_DEV_COMPONENT = 34,
	DMI_ENTRY_MGMT_DEV_THRES = 35,
	DMI_ENTRY_MEM_CHANNEL = 36,
	DMI_ENTRY_IPMI_DEV = 37,
	DMI_ENTRY_SYS_POWER_SUPPLY = 38,
	DMI_ENTRY_ADDITIONAL = 39,
	DMI_ENTRY_ONBOARD_DEV_EXT = 40,
	DMI_ENTRY_MGMT_CONTROLLER_HOST = 41,
	DMI_ENTRY_INACTIVE = 126,
	DMI_ENTRY_END_OF_TABLE = 127,
};

struct dmi_memdev_info {
	const char *device;
	const char *bank;
	u64 size;
	u16 handle;
};

struct dmi_sysfs_entry {
	struct dmi_header dh;
	struct kobject___2 kobj;
	int instance;
	int position;
	struct list_head list;
	struct kobject___2 *child;
};

struct dmi_sysfs_attribute {
	struct attribute attr;
	ssize_t (*show)(struct dmi_sysfs_entry *, char *);
};

struct dmi_sysfs_mapped_attribute {
	struct attribute attr;
	ssize_t (*show)(struct dmi_sysfs_entry *, const struct dmi_header *, char *);
};

typedef ssize_t (*dmi_callback)(struct dmi_sysfs_entry *, const struct dmi_header *, void *);

struct find_dmi_data {
	struct dmi_sysfs_entry *entry;
	dmi_callback callback;
	void *private;
	int instance_countdown;
	ssize_t ret;
};

struct dmi_read_state {
	char *buf;
	loff_t pos;
	size_t count;
};

struct dmi_entry_attr_show_data {
	struct attribute *attr;
	char *buf;
};

struct dmi_system_event_log {
	struct dmi_header header;
	u16 area_length;
	u16 header_start_offset;
	u16 data_start_offset;
	u8 access_method;
	u8 status;
	u32 change_token;
	union {
		struct {
			u16 index_addr;
			u16 data_addr;
		} io;
		u32 phys_addr32;
		u16 gpnv_handle;
		u32 access_method_address;
	};
	u8 header_format;
	u8 type_descriptors_supported_count;
	u8 per_log_type_descriptor_length;
	u8 supported_log_type_descriptos[0];
} __attribute__((packed));

typedef u8 (*sel_io_reader)(const struct dmi_system_event_log *, loff_t);

struct dmi_device_attribute {
	struct device_attribute___2 dev_attr;
	int field;
};

struct mafield {
	const char *prefix;
	int field;
};

struct acpi_table_ibft {
	struct acpi_table_header header;
	u8 reserved[12];
};

struct firmware_map_entry {
	u64 start;
	u64 end;
	const char *type;
	struct list_head list;
	struct kobject___2 kobj;
};

struct memmap_attribute {
	struct attribute attr;
	ssize_t (*show)(struct firmware_map_entry *, char *);
};

struct bmp_header {
	u16 id;
	u32 size;
} __attribute__((packed));

typedef efi_status_t efi_query_variable_store_t(u32, long unsigned int, bool);

typedef struct {
	efi_guid_t guid;
	u32 table;
} efi_config_table_32_t;

typedef struct {
	u32 version;
	u32 length;
	u64 memory_protection_attribute;
} efi_properties_table_t;

struct efivar_operations {
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_store_t *query_variable_store;
};

struct efivars {
	struct kset___2 *kset;
	struct kobject___2 *kobject;
	const struct efivar_operations *ops;
};

struct linux_efi_random_seed {
	u32 size;
	u8 bits[0];
};

struct linux_efi_memreserve {
	int size;
	atomic_t count;
	phys_addr_t next;
	struct {
		phys_addr_t base;
		phys_addr_t size;
	} entry[0];
};

struct efi_generic_dev_path {
	u8 type;
	u8 sub_type;
	u16 length;
};

struct variable_validate {
	efi_guid_t vendor;
	char *name;
	bool (*validate)(efi_char16_t *, int, u8 *, long unsigned int);
};

typedef struct {
	u32 version;
	u32 num_entries;
	u32 desc_size;
	u32 reserved;
	efi_memory_desc_t entry[0];
} efi_memory_attributes_table_t;

typedef int (*efi_memattr_perm_setter___2)(struct mm_struct___2 *, efi_memory_desc_t *);

typedef struct {
	u64 length;
	u64 data;
} efi_capsule_block_desc_t;

struct compat_efi_variable {
	efi_char16_t VariableName[512];
	efi_guid_t VendorGuid;
	__u32 DataSize;
	__u8 Data[1024];
	__u32 Status;
	__u32 Attributes;
};

struct efivar_attribute {
	struct attribute attr;
	ssize_t (*show)(struct efivar_entry *, char *);
	ssize_t (*store)(struct efivar_entry *, const char *, size_t);
};

struct efi_system_resource_entry_v1 {
	efi_guid_t fw_class;
	u32 fw_type;
	u32 fw_version;
	u32 lowest_supported_fw_version;
	u32 capsule_flags;
	u32 last_attempt_version;
	u32 last_attempt_status;
};

struct efi_system_resource_table {
	u32 fw_resource_count;
	u32 fw_resource_count_max;
	u64 fw_resource_version;
	u8 entries[0];
};

struct esre_entry {
	union {
		struct efi_system_resource_entry_v1 *esre1;
	} esre;
	struct kobject kobj;
	struct list_head list;
};

struct esre_attribute {
	struct attribute attr;
	ssize_t (*show)(struct esre_entry *, char *);
	ssize_t (*store)(struct esre_entry *, const char *, size_t);
};

struct cper_sec_proc_generic {
	u64 validation_bits;
	u8 proc_type;
	u8 proc_isa;
	u8 proc_error_type;
	u8 operation;
	u8 flags;
	u8 level;
	u16 reserved;
	u64 cpu_version;
	char cpu_brand[128];
	u64 proc_id;
	u64 target_addr;
	u64 requestor_id;
	u64 responder_id;
	u64 ip;
};

struct cper_sec_proc_ia {
	u64 validation_bits;
	u64 lapic_id;
	u8 cpuid[48];
};

struct cper_mem_err_compact {
	u64 validation_bits;
	u16 node;
	u16 card;
	u16 module;
	u16 bank;
	u16 device;
	u16 row;
	u16 column;
	u16 bit_pos;
	u64 requestor_id;
	u64 responder_id;
	u64 target_id;
	u16 rank;
	u16 mem_array_handle;
	u16 mem_dev_handle;
} __attribute__((packed));

struct efi_runtime_map_entry {
	efi_memory_desc_t md;
	struct kobject___2 kobj;
};

struct map_attribute {
	struct attribute attr;
	ssize_t (*show)(struct efi_runtime_map_entry *, char *);
};

struct cper_ia_err_info {
	guid_t err_type;
	u64 validation_bits;
	u64 check_info;
	u64 target_id;
	u64 requestor_id;
	u64 responder_id;
	u64 ip;
};

struct cper_ia_proc_ctx {
	u16 reg_ctx_type;
	u16 reg_arr_size;
	u32 msr_addr;
	u64 mm_reg_addr;
};

enum err_types {
	ERR_TYPE_CACHE = 0,
	ERR_TYPE_TLB = 1,
	ERR_TYPE_BUS = 2,
	ERR_TYPE_MS = 3,
	N_ERR_TYPES = 4,
};

union hv_stimer_config {
	u64 as_uint64;
	struct {
		u64 enable: 1;
		u64 periodic: 1;
		u64 lazy: 1;
		u64 auto_enable: 1;
		u64 apic_vector: 8;
		u64 direct_mode: 1;
		u64 reserved_z0: 3;
		u64 sintx: 4;
		u64 reserved_z1: 44;
	};
};

struct dca_domain {
	struct list_head node;
	struct list_head dca_providers;
	struct pci_bus *pci_rc;
};

struct hid_device_id {
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	kernel_ulong_t driver_data;
};

struct hid_item {
	unsigned int format;
	__u8 size;
	__u8 type;
	__u8 tag;
	union {
		__u8 u8;
		__s8 s8;
		__u16 u16;
		__s16 s16;
		__u32 u32;
		__s32 s32;
		__u8 *longdata;
	} data;
};

struct hid_global {
	unsigned int usage_page;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	unsigned int report_id;
	unsigned int report_size;
	unsigned int report_count;
};

struct hid_local {
	unsigned int usage[12288];
	u8 usage_size[12288];
	unsigned int collection_index[12288];
	unsigned int usage_index;
	unsigned int usage_minimum;
	unsigned int delimiter_depth;
	unsigned int delimiter_branch;
};

struct hid_collection {
	int parent_idx;
	unsigned int type;
	unsigned int usage;
	unsigned int level;
};

struct hid_usage {
	unsigned int hid;
	unsigned int collection_index;
	unsigned int usage_index;
	__s8 resolution_multiplier;
	__s8 wheel_factor;
	__u16 code;
	__u8 type;
	__s8 hat_min;
	__s8 hat_max;
	__s8 hat_dir;
	__s16 wheel_accumulated;
};

struct hid_report;

struct hid_input;

struct hid_field {
	unsigned int physical;
	unsigned int logical;
	unsigned int application;
	struct hid_usage *usage;
	unsigned int maxusage;
	unsigned int flags;
	unsigned int report_offset;
	unsigned int report_size;
	unsigned int report_count;
	unsigned int report_type;
	__s32 *value;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	struct hid_report *report;
	unsigned int index;
	struct hid_input *hidinput;
	__u16 dpad;
};

struct hid_device;

struct hid_report {
	struct list_head list;
	struct list_head hidinput_list;
	unsigned int id;
	unsigned int type;
	unsigned int application;
	struct hid_field *field[256];
	unsigned int maxfield;
	unsigned int size;
	struct hid_device *device;
};

struct hid_input {
	struct list_head list;
	struct hid_report *report;
	struct input_dev *input;
	const char *name;
	bool registered;
	struct list_head reports;
	unsigned int application;
};

enum hid_type {
	HID_TYPE_OTHER = 0,
	HID_TYPE_USBMOUSE = 1,
	HID_TYPE_USBNONE = 2,
};

struct hid_report_enum {
	unsigned int numbered;
	struct list_head report_list;
	struct hid_report *report_id_hash[256];
};

struct hid_driver;

struct hid_ll_driver;

struct hid_device {
	__u8 *dev_rdesc;
	unsigned int dev_rsize;
	__u8 *rdesc;
	unsigned int rsize;
	struct hid_collection *collection;
	unsigned int collection_size;
	unsigned int maxcollection;
	unsigned int maxapplication;
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	__u32 version;
	enum hid_type type;
	unsigned int country;
	struct hid_report_enum report_enum[3];
	struct work_struct led_work;
	struct semaphore driver_input_lock;
	struct device___2 dev;
	struct hid_driver *driver;
	struct hid_ll_driver *ll_driver;
	struct mutex ll_open_lock;
	unsigned int ll_open_count;
	long unsigned int status;
	unsigned int claimed;
	unsigned int quirks;
	bool io_started;
	struct list_head inputs;
	void *hiddev;
	void *hidraw;
	char name[128];
	char phys[64];
	char uniq[64];
	void *driver_data;
	int (*ff_init)(struct hid_device *);
	int (*hiddev_connect)(struct hid_device *, unsigned int);
	void (*hiddev_disconnect)(struct hid_device *);
	void (*hiddev_hid_event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*hiddev_report_event)(struct hid_device *, struct hid_report *);
	short unsigned int debug;
	struct dentry___2 *debug_dir;
	struct dentry___2 *debug_rdesc;
	struct dentry___2 *debug_events;
	struct list_head debug_list;
	spinlock_t debug_list_lock;
	wait_queue_head_t debug_wait;
};

struct hid_report_id;

struct hid_usage_id;

struct hid_driver {
	char *name;
	const struct hid_device_id *id_table;
	struct list_head dyn_list;
	spinlock_t dyn_lock;
	bool (*match)(struct hid_device *, bool);
	int (*probe)(struct hid_device *, const struct hid_device_id *);
	void (*remove)(struct hid_device *);
	const struct hid_report_id *report_table;
	int (*raw_event)(struct hid_device *, struct hid_report *, u8 *, int);
	const struct hid_usage_id *usage_table;
	int (*event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*report)(struct hid_device *, struct hid_report *);
	__u8 * (*report_fixup)(struct hid_device *, __u8 *, unsigned int *);
	int (*input_mapping)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_mapped)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_configured)(struct hid_device *, struct hid_input *);
	void (*feature_mapping)(struct hid_device *, struct hid_field *, struct hid_usage *);
	int (*suspend)(struct hid_device *, pm_message_t);
	int (*resume)(struct hid_device *);
	int (*reset_resume)(struct hid_device *);
	struct device_driver___2 driver;
};

struct hid_ll_driver {
	int (*start)(struct hid_device *);
	void (*stop)(struct hid_device *);
	int (*open)(struct hid_device *);
	void (*close)(struct hid_device *);
	int (*power)(struct hid_device *, int);
	int (*parse)(struct hid_device *);
	void (*request)(struct hid_device *, struct hid_report *, int);
	int (*wait)(struct hid_device *);
	int (*raw_request)(struct hid_device *, unsigned char, __u8 *, size_t, unsigned char, int);
	int (*output_report)(struct hid_device *, __u8 *, size_t);
	int (*idle)(struct hid_device *, int, int, int);
};

struct hid_parser {
	struct hid_global global;
	struct hid_global global_stack[4];
	unsigned int global_stack_ptr;
	struct hid_local local;
	unsigned int *collection_stack;
	unsigned int collection_stack_ptr;
	unsigned int collection_stack_size;
	struct hid_device *device;
	unsigned int scan_flags;
};

struct hid_report_id {
	__u32 report_type;
};

struct hid_usage_id {
	__u32 usage_hid;
	__u32 usage_type;
	__u32 usage_code;
};

struct hiddev {
	int minor;
	int exist;
	int open;
	struct mutex existancelock;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct list_head list;
	spinlock_t list_lock;
	bool initialized;
};

struct hidraw {
	unsigned int minor;
	int exist;
	int open;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct device___2 *dev;
	spinlock_t list_lock;
	struct list_head list;
};

struct hid_dynid {
	struct list_head list;
	struct hid_device_id id;
};

typedef bool (*hid_usage_cmp_t)(struct hid_usage *, unsigned int, unsigned int);

struct quirks_list_struct {
	struct hid_device_id hid_bl_item;
	struct list_head node;
};

struct hid_debug_list {
	struct {
		union {
			struct __kfifo kfifo;
			char *type;
			const char *const_type;
			char (*rectype)[0];
			char *ptr;
			const char *ptr_const;
		};
		char buf[0];
	} hid_debug_fifo;
	struct fasync_struct___2 *fasync;
	struct hid_device *hdev;
	struct list_head node;
	struct mutex read_mutex;
};

struct hid_usage_entry {
	unsigned int page;
	unsigned int usage;
	const char *description;
};

struct a4tech_sc {
	long unsigned int quirks;
	unsigned int hw_wheel;
	__s32 delayed_value;
};

struct apple_sc {
	long unsigned int quirks;
	unsigned int fn_on;
	unsigned int fn_found;
	long unsigned int pressed_numlock[12];
};

struct apple_key_translation {
	u16 from;
	u16 to;
	u8 flags;
};

struct lg_drv_data {
	long unsigned int quirks;
	void *device_props;
};

struct ms_data {
	long unsigned int quirks;
	struct hid_device *hdev;
	struct work_struct ff_worker;
	__u8 strong;
	__u8 weak;
	void *output_report_dmabuf;
};

enum {
	MAGNITUDE_STRONG = 2,
	MAGNITUDE_WEAK = 3,
	MAGNITUDE_NUM = 4,
};

struct xb1s_ff_report {
	__u8 report_id;
	__u8 enable;
	__u8 magnitude[4];
	__u8 duration_10ms;
	__u8 start_delay_10ms;
	__u8 loop_count;
};

struct hid_control_fifo {
	unsigned char dir;
	struct hid_report *report;
	char *raw_report;
};

struct hid_output_fifo {
	struct hid_report *report;
	char *raw_report;
};

struct hid_class_descriptor {
	__u8 bDescriptorType;
	__le16 wDescriptorLength;
} __attribute__((packed));

struct hid_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdHID;
	__u8 bCountryCode;
	__u8 bNumDescriptors;
	struct hid_class_descriptor desc[1];
} __attribute__((packed));

struct usbhid_device {
	struct hid_device *hid;
	struct usb_interface *intf;
	int ifnum;
	unsigned int bufsize;
	struct urb *urbin;
	char *inbuf;
	dma_addr_t inbuf_dma;
	struct urb *urbctrl;
	struct usb_ctrlrequest *cr;
	struct hid_control_fifo ctrl[256];
	unsigned char ctrlhead;
	unsigned char ctrltail;
	char *ctrlbuf;
	dma_addr_t ctrlbuf_dma;
	long unsigned int last_ctrl;
	struct urb *urbout;
	struct hid_output_fifo out[256];
	unsigned char outhead;
	unsigned char outtail;
	char *outbuf;
	dma_addr_t outbuf_dma;
	long unsigned int last_out;
	struct mutex mutex;
	spinlock_t lock;
	long unsigned int iofl;
	struct timer_list io_retry;
	long unsigned int stop_retry;
	unsigned int retry_delay;
	struct work_struct reset_work;
	wait_queue_head_t wait;
};

struct hiddev_event {
	unsigned int hid;
	int value;
};

struct hiddev_devinfo {
	__u32 bustype;
	__u32 busnum;
	__u32 devnum;
	__u32 ifnum;
	__s16 vendor;
	__s16 product;
	__s16 version;
	__u32 num_applications;
};

struct hiddev_collection_info {
	__u32 index;
	__u32 type;
	__u32 usage;
	__u32 level;
};

struct hiddev_report_info {
	__u32 report_type;
	__u32 report_id;
	__u32 num_fields;
};

struct hiddev_field_info {
	__u32 report_type;
	__u32 report_id;
	__u32 field_index;
	__u32 maxusage;
	__u32 flags;
	__u32 physical;
	__u32 logical;
	__u32 application;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__u32 unit_exponent;
	__u32 unit;
};

struct hiddev_usage_ref {
	__u32 report_type;
	__u32 report_id;
	__u32 field_index;
	__u32 usage_index;
	__u32 usage_code;
	__s32 value;
};

struct hiddev_usage_ref_multi {
	struct hiddev_usage_ref uref;
	__u32 num_values;
	__s32 values[1024];
};

struct hiddev_list {
	struct hiddev_usage_ref buffer[2048];
	int head;
	int tail;
	unsigned int flags;
	struct fasync_struct___2 *fasync;
	struct hiddev *hiddev;
	struct list_head node;
	struct mutex thread_lock;
};

struct ashmem_pin {
	__u32 offset;
	__u32 len;
};

struct ashmem_area {
	char name[267];
	struct list_head unpinned_list;
	struct file___2 *file;
	size_t size;
	long unsigned int prot_mask;
};

struct ashmem_range {
	struct list_head lru;
	struct list_head unpinned;
	struct ashmem_area *asma;
	size_t pgstart;
	size_t pgend;
	unsigned int purged;
};

struct pmc_bit_map {
	const char *name;
	u32 bit_mask;
};

struct pmc_reg_map {
	const struct pmc_bit_map *d3_sts_0;
	const struct pmc_bit_map *d3_sts_1;
	const struct pmc_bit_map *func_dis;
	const struct pmc_bit_map *func_dis_2;
	const struct pmc_bit_map *pss;
};

struct pmc_data {
	const struct pmc_reg_map *map;
	const struct pmc_clk *clks;
};

struct pmc_dev {
	u32 base_addr;
	void *regmap;
	const struct pmc_reg_map *map;
	struct dentry___2 *dbgfs_dir;
	bool init;
};

struct acpi_table_pcct {
	struct acpi_table_header header;
	u32 flags;
	u64 reserved;
};

enum acpi_pcct_type {
	ACPI_PCCT_TYPE_GENERIC_SUBSPACE = 0,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE = 1,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2 = 2,
	ACPI_PCCT_TYPE_EXT_PCC_MASTER_SUBSPACE = 3,
	ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE = 4,
	ACPI_PCCT_TYPE_RESERVED = 5,
};

struct acpi_pcct_subspace {
	struct acpi_subtable_header header;
	u8 reserved[6];
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pcct_hw_reduced_type2 {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
	struct acpi_generic_address platform_ack_register;
	u64 ack_preserve_mask;
	u64 ack_write_mask;
} __attribute__((packed));

struct devfreq_freqs {
	long unsigned int old;
	long unsigned int new;
};

struct trace_event_raw_devfreq_monitor {
	struct trace_entry ent;
	long unsigned int freq;
	long unsigned int busy_time;
	long unsigned int total_time;
	unsigned int polling_ms;
	u32 __data_loc_dev_name;
	char __data[0];
};

struct trace_event_data_offsets_devfreq_monitor {
	u32 dev_name;
};

typedef void (*btf_trace_devfreq_monitor)(void *, struct devfreq *);

struct devfreq_notifier_devres {
	struct devfreq *devfreq;
	struct notifier_block *nb;
	unsigned int list;
};

struct dev_pm_opp;

struct devfreq_simple_ondemand_data {
	unsigned int upthreshold;
	unsigned int downdifferential;
};

enum hw_event_mc_err_type {
	HW_EVENT_ERR_CORRECTED = 0,
	HW_EVENT_ERR_UNCORRECTED = 1,
	HW_EVENT_ERR_DEFERRED = 2,
	HW_EVENT_ERR_FATAL = 3,
	HW_EVENT_ERR_INFO = 4,
};

struct trace_event_raw_extlog_mem_event {
	struct trace_entry ent;
	u32 err_seq;
	u8 etype;
	u8 sev;
	u64 pa;
	u8 pa_mask_lsb;
	guid_t fru_id;
	u32 __data_loc_fru_text;
	struct cper_mem_err_compact data;
	char __data[0];
};

struct trace_event_raw_mc_event {
	struct trace_entry ent;
	unsigned int error_type;
	u32 __data_loc_msg;
	u32 __data_loc_label;
	u16 error_count;
	u8 mc_index;
	s8 top_layer;
	s8 middle_layer;
	s8 lower_layer;
	long int address;
	u8 grain_bits;
	long int syndrome;
	u32 __data_loc_driver_detail;
	char __data[0];
};

struct trace_event_raw_arm_event {
	struct trace_entry ent;
	u64 mpidr;
	u64 midr;
	u32 running_state;
	u32 psci_state;
	u8 affinity;
	char __data[0];
};

struct trace_event_raw_non_standard_event {
	struct trace_entry ent;
	char sec_type[16];
	char fru_id[16];
	u32 __data_loc_fru_text;
	u8 sev;
	u32 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_aer_event {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 status;
	u8 severity;
	u8 tlp_header_valid;
	u32 tlp_header[4];
	char __data[0];
};

struct trace_event_raw_memory_failure_event {
	struct trace_entry ent;
	long unsigned int pfn;
	int type;
	int result;
	char __data[0];
};

struct trace_event_data_offsets_extlog_mem_event {
	u32 fru_text;
};

struct trace_event_data_offsets_mc_event {
	u32 msg;
	u32 label;
	u32 driver_detail;
};

struct trace_event_data_offsets_arm_event {};

struct trace_event_data_offsets_non_standard_event {
	u32 fru_text;
	u32 buf;
};

struct trace_event_data_offsets_aer_event {
	u32 dev_name;
};

struct trace_event_data_offsets_memory_failure_event {};

typedef void (*btf_trace_extlog_mem_event)(void *, struct cper_sec_mem_err *, u32, const guid_t *, const char *, u8);

typedef void (*btf_trace_mc_event)(void *, const unsigned int, const char *, const char *, const int, const u8, const s8, const s8, const s8, long unsigned int, const u8, long unsigned int, const char *);

typedef void (*btf_trace_arm_event)(void *, const struct cper_sec_proc_arm *);

typedef void (*btf_trace_non_standard_event)(void *, const guid_t *, const guid_t *, const char *, const u8, const u8 *, const u32);

typedef void (*btf_trace_aer_event)(void *, const char *, const u32, const u8, const u8, struct aer_header_log_regs *);

typedef void (*btf_trace_memory_failure_event)(void *, long unsigned int, int, int);

enum {
	BINDER_TYPE_BINDER = 1935813253,
	BINDER_TYPE_WEAK_BINDER = 2002922117,
	BINDER_TYPE_HANDLE = 1936206469,
	BINDER_TYPE_WEAK_HANDLE = 2003315333,
	BINDER_TYPE_FD = 1717840517,
	BINDER_TYPE_FDA = 1717854597,
	BINDER_TYPE_PTR = 1886661253,
};

enum {
	FLAT_BINDER_FLAG_PRIORITY_MASK = 255,
	FLAT_BINDER_FLAG_ACCEPTS_FDS = 256,
	FLAT_BINDER_FLAG_TXN_SECURITY_CTX = 4096,
};

typedef __u64 binder_size_t;

typedef __u64 binder_uintptr_t;

struct binder_object_header {
	__u32 type;
};

struct flat_binder_object {
	struct binder_object_header hdr;
	__u32 flags;
	union {
		binder_uintptr_t binder;
		__u32 handle;
	};
	binder_uintptr_t cookie;
};

struct binder_fd_object {
	struct binder_object_header hdr;
	__u32 pad_flags;
	union {
		binder_uintptr_t pad_binder;
		__u32 fd;
	};
	binder_uintptr_t cookie;
};

struct binder_buffer_object {
	struct binder_object_header hdr;
	__u32 flags;
	binder_uintptr_t buffer;
	binder_size_t length;
	binder_size_t parent;
	binder_size_t parent_offset;
};

enum {
	BINDER_BUFFER_FLAG_HAS_PARENT = 1,
};

struct binder_fd_array_object {
	struct binder_object_header hdr;
	__u32 pad;
	binder_size_t num_fds;
	binder_size_t parent;
	binder_size_t parent_offset;
};

struct binder_write_read {
	binder_size_t write_size;
	binder_size_t write_consumed;
	binder_uintptr_t write_buffer;
	binder_size_t read_size;
	binder_size_t read_consumed;
	binder_uintptr_t read_buffer;
};

struct binder_version {
	__s32 protocol_version;
};

struct binder_node_debug_info {
	binder_uintptr_t ptr;
	binder_uintptr_t cookie;
	__u32 has_strong_ref;
	__u32 has_weak_ref;
};

struct binder_node_info_for_ref {
	__u32 handle;
	__u32 strong_count;
	__u32 weak_count;
	__u32 reserved1;
	__u32 reserved2;
	__u32 reserved3;
};

enum transaction_flags {
	TF_ONE_WAY = 1,
	TF_ROOT_OBJECT = 4,
	TF_STATUS_CODE = 8,
	TF_ACCEPT_FDS = 16,
	TF_CLEAR_BUF = 32,
};

struct binder_transaction_data {
	union {
		__u32 handle;
		binder_uintptr_t ptr;
	} target;
	binder_uintptr_t cookie;
	__u32 code;
	__u32 flags;
	pid_t sender_pid;
	uid_t sender_euid;
	binder_size_t data_size;
	binder_size_t offsets_size;
	union {
		struct {
			binder_uintptr_t buffer;
			binder_uintptr_t offsets;
		} ptr;
		__u8 buf[8];
	} data;
};

struct binder_transaction_data_secctx {
	struct binder_transaction_data transaction_data;
	binder_uintptr_t secctx;
};

struct binder_transaction_data_sg {
	struct binder_transaction_data transaction_data;
	binder_size_t buffers_size;
};

enum binder_driver_return_protocol {
	BR_ERROR = 2147774976,
	BR_OK = 29185,
	BR_TRANSACTION_SEC_CTX = 2152231426,
	BR_TRANSACTION = 2151707138,
	BR_REPLY = 2151707139,
	BR_ACQUIRE_RESULT = 2147774980,
	BR_DEAD_REPLY = 29189,
	BR_TRANSACTION_COMPLETE = 29190,
	BR_INCREFS = 2148561415,
	BR_ACQUIRE = 2148561416,
	BR_RELEASE = 2148561417,
	BR_DECREFS = 2148561418,
	BR_ATTEMPT_ACQUIRE = 2149085707,
	BR_NOOP = 29196,
	BR_SPAWN_LOOPER = 29197,
	BR_FINISHED = 29198,
	BR_DEAD_BINDER = 2148037135,
	BR_CLEAR_DEATH_NOTIFICATION_DONE = 2148037136,
	BR_FAILED_REPLY = 29201,
};

enum binder_driver_command_protocol {
	BC_TRANSACTION = 1077961472,
	BC_REPLY = 1077961473,
	BC_ACQUIRE_RESULT = 1074029314,
	BC_FREE_BUFFER = 1074291459,
	BC_INCREFS = 1074029316,
	BC_ACQUIRE = 1074029317,
	BC_RELEASE = 1074029318,
	BC_DECREFS = 1074029319,
	BC_INCREFS_DONE = 1074815752,
	BC_ACQUIRE_DONE = 1074815753,
	BC_ATTEMPT_ACQUIRE = 1074291466,
	BC_REGISTER_LOOPER = 25355,
	BC_ENTER_LOOPER = 25356,
	BC_EXIT_LOOPER = 25357,
	BC_REQUEST_DEATH_NOTIFICATION = 1074553614,
	BC_CLEAR_DEATH_NOTIFICATION = 1074553615,
	BC_DEAD_BINDER_DONE = 1074291472,
	BC_TRANSACTION_SG = 1078485777,
	BC_REPLY_SG = 1078485778,
};

struct binder_transaction;

struct binder_node;

struct binder_buffer {
	struct list_head entry;
	struct rb_node rb_node;
	unsigned int free: 1;
	unsigned int clear_on_free: 1;
	unsigned int allow_user_free: 1;
	unsigned int async_transaction: 1;
	unsigned int debug_id: 28;
	struct binder_transaction *transaction;
	struct binder_node *target_node;
	size_t data_size;
	size_t offsets_size;
	size_t extra_buffers_size;
	void *user_data;
};

enum binder_work_type {
	BINDER_WORK_TRANSACTION = 1,
	BINDER_WORK_TRANSACTION_COMPLETE = 2,
	BINDER_WORK_RETURN_ERROR = 3,
	BINDER_WORK_NODE = 4,
	BINDER_WORK_DEAD_BINDER = 5,
	BINDER_WORK_DEAD_BINDER_AND_CLEAR = 6,
	BINDER_WORK_CLEAR_DEATH_NOTIFICATION = 7,
};

struct binder_work {
	struct list_head entry;
	enum binder_work_type type;
};

struct binder_thread;

struct binder_proc;

struct binder_transaction {
	int debug_id;
	struct binder_work work;
	struct binder_thread *from;
	struct binder_transaction *from_parent;
	struct binder_proc *to_proc;
	struct binder_thread *to_thread;
	struct binder_transaction *to_parent;
	unsigned int need_reply: 1;
	struct binder_buffer *buffer;
	unsigned int code;
	unsigned int flags;
	long int priority;
	long int saved_priority;
	kuid_t sender_euid;
	struct list_head fd_fixups;
	binder_uintptr_t security_ctx;
	spinlock_t lock;
};

struct binder_node {
	int debug_id;
	spinlock_t lock;
	struct binder_work work;
	union {
		struct rb_node rb_node;
		struct hlist_node dead_node;
	};
	struct binder_proc *proc;
	struct hlist_head refs;
	int internal_strong_refs;
	int local_weak_refs;
	int local_strong_refs;
	int tmp_refs;
	binder_uintptr_t ptr;
	binder_uintptr_t cookie;
	struct {
		u8 has_strong_ref: 1;
		u8 pending_strong_ref: 1;
		u8 has_weak_ref: 1;
		u8 pending_weak_ref: 1;
	};
	struct {
		u8 accept_fds: 1;
		u8 txn_security_ctx: 1;
		u8 min_priority;
	};
	bool has_async_transaction;
	struct list_head async_todo;
};

struct binder_alloc;

struct binder_lru_page {
	struct list_head lru;
	struct page *page_ptr;
	struct binder_alloc *alloc;
};

struct binder_alloc {
	struct mutex mutex;
	struct vm_area_struct___2 *vma;
	struct mm_struct___2 *vma_vm_mm;
	void *buffer;
	struct list_head buffers;
	struct rb_root free_buffers;
	struct rb_root allocated_buffers;
	size_t free_async_space;
	struct binder_lru_page *pages;
	size_t buffer_size;
	uint32_t buffer_free;
	int pid;
	size_t pages_high;
};

struct binder_context {
	struct binder_node *binder_context_mgr_node;
	struct mutex context_mgr_node_lock;
	kuid_t binder_context_mgr_uid;
	const char *name;
};

struct binder_device {
	struct hlist_node hlist;
	struct miscdevice miscdev;
	struct binder_context context;
	struct inode___2 *binderfs_inode;
	refcount_t ref;
};

struct binderfs_mount_opts {
	int max;
	int stats_mode;
};

struct binderfs_info {
	struct ipc_namespace *ipc_ns;
	struct dentry___2 *control_dentry;
	kuid_t root_uid;
	kgid_t root_gid;
	struct binderfs_mount_opts mount_opts;
	int device_count;
	struct dentry___2 *proc_log_dir;
};

struct binder_transaction_log_entry {
	int debug_id;
	int debug_id_done;
	int call_type;
	int from_proc;
	int from_thread;
	int target_handle;
	int to_proc;
	int to_thread;
	int to_node;
	int data_size;
	int offsets_size;
	int return_error_line;
	uint32_t return_error;
	uint32_t return_error_param;
	char context_name[256];
};

struct binder_transaction_log {
	atomic_t cur;
	bool full;
	struct binder_transaction_log_entry entry[32];
};

enum {
	BINDER_DEBUG_USER_ERROR = 1,
	BINDER_DEBUG_FAILED_TRANSACTION = 2,
	BINDER_DEBUG_DEAD_TRANSACTION = 4,
	BINDER_DEBUG_OPEN_CLOSE = 8,
	BINDER_DEBUG_DEAD_BINDER = 16,
	BINDER_DEBUG_DEATH_NOTIFICATION = 32,
	BINDER_DEBUG_READ_WRITE = 64,
	BINDER_DEBUG_USER_REFS = 128,
	BINDER_DEBUG_THREADS = 256,
	BINDER_DEBUG_TRANSACTION = 512,
	BINDER_DEBUG_TRANSACTION_COMPLETE = 1024,
	BINDER_DEBUG_FREE_BUFFER = 2048,
	BINDER_DEBUG_INTERNAL_REFS = 4096,
	BINDER_DEBUG_PRIORITY_CAP = 8192,
	BINDER_DEBUG_SPINLOCKS = 16384,
};

enum binder_stat_types {
	BINDER_STAT_PROC = 0,
	BINDER_STAT_THREAD = 1,
	BINDER_STAT_NODE = 2,
	BINDER_STAT_REF = 3,
	BINDER_STAT_DEATH = 4,
	BINDER_STAT_TRANSACTION = 5,
	BINDER_STAT_TRANSACTION_COMPLETE = 6,
	BINDER_STAT_COUNT = 7,
};

struct binder_stats {
	atomic_t br[18];
	atomic_t bc[19];
	atomic_t obj_created[7];
	atomic_t obj_deleted[7];
};

struct binder_error {
	struct binder_work work;
	uint32_t cmd;
};

struct binder_proc {
	struct hlist_node proc_node;
	struct rb_root threads;
	struct rb_root nodes;
	struct rb_root refs_by_desc;
	struct rb_root refs_by_node;
	struct list_head waiting_threads;
	int pid;
	struct task_struct___2 *tsk;
	struct hlist_node deferred_work_node;
	int deferred_work;
	bool is_dead;
	struct list_head todo;
	struct binder_stats stats;
	struct list_head delivered_death;
	int max_threads;
	int requested_threads;
	int requested_threads_started;
	int tmp_ref;
	long int default_priority;
	struct dentry___2 *debugfs_entry;
	struct binder_alloc alloc;
	struct binder_context *context;
	spinlock_t inner_lock;
	spinlock_t outer_lock;
	struct dentry___2 *binderfs_entry;
};

struct binder_ref_death {
	struct binder_work work;
	binder_uintptr_t cookie;
};

struct binder_ref_data {
	int debug_id;
	uint32_t desc;
	int strong;
	int weak;
};

struct binder_ref {
	struct binder_ref_data data;
	struct rb_node rb_node_desc;
	struct rb_node rb_node_node;
	struct hlist_node node_entry;
	struct binder_proc *proc;
	struct binder_node *node;
	struct binder_ref_death *death;
};

enum binder_deferred_state {
	BINDER_DEFERRED_FLUSH = 1,
	BINDER_DEFERRED_RELEASE = 2,
};

enum {
	BINDER_LOOPER_STATE_REGISTERED = 1,
	BINDER_LOOPER_STATE_ENTERED = 2,
	BINDER_LOOPER_STATE_EXITED = 4,
	BINDER_LOOPER_STATE_INVALID = 8,
	BINDER_LOOPER_STATE_WAITING = 16,
	BINDER_LOOPER_STATE_POLL = 32,
};

struct binder_thread {
	struct binder_proc *proc;
	struct rb_node rb_node;
	struct list_head waiting_thread_node;
	int pid;
	int looper;
	bool looper_need_return;
	struct binder_transaction *transaction_stack;
	struct list_head todo;
	bool process_todo;
	struct binder_error return_error;
	struct binder_error reply_error;
	wait_queue_head_t wait;
	struct binder_stats stats;
	atomic_t tmp_ref;
	bool is_dead;
};

struct binder_txn_fd_fixup {
	struct list_head fixup_entry;
	struct file___2 *file;
	size_t offset;
};

struct binder_object {
	union {
		struct binder_object_header hdr;
		struct flat_binder_object fbo;
		struct binder_fd_object fdo;
		struct binder_buffer_object bbo;
		struct binder_fd_array_object fdao;
	};
};

struct binder_task_work_cb {
	struct callback_head twork;
	struct file___2 *file;
};

struct trace_event_raw_binder_ioctl {
	struct trace_entry ent;
	unsigned int cmd;
	long unsigned int arg;
	char __data[0];
};

struct trace_event_raw_binder_lock_class {
	struct trace_entry ent;
	const char *tag;
	char __data[0];
};

struct trace_event_raw_binder_function_return_class {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_binder_wait_for_work {
	struct trace_entry ent;
	bool proc_work;
	bool transaction_stack;
	bool thread_todo;
	char __data[0];
};

struct trace_event_raw_binder_transaction {
	struct trace_entry ent;
	int debug_id;
	int target_node;
	int to_proc;
	int to_thread;
	int reply;
	unsigned int code;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_binder_transaction_received {
	struct trace_entry ent;
	int debug_id;
	char __data[0];
};

struct trace_event_raw_binder_transaction_node_to_ref {
	struct trace_entry ent;
	int debug_id;
	int node_debug_id;
	binder_uintptr_t node_ptr;
	int ref_debug_id;
	uint32_t ref_desc;
	char __data[0];
};

struct trace_event_raw_binder_transaction_ref_to_node {
	struct trace_entry ent;
	int debug_id;
	int ref_debug_id;
	uint32_t ref_desc;
	int node_debug_id;
	binder_uintptr_t node_ptr;
	char __data[0];
};

struct trace_event_raw_binder_transaction_ref_to_ref {
	struct trace_entry ent;
	int debug_id;
	int node_debug_id;
	int src_ref_debug_id;
	uint32_t src_ref_desc;
	int dest_ref_debug_id;
	uint32_t dest_ref_desc;
	char __data[0];
};

struct trace_event_raw_binder_transaction_fd_send {
	struct trace_entry ent;
	int debug_id;
	int fd;
	size_t offset;
	char __data[0];
};

struct trace_event_raw_binder_transaction_fd_recv {
	struct trace_entry ent;
	int debug_id;
	int fd;
	size_t offset;
	char __data[0];
};

struct trace_event_raw_binder_buffer_class {
	struct trace_entry ent;
	int debug_id;
	size_t data_size;
	size_t offsets_size;
	size_t extra_buffers_size;
	char __data[0];
};

struct trace_event_raw_binder_update_page_range {
	struct trace_entry ent;
	int proc;
	bool allocate;
	size_t offset;
	size_t size;
	char __data[0];
};

struct trace_event_raw_binder_lru_page_class {
	struct trace_entry ent;
	int proc;
	size_t page_index;
	char __data[0];
};

struct trace_event_raw_binder_command {
	struct trace_entry ent;
	uint32_t cmd;
	char __data[0];
};

struct trace_event_raw_binder_return {
	struct trace_entry ent;
	uint32_t cmd;
	char __data[0];
};

struct trace_event_data_offsets_binder_ioctl {};

struct trace_event_data_offsets_binder_lock_class {};

struct trace_event_data_offsets_binder_function_return_class {};

struct trace_event_data_offsets_binder_wait_for_work {};

struct trace_event_data_offsets_binder_transaction {};

struct trace_event_data_offsets_binder_transaction_received {};

struct trace_event_data_offsets_binder_transaction_node_to_ref {};

struct trace_event_data_offsets_binder_transaction_ref_to_node {};

struct trace_event_data_offsets_binder_transaction_ref_to_ref {};

struct trace_event_data_offsets_binder_transaction_fd_send {};

struct trace_event_data_offsets_binder_transaction_fd_recv {};

struct trace_event_data_offsets_binder_buffer_class {};

struct trace_event_data_offsets_binder_update_page_range {};

struct trace_event_data_offsets_binder_lru_page_class {};

struct trace_event_data_offsets_binder_command {};

struct trace_event_data_offsets_binder_return {};

typedef void (*btf_trace_binder_ioctl)(void *, unsigned int, long unsigned int);

typedef void (*btf_trace_binder_lock)(void *, const char *);

typedef void (*btf_trace_binder_locked)(void *, const char *);

typedef void (*btf_trace_binder_unlock)(void *, const char *);

typedef void (*btf_trace_binder_ioctl_done)(void *, int);

typedef void (*btf_trace_binder_write_done)(void *, int);

typedef void (*btf_trace_binder_read_done)(void *, int);

typedef void (*btf_trace_binder_wait_for_work)(void *, bool, bool, bool);

typedef void (*btf_trace_binder_transaction)(void *, bool, struct binder_transaction *, struct binder_node *);

typedef void (*btf_trace_binder_transaction_received)(void *, struct binder_transaction *);

typedef void (*btf_trace_binder_transaction_node_to_ref)(void *, struct binder_transaction *, struct binder_node *, struct binder_ref_data *);

typedef void (*btf_trace_binder_transaction_ref_to_node)(void *, struct binder_transaction *, struct binder_node *, struct binder_ref_data *);

typedef void (*btf_trace_binder_transaction_ref_to_ref)(void *, struct binder_transaction *, struct binder_node *, struct binder_ref_data *, struct binder_ref_data *);

typedef void (*btf_trace_binder_transaction_fd_send)(void *, struct binder_transaction *, int, size_t);

typedef void (*btf_trace_binder_transaction_fd_recv)(void *, struct binder_transaction *, int, size_t);

typedef void (*btf_trace_binder_transaction_alloc_buf)(void *, struct binder_buffer *);

typedef void (*btf_trace_binder_transaction_buffer_release)(void *, struct binder_buffer *);

typedef void (*btf_trace_binder_transaction_failed_buffer_release)(void *, struct binder_buffer *);

typedef void (*btf_trace_binder_update_page_range)(void *, struct binder_alloc *, bool, void *, void *);

typedef void (*btf_trace_binder_alloc_lru_start)(void *, const struct binder_alloc *, size_t);

typedef void (*btf_trace_binder_alloc_lru_end)(void *, const struct binder_alloc *, size_t);

typedef void (*btf_trace_binder_free_lru_start)(void *, const struct binder_alloc *, size_t);

typedef void (*btf_trace_binder_free_lru_end)(void *, const struct binder_alloc *, size_t);

typedef void (*btf_trace_binder_alloc_page_start)(void *, const struct binder_alloc *, size_t);

typedef void (*btf_trace_binder_alloc_page_end)(void *, const struct binder_alloc *, size_t);

typedef void (*btf_trace_binder_unmap_user_start)(void *, const struct binder_alloc *, size_t);

typedef void (*btf_trace_binder_unmap_user_end)(void *, const struct binder_alloc *, size_t);

typedef void (*btf_trace_binder_unmap_kernel_start)(void *, const struct binder_alloc *, size_t);

typedef void (*btf_trace_binder_unmap_kernel_end)(void *, const struct binder_alloc *, size_t);

typedef void (*btf_trace_binder_command)(void *, uint32_t);

typedef void (*btf_trace_binder_return)(void *, uint32_t);

enum {
	BINDER_DEBUG_USER_ERROR___2 = 1,
	BINDER_DEBUG_OPEN_CLOSE___2 = 2,
	BINDER_DEBUG_BUFFER_ALLOC = 4,
	BINDER_DEBUG_BUFFER_ALLOC_ASYNC = 8,
};

struct nvmem_cell_lookup {
	const char *nvmem_name;
	const char *cell_name;
	const char *dev_id;
	const char *con_id;
	struct list_head node;
};

enum {
	NVMEM_ADD = 1,
	NVMEM_REMOVE = 2,
	NVMEM_CELL_ADD = 3,
	NVMEM_CELL_REMOVE = 4,
};

struct nvmem_cell_table {
	const char *nvmem_name;
	const struct nvmem_cell_info *cells;
	size_t ncells;
	struct list_head node;
};

struct nvmem_device {
	struct module___2 *owner;
	struct device___2 dev;
	int stride;
	int word_size;
	int id;
	struct kref refcnt;
	size_t size;
	bool read_only;
	int flags;
	enum nvmem_type type;
	struct bin_attribute___2 eeprom;
	struct device___2 *base_dev;
	struct list_head cells;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	void *priv;
};

struct nvmem_cell {
	const char *name;
	int offset;
	int bytes;
	int bit_offset;
	int nbits;
	struct device_node___2 *np;
	struct nvmem_device *nvmem;
	struct list_head node;
};

struct pcibios_fwaddrmap {
	struct list_head list;
	struct pci_dev *dev;
	resource_size_t fw_addr[17];
};

struct pci_check_idx_range {
	int start;
	int end;
};

struct pci_raw_ops {
	int (*read)(unsigned int, unsigned int, unsigned int, int, int, u32 *);
	int (*write)(unsigned int, unsigned int, unsigned int, int, int, u32);
};

struct acpi_table_mcfg {
	struct acpi_table_header header;
	u8 reserved[8];
};

struct acpi_mcfg_allocation {
	u64 address;
	u16 pci_segment;
	u8 start_bus_number;
	u8 end_bus_number;
	u32 reserved;
};

struct pci_mmcfg_hostbridge_probe {
	u32 bus;
	u32 devfn;
	u32 vendor;
	u32 device;
	const char * (*probe)();
};

typedef bool (*check_reserved_t)(u64, u64, unsigned int);

struct pci_root_info {
	struct acpi_pci_root_info common;
	struct pci_sysdata sd;
	bool mcfg_added;
	u8 start_bus;
	u8 end_bus;
};

struct irq_info___2 {
	u8 bus;
	u8 devfn;
	struct {
		u8 link;
		u16 bitmap;
	} __attribute__((packed)) irq[4];
	u8 slot;
	u8 rfu;
};

struct irq_routing_table {
	u32 signature;
	u16 version;
	u16 size;
	u8 rtr_bus;
	u8 rtr_devfn;
	u16 exclusive_irqs;
	u16 rtr_vendor;
	u16 rtr_device;
	u32 miniport_data;
	u8 rfu[11];
	u8 checksum;
	struct irq_info___2 slots[0];
};

struct irq_router {
	char *name;
	u16 vendor;
	u16 device;
	int (*get)(struct pci_dev *, struct pci_dev *, int);
	int (*set)(struct pci_dev *, struct pci_dev *, int, int);
};

struct irq_router_handler {
	u16 vendor;
	int (*probe)(struct irq_router *, struct pci_dev *, u16);
};

struct pci_setup_rom {
	struct setup_data data;
	uint16_t vendor;
	uint16_t devid;
	uint64_t pcilen;
	long unsigned int segment;
	long unsigned int bus;
	long unsigned int device;
	long unsigned int function;
	uint8_t romdata[0];
};

enum pci_bf_sort_state {
	pci_bf_sort_default = 0,
	pci_force_nobf = 1,
	pci_force_bf = 2,
	pci_dmi_bf = 3,
};

struct pci_root_res {
	struct list_head list;
	struct resource res;
};

struct pci_root_info___2 {
	struct list_head list;
	char name[12];
	struct list_head resources;
	struct resource busn;
	int node;
	int link;
};

struct amd_hostbridge {
	u32 bus;
	u32 slot;
	u32 device;
};

struct saved_msr {
	bool valid;
	struct msr_info info;
};

struct saved_msrs {
	unsigned int num;
	struct saved_msr *array;
};

struct saved_context {
	struct pt_regs regs;
	u16 ds;
	u16 es;
	u16 fs;
	u16 gs;
	long unsigned int kernelmode_gs_base;
	long unsigned int usermode_gs_base;
	long unsigned int fs_base;
	long unsigned int cr0;
	long unsigned int cr2;
	long unsigned int cr3;
	long unsigned int cr4;
	u64 misc_enable;
	bool misc_enable_saved;
	struct saved_msrs saved_msrs;
	long unsigned int efer;
	u16 gdt_pad;
	struct desc_ptr gdt_desc;
	u16 idt_pad;
	struct desc_ptr idt;
	u16 ldt;
	u16 tss;
	long unsigned int tr;
	long unsigned int safety;
	long unsigned int return_address;
} __attribute__((packed));

typedef int (*pm_cpu_match_t)(const struct x86_cpu_id *);

struct __kernel_sock_timeval {
	__s64 tv_sec;
	__s64 tv_usec;
};

struct mmsghdr {
	struct user_msghdr msg_hdr;
	unsigned int msg_len;
};

struct scm_timestamping_internal {
	struct timespec64 ts[3];
};

struct ifconf {
	int ifc_len;
	union {
		char *ifcu_buf;
		struct ifreq *ifcu_req;
	} ifc_ifcu;
};

struct compat_ifmap {
	compat_ulong_t mem_start;
	compat_ulong_t mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct compat_if_settings {
	unsigned int type;
	unsigned int size;
	compat_uptr_t ifs_ifsu;
};

struct compat_ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		compat_int_t ifru_ivalue;
		compat_int_t ifru_mtu;
		struct compat_ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		compat_caddr_t ifru_data;
		struct compat_if_settings ifru_settings;
	} ifr_ifru;
};

struct compat_ifconf {
	compat_int_t ifc_len;
	compat_caddr_t ifcbuf;
};

struct compat_ethtool_rx_flow_spec {
	u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	compat_u64 ring_cookie;
	u32 location;
} __attribute__((packed));

struct compat_ethtool_rxnfc {
	u32 cmd;
	u32 flow_type;
	compat_u64 data;
	struct compat_ethtool_rx_flow_spec fs;
	u32 rule_cnt;
	u32 rule_locs[0];
} __attribute__((packed));

struct compat_msghdr {
	compat_uptr_t msg_name;
	compat_int_t msg_namelen;
	compat_uptr_t msg_iov;
	compat_size_t msg_iovlen;
	compat_uptr_t msg_control;
	compat_size_t msg_controllen;
	compat_uint_t msg_flags;
};

struct compat_mmsghdr {
	struct compat_msghdr msg_hdr;
	compat_uint_t msg_len;
};

enum {
	SOF_TIMESTAMPING_TX_HARDWARE = 1,
	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
	SOF_TIMESTAMPING_RX_HARDWARE = 4,
	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
	SOF_TIMESTAMPING_SOFTWARE = 16,
	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
	SOF_TIMESTAMPING_OPT_ID = 128,
	SOF_TIMESTAMPING_TX_SCHED = 256,
	SOF_TIMESTAMPING_TX_ACK = 512,
	SOF_TIMESTAMPING_OPT_CMSG = 1024,
	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
	SOF_TIMESTAMPING_OPT_STATS = 4096,
	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
	SOF_TIMESTAMPING_BIND_PHC = 32768,
	SOF_TIMESTAMPING_LAST = 16384,
	SOF_TIMESTAMPING_MASK = 32767,
};

struct scm_ts_pktinfo {
	__u32 if_index;
	__u32 pkt_length;
	__u32 reserved[2];
};

struct socket_alloc {
	struct socket socket;
	struct inode vfs_inode;
};

struct sock_skb_cb {
	u32 dropcount;
};

struct in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	__u32 rtmsg_type;
	__u16 rtmsg_dst_len;
	__u16 rtmsg_src_len;
	__u32 rtmsg_metric;
	long unsigned int rtmsg_info;
	__u32 rtmsg_flags;
	int rtmsg_ifindex;
};

struct rtentry {
	long unsigned int rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	long unsigned int rt_pad3;
	void *rt_pad4;
	short int rt_metric;
	char *rt_dev;
	long unsigned int rt_mtu;
	long unsigned int rt_window;
	short unsigned int rt_irtt;
};

struct inet6_skb_parm {
	int iif;
	__be16 ra;
	__u16 dst0;
	__u16 srcrt;
	__u16 dst1;
	__u16 lastopt;
	__u16 nhoff;
	__u16 flags;
	__u16 dsthao;
	__u16 frag_max_size;
};

struct inet_skb_parm {
	int iif;
	struct ip_options opt;
	u16 flags;
	u16 frag_max_size;
};

struct sock_extended_err {
	__u32 ee_errno;
	__u8 ee_origin;
	__u8 ee_type;
	__u8 ee_code;
	__u8 ee_pad;
	__u32 ee_info;
	__u32 ee_data;
};

struct sock_exterr_skb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sock_extended_err ee;
	u16 addr_offset;
	__be16 port;
	u8 opt_stats: 1;
	u8 unused: 7;
};

typedef void (*GET_INFO_HOOK_FUNC)(struct socket *, int, struct __kernel_sockaddr_storage *, int);

enum get_infotype {
	CONNECT_INFO = 0,
	ACCEPT_INFO = 1,
	SENDTO_INFO = 2,
	RECVFROM_INFO = 3,
};

struct used_address {
	struct __kernel_sockaddr_storage name;
	unsigned int name_len;
};

struct rtentry32 {
	u32 rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	u32 rt_pad3;
	unsigned char rt_tos;
	unsigned char rt_class;
	short int rt_pad4;
	short int rt_metric;
	u32 rt_dev;
	u32 rt_mtu;
	u32 rt_window;
	short unsigned int rt_irtt;
};

struct in6_rtmsg32 {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	u32 rtmsg_type;
	u16 rtmsg_dst_len;
	u16 rtmsg_src_len;
	u32 rtmsg_metric;
	u32 rtmsg_info;
	u32 rtmsg_flags;
	s32 rtmsg_ifindex;
};

struct linger {
	int l_onoff;
	int l_linger;
};

struct ucred {
	__u32 pid;
	__u32 uid;
	__u32 gid;
};

struct mmpin {
	struct user_struct *user;
	unsigned int num_pg;
};

struct ubuf_info {
	void (*callback)(struct ubuf_info *, bool);
	union {
		struct {
			long unsigned int desc;
			void *ctx;
		};
		struct {
			u32 id;
			u16 len;
			u16 zerocopy: 1;
			u32 bytelen;
		};
	};
	refcount_t refcnt;
	struct mmpin mmp;
};

struct prot_inuse {
	int val[64];
};

struct rt6key {
	struct in6_addr addr;
	int plen;
};

struct rtable;

struct fnhe_hash_bucket;

struct fib_nh_common {
	struct net_device *nhc_dev;
	int nhc_oif;
	unsigned char nhc_scope;
	u8 nhc_family;
	u8 nhc_gw_family;
	unsigned char nhc_flags;
	struct lwtunnel_state *nhc_lwtstate;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} nhc_gw;
	int nhc_weight;
	atomic_t nhc_upper_bound;
	struct rtable **nhc_pcpu_rth_output;
	struct rtable *nhc_rth_input;
	struct fnhe_hash_bucket *nhc_exceptions;
};

struct rt6_exception_bucket;

struct fib6_nh {
	struct fib_nh_common nh_common;
	long unsigned int last_probe;
	struct rt6_info **rt6i_pcpu;
	struct rt6_exception_bucket *rt6i_exception_bucket;
};

struct fib6_node;

struct dst_metrics;

struct nexthop;

struct fib6_info {
	struct fib6_table *fib6_table;
	struct fib6_info *fib6_next;
	struct fib6_node *fib6_node;
	union {
		struct list_head fib6_siblings;
		struct list_head nh_list;
	};
	unsigned int fib6_nsiblings;
	refcount_t fib6_ref;
	long unsigned int expires;
	struct dst_metrics *fib6_metrics;
	struct rt6key fib6_dst;
	u32 fib6_flags;
	struct rt6key fib6_src;
	struct rt6key fib6_prefsrc;
	u32 fib6_metric;
	u8 fib6_protocol;
	u8 fib6_type;
	u8 should_flush: 1;
	u8 dst_nocount: 1;
	u8 dst_nopolicy: 1;
	u8 dst_host: 1;
	u8 fib6_destroying: 1;
	u8 unused: 3;
	struct callback_head rcu;
	struct nexthop *nh;
	struct fib6_nh fib6_nh[0];
};

struct uncached_list;

struct rt6_info {
	struct dst_entry dst;
	struct fib6_info *from;
	int sernum;
	struct rt6key rt6i_dst;
	struct rt6key rt6i_src;
	struct in6_addr rt6i_gateway;
	struct inet6_dev *rt6i_idev;
	u32 rt6i_flags;
	struct list_head rt6i_uncached;
	struct uncached_list *rt6i_uncached_list;
	short unsigned int rt6i_nfheader_len;
};

struct rt6_statistics {
	__u32 fib_nodes;
	__u32 fib_route_nodes;
	__u32 fib_rt_entries;
	__u32 fib_rt_cache;
	__u32 fib_discarded_routes;
	atomic_t fib_rt_alloc;
	atomic_t fib_rt_uncache;
};

struct fib6_node {
	struct fib6_node *parent;
	struct fib6_node *left;
	struct fib6_node *right;
	struct fib6_info *leaf;
	__u16 fn_bit;
	__u16 fn_flags;
	int fn_sernum;
	struct fib6_info *rr_ptr;
	struct callback_head rcu;
};

struct fib6_table {
	struct hlist_node tb6_hlist;
	u32 tb6_id;
	spinlock_t tb6_lock;
	struct fib6_node tb6_root;
	struct inet_peer_base tb6_peers;
	unsigned int flags;
	unsigned int fib_seq;
};

typedef union {
	__be32 a4;
	__be32 a6[4];
	struct in6_addr in6;
} xfrm_address_t;

struct xfrm_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u8 proto;
};

struct xfrm_sec_ctx {
	__u8 ctx_doi;
	__u8 ctx_alg;
	__u16 ctx_len;
	__u32 ctx_sid;
	char ctx_str[0];
};

struct xfrm_selector {
	xfrm_address_t daddr;
	xfrm_address_t saddr;
	__be16 dport;
	__be16 dport_mask;
	__be16 sport;
	__be16 sport_mask;
	__u16 family;
	__u8 prefixlen_d;
	__u8 prefixlen_s;
	__u8 proto;
	int ifindex;
	__kernel_uid32_t user;
};

struct xfrm_lifetime_cfg {
	__u64 soft_byte_limit;
	__u64 hard_byte_limit;
	__u64 soft_packet_limit;
	__u64 hard_packet_limit;
	__u64 soft_add_expires_seconds;
	__u64 hard_add_expires_seconds;
	__u64 soft_use_expires_seconds;
	__u64 hard_use_expires_seconds;
};

struct xfrm_lifetime_cur {
	__u64 bytes;
	__u64 packets;
	__u64 add_time;
	__u64 use_time;
};

struct xfrm_replay_state {
	__u32 oseq;
	__u32 seq;
	__u32 bitmap;
};

struct xfrm_replay_state_esn {
	unsigned int bmp_len;
	__u32 oseq;
	__u32 seq;
	__u32 oseq_hi;
	__u32 seq_hi;
	__u32 replay_window;
	__u32 bmp[0];
};

struct xfrm_algo {
	char alg_name[64];
	unsigned int alg_key_len;
	char alg_key[0];
};

struct xfrm_algo_auth {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_trunc_len;
	char alg_key[0];
};

struct xfrm_algo_aead {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_icv_len;
	char alg_key[0];
};

struct xfrm_stats {
	__u32 replay_window;
	__u32 replay;
	__u32 integrity_failed;
};

enum {
	XFRM_POLICY_TYPE_MAIN = 0,
	XFRM_POLICY_TYPE_SUB = 1,
	XFRM_POLICY_TYPE_MAX = 2,
	XFRM_POLICY_TYPE_ANY = 255,
};

struct xfrm_encap_tmpl {
	__u16 encap_type;
	__be16 encap_sport;
	__be16 encap_dport;
	xfrm_address_t encap_oa;
};

struct xfrm_mark {
	__u32 v;
	__u32 m;
};

struct xfrm_address_filter {
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__u16 family;
	__u8 splen;
	__u8 dplen;
};

struct gro_list {
	struct list_head list;
	int count;
};

struct napi_struct {
	struct list_head poll_list;
	long unsigned int state;
	int weight;
	long unsigned int gro_bitmask;
	int (*poll)(struct napi_struct *, int);
	int poll_owner;
	struct net_device *dev;
	struct gro_list gro_hash[8];
	struct sk_buff *skb;
	struct list_head rx_list;
	int rx_count;
	struct hrtimer timer;
	struct list_head dev_list;
	struct hlist_node napi_hash_node;
	unsigned int napi_id;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct xfrm_state_walk {
	struct list_head all;
	u8 state;
	u8 dying;
	u8 proto;
	u32 seq;
	struct xfrm_address_filter *filter;
	long unsigned int kabi_reserved1;
};

struct xfrm_state_offload {
	struct net_device *dev;
	long unsigned int offload_handle;
	unsigned int num_exthdrs;
	u8 flags;
	long unsigned int kabi_reserved1;
};

struct xfrm_mode {
	u8 encap;
	u8 family;
	u8 flags;
};

struct xfrm_replay;

struct xfrm_type;

struct xfrm_type_offload;

struct xfrm_state {
	possible_net_t xs_net;
	union {
		struct hlist_node gclist;
		struct hlist_node bydst;
	};
	struct hlist_node bysrc;
	struct hlist_node byspi;
	refcount_t refcnt;
	spinlock_t lock;
	struct xfrm_id id;
	struct xfrm_selector sel;
	struct xfrm_mark mark;
	u32 if_id;
	u32 tfcpad;
	u32 genid;
	struct xfrm_state_walk km;
	struct {
		u32 reqid;
		u8 mode;
		u8 replay_window;
		u8 aalgo;
		u8 ealgo;
		u8 calgo;
		u8 flags;
		u16 family;
		xfrm_address_t saddr;
		int header_len;
		int trailer_len;
		u32 extra_flags;
		struct xfrm_mark smark;
	} props;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_algo_auth *aalg;
	struct xfrm_algo *ealg;
	struct xfrm_algo *calg;
	struct xfrm_algo_aead *aead;
	const char *geniv;
	struct xfrm_encap_tmpl *encap;
	xfrm_address_t *coaddr;
	struct xfrm_state *tunnel;
	atomic_t tunnel_users;
	struct xfrm_replay_state replay;
	struct xfrm_replay_state_esn *replay_esn;
	struct xfrm_replay_state preplay;
	struct xfrm_replay_state_esn *preplay_esn;
	const struct xfrm_replay *repl;
	u32 xflags;
	u32 replay_maxage;
	u32 replay_maxdiff;
	struct timer_list rtimer;
	struct xfrm_stats stats;
	struct xfrm_lifetime_cur curlft;
	struct hrtimer mtimer;
	struct xfrm_state_offload xso;
	long int saved_tmo;
	time64_t lastused;
	struct page_frag xfrag;
	const struct xfrm_type *type;
	struct xfrm_mode inner_mode;
	struct xfrm_mode inner_mode_iaf;
	struct xfrm_mode outer_mode;
	const struct xfrm_type_offload *type_offload;
	struct xfrm_sec_ctx *security;
	void *data;
};

struct sd_flow_limit {
	u64 count;
	unsigned int num_buckets;
	unsigned int history_head;
	u16 history[128];
	u8 buckets[0];
};

struct softnet_data {
	struct list_head poll_list;
	struct sk_buff_head process_queue;
	unsigned int processed;
	unsigned int time_squeeze;
	unsigned int received_rps;
	struct softnet_data *rps_ipi_list;
	struct sd_flow_limit *flow_limit;
	struct Qdisc *output_queue;
	struct Qdisc **output_queue_tailp;
	struct sk_buff *completion_queue;
	struct sk_buff_head xfrm_backlog;
	struct {
		u16 recursion;
		u8 more;
	} xmit;
	int: 32;
	unsigned int input_queue_head;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t csd;
	struct softnet_data *rps_ipi_next;
	unsigned int cpu;
	unsigned int input_queue_tail;
	unsigned int dropped;
	struct sk_buff_head input_pkt_queue;
	struct napi_struct backlog;
	long: 64;
};

struct dst_metrics {
	u32 metrics[17];
	refcount_t refcnt;
};

struct so_timestamping {
	int flags;
	int bind_phc;
};

enum txtime_flags {
	SOF_TXTIME_DEADLINE_MODE = 1,
	SOF_TXTIME_REPORT_ERRORS = 2,
	SOF_TXTIME_FLAGS_LAST = 2,
	SOF_TXTIME_FLAGS_MASK = 3,
};

struct sock_txtime {
	__kernel_clockid_t clockid;
	__u32 flags;
};

struct xfrm_policy_walk_entry {
	struct list_head all;
	u8 dead;
};

struct xfrm_policy_queue {
	struct sk_buff_head hold_queue;
	struct timer_list hold_timer;
	long unsigned int timeout;
};

struct xfrm_tmpl {
	struct xfrm_id id;
	xfrm_address_t saddr;
	short unsigned int encap_family;
	u32 reqid;
	u8 mode;
	u8 share;
	u8 optional;
	u8 allalgs;
	u32 aalgos;
	u32 ealgos;
	u32 calgos;
};

struct xfrm_policy {
	possible_net_t xp_net;
	struct hlist_node bydst;
	struct hlist_node byidx;
	rwlock_t lock;
	refcount_t refcnt;
	u32 pos;
	struct timer_list timer;
	atomic_t genid;
	u32 priority;
	u32 index;
	u32 if_id;
	struct xfrm_mark mark;
	struct xfrm_selector selector;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	struct xfrm_policy_walk_entry walk;
	struct xfrm_policy_queue polq;
	bool bydst_reinsert;
	u8 type;
	u8 action;
	u8 flags;
	u8 xfrm_nr;
	u16 family;
	struct xfrm_sec_ctx *security;
	struct xfrm_tmpl xfrm_vec[6];
	struct hlist_node bydst_inexact_list;
	struct callback_head rcu;
};

enum sk_pacing {
	SK_PACING_NONE = 0,
	SK_PACING_NEEDED = 1,
	SK_PACING_FQ = 2,
};

struct sockcm_cookie {
	u64 transmit_time;
	u32 mark;
	u16 tsflags;
};

struct fastopen_queue {
	struct request_sock *rskq_rst_head;
	struct request_sock *rskq_rst_tail;
	spinlock_t lock;
	int qlen;
	int max_qlen;
	struct tcp_fastopen_context *ctx;
};

struct request_sock_queue {
	spinlock_t rskq_lock;
	u8 rskq_defer_accept;
	u32 synflood_warned;
	atomic_t qlen;
	atomic_t young;
	struct request_sock *rskq_accept_head;
	struct request_sock *rskq_accept_tail;
	struct fastopen_queue fastopenq;
};

struct minmax_sample {
	u32 t;
	u32 v;
};

struct minmax {
	struct minmax_sample s[3];
};

struct inet_connection_sock_af_ops {
	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
	void (*send_check)(struct sock *, struct sk_buff *);
	int (*rebuild_header)(struct sock *);
	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
	int (*conn_request)(struct sock *, struct sk_buff *, enum skb_drop_reason *);
	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
	u16 net_header_len;
	u16 net_frag_header_len;
	u16 sockaddr_len;
	int (*setsockopt)(struct sock *, int, int, char *, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	int (*compat_setsockopt)(struct sock *, int, int, char *, unsigned int);
	int (*compat_getsockopt)(struct sock *, int, int, char *, int *);
	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
	void (*mtu_reduced)(struct sock *);
};

struct tcp_ulp_ops;

struct inet_connection_sock {
	struct inet_sock icsk_inet;
	struct request_sock_queue icsk_accept_queue;
	struct inet_bind_bucket *icsk_bind_hash;
	long unsigned int icsk_timeout;
	struct timer_list icsk_retransmit_timer;
	struct timer_list icsk_delack_timer;
	__u32 icsk_rto;
	__u32 icsk_pmtu_cookie;
	const struct tcp_congestion_ops *icsk_ca_ops;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	const struct tcp_ulp_ops *icsk_ulp_ops;
	void *icsk_ulp_data;
	void (*icsk_clean_acked)(struct sock *, u32);
	struct hlist_node icsk_listen_portaddr_node;
	unsigned int (*icsk_sync_mss)(struct sock *, u32);
	__u8 icsk_ca_state: 6;
	__u8 icsk_ca_setsockopt: 1;
	__u8 icsk_ca_dst_locked: 1;
	__u8 icsk_retransmits;
	__u8 icsk_pending;
	__u8 icsk_backoff;
	__u8 icsk_syn_retries;
	__u8 icsk_probes_out;
	__u16 icsk_ext_hdr_len;
	struct {
		__u8 pending;
		__u8 quick;
		__u8 pingpong;
		__u8 blocked;
		__u32 ato;
		long unsigned int timeout;
		__u32 lrcvtime;
		__u16 last_seg_size;
		__u16 rcv_mss;
	} icsk_ack;
	struct {
		int enabled;
		int search_high;
		int search_low;
		int probe_size;
		u32 probe_timestamp;
	} icsk_mtup;
	u32 icsk_probes_tstamp;
	u32 icsk_user_timeout;
	u64 icsk_ca_priv[13];
};

struct inet_bind_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct in6_addr fast_v6_rcv_saddr;
	__be32 fast_rcv_saddr;
	short unsigned int fast_sk_family;
	bool fast_ipv6_only;
	struct hlist_node node;
	struct hlist_head owners;
};

struct tcp_ulp_ops {
	struct list_head list;
	int (*init)(struct sock *);
	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
	void (*release)(struct sock *);
	int (*get_info)(const struct sock *, struct sk_buff *);
	size_t (*get_info_size)(const struct sock *);
	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
	char name[16];
	struct module___2 *owner;
};

struct tcp_fastopen_cookie {
	__le64 val[2];
	s8 len;
	bool exp;
};

struct tcp_sack_block {
	u32 start_seq;
	u32 end_seq;
};

struct tcp_options_received {
	int ts_recent_stamp;
	u32 ts_recent;
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 saw_tstamp: 1;
	u16 tstamp_ok: 1;
	u16 dsack: 1;
	u16 wscale_ok: 1;
	u16 sack_ok: 3;
	u16 smc_ok: 1;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u8 num_sacks;
	u16 user_mss;
	u16 mss_clamp;
};

struct tcp_rack {
	u64 mstamp;
	u32 rtt_us;
	u32 end_seq;
	u32 last_delivered;
	u8 reo_wnd_steps;
	u8 reo_wnd_persist: 5;
	u8 dsack_seen: 1;
	u8 advanced: 1;
};

struct tcp_sock_af_ops;

struct tcp_md5sig_info;

struct tcp_fastopen_request;

struct tcp_sock {
	struct inet_connection_sock inet_conn;
	u16 tcp_header_len;
	u16 gso_segs;
	__be32 pred_flags;
	u64 bytes_received;
	u32 segs_in;
	u32 data_segs_in;
	u32 rcv_nxt;
	u32 copied_seq;
	u32 rcv_wup;
	u32 snd_nxt;
	u32 segs_out;
	u32 data_segs_out;
	u64 bytes_sent;
	u64 bytes_acked;
	u32 dsack_dups;
	u32 snd_una;
	u32 snd_sml;
	u32 rcv_tstamp;
	u32 lsndtime;
	u32 last_oow_ack_time;
	u32 compressed_ack_rcv_nxt;
	u32 tsoffset;
	struct list_head tsq_node;
	struct list_head tsorted_sent_queue;
	u32 snd_wl1;
	u32 snd_wnd;
	u32 max_window;
	u32 mss_cache;
	u32 window_clamp;
	u32 rcv_ssthresh;
	struct tcp_rack rack;
	u16 advmss;
	u8 compressed_ack;
	u8 tlp_retrans: 1;
	u8 unused_1: 7;
	u32 chrono_start;
	u32 chrono_stat[3];
	u8 chrono_type: 2;
	u8 rate_app_limited: 1;
	u8 fastopen_connect: 1;
	u8 fastopen_no_cookie: 1;
	u8 is_sack_reneg: 1;
	u8 unused: 2;
	u8 nonagle: 4;
	u8 thin_lto: 1;
	u8 recvmsg_inq: 1;
	u8 repair: 1;
	u8 frto: 1;
	u8 repair_queue;
	u8 syn_data: 1;
	u8 syn_fastopen: 1;
	u8 syn_fastopen_exp: 1;
	u8 syn_fastopen_ch: 1;
	u8 syn_data_acked: 1;
	u8 save_syn: 1;
	u8 is_cwnd_limited: 1;
	u8 syn_smc: 1;
	u32 tlp_high_seq;
	u32 tcp_tx_delay;
	u64 tcp_wstamp_ns;
	u64 tcp_clock_cache;
	u64 tcp_mstamp;
	u32 srtt_us;
	u32 mdev_us;
	u32 mdev_max_us;
	u32 rttvar_us;
	u32 rtt_seq;
	struct minmax rtt_min;
	u32 packets_out;
	u32 retrans_out;
	u32 max_packets_out;
	u32 max_packets_seq;
	u16 urg_data;
	u8 ecn_flags;
	u8 keepalive_probes;
	u32 reordering;
	u32 reord_seen;
	u32 snd_up;
	struct tcp_options_received rx_opt;
	u32 snd_ssthresh;
	u32 snd_cwnd;
	u32 snd_cwnd_cnt;
	u32 snd_cwnd_clamp;
	u32 snd_cwnd_used;
	u32 snd_cwnd_stamp;
	u32 prior_cwnd;
	u32 prr_delivered;
	u32 prr_out;
	u32 delivered;
	u32 delivered_ce;
	u32 lost;
	u32 app_limited;
	u64 first_tx_mstamp;
	u64 delivered_mstamp;
	u32 rate_delivered;
	u32 rate_interval_us;
	u32 rcv_wnd;
	u32 write_seq;
	u32 notsent_lowat;
	u32 pushed_seq;
	u32 lost_out;
	u32 sacked_out;
	struct hrtimer pacing_timer;
	struct hrtimer compressed_ack_timer;
	struct sk_buff *lost_skb_hint;
	struct sk_buff *retransmit_skb_hint;
	struct rb_root out_of_order_queue;
	struct sk_buff *ooo_last_skb;
	struct tcp_sack_block duplicate_sack[1];
	struct tcp_sack_block selective_acks[4];
	struct tcp_sack_block recv_sack_cache[4];
	struct sk_buff *highest_sack;
	int lost_cnt_hint;
	u32 prior_ssthresh;
	u32 high_seq;
	u32 retrans_stamp;
	u32 undo_marker;
	int undo_retrans;
	u64 bytes_retrans;
	u32 total_retrans;
	u32 urg_seq;
	unsigned int keepalive_time;
	unsigned int keepalive_intvl;
	int linger2;
	u8 bpf_sock_ops_cb_flags;
	u32 rcv_ooopack;
	u32 rcv_rtt_last_tsecr;
	struct {
		u32 rtt_us;
		u32 seq;
		u64 time;
	} rcv_rtt_est;
	struct {
		u32 space;
		u32 seq;
		u64 time;
	} rcvq_space;
	struct {
		u32 probe_seq_start;
		u32 probe_seq_end;
	} mtu_probe;
	u32 mtu_info;
	bool is_mptcp;
	const struct tcp_sock_af_ops *af_specific;
	struct tcp_md5sig_info *md5sig_info;
	struct tcp_fastopen_request *fastopen_req;
	struct request_sock *fastopen_rsk;
	u32 *saved_syn;
	u32 fullnat_real_ip;
	u16 fullnat_real_port;
	u32 fullnat_first_data_seq;
	bool fullnat_real_ip_inserted;
};

struct tcp_md5sig_key;

struct tcp_sock_af_ops {
	struct tcp_md5sig_key * (*md5_lookup)(const struct sock *, const struct sock *);
	int (*calc_md5_hash)(char *, const struct tcp_md5sig_key *, const struct sock *, const struct sk_buff *);
	int (*md5_parse)(struct sock *, int, char *, int);
};

struct tcp_md5sig_info {
	struct hlist_head head;
	struct callback_head rcu;
};

struct tcp_fastopen_request {
	struct tcp_fastopen_cookie cookie;
	struct msghdr *data;
	size_t size;
	int copied;
	struct ubuf_info *uarg;
};

union tcp_md5_addr {
	struct in_addr a4;
	struct in6_addr a6;
};

struct tcp_md5sig_key {
	struct hlist_node node;
	u8 keylen;
	u8 family;
	union tcp_md5_addr addr;
	u8 prefixlen;
	u8 key[80];
	struct callback_head rcu;
};

struct fib_nh_exception {
	struct fib_nh_exception *fnhe_next;
	int fnhe_genid;
	__be32 fnhe_daddr;
	u32 fnhe_pmtu;
	bool fnhe_mtu_locked;
	__be32 fnhe_gw;
	long unsigned int fnhe_expires;
	struct rtable *fnhe_rth_input;
	struct rtable *fnhe_rth_output;
	long unsigned int fnhe_stamp;
	struct callback_head rcu;
};

struct rtable {
	struct dst_entry dst;
	int rt_genid;
	unsigned int rt_flags;
	__u16 rt_type;
	__u8 rt_is_input;
	__u8 rt_uses_gateway;
	int rt_iif;
	u8 rt_gw_family;
	union {
		__be32 rt_gw4;
		struct in6_addr rt_gw6;
	};
	u32 rt_mtu_locked: 1;
	u32 rt_pmtu: 31;
	struct list_head rt_uncached;
	struct uncached_list *rt_uncached_list;
};

struct fnhe_hash_bucket {
	struct fib_nh_exception *chain;
};

struct net_protocol {
	int (*early_demux)(struct sk_buff *);
	int (*early_demux_handler)(struct sk_buff *);
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, u32);
	unsigned int no_policy: 1;
	unsigned int netns_ok: 1;
	unsigned int icmp_strict_tag_validation: 1;
};

struct rt6_exception_bucket {
	struct hlist_head chain;
	int depth;
};

struct xfrm_replay {
	void (*advance)(struct xfrm_state *, __be32);
	int (*check)(struct xfrm_state *, struct sk_buff *, __be32);
	int (*recheck)(struct xfrm_state *, struct sk_buff *, __be32);
	void (*notify)(struct xfrm_state *, int);
	int (*overflow)(struct xfrm_state *, struct sk_buff *);
};

struct xfrm_type {
	char *description;
	struct module___2 *owner;
	u8 proto;
	u8 flags;
	int (*init_state)(struct xfrm_state *);
	void (*destructor)(struct xfrm_state *);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct xfrm_state *, struct sk_buff *);
	int (*reject)(struct xfrm_state *, struct sk_buff *, const struct flowi *);
	int (*hdr_offset)(struct xfrm_state *, struct sk_buff *, u8 **);
};

struct xfrm_type_offload {
	char *description;
	struct module___2 *owner;
	u8 proto;
	void (*encap)(struct xfrm_state *, struct sk_buff *);
	int (*input_tail)(struct xfrm_state *, struct sk_buff *);
	int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t);
};

struct xfrm_dst {
	union {
		struct dst_entry dst;
		struct rtable rt;
		struct rt6_info rt6;
	} u;
	struct dst_entry *route;
	struct dst_entry *child;
	struct dst_entry *path;
	struct xfrm_policy *pols[2];
	int num_pols;
	int num_xfrms;
	u32 xfrm_genid;
	u32 policy_genid;
	u32 route_mtu_cached;
	u32 child_mtu_cached;
	u32 route_cookie;
	u32 path_cookie;
};

struct cgroup_cls_state {
	struct cgroup_subsys_state css;
	u32 classid;
};

enum {
	SK_MEMINFO_RMEM_ALLOC = 0,
	SK_MEMINFO_RCVBUF = 1,
	SK_MEMINFO_WMEM_ALLOC = 2,
	SK_MEMINFO_SNDBUF = 3,
	SK_MEMINFO_FWD_ALLOC = 4,
	SK_MEMINFO_WMEM_QUEUED = 5,
	SK_MEMINFO_OPTMEM = 6,
	SK_MEMINFO_BACKLOG = 7,
	SK_MEMINFO_DROPS = 8,
	SK_MEMINFO_VARS = 9,
};

enum sknetlink_groups {
	SKNLGRP_NONE = 0,
	SKNLGRP_INET_TCP_DESTROY = 1,
	SKNLGRP_INET_UDP_DESTROY = 2,
	SKNLGRP_INET6_TCP_DESTROY = 3,
	SKNLGRP_INET6_UDP_DESTROY = 4,
	__SKNLGRP_MAX = 5,
};

struct inet_request_sock {
	struct request_sock req;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u16 tstamp_ok: 1;
	u16 sack_ok: 1;
	u16 wscale_ok: 1;
	u16 ecn_ok: 1;
	u16 acked: 1;
	u16 no_srccheck: 1;
	u16 smc_ok: 1;
	u32 ir_mark;
	union {
		struct ip_options_rcu *ireq_opt;
		struct {
			struct ipv6_txoptions *ipv6_opt;
			struct sk_buff *pktopts;
		};
	};
};

struct tcp_request_sock_ops;

struct tcp_request_sock {
	struct inet_request_sock req;
	const struct tcp_request_sock_ops *af_specific;
	u64 snt_synack;
	bool tfo_listener;
	bool is_mptcp;
	bool drop_req;
	u32 txhash;
	u32 rcv_isn;
	u32 snt_isn;
	u32 ts_off;
	u32 last_oow_ack_time;
	u32 rcv_nxt;
};

enum tcp_synack_type {
	TCP_SYNACK_NORMAL = 0,
	TCP_SYNACK_FASTOPEN = 1,
	TCP_SYNACK_COOKIE = 2,
};

struct tcp_request_sock_ops {
	u16 mss_clamp;
	struct tcp_md5sig_key * (*req_md5_lookup)(const struct sock *, const struct sock *);
	int (*calc_md5_hash)(char *, const struct tcp_md5sig_key *, const struct sock *, const struct sk_buff *);
	__u32 (*cookie_init_seq)(const struct sk_buff *, __u16 *);
	struct dst_entry * (*route_req)(const struct sock *, struct sk_buff *, struct flowi *, struct request_sock *, enum skb_drop_reason *);
	u32 (*init_seq)(const struct sk_buff *);
	u32 (*init_ts_off)(const struct net___2 *, const struct sk_buff *);
	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type);
};

struct nf_conntrack {
	atomic_t use;
};

enum {
	SKB_FCLONE_UNAVAILABLE = 0,
	SKB_FCLONE_ORIG = 1,
	SKB_FCLONE_CLONE = 2,
};

struct sk_buff_fclones {
	struct sk_buff skb1;
	struct sk_buff skb2;
	refcount_t fclone_ref;
};

struct skb_checksum_ops {
	__wsum (*update)(const void *, int, __wsum);
	__wsum (*combine)(__wsum, __wsum, int, int);
};

struct skb_gso_cb {
	union {
		int mac_offset;
		int data_offset;
	};
	int encap_level;
	__wsum csum;
	__u16 csum_start;
};

struct napi_gro_cb {
	void *frag0;
	unsigned int frag0_len;
	int data_offset;
	u16 flush;
	u16 flush_id;
	u16 count;
	u16 gro_remcsum_start;
	long unsigned int age;
	u16 proto;
	u8 same_flow: 1;
	u8 encap_mark: 1;
	u8 csum_valid: 1;
	u8 csum_cnt: 3;
	u8 free: 2;
	u8 is_ipv6: 1;
	u8 is_fou: 1;
	u8 is_atomic: 1;
	u8 recursion_counter: 4;
	__wsum csum;
	struct sk_buff *last;
};

struct vlan_hdr {
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct qdisc_walker {
	int stop;
	int skip;
	int count;
	int (*fn)(struct Qdisc *, long unsigned int, struct qdisc_walker *);
};

enum sctp_msg_flags {
	MSG_NOTIFICATION = 32768,
};

struct ip_auth_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__be16 reserved;
	__be32 spi;
	__be32 seq_no;
	__u8 auth_data[0];
};

struct frag_hdr {
	__u8 nexthdr;
	__u8 reserved;
	__be16 frag_off;
	__be32 identification;
};

enum {
	SCM_TSTAMP_SND = 0,
	SCM_TSTAMP_SCHED = 1,
	SCM_TSTAMP_ACK = 2,
};

struct xfrm_offload {
	struct {
		__u32 low;
		__u32 hi;
	} seq;
	__u32 flags;
	__u32 status;
	__u8 proto;
};

struct sec_path {
	int len;
	int olen;
	struct xfrm_state *xvec[6];
	struct xfrm_offload ovec[1];
};

struct mpls_shim_hdr {
	__be32 label_stack_entry;
};

struct napi_alloc_cache {
	struct page_frag_cache page;
	unsigned int skb_count;
	void *skb_cache[64];
};

struct scm_cookie {
	struct pid___2 *pid;
	struct scm_fp_list *fp;
	struct scm_creds creds;
	u32 secid;
};

struct scm_timestamping {
	struct timespec ts[3];
};

struct scm_timestamping64 {
	struct __kernel_timespec ts[3];
};

enum {
	TCA_STATS_UNSPEC = 0,
	TCA_STATS_BASIC = 1,
	TCA_STATS_RATE_EST = 2,
	TCA_STATS_QUEUE = 3,
	TCA_STATS_APP = 4,
	TCA_STATS_RATE_EST64 = 5,
	TCA_STATS_PAD = 6,
	TCA_STATS_BASIC_HW = 7,
	__TCA_STATS_MAX = 8,
};

struct gnet_stats_basic {
	__u64 bytes;
	__u32 packets;
};

struct gnet_stats_rate_est {
	__u32 bps;
	__u32 pps;
};

struct gnet_stats_rate_est64 {
	__u64 bps;
	__u64 pps;
};

struct gnet_estimator {
	signed char interval;
	unsigned char ewma_log;
};

struct net_rate_estimator {
	struct gnet_stats_basic_packed *bstats;
	spinlock_t *stats_lock;
	seqcount_t *running;
	struct gnet_stats_basic_cpu *cpu_bstats;
	u8 ewma_log;
	u8 intvl_log;
	seqcount_t seq;
	u32 last_packets;
	u64 last_bytes;
	u64 avpps;
	u64 avbps;
	long unsigned int next_jiffies;
	struct timer_list timer;
	struct callback_head rcu;
};

enum {
	RTM_BASE = 16,
	RTM_NEWLINK = 16,
	RTM_DELLINK = 17,
	RTM_GETLINK = 18,
	RTM_SETLINK = 19,
	RTM_NEWADDR = 20,
	RTM_DELADDR = 21,
	RTM_GETADDR = 22,
	RTM_NEWROUTE = 24,
	RTM_DELROUTE = 25,
	RTM_GETROUTE = 26,
	RTM_NEWNEIGH = 28,
	RTM_DELNEIGH = 29,
	RTM_GETNEIGH = 30,
	RTM_NEWRULE = 32,
	RTM_DELRULE = 33,
	RTM_GETRULE = 34,
	RTM_NEWQDISC = 36,
	RTM_DELQDISC = 37,
	RTM_GETQDISC = 38,
	RTM_NEWTCLASS = 40,
	RTM_DELTCLASS = 41,
	RTM_GETTCLASS = 42,
	RTM_NEWTFILTER = 44,
	RTM_DELTFILTER = 45,
	RTM_GETTFILTER = 46,
	RTM_NEWACTION = 48,
	RTM_DELACTION = 49,
	RTM_GETACTION = 50,
	RTM_NEWPREFIX = 52,
	RTM_GETMULTICAST = 58,
	RTM_GETANYCAST = 62,
	RTM_NEWNEIGHTBL = 64,
	RTM_GETNEIGHTBL = 66,
	RTM_SETNEIGHTBL = 67,
	RTM_NEWNDUSEROPT = 68,
	RTM_NEWADDRLABEL = 72,
	RTM_DELADDRLABEL = 73,
	RTM_GETADDRLABEL = 74,
	RTM_GETDCB = 78,
	RTM_SETDCB = 79,
	RTM_NEWNETCONF = 80,
	RTM_DELNETCONF = 81,
	RTM_GETNETCONF = 82,
	RTM_NEWMDB = 84,
	RTM_DELMDB = 85,
	RTM_GETMDB = 86,
	RTM_NEWNSID = 88,
	RTM_DELNSID = 89,
	RTM_GETNSID = 90,
	RTM_NEWSTATS = 92,
	RTM_GETSTATS = 94,
	RTM_NEWCACHEREPORT = 96,
	RTM_NEWCHAIN = 100,
	RTM_DELCHAIN = 101,
	RTM_GETCHAIN = 102,
	RTM_NEWNEXTHOP = 104,
	RTM_DELNEXTHOP = 105,
	RTM_GETNEXTHOP = 106,
	__RTM_MAX = 107,
};

struct rtgenmsg {
	unsigned char rtgen_family;
};

enum rtnetlink_groups {
	RTNLGRP_NONE = 0,
	RTNLGRP_LINK = 1,
	RTNLGRP_NOTIFY = 2,
	RTNLGRP_NEIGH = 3,
	RTNLGRP_TC = 4,
	RTNLGRP_IPV4_IFADDR = 5,
	RTNLGRP_IPV4_MROUTE = 6,
	RTNLGRP_IPV4_ROUTE = 7,
	RTNLGRP_IPV4_RULE = 8,
	RTNLGRP_IPV6_IFADDR = 9,
	RTNLGRP_IPV6_MROUTE = 10,
	RTNLGRP_IPV6_ROUTE = 11,
	RTNLGRP_IPV6_IFINFO = 12,
	RTNLGRP_DECnet_IFADDR = 13,
	RTNLGRP_NOP2 = 14,
	RTNLGRP_DECnet_ROUTE = 15,
	RTNLGRP_DECnet_RULE = 16,
	RTNLGRP_NOP4 = 17,
	RTNLGRP_IPV6_PREFIX = 18,
	RTNLGRP_IPV6_RULE = 19,
	RTNLGRP_ND_USEROPT = 20,
	RTNLGRP_PHONET_IFADDR = 21,
	RTNLGRP_PHONET_ROUTE = 22,
	RTNLGRP_DCB = 23,
	RTNLGRP_IPV4_NETCONF = 24,
	RTNLGRP_IPV6_NETCONF = 25,
	RTNLGRP_MDB = 26,
	RTNLGRP_MPLS_ROUTE = 27,
	RTNLGRP_NSID = 28,
	RTNLGRP_MPLS_NETCONF = 29,
	RTNLGRP_IPV4_MROUTE_R = 30,
	RTNLGRP_IPV6_MROUTE_R = 31,
	RTNLGRP_NEXTHOP = 32,
	__RTNLGRP_MAX = 33,
};

enum {
	NETNSA_NONE = 0,
	NETNSA_NSID = 1,
	NETNSA_PID = 2,
	NETNSA_FD = 3,
	NETNSA_TARGET_NSID = 4,
	NETNSA_CURRENT_NSID = 5,
	__NETNSA_MAX = 6,
};

struct pcpu_gen_cookie {
	local_t nesting;
	u64 last;
};

struct gen_cookie {
	struct pcpu_gen_cookie *local;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t forward_last;
	atomic64_t reverse_last;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);

typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

enum rtnl_link_flags {
	RTNL_FLAG_DOIT_UNLOCKED = 1,
};

struct net_fill_args {
	u32 portid;
	u32 seq;
	int flags;
	int cmd;
	int nsid;
	bool add_ref;
	int ref_nsid;
};

struct rtnl_net_dump_cb {
	struct net___2 *tgt_net;
	struct net___2 *ref_net;
	struct sk_buff *skb;
	struct net_fill_args fillargs;
	int idx;
	int s_idx;
};

typedef u64 u_int64_t;

struct flow_dissector_key_control {
	u16 thoff;
	u16 addr_type;
	u32 flags;
};

enum flow_dissect_ret {
	FLOW_DISSECT_RET_OUT_GOOD = 0,
	FLOW_DISSECT_RET_OUT_BAD = 1,
	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
	FLOW_DISSECT_RET_CONTINUE = 4,
};

struct flow_dissector_key_basic {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
};

struct flow_dissector_key_tags {
	u32 flow_label;
};

struct flow_dissector_key_vlan {
	u16 vlan_id: 12;
	u16 vlan_dei: 1;
	u16 vlan_priority: 3;
	__be16 vlan_tpid;
};

struct flow_dissector_key_mpls {
	u32 mpls_ttl: 8;
	u32 mpls_bos: 1;
	u32 mpls_tc: 3;
	u32 mpls_label: 20;
};

struct flow_dissector_key_enc_opts {
	u8 data[255];
	u8 len;
	__be16 dst_opt_type;
};

struct flow_dissector_key_keyid {
	__be32 keyid;
};

struct flow_dissector_key_ipv4_addrs {
	__be32 src;
	__be32 dst;
};

struct flow_dissector_key_ipv6_addrs {
	struct in6_addr src;
	struct in6_addr dst;
};

struct flow_dissector_key_tipc {
	__be32 key;
};

struct flow_dissector_key_addrs {
	union {
		struct flow_dissector_key_ipv4_addrs v4addrs;
		struct flow_dissector_key_ipv6_addrs v6addrs;
		struct flow_dissector_key_tipc tipckey;
	};
};

struct flow_dissector_key_arp {
	__u32 sip;
	__u32 tip;
	__u8 op;
	unsigned char sha[6];
	unsigned char tha[6];
};

struct flow_dissector_key_ports {
	union {
		__be32 ports;
		struct {
			__be16 src;
			__be16 dst;
		};
	};
};

struct flow_dissector_key_icmp {
	union {
		__be16 icmp;
		struct {
			u8 type;
			u8 code;
		};
	};
};

struct flow_dissector_key_eth_addrs {
	unsigned char dst[6];
	unsigned char src[6];
};

struct flow_dissector_key_tcp {
	__be16 flags;
};

struct flow_dissector_key_ip {
	__u8 tos;
	__u8 ttl;
};

struct flow_dissector_key_meta {
	int ingress_ifindex;
};

struct flow_dissector_key_ct {
	u16 ct_state;
	u16 ct_zone;
	u32 ct_mark;
	u32 ct_labels[4];
};

struct flow_dissector_key {
	enum flow_dissector_key_id key_id;
	size_t offset;
};

struct flow_dissector {
	unsigned int used_keys;
	short unsigned int offset[27];
};

struct flow_keys_basic {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
};

struct flow_keys {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_tags tags;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_keyid keyid;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_addrs addrs;
};

struct flow_keys_digest {
	u8 data[16];
};

enum ip_conntrack_info {
	IP_CT_ESTABLISHED = 0,
	IP_CT_RELATED = 1,
	IP_CT_NEW = 2,
	IP_CT_IS_REPLY = 3,
	IP_CT_ESTABLISHED_REPLY = 3,
	IP_CT_RELATED_REPLY = 4,
	IP_CT_NUMBER = 5,
	IP_CT_UNTRACKED = 7,
};

struct xt_table_info;

struct xt_table {
	struct list_head list;
	unsigned int valid_hooks;
	struct xt_table_info *private;
	struct module___2 *me;
	u_int8_t af;
	int priority;
	int (*table_init)(struct net___2 *);
	const char name[32];
};

union nf_inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

union tcp_word_hdr {
	struct tcphdr hdr;
	__be32 words[5];
};

struct ip_ct_tcp_state {
	u_int32_t td_end;
	u_int32_t td_maxend;
	u_int32_t td_maxwin;
	u_int32_t td_maxack;
	u_int8_t td_scale;
	u_int8_t flags;
};

struct ip_ct_tcp {
	struct ip_ct_tcp_state seen[2];
	u_int8_t state;
	u_int8_t last_dir;
	u_int8_t retrans;
	u_int8_t last_index;
	u_int32_t last_seq;
	u_int32_t last_ack;
	u_int32_t last_end;
	u_int16_t last_win;
	u_int8_t last_wscale;
	u_int8_t last_flags;
};

struct nf_ct_event;

struct nf_ct_event_notifier {
	int (*fcn)(unsigned int, struct nf_ct_event *);
};

struct nf_exp_event;

struct nf_exp_event_notifier {
	int (*fcn)(unsigned int, struct nf_exp_event *);
};

enum bpf_ret_code {
	BPF_OK = 0,
	BPF_DROP = 2,
	BPF_REDIRECT = 7,
	BPF_LWT_REROUTE = 128,
};

enum {
	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG = 1,
	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL = 2,
	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP = 4,
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET = 0,
	DEVLINK_PORT_TYPE_AUTO = 1,
	DEVLINK_PORT_TYPE_ETH = 2,
	DEVLINK_PORT_TYPE_IB = 3,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
	DEVLINK_PORT_FLAVOUR_CPU = 1,
	DEVLINK_PORT_FLAVOUR_DSA = 2,
	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
};

struct devlink_port_phys_attrs {
	u32 port_number;
	u32 split_subport_number;
};

struct devlink_port_pci_pf_attrs {
	u16 pf;
};

struct devlink_port_pci_vf_attrs {
	u16 pf;
	u16 vf;
};

struct devlink_port_attrs {
	u8 set: 1;
	u8 split: 1;
	u8 switch_port: 1;
	enum devlink_port_flavour flavour;
	struct netdev_phys_item_id switch_id;
	union {
		struct devlink_port_phys_attrs phys;
		struct devlink_port_pci_pf_attrs pci_pf;
		struct devlink_port_pci_vf_attrs pci_vf;
	};
};

struct devlink;

struct devlink_port {
	struct list_head list;
	struct list_head param_list;
	struct devlink *devlink;
	unsigned int index;
	bool registered;
	spinlock_t type_lock;
	enum devlink_port_type type;
	enum devlink_port_type desired_type;
	void *type_dev;
	struct devlink_port_attrs attrs;
	struct delayed_work type_warn_dw;
};

struct ip_tunnel_key {
	__be64 tun_id;
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ipv4;
		struct {
			struct in6_addr src;
			struct in6_addr dst;
		} ipv6;
	} u;
	__be16 tun_flags;
	u8 tos;
	u8 ttl;
	__be32 label;
	__be16 tp_src;
	__be16 tp_dst;
};

struct dst_cache_pcpu;

struct dst_cache {
	struct dst_cache_pcpu *cache;
	long unsigned int reset_ts;
};

struct ip_tunnel_info {
	struct ip_tunnel_key key;
	struct dst_cache dst_cache;
	u8 options_len;
	u8 mode;
};

struct lwtunnel_state {
	__u16 type;
	__u16 flags;
	__u16 headroom;
	atomic_t refcnt;
	int (*orig_output)(struct net___2 *, struct sock *, struct sk_buff *);
	int (*orig_input)(struct sk_buff *);
	struct callback_head rcu;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	__u8 data[0];
};

enum devlink_sb_pool_type {
	DEVLINK_SB_POOL_TYPE_INGRESS = 0,
	DEVLINK_SB_POOL_TYPE_EGRESS = 1,
};

enum devlink_sb_threshold_type {
	DEVLINK_SB_THRESHOLD_TYPE_STATIC = 0,
	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC = 1,
};

enum devlink_eswitch_encap_mode {
	DEVLINK_ESWITCH_ENCAP_MODE_NONE = 0,
	DEVLINK_ESWITCH_ENCAP_MODE_BASIC = 1,
};

enum devlink_trap_action {
	DEVLINK_TRAP_ACTION_DROP = 0,
	DEVLINK_TRAP_ACTION_TRAP = 1,
};

enum devlink_trap_type {
	DEVLINK_TRAP_TYPE_DROP = 0,
	DEVLINK_TRAP_TYPE_EXCEPTION = 1,
};

enum devlink_dpipe_field_mapping_type {
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE = 0,
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX = 1,
};

struct devlink_dpipe_headers;

struct devlink_ops;

struct devlink {
	struct list_head list;
	struct list_head port_list;
	struct list_head sb_list;
	struct list_head dpipe_table_list;
	struct list_head resource_list;
	struct list_head param_list;
	struct list_head region_list;
	u32 snapshot_id;
	struct list_head reporter_list;
	struct mutex reporters_lock;
	struct devlink_dpipe_headers *dpipe_headers;
	struct list_head trap_list;
	struct list_head trap_group_list;
	const struct devlink_ops *ops;
	struct device *dev;
	possible_net_t _net;
	struct mutex lock;
	u8 reload_failed: 1;
	u8 reload_enabled: 1;
	long: 62;
	long: 64;
	long: 64;
	char priv[0];
};

struct devlink_dpipe_header;

struct devlink_dpipe_headers {
	struct devlink_dpipe_header **headers;
	unsigned int headers_count;
};

struct devlink_sb_pool_info;

struct devlink_info_req;

struct devlink_trap;

struct devlink_trap_group;

struct devlink_ops {
	int (*reload_down)(struct devlink *, struct netlink_ext_ack *);
	int (*reload_up)(struct devlink *, struct netlink_ext_ack *);
	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
	int (*port_split)(struct devlink *, unsigned int, unsigned int, struct netlink_ext_ack *);
	int (*port_unsplit)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	int (*sb_pool_get)(struct devlink *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*sb_pool_set)(struct devlink *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*sb_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *);
	int (*sb_port_pool_set)(struct devlink_port *, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*sb_tc_pool_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*sb_tc_pool_bind_set)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*sb_occ_snapshot)(struct devlink *, unsigned int);
	int (*sb_occ_max_clear)(struct devlink *, unsigned int);
	int (*sb_occ_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *, u32 *);
	int (*sb_occ_tc_port_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*eswitch_mode_get)(struct devlink *, u16 *);
	int (*eswitch_mode_set)(struct devlink *, u16, struct netlink_ext_ack *);
	int (*eswitch_inline_mode_get)(struct devlink *, u8 *);
	int (*eswitch_inline_mode_set)(struct devlink *, u8, struct netlink_ext_ack *);
	int (*eswitch_encap_mode_get)(struct devlink *, enum devlink_eswitch_encap_mode *);
	int (*eswitch_encap_mode_set)(struct devlink *, enum devlink_eswitch_encap_mode, struct netlink_ext_ack *);
	int (*info_get)(struct devlink *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*flash_update)(struct devlink *, const char *, const char *, struct netlink_ext_ack *);
	int (*trap_init)(struct devlink *, const struct devlink_trap *, void *);
	void (*trap_fini)(struct devlink *, const struct devlink_trap *, void *);
	int (*trap_action_set)(struct devlink *, const struct devlink_trap *, enum devlink_trap_action);
	int (*trap_group_init)(struct devlink *, const struct devlink_trap_group *);
};

struct devlink_sb_pool_info {
	enum devlink_sb_pool_type pool_type;
	u32 size;
	enum devlink_sb_threshold_type threshold_type;
	u32 cell_size;
};

struct devlink_dpipe_field {
	const char *name;
	unsigned int id;
	unsigned int bitwidth;
	enum devlink_dpipe_field_mapping_type mapping_type;
};

struct devlink_dpipe_header {
	const char *name;
	unsigned int id;
	struct devlink_dpipe_field *fields;
	unsigned int fields_count;
	bool global;
};

struct devlink_trap_group {
	const char *name;
	u16 id;
	bool generic;
};

struct devlink_trap {
	enum devlink_trap_type type;
	enum devlink_trap_action init_action;
	bool generic;
	u16 id;
	const char *name;
	struct devlink_trap_group group;
	u32 metadata_cap;
};

struct arphdr {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
};

struct fib_info;

struct fib_nh {
	struct fib_nh_common nh_common;
	struct hlist_node nh_hash;
	struct fib_info *nh_parent;
	__u32 nh_tclassid;
	__be32 nh_saddr;
	int nh_saddr_genid;
};

struct fib_info {
	struct hlist_node fib_hash;
	struct hlist_node fib_lhash;
	struct list_head nh_list;
	struct net___2 *fib_net;
	int fib_treeref;
	refcount_t fib_clntref;
	unsigned int fib_flags;
	unsigned char fib_dead;
	unsigned char fib_protocol;
	unsigned char fib_scope;
	unsigned char fib_type;
	__be32 fib_prefsrc;
	u32 fib_tb_id;
	u32 fib_priority;
	struct dst_metrics *fib_metrics;
	int fib_nhs;
	bool fib_nh_is_v6;
	bool nh_updated;
	struct nexthop *nh;
	struct callback_head rcu;
	struct fib_nh fib_nh[0];
};

struct nh_info;

struct nh_group;

struct nexthop {
	struct rb_node rb_node;
	struct list_head fi_list;
	struct list_head f6i_list;
	struct list_head grp_list;
	struct net___2 *net;
	u32 id;
	u8 protocol;
	u8 nh_flags;
	bool is_group;
	refcount_t refcnt;
	struct callback_head rcu;
	union {
		struct nh_info *nh_info;
		struct nh_group *nh_grp;
	};
};

struct nh_info {
	struct hlist_node dev_hash;
	struct nexthop *nh_parent;
	u8 family;
	bool reject_nh;
	union {
		struct fib_nh_common fib_nhc;
		struct fib_nh fib_nh;
		struct fib6_nh fib6_nh;
	};
};

struct nh_grp_entry {
	struct nexthop *nh;
	u8 weight;
	atomic_t upper_bound;
	struct list_head nh_list;
	struct nexthop *nh_parent;
};

struct nh_group {
	struct nh_group *spare;
	u16 num_nh;
	bool mpath;
	bool has_v4;
	struct nh_grp_entry nh_entries[0];
};

enum metadata_type {
	METADATA_IP_TUNNEL = 0,
	METADATA_HW_PORT_MUX = 1,
};

struct hw_port_info {
	struct net_device *lower_dev;
	u32 port_id;
};

struct metadata_dst {
	struct dst_entry dst;
	enum metadata_type type;
	union {
		struct ip_tunnel_info tun_info;
		struct hw_port_info port_info;
	} u;
};

struct gre_base_hdr {
	__be16 flags;
	__be16 protocol;
};

struct gre_full_hdr {
	struct gre_base_hdr fixed_header;
	__be16 csum;
	__be16 reserved1;
	__be32 key;
	__be32 seq;
};

struct pptp_gre_header {
	struct gre_base_hdr gre_hd;
	__be16 payload_len;
	__be16 call_id;
	__be32 seq;
	__be32 ack;
};

struct tipc_basic_hdr {
	__be32 w[4];
};

enum dccp_state {
	DCCP_OPEN = 1,
	DCCP_REQUESTING = 2,
	DCCP_LISTEN = 10,
	DCCP_RESPOND = 3,
	DCCP_ACTIVE_CLOSEREQ = 4,
	DCCP_PASSIVE_CLOSE = 8,
	DCCP_CLOSING = 11,
	DCCP_TIME_WAIT = 6,
	DCCP_CLOSED = 7,
	DCCP_NEW_SYN_RECV = 12,
	DCCP_PARTOPEN = 13,
	DCCP_PASSIVE_CLOSEREQ = 14,
	DCCP_MAX_STATES = 15,
};

enum l2tp_debug_flags {
	L2TP_MSG_DEBUG = 1,
	L2TP_MSG_CONTROL = 2,
	L2TP_MSG_SEQ = 4,
	L2TP_MSG_DATA = 8,
};

struct pppoe_tag {
	__be16 tag_type;
	__be16 tag_len;
	char tag_data[0];
};

struct pppoe_hdr {
	__u8 type: 4;
	__u8 ver: 4;
	__u8 code;
	__be16 sid;
	__be16 length;
	struct pppoe_tag tag[0];
};

struct mpls_label {
	__be32 entry;
};

enum batadv_packettype {
	BATADV_IV_OGM = 0,
	BATADV_BCAST = 1,
	BATADV_CODED = 2,
	BATADV_ELP = 3,
	BATADV_OGM2 = 4,
	BATADV_UNICAST = 64,
	BATADV_UNICAST_FRAG = 65,
	BATADV_UNICAST_4ADDR = 66,
	BATADV_ICMP = 67,
	BATADV_UNICAST_TVLV = 68,
};

struct batadv_unicast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 ttvn;
	__u8 dest[6];
};

struct nf_conntrack_zone {
	u16 id;
	u8 flags;
	u8 dir;
};

union nf_conntrack_man_proto {
	__be16 all;
	struct {
		__be16 port;
	} tcp;
	struct {
		__be16 port;
	} udp;
	struct {
		__be16 id;
	} icmp;
	struct {
		__be16 port;
	} dccp;
	struct {
		__be16 port;
	} sctp;
	struct {
		__be16 key;
	} gre;
};

struct nf_conntrack_man {
	union nf_inet_addr u3;
	union nf_conntrack_man_proto u;
	u_int16_t l3num;
};

struct nf_conntrack_tuple {
	struct nf_conntrack_man src;
	struct {
		union nf_inet_addr u3;
		union {
			__be16 all;
			struct {
				__be16 port;
			} tcp;
			struct {
				__be16 port;
			} udp;
			struct {
				u_int8_t type;
				u_int8_t code;
			} icmp;
			struct {
				__be16 port;
			} dccp;
			struct {
				__be16 port;
			} sctp;
			struct {
				__be16 key;
			} gre;
		} u;
		u_int8_t protonum;
		u_int8_t dir;
	} dst;
};

struct nf_conntrack_tuple_hash {
	struct hlist_nulls_node hnnode;
	struct nf_conntrack_tuple tuple;
};

struct nf_ct_dccp {
	u_int8_t role[2];
	u_int8_t state;
	u_int8_t last_pkt;
	u_int8_t last_dir;
	u_int64_t handshake_seq;
};

enum sctp_conntrack {
	SCTP_CONNTRACK_NONE = 0,
	SCTP_CONNTRACK_CLOSED = 1,
	SCTP_CONNTRACK_COOKIE_WAIT = 2,
	SCTP_CONNTRACK_COOKIE_ECHOED = 3,
	SCTP_CONNTRACK_ESTABLISHED = 4,
	SCTP_CONNTRACK_SHUTDOWN_SENT = 5,
	SCTP_CONNTRACK_SHUTDOWN_RECD = 6,
	SCTP_CONNTRACK_SHUTDOWN_ACK_SENT = 7,
	SCTP_CONNTRACK_HEARTBEAT_SENT = 8,
	SCTP_CONNTRACK_HEARTBEAT_ACKED = 9,
	SCTP_CONNTRACK_MAX = 10,
};

struct ip_ct_sctp {
	enum sctp_conntrack state;
	__be32 vtag[2];
	u8 last_dir;
	u8 flags;
};

struct nf_ct_udp {
	long unsigned int stream_ts;
};

struct nf_ct_gre {
	unsigned int stream_timeout;
	unsigned int timeout;
};

union nf_conntrack_proto {
	struct nf_ct_dccp dccp;
	struct ip_ct_sctp sctp;
	struct ip_ct_tcp tcp;
	struct nf_ct_udp udp;
	struct nf_ct_gre gre;
	unsigned int tmpl_padto;
};

struct nf_ct_ext;

struct nf_conn {
	struct nf_conntrack ct_general;
	spinlock_t lock;
	u32 timeout;
	struct nf_conntrack_zone zone;
	struct nf_conntrack_tuple_hash tuplehash[2];
	long unsigned int status;
	u16 cpu;
	possible_net_t ct_net;
	struct hlist_node nat_bysource;
	struct {	} __nfct_init_offset;
	struct nf_conn *master;
	u_int32_t mark;
	u_int32_t secmark;
	struct nf_ct_ext *ext;
	union nf_conntrack_proto proto;
};

enum ip_conntrack_dir {
	IP_CT_DIR_ORIGINAL = 0,
	IP_CT_DIR_REPLY = 1,
	IP_CT_DIR_MAX = 2,
};

struct xt_table_info {
	unsigned int size;
	unsigned int number;
	unsigned int initial_entries;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int stacksize;
	void ***jumpstack;
	unsigned char entries[0];
};

struct nf_conntrack_tuple_mask {
	struct {
		union nf_inet_addr u3;
		union nf_conntrack_man_proto u;
	} src;
};

struct nf_ct_ext {
	struct callback_head rcu;
	u8 offset[10];
	u8 len;
	char data[0];
};

struct nf_conntrack_helper;

struct nf_conntrack_expect {
	struct hlist_node lnode;
	struct hlist_node hnode;
	struct nf_conntrack_tuple tuple;
	struct nf_conntrack_tuple_mask mask;
	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
	struct nf_conntrack_helper *helper;
	struct nf_conn *master;
	struct timer_list timeout;
	refcount_t use;
	unsigned int flags;
	unsigned int class;
	union nf_inet_addr saved_addr;
	union nf_conntrack_man_proto saved_proto;
	enum ip_conntrack_dir dir;
	struct callback_head rcu;
};

enum nf_ct_ext_id {
	NF_CT_EXT_HELPER = 0,
	NF_CT_EXT_NAT = 1,
	NF_CT_EXT_SEQADJ = 2,
	NF_CT_EXT_ACCT = 3,
	NF_CT_EXT_ECACHE = 4,
	NF_CT_EXT_TSTAMP = 5,
	NF_CT_EXT_TIMEOUT = 6,
	NF_CT_EXT_LABELS = 7,
	NF_CT_EXT_SYNPROXY = 8,
	NF_CT_EXT_MPTCP = 9,
	NF_CT_EXT_NUM = 10,
};

struct nf_ct_event {
	struct nf_conn *ct;
	u32 portid;
	int report;
};

struct nf_exp_event {
	struct nf_conntrack_expect *exp;
	u32 portid;
	int report;
};

struct nf_conn_labels {
	long unsigned int bits[2];
};

struct _flow_keys_digest_data {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
	__be32 ports;
	__be32 src;
	__be32 dst;
};

struct rps_sock_flow_table {
	u32 mask;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 ents[0];
};

struct ipv4_devconf {
	void *sysctl;
	int data[32];
	long unsigned int state[1];
};

enum nf_dev_hooks {
	NF_NETDEV_INGRESS = 0,
	NF_NETDEV_NUMHOOKS = 1,
};

struct ifbond {
	__s32 bond_mode;
	__s32 num_slaves;
	__s32 miimon;
};

typedef struct ifbond ifbond;

struct ifslave {
	__s32 slave_id;
	char slave_name[16];
	__s8 link;
	__s8 state;
	__u32 link_failure_count;
};

typedef struct ifslave ifslave;

enum netdev_state_t {
	__LINK_STATE_START = 0,
	__LINK_STATE_PRESENT = 1,
	__LINK_STATE_NOCARRIER = 2,
	__LINK_STATE_LINKWATCH_PENDING = 3,
	__LINK_STATE_DORMANT = 4,
};

struct netdev_boot_setup {
	char name[16];
	struct ifmap map;
};

enum {
	NAPIF_STATE_SCHED = 1,
	NAPIF_STATE_MISSED = 2,
	NAPIF_STATE_DISABLE = 4,
	NAPIF_STATE_NPSVC = 8,
	NAPIF_STATE_HASHED = 16,
	NAPIF_STATE_NO_BUSY_POLL = 32,
	NAPIF_STATE_IN_BUSY_POLL = 64,
};

enum gro_result {
	GRO_MERGED = 0,
	GRO_MERGED_FREE = 1,
	GRO_HELD = 2,
	GRO_NORMAL = 3,
	GRO_DROP = 4,
	GRO_CONSUMED = 5,
};

typedef enum gro_result gro_result_t;

enum netdev_queue_state_t {
	__QUEUE_STATE_DRV_XOFF = 0,
	__QUEUE_STATE_STACK_XOFF = 1,
	__QUEUE_STATE_FROZEN = 2,
};

struct netpoll;

struct netpoll_info {
	refcount_t refcnt;
	struct semaphore dev_lock;
	struct sk_buff_head txq;
	struct delayed_work tx_work;
	struct netpoll *netpoll;
	struct callback_head rcu;
};

struct udp_tunnel_info {
	short unsigned int type;
	sa_family_t sa_family;
	__be16 port;
};

struct in_ifaddr;

struct ip_mc_list;

struct in_device {
	struct net_device *dev;
	refcount_t refcnt;
	int dead;
	struct in_ifaddr *ifa_list;
	struct ip_mc_list *mc_list;
	struct ip_mc_list **mc_hash;
	int mc_count;
	spinlock_t mc_tomb_lock;
	struct ip_mc_list *mc_tomb;
	long unsigned int mr_v1_seen;
	long unsigned int mr_v2_seen;
	long unsigned int mr_maxdelay;
	long unsigned int mr_qi;
	long unsigned int mr_qri;
	unsigned char mr_qrv;
	unsigned char mr_gq_running;
	unsigned char mr_ifc_count;
	struct timer_list mr_gq_timer;
	struct timer_list mr_ifc_timer;
	struct neigh_parms *arp_parms;
	struct ipv4_devconf cnf;
	struct callback_head callback_head;
};

struct offload_callbacks {
	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sk_buff *, int);
};

struct packet_offload {
	__be16 type;
	u16 priority;
	struct offload_callbacks callbacks;
	struct list_head list;
};

struct netdev_notifier_info_ext {
	struct netdev_notifier_info info;
	union {
		u32 mtu;
	} ext;
};

struct netdev_notifier_change_info {
	struct netdev_notifier_info info;
	unsigned int flags_changed;
};

struct netdev_notifier_changeupper_info {
	struct netdev_notifier_info info;
	struct net_device *upper_dev;
	bool master;
	bool linking;
	void *upper_info;
};

struct netdev_notifier_changelowerstate_info {
	struct netdev_notifier_info info;
	void *lower_state_info;
};

struct netdev_notifier_pre_changeaddr_info {
	struct netdev_notifier_info info;
	const unsigned char *dev_addr;
};

typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);

struct netdev_bonding_info {
	ifslave slave;
	ifbond master;
};

struct netdev_notifier_bonding_info {
	struct netdev_notifier_info info;
	struct netdev_bonding_info bonding_info;
};

union inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

struct netpoll {
	struct net_device *dev;
	char dev_name[16];
	const char *name;
	union inet_addr local_ip;
	union inet_addr remote_ip;
	bool ipv6;
	u16 local_port;
	u16 remote_port;
	u8 remote_mac[6];
};

enum qdisc_state_t {
	__QDISC_STATE_SCHED = 0,
	__QDISC_STATE_DEACTIVATED = 1,
};

struct tcf_walker {
	int stop;
	int skip;
	int count;
	bool nonempty;
	long unsigned int cookie;
	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
};

struct udp_hslot;

struct udp_table {
	struct udp_hslot *hash;
	struct udp_hslot *hash2;
	unsigned int mask;
	unsigned int log;
};

enum {
	IPV4_DEVCONF_FORWARDING = 1,
	IPV4_DEVCONF_MC_FORWARDING = 2,
	IPV4_DEVCONF_PROXY_ARP = 3,
	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
	IPV4_DEVCONF_SEND_REDIRECTS = 6,
	IPV4_DEVCONF_SHARED_MEDIA = 7,
	IPV4_DEVCONF_RP_FILTER = 8,
	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
	IPV4_DEVCONF_BOOTP_RELAY = 10,
	IPV4_DEVCONF_LOG_MARTIANS = 11,
	IPV4_DEVCONF_TAG = 12,
	IPV4_DEVCONF_ARPFILTER = 13,
	IPV4_DEVCONF_MEDIUM_ID = 14,
	IPV4_DEVCONF_NOXFRM = 15,
	IPV4_DEVCONF_NOPOLICY = 16,
	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
	IPV4_DEVCONF_ARP_IGNORE = 19,
	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
	IPV4_DEVCONF_ARP_ACCEPT = 21,
	IPV4_DEVCONF_ARP_NOTIFY = 22,
	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
	IPV4_DEVCONF_SRC_VMARK = 24,
	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
	IPV4_DEVCONF_BC_FORWARDING = 32,
	__IPV4_DEVCONF_MAX = 33,
};

struct in_ifaddr {
	struct hlist_node hash;
	struct in_ifaddr *ifa_next;
	struct in_device *ifa_dev;
	struct callback_head callback_head;
	__be32 ifa_local;
	__be32 ifa_address;
	__be32 ifa_mask;
	__u32 ifa_rt_priority;
	__be32 ifa_broadcast;
	unsigned char ifa_scope;
	unsigned char ifa_prefixlen;
	__u32 ifa_flags;
	char ifa_label[16];
	__u32 ifa_valid_lft;
	__u32 ifa_preferred_lft;
	long unsigned int ifa_cstamp;
	long unsigned int ifa_tstamp;
};

struct udp_hslot {
	struct hlist_head head;
	int count;
	spinlock_t lock;
};

struct dev_kfree_skb_cb {
	enum skb_free_reason reason;
};

struct netdev_adjacent {
	struct net_device *dev;
	bool master;
	bool ignore;
	u16 ref_nr;
	void *private;
	struct list_head list;
	struct callback_head rcu;
};

typedef struct sk_buff *pto_T_____31;

typedef __u32 pao_T_____8;

typedef u16 pao_T_____9;

struct ethtool_value {
	__u32 cmd;
	__u32 data;
};

enum tunable_id {
	ETHTOOL_ID_UNSPEC = 0,
	ETHTOOL_RX_COPYBREAK = 1,
	ETHTOOL_TX_COPYBREAK = 2,
	ETHTOOL_PFC_PREVENTION_TOUT = 3,
	__ETHTOOL_TUNABLE_COUNT = 4,
};

enum tunable_type_id {
	ETHTOOL_TUNABLE_UNSPEC = 0,
	ETHTOOL_TUNABLE_U8 = 1,
	ETHTOOL_TUNABLE_U16 = 2,
	ETHTOOL_TUNABLE_U32 = 3,
	ETHTOOL_TUNABLE_U64 = 4,
	ETHTOOL_TUNABLE_STRING = 5,
	ETHTOOL_TUNABLE_S8 = 6,
	ETHTOOL_TUNABLE_S16 = 7,
	ETHTOOL_TUNABLE_S32 = 8,
	ETHTOOL_TUNABLE_S64 = 9,
};

enum phy_tunable_id {
	ETHTOOL_PHY_ID_UNSPEC = 0,
	ETHTOOL_PHY_DOWNSHIFT = 1,
	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
	ETHTOOL_PHY_EDPD = 3,
	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
};

enum ethtool_stringset {
	ETH_SS_TEST = 0,
	ETH_SS_STATS = 1,
	ETH_SS_PRIV_FLAGS = 2,
	ETH_SS_NTUPLE_FILTERS = 3,
	ETH_SS_FEATURES = 4,
	ETH_SS_RSS_HASH_FUNCS = 5,
	ETH_SS_TUNABLES = 6,
	ETH_SS_PHY_STATS = 7,
	ETH_SS_PHY_TUNABLES = 8,
};

struct ethtool_gstrings {
	__u32 cmd;
	__u32 string_set;
	__u32 len;
	__u8 data[0];
};

struct ethtool_sset_info {
	__u32 cmd;
	__u32 reserved;
	__u64 sset_mask;
	__u32 data[0];
};

struct ethtool_perm_addr {
	__u32 cmd;
	__u32 size;
	__u8 data[0];
};

enum ethtool_flags {
	ETH_FLAG_TXVLAN = 128,
	ETH_FLAG_RXVLAN = 256,
	ETH_FLAG_LRO = 32768,
	ETH_FLAG_NTUPLE = 134217728,
	ETH_FLAG_RXHASH = 268435456,
};

struct ethtool_rxfh {
	__u32 cmd;
	__u32 rss_context;
	__u32 indir_size;
	__u32 key_size;
	__u8 hfunc;
	__u8 rsvd8[3];
	__u32 rsvd32;
	__u32 rss_config[0];
};

struct ethtool_get_features_block {
	__u32 available;
	__u32 requested;
	__u32 active;
	__u32 never_changed;
};

struct ethtool_gfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_get_features_block features[0];
};

struct ethtool_set_features_block {
	__u32 valid;
	__u32 requested;
};

struct ethtool_sfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_set_features_block features[0];
};

enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT = 0,
	ETHTOOL_F_WISH__BIT = 1,
	ETHTOOL_F_COMPAT__BIT = 2,
};

struct ethtool_per_queue_op {
	__u32 cmd;
	__u32 sub_command;
	__u32 queue_mask[128];
	char data[0];
};

enum {
	ETH_RSS_HASH_TOP_BIT = 0,
	ETH_RSS_HASH_XOR_BIT = 1,
	ETH_RSS_HASH_CRC32_BIT = 2,
	ETH_RSS_HASH_FUNCS_COUNT = 3,
};

struct flow_rule;

struct ethtool_rx_flow_rule {
	struct flow_rule *rule;
	long unsigned int priv[0];
};

struct flow_match {
	struct flow_dissector *dissector;
	void *mask;
	void *key;
};

enum flow_action_id {
	FLOW_ACTION_ACCEPT = 0,
	FLOW_ACTION_DROP = 1,
	FLOW_ACTION_TRAP = 2,
	FLOW_ACTION_GOTO = 3,
	FLOW_ACTION_REDIRECT = 4,
	FLOW_ACTION_MIRRED = 5,
	FLOW_ACTION_REDIRECT_INGRESS = 6,
	FLOW_ACTION_MIRRED_INGRESS = 7,
	FLOW_ACTION_VLAN_PUSH = 8,
	FLOW_ACTION_VLAN_POP = 9,
	FLOW_ACTION_VLAN_MANGLE = 10,
	FLOW_ACTION_TUNNEL_ENCAP = 11,
	FLOW_ACTION_TUNNEL_DECAP = 12,
	FLOW_ACTION_MANGLE = 13,
	FLOW_ACTION_ADD = 14,
	FLOW_ACTION_CSUM = 15,
	FLOW_ACTION_MARK = 16,
	FLOW_ACTION_PTYPE = 17,
	FLOW_ACTION_WAKE = 18,
	FLOW_ACTION_QUEUE = 19,
	FLOW_ACTION_SAMPLE = 20,
	FLOW_ACTION_POLICE = 21,
	FLOW_ACTION_CT = 22,
	FLOW_ACTION_MPLS_PUSH = 23,
	FLOW_ACTION_MPLS_POP = 24,
	FLOW_ACTION_MPLS_MANGLE = 25,
	NUM_FLOW_ACTIONS = 26,
};

typedef void (*action_destr)(void *);

enum flow_action_mangle_base {
	FLOW_ACT_MANGLE_UNSPEC = 0,
	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
};

struct psample_group;

struct flow_action_entry {
	enum flow_action_id id;
	action_destr destructor;
	void *destructor_priv;
	union {
		u32 chain_index;
		struct net_device *dev;
		struct {
			u16 vid;
			__be16 proto;
			u8 prio;
		} vlan;
		struct {
			enum flow_action_mangle_base htype;
			u32 offset;
			u32 mask;
			u32 val;
		} mangle;
		struct ip_tunnel_info *tunnel;
		u32 csum_flags;
		u32 mark;
		u16 ptype;
		struct {
			u32 ctx;
			u32 index;
			u8 vf;
		} queue;
		struct {
			struct psample_group *psample_group;
			u32 rate;
			u32 trunc_size;
			bool truncate;
		} sample;
		struct {
			s64 burst;
			u64 rate_bytes_ps;
		} police;
		struct {
			int action;
			u16 zone;
		} ct;
		struct {
			u32 label;
			__be16 proto;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_push;
		struct {
			__be16 proto;
		} mpls_pop;
		struct {
			u32 label;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_mangle;
	};
};

struct flow_action {
	unsigned int num_entries;
	struct flow_action_entry entries[0];
};

struct flow_rule {
	struct flow_match match;
	struct flow_action action;
};

struct ethtool_rx_flow_spec_input {
	const struct ethtool_rx_flow_spec *fs;
	u32 rss_ctx;
};

struct ethtool_link_usettings {
	struct ethtool_link_settings base;
	struct {
		__u32 supported[3];
		__u32 advertising[3];
		__u32 lp_advertising[3];
	} link_modes;
};

struct ethtool_rx_flow_key {
	struct flow_dissector_key_basic basic;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
	long: 48;
};

struct ethtool_rx_flow_match {
	struct flow_dissector dissector;
	int: 32;
	struct ethtool_rx_flow_key key;
	struct ethtool_rx_flow_key mask;
};

enum {
	NDA_UNSPEC = 0,
	NDA_DST = 1,
	NDA_LLADDR = 2,
	NDA_CACHEINFO = 3,
	NDA_PROBES = 4,
	NDA_VLAN = 5,
	NDA_PORT = 6,
	NDA_VNI = 7,
	NDA_IFINDEX = 8,
	NDA_MASTER = 9,
	NDA_LINK_NETNSID = 10,
	NDA_SRC_VNI = 11,
	NDA_PROTOCOL = 12,
	__NDA_MAX = 13,
};

struct nda_cacheinfo {
	__u32 ndm_confirmed;
	__u32 ndm_used;
	__u32 ndm_updated;
	__u32 ndm_refcnt;
};

struct ndt_stats {
	__u64 ndts_allocs;
	__u64 ndts_destroys;
	__u64 ndts_hash_grows;
	__u64 ndts_res_failed;
	__u64 ndts_lookups;
	__u64 ndts_hits;
	__u64 ndts_rcv_probes_mcast;
	__u64 ndts_rcv_probes_ucast;
	__u64 ndts_periodic_gc_runs;
	__u64 ndts_forced_gc_runs;
	__u64 ndts_table_fulls;
};

enum {
	NDTPA_UNSPEC = 0,
	NDTPA_IFINDEX = 1,
	NDTPA_REFCNT = 2,
	NDTPA_REACHABLE_TIME = 3,
	NDTPA_BASE_REACHABLE_TIME = 4,
	NDTPA_RETRANS_TIME = 5,
	NDTPA_GC_STALETIME = 6,
	NDTPA_DELAY_PROBE_TIME = 7,
	NDTPA_QUEUE_LEN = 8,
	NDTPA_APP_PROBES = 9,
	NDTPA_UCAST_PROBES = 10,
	NDTPA_MCAST_PROBES = 11,
	NDTPA_ANYCAST_DELAY = 12,
	NDTPA_PROXY_DELAY = 13,
	NDTPA_PROXY_QLEN = 14,
	NDTPA_LOCKTIME = 15,
	NDTPA_QUEUE_LENBYTES = 16,
	NDTPA_MCAST_REPROBES = 17,
	NDTPA_PAD = 18,
	__NDTPA_MAX = 19,
};

struct ndtmsg {
	__u8 ndtm_family;
	__u8 ndtm_pad1;
	__u16 ndtm_pad2;
};

struct ndt_config {
	__u16 ndtc_key_len;
	__u16 ndtc_entry_size;
	__u32 ndtc_entries;
	__u32 ndtc_last_flush;
	__u32 ndtc_last_rand;
	__u32 ndtc_hash_rnd;
	__u32 ndtc_hash_mask;
	__u32 ndtc_hash_chain_gc;
	__u32 ndtc_proxy_qlen;
};

enum {
	NDTA_UNSPEC = 0,
	NDTA_NAME = 1,
	NDTA_THRESH1 = 2,
	NDTA_THRESH2 = 3,
	NDTA_THRESH3 = 4,
	NDTA_CONFIG = 5,
	NDTA_PARMS = 6,
	NDTA_STATS = 7,
	NDTA_GC_INTERVAL = 8,
	NDTA_PAD = 9,
	__NDTA_MAX = 10,
};

enum {
	RTN_UNSPEC = 0,
	RTN_UNICAST = 1,
	RTN_LOCAL = 2,
	RTN_BROADCAST = 3,
	RTN_ANYCAST = 4,
	RTN_MULTICAST = 5,
	RTN_BLACKHOLE = 6,
	RTN_UNREACHABLE = 7,
	RTN_PROHIBIT = 8,
	RTN_THROW = 9,
	RTN_NAT = 10,
	RTN_XRESOLVE = 11,
	__RTN_MAX = 12,
};

enum {
	NEIGH_ARP_TABLE = 0,
	NEIGH_ND_TABLE = 1,
	NEIGH_DN_TABLE = 2,
	NEIGH_NR_TABLES = 3,
	NEIGH_LINK_TABLE = 3,
};

struct neigh_seq_state {
	struct seq_net_private p;
	struct neigh_table *tbl;
	struct neigh_hash_table *nht;
	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
	unsigned int bucket;
	unsigned int flags;
};

struct neighbour_cb {
	long unsigned int sched_next;
	unsigned int flags;
};

enum netevent_notif_type {
	NETEVENT_NEIGH_UPDATE = 1,
	NETEVENT_REDIRECT = 2,
	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
};

struct neigh_dump_filter {
	int master_idx;
	int dev_idx;
};

struct neigh_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table neigh_vars[21];
};

struct netlink_dump_control {
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module___2 *module;
	u16 min_dump_alloc;
};

struct rtnl_link_stats {
	__u32 rx_packets;
	__u32 tx_packets;
	__u32 rx_bytes;
	__u32 tx_bytes;
	__u32 rx_errors;
	__u32 tx_errors;
	__u32 rx_dropped;
	__u32 tx_dropped;
	__u32 multicast;
	__u32 collisions;
	__u32 rx_length_errors;
	__u32 rx_over_errors;
	__u32 rx_crc_errors;
	__u32 rx_frame_errors;
	__u32 rx_fifo_errors;
	__u32 rx_missed_errors;
	__u32 tx_aborted_errors;
	__u32 tx_carrier_errors;
	__u32 tx_fifo_errors;
	__u32 tx_heartbeat_errors;
	__u32 tx_window_errors;
	__u32 rx_compressed;
	__u32 tx_compressed;
	__u32 rx_nohandler;
};

struct rtnl_link_ifmap {
	__u64 mem_start;
	__u64 mem_end;
	__u64 base_addr;
	__u16 irq;
	__u8 dma;
	__u8 port;
};

enum {
	IFLA_UNSPEC = 0,
	IFLA_ADDRESS = 1,
	IFLA_BROADCAST = 2,
	IFLA_IFNAME = 3,
	IFLA_MTU = 4,
	IFLA_LINK = 5,
	IFLA_QDISC = 6,
	IFLA_STATS = 7,
	IFLA_COST = 8,
	IFLA_PRIORITY = 9,
	IFLA_MASTER = 10,
	IFLA_WIRELESS = 11,
	IFLA_PROTINFO = 12,
	IFLA_TXQLEN = 13,
	IFLA_MAP = 14,
	IFLA_WEIGHT = 15,
	IFLA_OPERSTATE = 16,
	IFLA_LINKMODE = 17,
	IFLA_LINKINFO = 18,
	IFLA_NET_NS_PID = 19,
	IFLA_IFALIAS = 20,
	IFLA_NUM_VF = 21,
	IFLA_VFINFO_LIST = 22,
	IFLA_STATS64 = 23,
	IFLA_VF_PORTS = 24,
	IFLA_PORT_SELF = 25,
	IFLA_AF_SPEC = 26,
	IFLA_GROUP = 27,
	IFLA_NET_NS_FD = 28,
	IFLA_EXT_MASK = 29,
	IFLA_PROMISCUITY = 30,
	IFLA_NUM_TX_QUEUES = 31,
	IFLA_NUM_RX_QUEUES = 32,
	IFLA_CARRIER = 33,
	IFLA_PHYS_PORT_ID = 34,
	IFLA_CARRIER_CHANGES = 35,
	IFLA_PHYS_SWITCH_ID = 36,
	IFLA_LINK_NETNSID = 37,
	IFLA_PHYS_PORT_NAME = 38,
	IFLA_PROTO_DOWN = 39,
	IFLA_GSO_MAX_SEGS = 40,
	IFLA_GSO_MAX_SIZE = 41,
	IFLA_PAD = 42,
	IFLA_XDP = 43,
	IFLA_EVENT = 44,
	IFLA_NEW_NETNSID = 45,
	IFLA_IF_NETNSID = 46,
	IFLA_TARGET_NETNSID = 46,
	IFLA_CARRIER_UP_COUNT = 47,
	IFLA_CARRIER_DOWN_COUNT = 48,
	IFLA_NEW_IFINDEX = 49,
	IFLA_MIN_MTU = 50,
	IFLA_MAX_MTU = 51,
	__IFLA_MAX = 52,
};

enum {
	IFLA_BRPORT_UNSPEC = 0,
	IFLA_BRPORT_STATE = 1,
	IFLA_BRPORT_PRIORITY = 2,
	IFLA_BRPORT_COST = 3,
	IFLA_BRPORT_MODE = 4,
	IFLA_BRPORT_GUARD = 5,
	IFLA_BRPORT_PROTECT = 6,
	IFLA_BRPORT_FAST_LEAVE = 7,
	IFLA_BRPORT_LEARNING = 8,
	IFLA_BRPORT_UNICAST_FLOOD = 9,
	IFLA_BRPORT_PROXYARP = 10,
	IFLA_BRPORT_LEARNING_SYNC = 11,
	IFLA_BRPORT_PROXYARP_WIFI = 12,
	IFLA_BRPORT_ROOT_ID = 13,
	IFLA_BRPORT_BRIDGE_ID = 14,
	IFLA_BRPORT_DESIGNATED_PORT = 15,
	IFLA_BRPORT_DESIGNATED_COST = 16,
	IFLA_BRPORT_ID = 17,
	IFLA_BRPORT_NO = 18,
	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
	IFLA_BRPORT_CONFIG_PENDING = 20,
	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
	IFLA_BRPORT_HOLD_TIMER = 23,
	IFLA_BRPORT_FLUSH = 24,
	IFLA_BRPORT_MULTICAST_ROUTER = 25,
	IFLA_BRPORT_PAD = 26,
	IFLA_BRPORT_MCAST_FLOOD = 27,
	IFLA_BRPORT_MCAST_TO_UCAST = 28,
	IFLA_BRPORT_VLAN_TUNNEL = 29,
	IFLA_BRPORT_BCAST_FLOOD = 30,
	IFLA_BRPORT_GROUP_FWD_MASK = 31,
	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
	IFLA_BRPORT_ISOLATED = 33,
	IFLA_BRPORT_BACKUP_PORT = 34,
	__IFLA_BRPORT_MAX = 35,
};

enum {
	IFLA_INFO_UNSPEC = 0,
	IFLA_INFO_KIND = 1,
	IFLA_INFO_DATA = 2,
	IFLA_INFO_XSTATS = 3,
	IFLA_INFO_SLAVE_KIND = 4,
	IFLA_INFO_SLAVE_DATA = 5,
	__IFLA_INFO_MAX = 6,
};

enum {
	IFLA_VF_INFO_UNSPEC = 0,
	IFLA_VF_INFO = 1,
	__IFLA_VF_INFO_MAX = 2,
};

enum {
	IFLA_VF_UNSPEC = 0,
	IFLA_VF_MAC = 1,
	IFLA_VF_VLAN = 2,
	IFLA_VF_TX_RATE = 3,
	IFLA_VF_SPOOFCHK = 4,
	IFLA_VF_LINK_STATE = 5,
	IFLA_VF_RATE = 6,
	IFLA_VF_RSS_QUERY_EN = 7,
	IFLA_VF_STATS = 8,
	IFLA_VF_TRUST = 9,
	IFLA_VF_IB_NODE_GUID = 10,
	IFLA_VF_IB_PORT_GUID = 11,
	IFLA_VF_VLAN_LIST = 12,
	IFLA_VF_BROADCAST = 13,
	__IFLA_VF_MAX = 14,
};

struct ifla_vf_mac {
	__u32 vf;
	__u8 mac[32];
};

struct ifla_vf_broadcast {
	__u8 broadcast[32];
};

struct ifla_vf_vlan {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
};

enum {
	IFLA_VF_VLAN_INFO_UNSPEC = 0,
	IFLA_VF_VLAN_INFO = 1,
	__IFLA_VF_VLAN_INFO_MAX = 2,
};

struct ifla_vf_vlan_info {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
	__be16 vlan_proto;
};

struct ifla_vf_tx_rate {
	__u32 vf;
	__u32 rate;
};

struct ifla_vf_rate {
	__u32 vf;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
};

struct ifla_vf_spoofchk {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_guid {
	__u32 vf;
	__u64 guid;
};

struct ifla_vf_link_state {
	__u32 vf;
	__u32 link_state;
};

struct ifla_vf_rss_query_en {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_STATS_RX_PACKETS = 0,
	IFLA_VF_STATS_TX_PACKETS = 1,
	IFLA_VF_STATS_RX_BYTES = 2,
	IFLA_VF_STATS_TX_BYTES = 3,
	IFLA_VF_STATS_BROADCAST = 4,
	IFLA_VF_STATS_MULTICAST = 5,
	IFLA_VF_STATS_PAD = 6,
	IFLA_VF_STATS_RX_DROPPED = 7,
	IFLA_VF_STATS_TX_DROPPED = 8,
	__IFLA_VF_STATS_MAX = 9,
};

struct ifla_vf_trust {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_PORT_UNSPEC = 0,
	IFLA_VF_PORT = 1,
	__IFLA_VF_PORT_MAX = 2,
};

enum {
	IFLA_PORT_UNSPEC = 0,
	IFLA_PORT_VF = 1,
	IFLA_PORT_PROFILE = 2,
	IFLA_PORT_VSI_TYPE = 3,
	IFLA_PORT_INSTANCE_UUID = 4,
	IFLA_PORT_HOST_UUID = 5,
	IFLA_PORT_REQUEST = 6,
	IFLA_PORT_RESPONSE = 7,
	__IFLA_PORT_MAX = 8,
};

struct if_stats_msg {
	__u8 family;
	__u8 pad1;
	__u16 pad2;
	__u32 ifindex;
	__u32 filter_mask;
};

enum {
	IFLA_STATS_UNSPEC = 0,
	IFLA_STATS_LINK_64 = 1,
	IFLA_STATS_LINK_XSTATS = 2,
	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
	IFLA_STATS_AF_SPEC = 5,
	__IFLA_STATS_MAX = 6,
};

enum {
	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
	__IFLA_OFFLOAD_XSTATS_MAX = 2,
};

enum {
	XDP_ATTACHED_NONE = 0,
	XDP_ATTACHED_DRV = 1,
	XDP_ATTACHED_SKB = 2,
	XDP_ATTACHED_HW = 3,
	XDP_ATTACHED_MULTI = 4,
};

enum {
	IFLA_XDP_UNSPEC = 0,
	IFLA_XDP_FD = 1,
	IFLA_XDP_ATTACHED = 2,
	IFLA_XDP_FLAGS = 3,
	IFLA_XDP_PROG_ID = 4,
	IFLA_XDP_DRV_PROG_ID = 5,
	IFLA_XDP_SKB_PROG_ID = 6,
	IFLA_XDP_HW_PROG_ID = 7,
	__IFLA_XDP_MAX = 8,
};

enum {
	IFLA_EVENT_NONE = 0,
	IFLA_EVENT_REBOOT = 1,
	IFLA_EVENT_FEATURES = 2,
	IFLA_EVENT_BONDING_FAILOVER = 3,
	IFLA_EVENT_NOTIFY_PEERS = 4,
	IFLA_EVENT_IGMP_RESEND = 5,
	IFLA_EVENT_BONDING_OPTIONS = 6,
};

enum {
	IFLA_BRIDGE_FLAGS = 0,
	IFLA_BRIDGE_MODE = 1,
	IFLA_BRIDGE_VLAN_INFO = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
	__IFLA_BRIDGE_MAX = 4,
};

enum {
	BR_MCAST_DIR_RX = 0,
	BR_MCAST_DIR_TX = 1,
	BR_MCAST_DIR_SIZE = 2,
};

enum rtattr_type_t {
	RTA_UNSPEC = 0,
	RTA_DST = 1,
	RTA_SRC = 2,
	RTA_IIF = 3,
	RTA_OIF = 4,
	RTA_GATEWAY = 5,
	RTA_PRIORITY = 6,
	RTA_PREFSRC = 7,
	RTA_METRICS = 8,
	RTA_MULTIPATH = 9,
	RTA_PROTOINFO = 10,
	RTA_FLOW = 11,
	RTA_CACHEINFO = 12,
	RTA_SESSION = 13,
	RTA_MP_ALGO = 14,
	RTA_TABLE = 15,
	RTA_MARK = 16,
	RTA_MFC_STATS = 17,
	RTA_VIA = 18,
	RTA_NEWDST = 19,
	RTA_PREF = 20,
	RTA_ENCAP_TYPE = 21,
	RTA_ENCAP = 22,
	RTA_EXPIRES = 23,
	RTA_PAD = 24,
	RTA_UID = 25,
	RTA_TTL_PROPAGATE = 26,
	RTA_IP_PROTO = 27,
	RTA_SPORT = 28,
	RTA_DPORT = 29,
	RTA_NH_ID = 30,
	__RTA_MAX = 31,
};

struct rta_cacheinfo {
	__u32 rta_clntref;
	__u32 rta_lastuse;
	__s32 rta_expires;
	__u32 rta_error;
	__u32 rta_used;
	__u32 rta_id;
	__u32 rta_ts;
	__u32 rta_tsage;
};

struct ifinfomsg {
	unsigned char ifi_family;
	unsigned char __ifi_pad;
	short unsigned int ifi_type;
	int ifi_index;
	unsigned int ifi_flags;
	unsigned int ifi_change;
};

struct rtnl_af_ops {
	struct list_head list;
	int family;
	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
	size_t (*get_link_af_size)(const struct net_device *, u32);
	int (*validate_link_af)(const struct net_device *, const struct nlattr *);
	int (*set_link_af)(struct net_device *, const struct nlattr *);
	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
	size_t (*get_stats_af_size)(const struct net_device *);
};

struct rtnl_link {
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	struct module___2 *owner;
	unsigned int flags;
	struct callback_head rcu;
};

enum {
	IF_LINK_MODE_DEFAULT = 0,
	IF_LINK_MODE_DORMANT = 1,
};

enum lw_bits {
	LW_URGENT = 0,
};

struct seg6_pernet_data {
	struct mutex lock;
	struct in6_addr *tun_src;
};

enum {
	BPF_F_RECOMPUTE_CSUM = 1,
	BPF_F_INVALIDATE_HASH = 2,
};

enum {
	BPF_F_HDR_FIELD_MASK = 15,
};

enum {
	BPF_F_PSEUDO_HDR = 16,
	BPF_F_MARK_MANGLED_0 = 32,
	BPF_F_MARK_ENFORCE = 64,
};

enum {
	BPF_F_INGRESS = 1,
};

enum {
	BPF_F_TUNINFO_IPV6 = 1,
};

enum {
	BPF_F_ZERO_CSUM_TX = 2,
	BPF_F_DONT_FRAGMENT = 4,
	BPF_F_SEQ_NUMBER = 8,
};

enum {
	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
};

enum {
	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
};

enum {
	BPF_SK_LOOKUP_F_REPLACE = 1,
	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
};

enum bpf_adj_room_mode {
	BPF_ADJ_ROOM_NET = 0,
	BPF_ADJ_ROOM_MAC = 1,
};

enum bpf_hdr_start_off {
	BPF_HDR_START_MAC = 0,
	BPF_HDR_START_NET = 1,
};

enum bpf_lwt_encap_mode {
	BPF_LWT_ENCAP_SEG6 = 0,
	BPF_LWT_ENCAP_SEG6_INLINE = 1,
	BPF_LWT_ENCAP_IP = 2,
};

struct bpf_tunnel_key {
	__u32 tunnel_id;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
	__u8 tunnel_tos;
	__u8 tunnel_ttl;
	__u16 tunnel_ext;
	__u32 tunnel_label;
};

struct bpf_xfrm_state {
	__u32 reqid;
	__u32 spi;
	__u16 family;
	__u16 ext;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
};

struct bpf_tcp_sock {
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u64 bytes_received;
	__u64 bytes_acked;
	__u32 dsack_dups;
	__u32 delivered;
	__u32 delivered_ce;
	__u32 icsk_retransmits;
};

struct bpf_sock_tuple {
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
			__be16 sport;
			__be16 dport;
		} ipv4;
		struct {
			__be32 saddr[4];
			__be32 daddr[4];
			__be16 sport;
			__be16 dport;
		} ipv6;
	};
};

struct bpf_xdp_sock {
	__u32 queue_id;
};

enum {
	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
	BPF_SOCK_OPS_TW_CLOSE_FLAG = 16,
	BPF_SOCK_OPS_ALL_CB_FLAGS = 31,
};

enum {
	BPF_SOCK_OPS_VOID = 0,
	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
	BPF_SOCK_OPS_RWND_INIT = 2,
	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
	BPF_SOCK_OPS_NEEDS_ECN = 6,
	BPF_SOCK_OPS_BASE_RTT = 7,
	BPF_SOCK_OPS_RTO_CB = 8,
	BPF_SOCK_OPS_RETRANS_CB = 9,
	BPF_SOCK_OPS_STATE_CB = 10,
	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
	BPF_SOCK_OPS_RTT_CB = 12,
};

enum {
	TCP_BPF_IW = 1001,
	TCP_BPF_SNDCWND_CLAMP = 1002,
};

enum {
	BPF_FIB_LOOKUP_DIRECT = 1,
	BPF_FIB_LOOKUP_OUTPUT = 2,
};

enum {
	BPF_FIB_LKUP_RET_SUCCESS = 0,
	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
	BPF_FIB_LKUP_RET_PROHIBIT = 3,
	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
};

struct bpf_fib_lookup {
	__u8 family;
	__u8 l4_protocol;
	__be16 sport;
	__be16 dport;
	__u16 tot_len;
	__u32 ifindex;
	union {
		__u8 tos;
		__be32 flowinfo;
		__u32 rt_metric;
	};
	union {
		__be32 ipv4_src;
		__u32 ipv6_src[4];
	};
	union {
		__be32 ipv4_dst;
		__u32 ipv6_dst[4];
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__u8 smac[6];
	__u8 dmac[6];
};

struct bpf_redir_neigh {
	__u32 nh_family;
	union {
		__be32 ipv4_nh;
		__u32 ipv6_nh[4];
	};
};

enum rt_scope_t {
	RT_SCOPE_UNIVERSE = 0,
	RT_SCOPE_SITE = 200,
	RT_SCOPE_LINK = 253,
	RT_SCOPE_HOST = 254,
	RT_SCOPE_NOWHERE = 255,
};

enum rt_class_t {
	RT_TABLE_UNSPEC = 0,
	RT_TABLE_COMPAT = 252,
	RT_TABLE_DEFAULT = 253,
	RT_TABLE_MAIN = 254,
	RT_TABLE_LOCAL = 255,
	RT_TABLE_MAX = 4294967295,
};

struct nl_info {
	struct nlmsghdr *nlh;
	struct net___2 *nl_net;
	u32 portid;
	u8 skip_notify: 1;
	u8 skip_notify_kernel: 1;
};

struct bpf_nh_params {
	u32 nh_family;
	union {
		u32 ipv4_nh;
		struct in6_addr ipv6_nh;
	};
};

struct bpf_redirect_info {
	u32 flags;
	u32 tgt_index;
	void *tgt_value;
	struct bpf_map *map;
	struct bpf_map *map_to_flush;
	u32 kern_flags;
	struct bpf_nh_params nh;
};

struct udp_sock {
	struct inet_sock inet;
	int pending;
	unsigned int corkflag;
	__u8 encap_type;
	unsigned char no_check6_tx: 1;
	unsigned char no_check6_rx: 1;
	unsigned char encap_enabled: 1;
	unsigned char gro_enabled: 1;
	__u16 len;
	__u16 gso_size;
	__u16 pcslen;
	__u16 pcrlen;
	__u8 pcflag;
	__u8 unused[3];
	int (*encap_rcv)(struct sock *, struct sk_buff *);
	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
	void (*encap_destroy)(struct sock *);
	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sock *, struct sk_buff *, int);
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head reader_queue;
	int forward_deficit;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct udp6_sock {
	struct udp_sock udp;
	struct ipv6_pinfo inet6;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcp6_sock {
	struct tcp_sock tcp;
	struct ipv6_pinfo inet6;
};

struct fib6_result;

struct fib6_config;

struct ipv6_stub {
	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net___2 *, const struct sock *, struct flowi6 *, const struct in6_addr *);
	int (*ipv6_route_input)(struct sk_buff *);
	struct fib6_table * (*fib6_get_table)(struct net___2 *, u32);
	int (*fib6_lookup)(struct net___2 *, int, struct flowi6 *, struct fib6_result *, int);
	int (*fib6_table_lookup)(struct net___2 *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
	void (*fib6_select_path)(const struct net___2 *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
	int (*fib6_nh_init)(struct net___2 *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
	void (*fib6_nh_release)(struct fib6_nh *);
	void (*fib6_update_sernum)(struct net___2 *, struct fib6_info *);
	int (*ip6_del_rt)(struct net___2 *, struct fib6_info *);
	void (*fib6_rt_update)(struct net___2 *, struct fib6_info *, struct nl_info *);
	void (*udpv6_encap_enable)();
	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
	struct neigh_table *nd_tbl;
};

struct fib6_result {
	struct fib6_nh *nh;
	struct fib6_info *f6i;
	u32 fib6_flags;
	u8 fib6_type;
	struct rt6_info *rt6;
};

struct fib6_config {
	u32 fc_table;
	u32 fc_metric;
	int fc_dst_len;
	int fc_src_len;
	int fc_ifindex;
	u32 fc_flags;
	u32 fc_protocol;
	u16 fc_type;
	u16 fc_delete_all_nh: 1;
	u16 fc_ignore_dev_down: 1;
	u16 __unused: 14;
	u32 fc_nh_id;
	struct in6_addr fc_dst;
	struct in6_addr fc_src;
	struct in6_addr fc_prefsrc;
	struct in6_addr fc_gateway;
	long unsigned int fc_expires;
	struct nlattr *fc_mx;
	int fc_mx_len;
	int fc_mp_len;
	struct nlattr *fc_mp;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct ipv6_bpf_stub {
	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
	struct sock * (*udp6_lib_lookup)(struct net___2 *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
};

struct fib_result {
	__be32 prefix;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	u32 tclassid;
	struct fib_nh_common *nhc;
	struct fib_info *fi;
	struct fib_table *table;
	struct hlist_head *fa_head;
};

enum {
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,
	INET_ECN_CE = 3,
	INET_ECN_MASK = 3,
};

struct tcp_skb_cb {
	__u32 seq;
	__u32 end_seq;
	union {
		__u32 tcp_tw_isn;
		struct {
			u16 tcp_gso_segs;
			u16 tcp_gso_size;
		};
	};
	__u8 tcp_flags;
	__u8 sacked;
	__u8 ip_dsfield;
	__u8 txstamp_ack: 1;
	__u8 eor: 1;
	__u8 has_rxtstamp: 1;
	__u8 unused: 5;
	__u32 ack_seq;
	union {
		struct {
			__u32 in_flight: 30;
			__u32 is_app_limited: 1;
			__u32 unused: 1;
			__u32 delivered;
			u64 first_tx_mstamp;
			u64 delivered_mstamp;
		} tx;
		union {
			struct inet_skb_parm h4;
			struct inet6_skb_parm h6;
		} header;
		struct {
			__u32 flags;
			struct sock *sk_redir;
			void *data_end;
		} bpf;
	};
};

struct _bpf_dtab_netdev {
	struct net_device *dev;
};

enum {
	BTF_SOCK_TYPE_INET = 0,
	BTF_SOCK_TYPE_INET_CONN = 1,
	BTF_SOCK_TYPE_INET_REQ = 2,
	BTF_SOCK_TYPE_INET_TW = 3,
	BTF_SOCK_TYPE_REQ = 4,
	BTF_SOCK_TYPE_SOCK = 5,
	BTF_SOCK_TYPE_SOCK_COMMON = 6,
	BTF_SOCK_TYPE_TCP = 7,
	BTF_SOCK_TYPE_TCP_REQ = 8,
	BTF_SOCK_TYPE_TCP_TW = 9,
	BTF_SOCK_TYPE_TCP6 = 10,
	BTF_SOCK_TYPE_UDP = 11,
	BTF_SOCK_TYPE_UDP6 = 12,
	MAX_BTF_SOCK_TYPE = 13,
};

struct bpf_scratchpad {
	union {
		__be32 diff[128];
		u8 buff[512];
	};
};

enum {
	BPF_F_NEIGH = 2,
	BPF_F_PEER = 4,
	BPF_F_NEXTHOP = 8,
};

struct bpf_cpu_map_entry;

struct bpf_dtab_netdev;

enum {
	INET_DIAG_REQ_NONE = 0,
	INET_DIAG_REQ_BYTECODE = 1,
	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
	__INET_DIAG_REQ_MAX = 3,
};

struct sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
};

struct sock_diag_handler {
	__u8 family;
	int (*dump)(struct sk_buff *, struct nlmsghdr *);
	int (*get_info)(struct sk_buff *, struct sock *);
	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
};

struct broadcast_sk {
	struct sock *sk;
	struct work_struct work;
};

typedef int gifconf_func_t(struct net_device___2 *, char *, int, int);

struct hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
};

enum hwtstamp_tx_types {
	HWTSTAMP_TX_OFF = 0,
	HWTSTAMP_TX_ON = 1,
	HWTSTAMP_TX_ONESTEP_SYNC = 2,
};

enum hwtstamp_rx_filters {
	HWTSTAMP_FILTER_NONE = 0,
	HWTSTAMP_FILTER_ALL = 1,
	HWTSTAMP_FILTER_SOME = 2,
	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
	HWTSTAMP_FILTER_NTP_ALL = 15,
};

struct tso_t {
	int next_frag_idx;
	void *data;
	size_t size;
	u16 ip_id;
	bool ipv6;
	u32 tcp_seq;
};

struct fib_notifier_info {
	struct net___2 *net;
	int family;
	struct netlink_ext_ack *extack;
};

enum fib_event_type {
	FIB_EVENT_ENTRY_REPLACE = 0,
	FIB_EVENT_ENTRY_APPEND = 1,
	FIB_EVENT_ENTRY_ADD = 2,
	FIB_EVENT_ENTRY_DEL = 3,
	FIB_EVENT_RULE_ADD = 4,
	FIB_EVENT_RULE_DEL = 5,
	FIB_EVENT_NH_ADD = 6,
	FIB_EVENT_NH_DEL = 7,
	FIB_EVENT_VIF_ADD = 8,
	FIB_EVENT_VIF_DEL = 9,
};

struct fib_notifier_net {
	struct list_head fib_notifier_ops;
};

struct xdp_attachment_info {
	struct bpf_prog___2 *prog;
	u32 flags;
};

struct pp_alloc_cache {
	u32 count;
	void *cache[128];
};

struct page_pool_params {
	unsigned int flags;
	unsigned int order;
	unsigned int pool_size;
	int nid;
	struct device___2 *dev;
	enum dma_data_direction dma_dir;
};

struct page_pool {
	struct page_pool_params p;
	struct delayed_work release_dw;
	void (*disconnect)(void *);
	long unsigned int defer_start;
	long unsigned int defer_warn;
	u32 pages_state_hold_cnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct pp_alloc_cache alloc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring ring;
	atomic_t pages_state_release_cnt;
	refcount_t user_cnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct flow_match_meta {
	struct flow_dissector_key_meta *key;
	struct flow_dissector_key_meta *mask;
};

struct flow_match_basic {
	struct flow_dissector_key_basic *key;
	struct flow_dissector_key_basic *mask;
};

struct flow_match_control {
	struct flow_dissector_key_control *key;
	struct flow_dissector_key_control *mask;
};

struct flow_match_eth_addrs {
	struct flow_dissector_key_eth_addrs *key;
	struct flow_dissector_key_eth_addrs *mask;
};

struct flow_match_vlan {
	struct flow_dissector_key_vlan *key;
	struct flow_dissector_key_vlan *mask;
};

struct flow_match_ipv4_addrs {
	struct flow_dissector_key_ipv4_addrs *key;
	struct flow_dissector_key_ipv4_addrs *mask;
};

struct flow_match_ipv6_addrs {
	struct flow_dissector_key_ipv6_addrs *key;
	struct flow_dissector_key_ipv6_addrs *mask;
};

struct flow_match_ip {
	struct flow_dissector_key_ip *key;
	struct flow_dissector_key_ip *mask;
};

struct flow_match_ports {
	struct flow_dissector_key_ports *key;
	struct flow_dissector_key_ports *mask;
};

struct flow_match_icmp {
	struct flow_dissector_key_icmp *key;
	struct flow_dissector_key_icmp *mask;
};

struct flow_match_tcp {
	struct flow_dissector_key_tcp *key;
	struct flow_dissector_key_tcp *mask;
};

struct flow_match_mpls {
	struct flow_dissector_key_mpls *key;
	struct flow_dissector_key_mpls *mask;
};

struct flow_match_enc_keyid {
	struct flow_dissector_key_keyid *key;
	struct flow_dissector_key_keyid *mask;
};

struct flow_match_enc_opts {
	struct flow_dissector_key_enc_opts *key;
	struct flow_dissector_key_enc_opts *mask;
};

enum flow_block_command {
	FLOW_BLOCK_BIND = 0,
	FLOW_BLOCK_UNBIND = 1,
};

enum flow_block_binder_type {
	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
};

struct flow_block_offload {
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	bool block_shared;
	bool unlocked_driver_cb;
	struct net___2 *net;
	struct flow_block *block;
	struct list_head cb_list;
	struct list_head *driver_block_list;
	struct netlink_ext_ack *extack;
};

struct flow_block_cb {
	struct list_head driver_list;
	struct list_head list;
	flow_setup_cb_t *cb;
	void *cb_ident;
	void *cb_priv;
	void (*release)(void *);
	unsigned int refcnt;
};

typedef int flow_indr_block_bind_cb_t(struct net_device___2 *, void *, enum tc_setup_type, void *);

typedef void flow_indr_block_cmd_t(struct net_device___2 *, flow_indr_block_bind_cb_t *, void *, enum flow_block_command);

struct flow_indr_block_entry {
	flow_indr_block_cmd_t *cb;
	struct list_head list;
};

struct flow_indr_block_cb {
	struct list_head list;
	void *cb_priv;
	flow_indr_block_bind_cb_t *cb;
	void *cb_ident;
};

struct flow_indr_block_dev {
	struct rhash_head ht_node;
	struct net_device___2 *dev;
	unsigned int refcnt;
	struct list_head cb_list;
};

struct rx_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_rx_queue *, char *);
	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
};

struct netdev_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_queue *, char *);
	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
};

struct snmp_mib {
	const char *name;
	int entry;
};

struct strp_stats {
	long long unsigned int msgs;
	long long unsigned int bytes;
	unsigned int mem_fail;
	unsigned int need_more_hdr;
	unsigned int msg_too_big;
	unsigned int msg_timeouts;
	unsigned int bad_hdr_len;
};

struct strparser;

struct strp_callbacks {
	int (*parse_msg)(struct strparser *, struct sk_buff *);
	void (*rcv_msg)(struct strparser *, struct sk_buff *);
	int (*read_sock_done)(struct strparser *, int);
	void (*abort_parser)(struct strparser *, int);
	void (*lock)(struct strparser *);
	void (*unlock)(struct strparser *);
};

struct strparser {
	struct sock *sk;
	u32 stopped: 1;
	u32 paused: 1;
	u32 aborted: 1;
	u32 interrupted: 1;
	u32 unrecov_intr: 1;
	struct sk_buff **skb_nextp;
	struct sk_buff *skb_head;
	unsigned int need_bytes;
	struct delayed_work msg_timer_work;
	struct work_struct work;
	struct strp_stats stats;
	struct strp_callbacks cb;
};

enum __sk_action {
	__SK_DROP = 0,
	__SK_PASS = 1,
	__SK_REDIRECT = 2,
	__SK_NONE = 3,
};

struct sk_psock_progs {
	struct bpf_prog *msg_parser;
	struct bpf_prog *skb_parser;
	struct bpf_prog *skb_verdict;
};

enum sk_psock_state_bits {
	SK_PSOCK_TX_ENABLED = 0,
};

struct sk_psock_link {
	struct list_head list;
	struct bpf_map *map;
	void *link_raw;
};

struct sk_psock_parser {
	struct strparser strp;
	bool enabled;
	void (*saved_data_ready)(struct sock *);
};

struct sk_psock_work_state {
	struct sk_buff *skb;
	u32 len;
	u32 off;
};

struct sk_psock {
	struct sock *sk;
	struct sock *sk_redir;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 eval;
	struct sk_msg *cork;
	struct sk_psock_progs progs;
	struct sk_psock_parser parser;
	struct sk_buff_head ingress_skb;
	struct list_head ingress_msg;
	long unsigned int state;
	struct list_head link;
	spinlock_t link_lock;
	refcount_t refcnt;
	void (*saved_unhash)(struct sock *);
	void (*saved_close)(struct sock *, long int);
	void (*saved_write_space)(struct sock *);
	struct proto *sk_proto;
	struct sk_psock_work_state work_state;
	struct work_struct work;
	union {
		struct callback_head rcu;
		struct work_struct gc;
	};
};

struct tls_crypto_info {
	__u16 version;
	__u16 cipher_type;
};

struct tls12_crypto_info_aes_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls_sw_context_rx {
	struct crypto_aead *aead_recv;
	struct crypto_wait async_wait;
	struct strparser strp;
	struct sk_buff_head rx_list;
	void (*saved_data_ready)(struct sock *);
	struct sk_buff *recv_pkt;
	u8 control;
	int async_capable;
	bool decrypted;
	atomic_t decrypt_pending;
	spinlock_t decrypt_compl_lock;
	bool async_notify;
};

struct cipher_context {
	char *iv;
	char *rec_seq;
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
};

union tls_crypto_context {
	struct tls_crypto_info info;
	union {
		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
	};
};

struct tls_prot_info {
	u16 version;
	u16 cipher_type;
	u16 prepend_size;
	u16 tag_size;
	u16 overhead_size;
	u16 iv_size;
	u16 salt_size;
	u16 rec_seq_size;
	u16 aad_size;
	u16 tail_size;
};

struct tls_context {
	struct tls_prot_info prot_info;
	u8 tx_conf: 3;
	u8 rx_conf: 3;
	int (*push_pending_record)(struct sock *, int);
	void (*sk_write_space)(struct sock *);
	void *priv_ctx_tx;
	void *priv_ctx_rx;
	struct net_device *netdev;
	struct cipher_context tx;
	struct cipher_context rx;
	struct scatterlist *partially_sent_record;
	u16 partially_sent_offset;
	bool in_tcp_sendpages;
	bool pending_open_record_frags;
	struct mutex tx_lock;
	long unsigned int flags;
	struct proto *sk_proto;
	void (*sk_destruct)(struct sock *);
	union tls_crypto_context crypto_send;
	union tls_crypto_context crypto_recv;
	struct list_head list;
	refcount_t refcount;
	struct callback_head rcu;
};

struct inet6_ifaddr {
	struct in6_addr addr;
	__u32 prefix_len;
	__u32 rt_priority;
	__u32 valid_lft;
	__u32 prefered_lft;
	refcount_t refcnt;
	spinlock_t lock;
	int state;
	__u32 flags;
	__u8 dad_probes;
	__u8 stable_privacy_retry;
	__u16 scope;
	__u64 dad_nonce;
	long unsigned int cstamp;
	long unsigned int tstamp;
	struct delayed_work dad_work;
	struct inet6_dev *idev;
	struct fib6_info *rt;
	struct hlist_node addr_lst;
	struct list_head if_list;
	struct list_head tmp_list;
	struct inet6_ifaddr *ifpub;
	int regen_count;
	bool tokenized;
	struct callback_head rcu;
	struct in6_addr peer_addr;
};

struct fib_rule_uid_range {
	__u32 start;
	__u32 end;
};

enum {
	FRA_UNSPEC = 0,
	FRA_DST = 1,
	FRA_SRC = 2,
	FRA_IIFNAME = 3,
	FRA_GOTO = 4,
	FRA_UNUSED2 = 5,
	FRA_PRIORITY = 6,
	FRA_UNUSED3 = 7,
	FRA_UNUSED4 = 8,
	FRA_UNUSED5 = 9,
	FRA_FWMARK = 10,
	FRA_FLOW = 11,
	FRA_TUN_ID = 12,
	FRA_SUPPRESS_IFGROUP = 13,
	FRA_SUPPRESS_PREFIXLEN = 14,
	FRA_TABLE = 15,
	FRA_FWMASK = 16,
	FRA_OIFNAME = 17,
	FRA_PAD = 18,
	FRA_L3MDEV = 19,
	FRA_UID_RANGE = 20,
	FRA_PROTOCOL = 21,
	FRA_IP_PROTO = 22,
	FRA_SPORT_RANGE = 23,
	FRA_DPORT_RANGE = 24,
	__FRA_MAX = 25,
};

enum {
	FR_ACT_UNSPEC = 0,
	FR_ACT_TO_TBL = 1,
	FR_ACT_GOTO = 2,
	FR_ACT_NOP = 3,
	FR_ACT_RES3 = 4,
	FR_ACT_RES4 = 5,
	FR_ACT_BLACKHOLE = 6,
	FR_ACT_UNREACHABLE = 7,
	FR_ACT_PROHIBIT = 8,
	__FR_ACT_MAX = 9,
};

struct fib_rule_notifier_info {
	struct fib_notifier_info info;
	struct fib_rule *rule;
};

enum tcp_ca_state {
	TCP_CA_Open = 0,
	TCP_CA_Disorder = 1,
	TCP_CA_CWR = 2,
	TCP_CA_Recovery = 3,
	TCP_CA_Loss = 4,
};

struct trace_event_raw_kfree_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	short unsigned int protocol;
	enum skb_drop_reason reason;
	char __data[0];
};

struct trace_event_raw_consume_skb {
	struct trace_entry ent;
	void *skbaddr;
	char __data[0];
};

struct trace_event_raw_skb_copy_datagram_iovec {
	struct trace_entry ent;
	const void *skbaddr;
	int len;
	char __data[0];
};

struct trace_event_data_offsets_kfree_skb {};

struct trace_event_data_offsets_consume_skb {};

struct trace_event_data_offsets_skb_copy_datagram_iovec {};

typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *, enum skb_drop_reason);

typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);

struct trace_event_raw_net_dev_start_xmit {
	struct trace_entry ent;
	u32 __data_loc_name;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	unsigned int len;
	unsigned int data_len;
	int network_offset;
	bool transport_offset_valid;
	int transport_offset;
	u8 tx_flags;
	u16 gso_size;
	u16 gso_segs;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	int rc;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit_timeout {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_driver;
	int queue_index;
	char __data[0];
};

struct trace_event_raw_net_dev_template {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_verbose_template {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int napi_id;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	u32 hash;
	bool l4_hash;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	bool mac_header_valid;
	int mac_header;
	unsigned char nr_frags;
	u16 gso_size;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_exit_template {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_net_dev_start_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit_timeout {
	u32 name;
	u32 driver;
};

struct trace_event_data_offsets_net_dev_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_verbose_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_exit_template {};

typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);

typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);

typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);

typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_ni_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);

typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);

typedef void (*btf_trace_netif_rx_exit)(void *, int);

typedef void (*btf_trace_netif_rx_ni_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);

struct trace_event_raw_napi_poll {
	struct trace_entry ent;
	struct napi_struct *napi;
	u32 __data_loc_dev_name;
	int work;
	int budget;
	char __data[0];
};

struct trace_event_data_offsets_napi_poll {
	u32 dev_name;
};

typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);

struct trace_event_raw_sock_rcvqueue_full {
	struct trace_entry ent;
	int rmem_alloc;
	unsigned int truesize;
	int sk_rcvbuf;
	char __data[0];
};

struct trace_event_raw_sock_exceed_buf_limit {
	struct trace_entry ent;
	char name[32];
	long int *sysctl_mem;
	long int allocated;
	int sysctl_rmem;
	int rmem_alloc;
	int sysctl_wmem;
	int wmem_alloc;
	int wmem_queued;
	int kind;
	char __data[0];
};

struct trace_event_raw_inet_sock_set_state {
	struct trace_entry ent;
	const void *skaddr;
	int oldstate;
	int newstate;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_data_offsets_sock_rcvqueue_full {};

struct trace_event_data_offsets_sock_exceed_buf_limit {};

struct trace_event_data_offsets_inet_sock_set_state {};

typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long int, int);

typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);

struct trace_event_raw_udp_fail_queue_rcv_skb {
	struct trace_entry ent;
	int rc;
	__u16 lport;
	char __data[0];
};

struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};

typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *);

struct trace_event_raw_tcp_event_sk_skb {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_event_sk {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_retransmit_synack {
	struct trace_entry ent;
	const void *skaddr;
	const void *req;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u32 mark;
	__u16 data_len;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 snd_cwnd;
	__u32 ssthresh;
	__u32 snd_wnd;
	__u32 srtt;
	__u32 rcv_wnd;
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_data_offsets_tcp_event_sk_skb {};

struct trace_event_data_offsets_tcp_event_sk {};

struct trace_event_data_offsets_tcp_retransmit_synack {};

struct trace_event_data_offsets_tcp_probe {};

typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);

typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);

typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);

typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);

typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);

struct trace_event_raw_fib_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u8 proto;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[4];
	__u8 dst[4];
	__u8 gw4[4];
	__u8 gw6[16];
	u16 sport;
	u16 dport;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_fib_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);

struct trace_event_raw_qdisc_dequeue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	int packets;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	long unsigned int txq_state;
	char __data[0];
};

struct trace_event_data_offsets_qdisc_dequeue {};

typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);

struct br_mcast_stats {
	__u64 igmp_v1queries[2];
	__u64 igmp_v2queries[2];
	__u64 igmp_v3queries[2];
	__u64 igmp_leaves[2];
	__u64 igmp_v1reports[2];
	__u64 igmp_v2reports[2];
	__u64 igmp_v3reports[2];
	__u64 igmp_parse_errors;
	__u64 mld_v1queries[2];
	__u64 mld_v2queries[2];
	__u64 mld_leaves[2];
	__u64 mld_v1reports[2];
	__u64 mld_v2reports[2];
	__u64 mld_parse_errors;
	__u64 mcast_bytes[2];
	__u64 mcast_packets[2];
};

struct br_ip {
	union {
		__be32 ip4;
		struct in6_addr ip6;
	} u;
	__be16 proto;
	__u16 vid;
};

struct bridge_id {
	unsigned char prio[2];
	unsigned char addr[6];
};

typedef struct bridge_id bridge_id;

struct mac_addr {
	unsigned char addr[6];
};

typedef struct mac_addr mac_addr;

typedef __u16 port_id;

struct bridge_mcast_own_query {
	struct timer_list timer;
	u32 startup_sent;
};

struct bridge_mcast_other_query {
	struct timer_list timer;
	long unsigned int delay_time;
};

struct net_bridge_port;

struct bridge_mcast_querier {
	struct br_ip addr;
	struct net_bridge_port *port;
};

struct net_bridge;

struct net_bridge_vlan_group;

struct bridge_mcast_stats;

struct net_bridge_port {
	struct net_bridge *br;
	struct net_device *dev;
	struct list_head list;
	long unsigned int flags;
	struct net_bridge_vlan_group *vlgrp;
	struct net_bridge_port *backup_port;
	u8 priority;
	u8 state;
	u16 port_no;
	unsigned char topology_change_ack;
	unsigned char config_pending;
	port_id port_id;
	port_id designated_port;
	bridge_id designated_root;
	bridge_id designated_bridge;
	u32 path_cost;
	u32 designated_cost;
	long unsigned int designated_age;
	struct timer_list forward_delay_timer;
	struct timer_list hold_timer;
	struct timer_list message_age_timer;
	struct kobject___2 kobj;
	struct callback_head rcu;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_own_query ip6_own_query;
	unsigned char multicast_router;
	struct bridge_mcast_stats *mcast_stats;
	struct timer_list multicast_router_timer;
	struct hlist_head mglist;
	struct hlist_node rlist;
	char sysfs_name[16];
	struct netpoll *np;
	u16 group_fwd_mask;
	u16 backup_redirected_cnt;
};

struct bridge_mcast_stats {
	struct br_mcast_stats mstats;
	struct u64_stats_sync syncp;
};

struct net_bridge {
	spinlock_t lock;
	spinlock_t hash_lock;
	struct list_head port_list;
	struct net_device *dev;
	struct pcpu_sw_netstats *stats;
	long unsigned int options;
	__be16 vlan_proto;
	u16 default_pvid;
	struct net_bridge_vlan_group *vlgrp;
	struct rhashtable fdb_hash_tbl;
	union {
		struct rtable fake_rtable;
		struct rt6_info fake_rt6_info;
	};
	u16 group_fwd_mask;
	u16 group_fwd_mask_required;
	bridge_id designated_root;
	bridge_id bridge_id;
	unsigned char topology_change;
	unsigned char topology_change_detected;
	u16 root_port;
	long unsigned int max_age;
	long unsigned int hello_time;
	long unsigned int forward_delay;
	long unsigned int ageing_time;
	long unsigned int bridge_max_age;
	long unsigned int bridge_hello_time;
	long unsigned int bridge_forward_delay;
	long unsigned int bridge_ageing_time;
	u32 root_path_cost;
	u8 group_addr[6];
	enum {
		BR_NO_STP = 0,
		BR_KERNEL_STP = 1,
		BR_USER_STP = 2,
	} stp_enabled;
	u32 hash_max;
	u32 multicast_last_member_count;
	u32 multicast_startup_query_count;
	u8 multicast_igmp_version;
	u8 multicast_router;
	u8 multicast_mld_version;
	spinlock_t multicast_lock;
	long unsigned int multicast_last_member_interval;
	long unsigned int multicast_membership_interval;
	long unsigned int multicast_querier_interval;
	long unsigned int multicast_query_interval;
	long unsigned int multicast_query_response_interval;
	long unsigned int multicast_startup_query_interval;
	struct rhashtable mdb_hash_tbl;
	struct hlist_head mdb_list;
	struct hlist_head router_list;
	struct timer_list multicast_router_timer;
	struct bridge_mcast_other_query ip4_other_query;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_querier ip4_querier;
	struct bridge_mcast_stats *mcast_stats;
	struct bridge_mcast_other_query ip6_other_query;
	struct bridge_mcast_own_query ip6_own_query;
	struct bridge_mcast_querier ip6_querier;
	struct timer_list hello_timer;
	struct timer_list tcn_timer;
	struct timer_list topology_change_timer;
	struct delayed_work gc_work;
	struct kobject___2 *ifobj;
	u32 auto_cnt;
	struct hlist_head fdb_list;
};

struct net_bridge_vlan_group {
	struct rhashtable vlan_hash;
	struct rhashtable tunnel_hash;
	struct list_head vlan_list;
	u16 num_vlans;
	u16 pvid;
};

struct net_bridge_fdb_key {
	mac_addr addr;
	u16 vlan_id;
};

struct net_bridge_fdb_entry {
	struct rhash_head rhnode;
	struct net_bridge_port *dst;
	struct net_bridge_fdb_key key;
	struct hlist_node fdb_node;
	unsigned char is_local: 1;
	unsigned char is_static: 1;
	unsigned char is_sticky: 1;
	unsigned char added_by_user: 1;
	unsigned char added_by_external_learn: 1;
	unsigned char offloaded: 1;
	long: 58;
	long: 64;
	long: 64;
	long unsigned int updated;
	long unsigned int used;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_event_raw_br_fdb_add {
	struct trace_entry ent;
	u8 ndm_flags;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	u16 nlh_flags;
	char __data[0];
};

struct trace_event_raw_br_fdb_external_learn_add {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_fdb_delete {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_br_fdb_update {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	bool added_by_user;
	char __data[0];
};

struct trace_event_data_offsets_br_fdb_add {
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_external_learn_add {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_fdb_delete {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_update {
	u32 br_dev;
	u32 dev;
};

typedef void (*btf_trace_br_fdb_add)(void *, struct ndmsg *, struct net_device *, const unsigned char *, u16, u16);

typedef void (*btf_trace_br_fdb_external_learn_add)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16);

typedef void (*btf_trace_fdb_delete)(void *, struct net_bridge *, struct net_bridge_fdb_entry *);

typedef void (*btf_trace_br_fdb_update)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16, bool);

struct trace_event_raw_page_pool_inflight {
	struct trace_entry ent;
	const struct page_pool *pool;
	s32 inflight;
	u32 hold;
	u32 release;
	char __data[0];
};

struct trace_event_raw_page_pool_state_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 release;
	char __data[0];
};

struct trace_event_raw_page_pool_state_hold {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 hold;
	char __data[0];
};

struct trace_event_data_offsets_page_pool_inflight {};

struct trace_event_data_offsets_page_pool_state_release {};

struct trace_event_data_offsets_page_pool_state_hold {};

typedef void (*btf_trace_page_pool_inflight)(void *, const struct page_pool *, s32, u32, u32);

typedef void (*btf_trace_page_pool_state_release)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_state_hold)(void *, const struct page_pool *, const struct page *, u32);

struct trace_event_raw_neigh_create {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	int entries;
	u8 created;
	u8 gc_exempt;
	u8 primary_key4[4];
	u8 primary_key6[16];
	char __data[0];
};

struct trace_event_raw_neigh_update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u8 new_lladdr[32];
	u8 new_state;
	u32 update_flags;
	u32 pid;
	char __data[0];
};

struct trace_event_raw_neigh__update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u32 err;
	char __data[0];
};

struct trace_event_data_offsets_neigh_create {
	u32 dev;
};

struct trace_event_data_offsets_neigh_update {
	u32 dev;
};

struct trace_event_data_offsets_neigh__update {
	u32 dev;
};

typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);

typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);

typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);

struct net_dm_drop_point {
	__u8 pc[8];
	__u32 count;
};

struct net_dm_alert_msg {
	__u32 entries;
	struct net_dm_drop_point points[0];
};

enum {
	NET_DM_CMD_UNSPEC = 0,
	NET_DM_CMD_ALERT = 1,
	NET_DM_CMD_CONFIG = 2,
	NET_DM_CMD_START = 3,
	NET_DM_CMD_STOP = 4,
	NET_DM_CMD_PACKET_ALERT = 5,
	NET_DM_CMD_CONFIG_GET = 6,
	NET_DM_CMD_CONFIG_NEW = 7,
	NET_DM_CMD_STATS_GET = 8,
	NET_DM_CMD_STATS_NEW = 9,
	_NET_DM_CMD_MAX = 10,
};

enum net_dm_attr {
	NET_DM_ATTR_UNSPEC = 0,
	NET_DM_ATTR_ALERT_MODE = 1,
	NET_DM_ATTR_PC = 2,
	NET_DM_ATTR_SYMBOL = 3,
	NET_DM_ATTR_IN_PORT = 4,
	NET_DM_ATTR_TIMESTAMP = 5,
	NET_DM_ATTR_PROTO = 6,
	NET_DM_ATTR_PAYLOAD = 7,
	NET_DM_ATTR_PAD = 8,
	NET_DM_ATTR_TRUNC_LEN = 9,
	NET_DM_ATTR_ORIG_LEN = 10,
	NET_DM_ATTR_QUEUE_LEN = 11,
	NET_DM_ATTR_STATS = 12,
	NET_DM_ATTR_HW_STATS = 13,
	NET_DM_ATTR_ORIGIN = 14,
	NET_DM_ATTR_HW_TRAP_GROUP_NAME = 15,
	NET_DM_ATTR_HW_TRAP_NAME = 16,
	NET_DM_ATTR_HW_ENTRIES = 17,
	NET_DM_ATTR_HW_ENTRY = 18,
	NET_DM_ATTR_HW_TRAP_COUNT = 19,
	NET_DM_ATTR_SW_DROPS = 20,
	NET_DM_ATTR_HW_DROPS = 21,
	NET_DM_ATTR_FLOW_ACTION_COOKIE = 22,
	NET_DM_ATTR_REASON = 23,
	__NET_DM_ATTR_MAX = 24,
	NET_DM_ATTR_MAX = 23,
};

enum net_dm_alert_mode {
	NET_DM_ALERT_MODE_SUMMARY = 0,
	NET_DM_ALERT_MODE_PACKET = 1,
};

enum {
	NET_DM_ATTR_PORT_NETDEV_IFINDEX = 0,
	NET_DM_ATTR_PORT_NETDEV_NAME = 1,
	__NET_DM_ATTR_PORT_MAX = 2,
	NET_DM_ATTR_PORT_MAX = 1,
};

enum {
	NET_DM_ATTR_STATS_DROPPED = 0,
	__NET_DM_ATTR_STATS_MAX = 1,
	NET_DM_ATTR_STATS_MAX = 0,
};

enum net_dm_origin {
	NET_DM_ORIGIN_SW = 0,
	NET_DM_ORIGIN_HW = 1,
};

struct net_dm_hw_metadata {
	const char *trap_group_name;
	const char *trap_name;
	struct net_device___2 *input_dev;
};

struct net_dm_stats {
	u64 dropped;
	struct u64_stats_sync syncp;
};

struct net_dm_hw_entry {
	char trap_name[40];
	u32 count;
};

struct net_dm_hw_entries {
	u32 num_entries;
	struct net_dm_hw_entry entries[0];
};

struct per_cpu_dm_data {
	spinlock_t lock;
	union {
		struct sk_buff___2 *skb;
		struct net_dm_hw_entries *hw_entries;
	};
	struct sk_buff_head drop_queue;
	struct work_struct dm_alert_work;
	struct timer_list send_timer;
	struct net_dm_stats stats;
};

struct dm_hw_stat_delta {
	struct net_device___2 *dev;
	long unsigned int last_rx;
	struct list_head list;
	struct callback_head rcu;
	long unsigned int last_drop_val;
};

struct net_dm_alert_ops {
	void (*kfree_skb_probe)(void *, struct sk_buff___2 *, void *, enum skb_drop_reason);
	void (*napi_poll_probe)(void *, struct napi_struct *, int, int);
	void (*work_item_func)(struct work_struct *);
	void (*hw_work_item_func)(struct work_struct *);
	void (*hw_probe)(struct sk_buff___2 *, const struct net_dm_hw_metadata *);
};

struct net_dm_skb_cb {
	union {
		struct net_dm_hw_metadata *hw_metadata;
		void *pc;
	};
	enum skb_drop_reason reason;
};

struct update_classid_context {
	u32 classid;
	unsigned int batch;
};

enum lwtunnel_encap_types {
	LWTUNNEL_ENCAP_NONE = 0,
	LWTUNNEL_ENCAP_MPLS = 1,
	LWTUNNEL_ENCAP_IP = 2,
	LWTUNNEL_ENCAP_ILA = 3,
	LWTUNNEL_ENCAP_IP6 = 4,
	LWTUNNEL_ENCAP_SEG6 = 5,
	LWTUNNEL_ENCAP_BPF = 6,
	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
	__LWTUNNEL_ENCAP_MAX = 8,
};

struct rtnexthop {
	short unsigned int rtnh_len;
	unsigned char rtnh_flags;
	unsigned char rtnh_hops;
	int rtnh_ifindex;
};

struct lwtunnel_encap_ops {
	int (*build_state)(struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
	void (*destroy_state)(struct lwtunnel_state *);
	int (*output)(struct net___2 *, struct sock *, struct sk_buff *);
	int (*input)(struct sk_buff *);
	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
	int (*get_encap_size)(struct lwtunnel_state *);
	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
	int (*xmit)(struct sk_buff *);
	struct module___2 *owner;
};

enum {
	LWT_BPF_PROG_UNSPEC = 0,
	LWT_BPF_PROG_FD = 1,
	LWT_BPF_PROG_NAME = 2,
	__LWT_BPF_PROG_MAX = 3,
};

enum {
	LWT_BPF_UNSPEC = 0,
	LWT_BPF_IN = 1,
	LWT_BPF_OUT = 2,
	LWT_BPF_XMIT = 3,
	LWT_BPF_XMIT_HEADROOM = 4,
	__LWT_BPF_MAX = 5,
};

enum {
	LWTUNNEL_XMIT_DONE = 0,
	LWTUNNEL_XMIT_CONTINUE = 1,
};

struct bpf_lwt_prog {
	struct bpf_prog *prog;
	char *name;
};

struct bpf_lwt {
	struct bpf_lwt_prog in;
	struct bpf_lwt_prog out;
	struct bpf_lwt_prog xmit;
	int family;
};

struct dst_cache_pcpu {
	long unsigned int refresh_ts;
	struct dst_entry *dst;
	u32 cookie;
	union {
		struct in_addr in_saddr;
		struct in6_addr in6_saddr;
	};
};

enum devlink_command {
	DEVLINK_CMD_UNSPEC = 0,
	DEVLINK_CMD_GET = 1,
	DEVLINK_CMD_SET = 2,
	DEVLINK_CMD_NEW = 3,
	DEVLINK_CMD_DEL = 4,
	DEVLINK_CMD_PORT_GET = 5,
	DEVLINK_CMD_PORT_SET = 6,
	DEVLINK_CMD_PORT_NEW = 7,
	DEVLINK_CMD_PORT_DEL = 8,
	DEVLINK_CMD_PORT_SPLIT = 9,
	DEVLINK_CMD_PORT_UNSPLIT = 10,
	DEVLINK_CMD_SB_GET = 11,
	DEVLINK_CMD_SB_SET = 12,
	DEVLINK_CMD_SB_NEW = 13,
	DEVLINK_CMD_SB_DEL = 14,
	DEVLINK_CMD_SB_POOL_GET = 15,
	DEVLINK_CMD_SB_POOL_SET = 16,
	DEVLINK_CMD_SB_POOL_NEW = 17,
	DEVLINK_CMD_SB_POOL_DEL = 18,
	DEVLINK_CMD_SB_PORT_POOL_GET = 19,
	DEVLINK_CMD_SB_PORT_POOL_SET = 20,
	DEVLINK_CMD_SB_PORT_POOL_NEW = 21,
	DEVLINK_CMD_SB_PORT_POOL_DEL = 22,
	DEVLINK_CMD_SB_TC_POOL_BIND_GET = 23,
	DEVLINK_CMD_SB_TC_POOL_BIND_SET = 24,
	DEVLINK_CMD_SB_TC_POOL_BIND_NEW = 25,
	DEVLINK_CMD_SB_TC_POOL_BIND_DEL = 26,
	DEVLINK_CMD_SB_OCC_SNAPSHOT = 27,
	DEVLINK_CMD_SB_OCC_MAX_CLEAR = 28,
	DEVLINK_CMD_ESWITCH_GET = 29,
	DEVLINK_CMD_ESWITCH_SET = 30,
	DEVLINK_CMD_DPIPE_TABLE_GET = 31,
	DEVLINK_CMD_DPIPE_ENTRIES_GET = 32,
	DEVLINK_CMD_DPIPE_HEADERS_GET = 33,
	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET = 34,
	DEVLINK_CMD_RESOURCE_SET = 35,
	DEVLINK_CMD_RESOURCE_DUMP = 36,
	DEVLINK_CMD_RELOAD = 37,
	DEVLINK_CMD_PARAM_GET = 38,
	DEVLINK_CMD_PARAM_SET = 39,
	DEVLINK_CMD_PARAM_NEW = 40,
	DEVLINK_CMD_PARAM_DEL = 41,
	DEVLINK_CMD_REGION_GET = 42,
	DEVLINK_CMD_REGION_SET = 43,
	DEVLINK_CMD_REGION_NEW = 44,
	DEVLINK_CMD_REGION_DEL = 45,
	DEVLINK_CMD_REGION_READ = 46,
	DEVLINK_CMD_PORT_PARAM_GET = 47,
	DEVLINK_CMD_PORT_PARAM_SET = 48,
	DEVLINK_CMD_PORT_PARAM_NEW = 49,
	DEVLINK_CMD_PORT_PARAM_DEL = 50,
	DEVLINK_CMD_INFO_GET = 51,
	DEVLINK_CMD_HEALTH_REPORTER_GET = 52,
	DEVLINK_CMD_HEALTH_REPORTER_SET = 53,
	DEVLINK_CMD_HEALTH_REPORTER_RECOVER = 54,
	DEVLINK_CMD_HEALTH_REPORTER_DIAGNOSE = 55,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_GET = 56,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_CLEAR = 57,
	DEVLINK_CMD_FLASH_UPDATE = 58,
	DEVLINK_CMD_FLASH_UPDATE_END = 59,
	DEVLINK_CMD_FLASH_UPDATE_STATUS = 60,
	DEVLINK_CMD_TRAP_GET = 61,
	DEVLINK_CMD_TRAP_SET = 62,
	DEVLINK_CMD_TRAP_NEW = 63,
	DEVLINK_CMD_TRAP_DEL = 64,
	DEVLINK_CMD_TRAP_GROUP_GET = 65,
	DEVLINK_CMD_TRAP_GROUP_SET = 66,
	DEVLINK_CMD_TRAP_GROUP_NEW = 67,
	DEVLINK_CMD_TRAP_GROUP_DEL = 68,
	__DEVLINK_CMD_MAX = 69,
	DEVLINK_CMD_MAX = 68,
};

enum devlink_param_cmode {
	DEVLINK_PARAM_CMODE_RUNTIME = 0,
	DEVLINK_PARAM_CMODE_DRIVERINIT = 1,
	DEVLINK_PARAM_CMODE_PERMANENT = 2,
	__DEVLINK_PARAM_CMODE_MAX = 3,
	DEVLINK_PARAM_CMODE_MAX = 2,
};

enum {
	DEVLINK_ATTR_STATS_RX_PACKETS = 0,
	DEVLINK_ATTR_STATS_RX_BYTES = 1,
	__DEVLINK_ATTR_STATS_MAX = 2,
	DEVLINK_ATTR_STATS_MAX = 1,
};

enum {
	DEVLINK_ATTR_TRAP_METADATA_TYPE_IN_PORT = 0,
};

enum devlink_attr {
	DEVLINK_ATTR_UNSPEC = 0,
	DEVLINK_ATTR_BUS_NAME = 1,
	DEVLINK_ATTR_DEV_NAME = 2,
	DEVLINK_ATTR_PORT_INDEX = 3,
	DEVLINK_ATTR_PORT_TYPE = 4,
	DEVLINK_ATTR_PORT_DESIRED_TYPE = 5,
	DEVLINK_ATTR_PORT_NETDEV_IFINDEX = 6,
	DEVLINK_ATTR_PORT_NETDEV_NAME = 7,
	DEVLINK_ATTR_PORT_IBDEV_NAME = 8,
	DEVLINK_ATTR_PORT_SPLIT_COUNT = 9,
	DEVLINK_ATTR_PORT_SPLIT_GROUP = 10,
	DEVLINK_ATTR_SB_INDEX = 11,
	DEVLINK_ATTR_SB_SIZE = 12,
	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT = 13,
	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT = 14,
	DEVLINK_ATTR_SB_INGRESS_TC_COUNT = 15,
	DEVLINK_ATTR_SB_EGRESS_TC_COUNT = 16,
	DEVLINK_ATTR_SB_POOL_INDEX = 17,
	DEVLINK_ATTR_SB_POOL_TYPE = 18,
	DEVLINK_ATTR_SB_POOL_SIZE = 19,
	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE = 20,
	DEVLINK_ATTR_SB_THRESHOLD = 21,
	DEVLINK_ATTR_SB_TC_INDEX = 22,
	DEVLINK_ATTR_SB_OCC_CUR = 23,
	DEVLINK_ATTR_SB_OCC_MAX = 24,
	DEVLINK_ATTR_ESWITCH_MODE = 25,
	DEVLINK_ATTR_ESWITCH_INLINE_MODE = 26,
	DEVLINK_ATTR_DPIPE_TABLES = 27,
	DEVLINK_ATTR_DPIPE_TABLE = 28,
	DEVLINK_ATTR_DPIPE_TABLE_NAME = 29,
	DEVLINK_ATTR_DPIPE_TABLE_SIZE = 30,
	DEVLINK_ATTR_DPIPE_TABLE_MATCHES = 31,
	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS = 32,
	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED = 33,
	DEVLINK_ATTR_DPIPE_ENTRIES = 34,
	DEVLINK_ATTR_DPIPE_ENTRY = 35,
	DEVLINK_ATTR_DPIPE_ENTRY_INDEX = 36,
	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES = 37,
	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES = 38,
	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER = 39,
	DEVLINK_ATTR_DPIPE_MATCH = 40,
	DEVLINK_ATTR_DPIPE_MATCH_VALUE = 41,
	DEVLINK_ATTR_DPIPE_MATCH_TYPE = 42,
	DEVLINK_ATTR_DPIPE_ACTION = 43,
	DEVLINK_ATTR_DPIPE_ACTION_VALUE = 44,
	DEVLINK_ATTR_DPIPE_ACTION_TYPE = 45,
	DEVLINK_ATTR_DPIPE_VALUE = 46,
	DEVLINK_ATTR_DPIPE_VALUE_MASK = 47,
	DEVLINK_ATTR_DPIPE_VALUE_MAPPING = 48,
	DEVLINK_ATTR_DPIPE_HEADERS = 49,
	DEVLINK_ATTR_DPIPE_HEADER = 50,
	DEVLINK_ATTR_DPIPE_HEADER_NAME = 51,
	DEVLINK_ATTR_DPIPE_HEADER_ID = 52,
	DEVLINK_ATTR_DPIPE_HEADER_FIELDS = 53,
	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL = 54,
	DEVLINK_ATTR_DPIPE_HEADER_INDEX = 55,
	DEVLINK_ATTR_DPIPE_FIELD = 56,
	DEVLINK_ATTR_DPIPE_FIELD_NAME = 57,
	DEVLINK_ATTR_DPIPE_FIELD_ID = 58,
	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH = 59,
	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE = 60,
	DEVLINK_ATTR_PAD = 61,
	DEVLINK_ATTR_ESWITCH_ENCAP_MODE = 62,
	DEVLINK_ATTR_RESOURCE_LIST = 63,
	DEVLINK_ATTR_RESOURCE = 64,
	DEVLINK_ATTR_RESOURCE_NAME = 65,
	DEVLINK_ATTR_RESOURCE_ID = 66,
	DEVLINK_ATTR_RESOURCE_SIZE = 67,
	DEVLINK_ATTR_RESOURCE_SIZE_NEW = 68,
	DEVLINK_ATTR_RESOURCE_SIZE_VALID = 69,
	DEVLINK_ATTR_RESOURCE_SIZE_MIN = 70,
	DEVLINK_ATTR_RESOURCE_SIZE_MAX = 71,
	DEVLINK_ATTR_RESOURCE_SIZE_GRAN = 72,
	DEVLINK_ATTR_RESOURCE_UNIT = 73,
	DEVLINK_ATTR_RESOURCE_OCC = 74,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_ID = 75,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_UNITS = 76,
	DEVLINK_ATTR_PORT_FLAVOUR = 77,
	DEVLINK_ATTR_PORT_NUMBER = 78,
	DEVLINK_ATTR_PORT_SPLIT_SUBPORT_NUMBER = 79,
	DEVLINK_ATTR_PARAM = 80,
	DEVLINK_ATTR_PARAM_NAME = 81,
	DEVLINK_ATTR_PARAM_GENERIC = 82,
	DEVLINK_ATTR_PARAM_TYPE = 83,
	DEVLINK_ATTR_PARAM_VALUES_LIST = 84,
	DEVLINK_ATTR_PARAM_VALUE = 85,
	DEVLINK_ATTR_PARAM_VALUE_DATA = 86,
	DEVLINK_ATTR_PARAM_VALUE_CMODE = 87,
	DEVLINK_ATTR_REGION_NAME = 88,
	DEVLINK_ATTR_REGION_SIZE = 89,
	DEVLINK_ATTR_REGION_SNAPSHOTS = 90,
	DEVLINK_ATTR_REGION_SNAPSHOT = 91,
	DEVLINK_ATTR_REGION_SNAPSHOT_ID = 92,
	DEVLINK_ATTR_REGION_CHUNKS = 93,
	DEVLINK_ATTR_REGION_CHUNK = 94,
	DEVLINK_ATTR_REGION_CHUNK_DATA = 95,
	DEVLINK_ATTR_REGION_CHUNK_ADDR = 96,
	DEVLINK_ATTR_REGION_CHUNK_LEN = 97,
	DEVLINK_ATTR_INFO_DRIVER_NAME = 98,
	DEVLINK_ATTR_INFO_SERIAL_NUMBER = 99,
	DEVLINK_ATTR_INFO_VERSION_FIXED = 100,
	DEVLINK_ATTR_INFO_VERSION_RUNNING = 101,
	DEVLINK_ATTR_INFO_VERSION_STORED = 102,
	DEVLINK_ATTR_INFO_VERSION_NAME = 103,
	DEVLINK_ATTR_INFO_VERSION_VALUE = 104,
	DEVLINK_ATTR_SB_POOL_CELL_SIZE = 105,
	DEVLINK_ATTR_FMSG = 106,
	DEVLINK_ATTR_FMSG_OBJ_NEST_START = 107,
	DEVLINK_ATTR_FMSG_PAIR_NEST_START = 108,
	DEVLINK_ATTR_FMSG_ARR_NEST_START = 109,
	DEVLINK_ATTR_FMSG_NEST_END = 110,
	DEVLINK_ATTR_FMSG_OBJ_NAME = 111,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_TYPE = 112,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_DATA = 113,
	DEVLINK_ATTR_HEALTH_REPORTER = 114,
	DEVLINK_ATTR_HEALTH_REPORTER_NAME = 115,
	DEVLINK_ATTR_HEALTH_REPORTER_STATE = 116,
	DEVLINK_ATTR_HEALTH_REPORTER_ERR_COUNT = 117,
	DEVLINK_ATTR_HEALTH_REPORTER_RECOVER_COUNT = 118,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS = 119,
	DEVLINK_ATTR_HEALTH_REPORTER_GRACEFUL_PERIOD = 120,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_RECOVER = 121,
	DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME = 122,
	DEVLINK_ATTR_FLASH_UPDATE_COMPONENT = 123,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_MSG = 124,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_DONE = 125,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TOTAL = 126,
	DEVLINK_ATTR_PORT_PCI_PF_NUMBER = 127,
	DEVLINK_ATTR_PORT_PCI_VF_NUMBER = 128,
	DEVLINK_ATTR_STATS = 129,
	DEVLINK_ATTR_TRAP_NAME = 130,
	DEVLINK_ATTR_TRAP_ACTION = 131,
	DEVLINK_ATTR_TRAP_TYPE = 132,
	DEVLINK_ATTR_TRAP_GENERIC = 133,
	DEVLINK_ATTR_TRAP_METADATA = 134,
	DEVLINK_ATTR_TRAP_GROUP_NAME = 135,
	DEVLINK_ATTR_RELOAD_FAILED = 136,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS_NS = 137,
	__DEVLINK_ATTR_MAX = 138,
	DEVLINK_ATTR_MAX = 137,
};

enum devlink_dpipe_match_type {
	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT = 0,
};

enum devlink_dpipe_action_type {
	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY = 0,
};

enum devlink_dpipe_field_ethernet_id {
	DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC = 0,
};

enum devlink_dpipe_field_ipv4_id {
	DEVLINK_DPIPE_FIELD_IPV4_DST_IP = 0,
};

enum devlink_dpipe_field_ipv6_id {
	DEVLINK_DPIPE_FIELD_IPV6_DST_IP = 0,
};

enum devlink_dpipe_header_id {
	DEVLINK_DPIPE_HEADER_ETHERNET = 0,
	DEVLINK_DPIPE_HEADER_IPV4 = 1,
	DEVLINK_DPIPE_HEADER_IPV6 = 2,
};

enum devlink_resource_unit {
	DEVLINK_RESOURCE_UNIT_ENTRY = 0,
};

struct devlink_dpipe_match {
	enum devlink_dpipe_match_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_action {
	enum devlink_dpipe_action_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_value {
	union {
		struct devlink_dpipe_action *action;
		struct devlink_dpipe_match *match;
	};
	unsigned int mapping_value;
	bool mapping_valid;
	unsigned int value_size;
	void *value;
	void *mask;
};

struct devlink_dpipe_entry {
	u64 index;
	struct devlink_dpipe_value *match_values;
	unsigned int match_values_count;
	struct devlink_dpipe_value *action_values;
	unsigned int action_values_count;
	u64 counter;
	bool counter_valid;
};

struct devlink_dpipe_dump_ctx {
	struct genl_info *info;
	enum devlink_command cmd;
	struct sk_buff *skb;
	struct nlattr *nest;
	void *hdr;
};

struct devlink_dpipe_table_ops;

struct devlink_dpipe_table {
	void *priv;
	struct list_head list;
	const char *name;
	bool counters_enabled;
	bool counter_control_extern;
	bool resource_valid;
	u64 resource_id;
	u64 resource_units;
	struct devlink_dpipe_table_ops *table_ops;
	struct callback_head rcu;
};

struct devlink_dpipe_table_ops {
	int (*actions_dump)(void *, struct sk_buff *);
	int (*matches_dump)(void *, struct sk_buff *);
	int (*entries_dump)(void *, bool, struct devlink_dpipe_dump_ctx *);
	int (*counters_set_update)(void *, bool);
	u64 (*size_get)(void *);
};

struct devlink_resource_size_params {
	u64 size_min;
	u64 size_max;
	u64 size_granularity;
	enum devlink_resource_unit unit;
};

typedef u64 devlink_resource_occ_get_t(void *);

struct devlink_resource {
	const char *name;
	u64 id;
	u64 size;
	u64 size_new;
	bool size_valid;
	struct devlink_resource *parent;
	struct devlink_resource_size_params size_params;
	struct list_head list;
	struct list_head resource_list;
	devlink_resource_occ_get_t *occ_get;
	void *occ_get_priv;
};

enum devlink_param_type {
	DEVLINK_PARAM_TYPE_U8 = 0,
	DEVLINK_PARAM_TYPE_U16 = 1,
	DEVLINK_PARAM_TYPE_U32 = 2,
	DEVLINK_PARAM_TYPE_STRING = 3,
	DEVLINK_PARAM_TYPE_BOOL = 4,
};

union devlink_param_value {
	u8 vu8;
	u16 vu16;
	u32 vu32;
	char vstr[32];
	bool vbool;
};

struct devlink_param_gset_ctx {
	union devlink_param_value val;
	enum devlink_param_cmode cmode;
};

struct devlink_param {
	u32 id;
	const char *name;
	bool generic;
	enum devlink_param_type type;
	long unsigned int supported_cmodes;
	int (*get)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*set)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*validate)(struct devlink *, u32, union devlink_param_value, struct netlink_ext_ack *);
};

struct devlink_param_item {
	struct list_head list;
	const struct devlink_param *param;
	union devlink_param_value driverinit_value;
	bool driverinit_value_valid;
	bool published;
};

enum devlink_param_generic_id {
	DEVLINK_PARAM_GENERIC_ID_INT_ERR_RESET = 0,
	DEVLINK_PARAM_GENERIC_ID_MAX_MACS = 1,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_SRIOV = 2,
	DEVLINK_PARAM_GENERIC_ID_REGION_SNAPSHOT = 3,
	DEVLINK_PARAM_GENERIC_ID_IGNORE_ARI = 4,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX = 5,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN = 6,
	DEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY = 7,
	DEVLINK_PARAM_GENERIC_ID_RESET_DEV_ON_DRV_PROBE = 8,
	__DEVLINK_PARAM_GENERIC_ID_MAX = 9,
	DEVLINK_PARAM_GENERIC_ID_MAX = 8,
};

typedef void devlink_snapshot_data_dest_t(const void *);

enum devlink_health_reporter_state {
	DEVLINK_HEALTH_REPORTER_STATE_HEALTHY = 0,
	DEVLINK_HEALTH_REPORTER_STATE_ERROR = 1,
};

struct devlink_health_reporter;

struct devlink_fmsg;

struct devlink_health_reporter_ops {
	char *name;
	int (*recover)(struct devlink_health_reporter *, void *);
	int (*dump)(struct devlink_health_reporter *, struct devlink_fmsg *, void *);
	int (*diagnose)(struct devlink_health_reporter *, struct devlink_fmsg *);
};

struct devlink_health_reporter {
	struct list_head list;
	void *priv;
	const struct devlink_health_reporter_ops *ops;
	struct devlink *devlink;
	struct devlink_fmsg *dump_fmsg;
	struct mutex dump_lock;
	u64 graceful_period;
	bool auto_recover;
	u8 health_state;
	u64 dump_ts;
	u64 dump_real_ts;
	u64 error_count;
	u64 recovery_count;
	u64 last_recovery_ts;
	refcount_t refcount;
};

struct devlink_fmsg {
	struct list_head item_list;
};

enum devlink_trap_generic_id {
	DEVLINK_TRAP_GENERIC_ID_SMAC_MC = 0,
	DEVLINK_TRAP_GENERIC_ID_VLAN_TAG_MISMATCH = 1,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER = 2,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_STP_FILTER = 3,
	DEVLINK_TRAP_GENERIC_ID_EMPTY_TX_LIST = 4,
	DEVLINK_TRAP_GENERIC_ID_PORT_LOOPBACK_FILTER = 5,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_ROUTE = 6,
	DEVLINK_TRAP_GENERIC_ID_TTL_ERROR = 7,
	DEVLINK_TRAP_GENERIC_ID_TAIL_DROP = 8,
	__DEVLINK_TRAP_GENERIC_ID_MAX = 9,
	DEVLINK_TRAP_GENERIC_ID_MAX = 8,
};

enum devlink_trap_group_generic_id {
	DEVLINK_TRAP_GROUP_GENERIC_ID_L2_DROPS = 0,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_DROPS = 1,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BUFFER_DROPS = 2,
	__DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 3,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 2,
};

struct devlink_info_req {
	struct sk_buff *msg;
};

struct trace_event_raw_devlink_hwmsg {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	bool incoming;
	long unsigned int type;
	u32 __data_loc_buf;
	size_t len;
	char __data[0];
};

struct trace_event_raw_devlink_hwerr {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	int err;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_recover_aborted {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	bool health_state;
	u64 time_since_last_recover;
	char __data[0];
};

struct trace_event_raw_devlink_health_reporter_state_update {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u8 new_state;
	char __data[0];
};

struct trace_event_data_offsets_devlink_hwmsg {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 buf;
};

struct trace_event_data_offsets_devlink_hwerr {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_recover_aborted {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_health_reporter_state_update {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

typedef void (*btf_trace_devlink_hwmsg)(void *, const struct devlink *, bool, long unsigned int, const u8 *, size_t);

typedef void (*btf_trace_devlink_hwerr)(void *, const struct devlink *, int, const char *);

typedef void (*btf_trace_devlink_health_report)(void *, const struct devlink *, const char *, const char *);

typedef void (*btf_trace_devlink_health_recover_aborted)(void *, const struct devlink *, const char *, bool, u64);

typedef void (*btf_trace_devlink_health_reporter_state_update)(void *, const struct devlink *, const char *, bool);

struct devlink_sb {
	struct list_head list;
	unsigned int index;
	u32 size;
	u16 ingress_pools_count;
	u16 egress_pools_count;
	u16 ingress_tc_count;
	u16 egress_tc_count;
};

struct devlink_region {
	struct devlink *devlink;
	struct list_head list;
	const char *name;
	struct list_head snapshot_list;
	u32 max_snapshots;
	u32 cur_snapshots;
	u64 size;
};

struct devlink_snapshot {
	struct list_head list;
	struct devlink_region *region;
	devlink_snapshot_data_dest_t *data_destructor;
	u8 *data;
	u32 id;
};

enum devlink_multicast_groups {
	DEVLINK_MCGRP_CONFIG = 0,
};

struct devlink_fmsg_item {
	struct list_head list;
	int attrtype;
	u8 nla_type;
	u16 len;
	int value[0];
};

struct devlink_stats {
	u64 rx_bytes;
	u64 rx_packets;
	struct u64_stats_sync syncp;
};

struct devlink_trap_group_item {
	const struct devlink_trap_group *group;
	refcount_t refcount;
	struct list_head list;
	struct devlink_stats *stats;
};

struct devlink_trap_item {
	const struct devlink_trap *trap;
	struct devlink_trap_group_item *group_item;
	struct list_head list;
	enum devlink_trap_action action;
	struct devlink_stats *stats;
	void *priv;
};

typedef struct bio_vec___2 skb_frag_t___2;

struct gro_cell;

struct gro_cells {
	struct gro_cell *cells;
};

struct gro_cell {
	struct sk_buff_head___2 napi_skbs;
	struct napi_struct napi;
};

enum {
	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
	BPF_SK_STORAGE_GET_F_CREATE = 1,
};

enum {
	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
	SK_DIAG_BPF_STORAGE = 1,
	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_NONE = 0,
	SK_DIAG_BPF_STORAGE_PAD = 1,
	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
	__SK_DIAG_BPF_STORAGE_MAX = 4,
};

struct bpf_iter_seq_sk_storage_map_info {
	struct bpf_map *map;
	unsigned int bucket_id;
	unsigned int skip_elems;
};

struct bpf_iter__bpf_sk_storage_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		struct sock *sk;
	};
	union {
		void *value;
	};
};

struct bpf_sk_storage_diag {
	u32 nr_maps;
	struct bpf_map *maps[0];
};

struct group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct group_filter {
	__u32 gf_interface;
	struct __kernel_sockaddr_storage gf_group;
	__u32 gf_fmode;
	__u32 gf_numsrc;
	struct __kernel_sockaddr_storage gf_slist[1];
};

struct compat_cmsghdr {
	compat_size_t cmsg_len;
	compat_int_t cmsg_level;
	compat_int_t cmsg_type;
};

struct compat_group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
} __attribute__((packed));

struct compat_group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
} __attribute__((packed));

struct compat_group_filter {
	__u32 gf_interface;
	struct __kernel_sockaddr_storage gf_group;
	__u32 gf_fmode;
	__u32 gf_numsrc;
	struct __kernel_sockaddr_storage gf_slist[1];
} __attribute__((packed));

struct llc_addr {
	unsigned char lsap;
	unsigned char mac[6];
};

struct llc_sap {
	unsigned char state;
	unsigned char p_bit;
	unsigned char f_bit;
	refcount_t refcnt;
	int (*rcv_func)(struct sk_buff___2 *, struct net_device___2 *, struct packet_type *, struct net_device___2 *);
	struct llc_addr laddr;
	struct list_head node;
	spinlock_t sk_lock;
	int sk_count;
	struct hlist_nulls_head sk_laddr_hash[64];
	struct hlist_head sk_dev_hash[64];
	struct callback_head rcu;
};

struct llc_pdu_sn {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
	u8 ctrl_2;
};

struct llc_pdu_un {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
};

typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);

struct nvmem_cell;

struct datalink_proto {
	unsigned char type[8];
	struct llc_sap *sap;
	short unsigned int header_length;
	int (*rcvfunc)(struct sk_buff___2 *, struct net_device___2 *, struct packet_type *, struct net_device___2 *);
	int (*request)(struct datalink_proto *, struct sk_buff___2 *, unsigned char *);
	struct list_head node;
};

struct fch_hdr {
	__u8 daddr[6];
	__u8 saddr[6];
};

struct fcllc {
	__u8 dsap;
	__u8 ssap;
	__u8 llc;
	__u8 protid[3];
	__be16 ethertype;
};

struct stp_proto {
	unsigned char group_address[6];
	void (*rcv)(const struct stp_proto *, struct sk_buff___2 *, struct net_device___2 *);
	void *data;
};

struct garp_applicant;

struct garp_port {
	struct garp_applicant *applicants[1];
	struct callback_head rcu;
};

struct garp_pdu_hdr {
	__be16 protocol;
};

struct garp_msg_hdr {
	u8 attrtype;
};

enum garp_attr_event {
	GARP_LEAVE_ALL = 0,
	GARP_JOIN_EMPTY = 1,
	GARP_JOIN_IN = 2,
	GARP_LEAVE_EMPTY = 3,
	GARP_LEAVE_IN = 4,
	GARP_EMPTY = 5,
};

struct garp_attr_hdr {
	u8 len;
	u8 event;
	u8 data[0];
};

struct garp_skb_cb {
	u8 cur_type;
};

enum garp_applicant_state {
	GARP_APPLICANT_INVALID = 0,
	GARP_APPLICANT_VA = 1,
	GARP_APPLICANT_AA = 2,
	GARP_APPLICANT_QA = 3,
	GARP_APPLICANT_LA = 4,
	GARP_APPLICANT_VP = 5,
	GARP_APPLICANT_AP = 6,
	GARP_APPLICANT_QP = 7,
	GARP_APPLICANT_VO = 8,
	GARP_APPLICANT_AO = 9,
	GARP_APPLICANT_QO = 10,
	__GARP_APPLICANT_MAX = 11,
};

enum garp_event {
	GARP_EVENT_REQ_JOIN = 0,
	GARP_EVENT_REQ_LEAVE = 1,
	GARP_EVENT_R_JOIN_IN = 2,
	GARP_EVENT_R_JOIN_EMPTY = 3,
	GARP_EVENT_R_EMPTY = 4,
	GARP_EVENT_R_LEAVE_IN = 5,
	GARP_EVENT_R_LEAVE_EMPTY = 6,
	GARP_EVENT_TRANSMIT_PDU = 7,
	__GARP_EVENT_MAX = 8,
};

enum garp_action {
	GARP_ACTION_NONE = 0,
	GARP_ACTION_S_JOIN_IN = 1,
	GARP_ACTION_S_LEAVE_EMPTY = 2,
};

struct garp_attr {
	struct rb_node node;
	enum garp_applicant_state state;
	u8 type;
	u8 dlen;
	unsigned char data[0];
};

enum garp_applications {
	GARP_APPLICATION_GVRP = 0,
	__GARP_APPLICATION_MAX = 1,
};

struct garp_application {
	enum garp_applications type;
	unsigned int maxattr;
	struct stp_proto proto;
};

struct garp_applicant {
	struct garp_application *app;
	struct net_device___2 *dev;
	struct timer_list join_timer;
	spinlock_t lock;
	struct sk_buff_head___2 queue;
	struct sk_buff___2 *pdu;
	struct rb_root gid;
	struct callback_head rcu;
};

struct garp_state_trans {
	u8 state;
	u8 action;
};

struct mrp_applicant;

struct mrp_port {
	struct mrp_applicant *applicants[1];
	struct callback_head rcu;
};

struct mrp_pdu_hdr {
	u8 version;
};

struct mrp_msg_hdr {
	u8 attrtype;
	u8 attrlen;
};

struct mrp_vecattr_hdr {
	__be16 lenflags;
	unsigned char firstattrvalue[0];
};

enum mrp_vecattr_event {
	MRP_VECATTR_EVENT_NEW = 0,
	MRP_VECATTR_EVENT_JOIN_IN = 1,
	MRP_VECATTR_EVENT_IN = 2,
	MRP_VECATTR_EVENT_JOIN_MT = 3,
	MRP_VECATTR_EVENT_MT = 4,
	MRP_VECATTR_EVENT_LV = 5,
	__MRP_VECATTR_EVENT_MAX = 6,
};

struct mrp_skb_cb {
	struct mrp_msg_hdr *mh;
	struct mrp_vecattr_hdr *vah;
	unsigned char attrvalue[0];
};

enum mrp_applicant_state {
	MRP_APPLICANT_INVALID = 0,
	MRP_APPLICANT_VO = 1,
	MRP_APPLICANT_VP = 2,
	MRP_APPLICANT_VN = 3,
	MRP_APPLICANT_AN = 4,
	MRP_APPLICANT_AA = 5,
	MRP_APPLICANT_QA = 6,
	MRP_APPLICANT_LA = 7,
	MRP_APPLICANT_AO = 8,
	MRP_APPLICANT_QO = 9,
	MRP_APPLICANT_AP = 10,
	MRP_APPLICANT_QP = 11,
	__MRP_APPLICANT_MAX = 12,
};

enum mrp_event {
	MRP_EVENT_NEW = 0,
	MRP_EVENT_JOIN = 1,
	MRP_EVENT_LV = 2,
	MRP_EVENT_TX = 3,
	MRP_EVENT_R_NEW = 4,
	MRP_EVENT_R_JOIN_IN = 5,
	MRP_EVENT_R_IN = 6,
	MRP_EVENT_R_JOIN_MT = 7,
	MRP_EVENT_R_MT = 8,
	MRP_EVENT_R_LV = 9,
	MRP_EVENT_R_LA = 10,
	MRP_EVENT_REDECLARE = 11,
	MRP_EVENT_PERIODIC = 12,
	__MRP_EVENT_MAX = 13,
};

enum mrp_tx_action {
	MRP_TX_ACTION_NONE = 0,
	MRP_TX_ACTION_S_NEW = 1,
	MRP_TX_ACTION_S_JOIN_IN = 2,
	MRP_TX_ACTION_S_JOIN_IN_OPTIONAL = 3,
	MRP_TX_ACTION_S_IN_OPTIONAL = 4,
	MRP_TX_ACTION_S_LV = 5,
};

struct mrp_attr {
	struct rb_node node;
	enum mrp_applicant_state state;
	u8 type;
	u8 len;
	unsigned char value[0];
};

enum mrp_applications {
	MRP_APPLICATION_MVRP = 0,
	__MRP_APPLICATION_MAX = 1,
};

struct mrp_application {
	enum mrp_applications type;
	unsigned int maxattr;
	struct packet_type pkttype;
	unsigned char group_address[6];
	u8 version;
};

struct mrp_applicant {
	struct mrp_application *app;
	struct net_device___2 *dev;
	struct timer_list join_timer;
	struct timer_list periodic_timer;
	spinlock_t lock;
	struct sk_buff_head___2 queue;
	struct sk_buff___2 *pdu;
	struct rb_root mad;
	struct callback_head rcu;
};

enum macvlan_mode {
	MACVLAN_MODE_PRIVATE = 1,
	MACVLAN_MODE_VEPA = 2,
	MACVLAN_MODE_BRIDGE = 4,
	MACVLAN_MODE_PASSTHRU = 8,
	MACVLAN_MODE_SOURCE = 16,
};

struct tc_ratespec {
	unsigned char cell_log;
	__u8 linklayer;
	short unsigned int overhead;
	short int cell_align;
	short unsigned int mpu;
	__u32 rate;
};

struct tc_prio_qopt {
	int bands;
	__u8 priomap[16];
};

enum {
	TCA_UNSPEC = 0,
	TCA_KIND = 1,
	TCA_OPTIONS = 2,
	TCA_STATS = 3,
	TCA_XSTATS = 4,
	TCA_RATE = 5,
	TCA_FCNT = 6,
	TCA_STATS2 = 7,
	TCA_STAB = 8,
	TCA_PAD = 9,
	TCA_DUMP_INVISIBLE = 10,
	TCA_CHAIN = 11,
	TCA_HW_OFFLOAD = 12,
	TCA_INGRESS_BLOCK = 13,
	TCA_EGRESS_BLOCK = 14,
	__TCA_MAX = 15,
};

struct vlan_pcpu_stats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 rx_multicast;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
	u32 rx_errors;
	u32 tx_dropped;
};

struct skb_array {
	struct ptr_ring ring;
};

struct macvlan_port;

struct macvlan_dev {
	struct net_device *dev;
	struct list_head list;
	struct hlist_node hlist;
	struct macvlan_port *port;
	struct net_device *lowerdev;
	void *accel_priv;
	struct vlan_pcpu_stats *pcpu_stats;
	long unsigned int mc_filter[4];
	netdev_features_t set_features;
	enum macvlan_mode mode;
	u16 flags;
	unsigned int macaddr_count;
	struct netpoll *netpoll;
};

struct psched_ratecfg {
	u64 rate_bytes_ps;
	u32 mult;
	u16 overhead;
	u8 linklayer;
	u8 shift;
};

struct mini_Qdisc_pair {
	struct mini_Qdisc miniq1;
	struct mini_Qdisc miniq2;
	struct mini_Qdisc **p_miniq;
};

struct pfifo_fast_priv {
	struct skb_array q[3];
};

struct tc_qopt_offload_stats {
	struct gnet_stats_basic_packed *bstats;
	struct gnet_stats_queue *qstats;
};

enum tc_mq_command {
	TC_MQ_CREATE = 0,
	TC_MQ_DESTROY = 1,
	TC_MQ_STATS = 2,
	TC_MQ_GRAFT = 3,
};

struct tc_mq_opt_offload_graft_params {
	long unsigned int queue;
	u32 child_handle;
};

struct tc_mq_qopt_offload {
	enum tc_mq_command command;
	u32 handle;
	union {
		struct tc_qopt_offload_stats stats;
		struct tc_mq_opt_offload_graft_params graft_params;
	};
};

struct mq_sched {
	struct Qdisc **qdiscs;
};

enum tc_link_layer {
	TC_LINKLAYER_UNAWARE = 0,
	TC_LINKLAYER_ETHERNET = 1,
	TC_LINKLAYER_ATM = 2,
};

enum {
	TCA_STAB_UNSPEC = 0,
	TCA_STAB_BASE = 1,
	TCA_STAB_DATA = 2,
	__TCA_STAB_MAX = 3,
};

struct qdisc_rate_table {
	struct tc_ratespec rate;
	u32 data[256];
	struct qdisc_rate_table *next;
	int refcnt;
};

struct Qdisc_class_common {
	u32 classid;
	struct hlist_node hnode;
};

struct Qdisc_class_hash {
	struct hlist_head *hash;
	unsigned int hashsize;
	unsigned int hashmask;
	unsigned int hashelems;
};

struct qdisc_watchdog {
	u64 last_expires;
	struct hrtimer timer;
	struct Qdisc *qdisc;
};

enum tc_root_command {
	TC_ROOT_GRAFT = 0,
};

struct tc_root_qopt_offload {
	enum tc_root_command command;
	u32 handle;
	bool ingress;
};

struct check_loop_arg {
	struct qdisc_walker w;
	struct Qdisc *p;
	int depth;
};

struct tcf_bind_args {
	struct tcf_walker w;
	long unsigned int base;
	long unsigned int cl;
	u32 classid;
};

struct tc_bind_class_args {
	struct qdisc_walker w;
	long unsigned int new_cl;
	u32 portid;
	u32 clid;
};

struct qdisc_dump_args {
	struct qdisc_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
};

enum net_xmit_qdisc_t {
	__NET_XMIT_STOLEN = 65536,
	__NET_XMIT_BYPASS = 131072,
};

enum {
	TCA_ACT_UNSPEC = 0,
	TCA_ACT_KIND = 1,
	TCA_ACT_OPTIONS = 2,
	TCA_ACT_INDEX = 3,
	TCA_ACT_STATS = 4,
	TCA_ACT_PAD = 5,
	TCA_ACT_COOKIE = 6,
	__TCA_ACT_MAX = 7,
};

enum tca_id {
	TCA_ID_UNSPEC = 0,
	TCA_ID_POLICE = 1,
	TCA_ID_GACT = 5,
	TCA_ID_IPT = 6,
	TCA_ID_PEDIT = 7,
	TCA_ID_MIRRED = 8,
	TCA_ID_NAT = 9,
	TCA_ID_XT = 10,
	TCA_ID_SKBEDIT = 11,
	TCA_ID_VLAN = 12,
	TCA_ID_BPF = 13,
	TCA_ID_CONNMARK = 14,
	TCA_ID_SKBMOD = 15,
	TCA_ID_CSUM = 16,
	TCA_ID_TUNNEL_KEY = 17,
	TCA_ID_SIMP = 22,
	TCA_ID_IFE = 25,
	TCA_ID_SAMPLE = 26,
	TCA_ID_CTINFO = 27,
	TCA_ID_MPLS = 28,
	TCA_ID_CT = 29,
	__TCA_ID_MAX = 255,
};

struct tcf_t {
	__u64 install;
	__u64 lastuse;
	__u64 expires;
	__u64 firstuse;
};

struct psample_group {
	struct list_head list;
	struct net___2 *net;
	u32 group_num;
	u32 refcount;
	u32 seq;
	struct callback_head rcu;
};

typedef int flow_indr_block_bind_cb_t___2(struct net_device *, void *, enum tc_setup_type, void *);

typedef void flow_indr_block_cmd_t___2(struct net_device *, flow_indr_block_bind_cb_t___2 *, void *, enum flow_block_command);

enum qdisc_class_ops_flags {
	QDISC_CLASS_OPS_DOIT_UNLOCKED = 1,
};

enum tcf_proto_ops_flags {
	TCF_PROTO_OPS_DOIT_UNLOCKED = 1,
};

typedef void tcf_chain_head_change_t(struct tcf_proto *, void *);

struct tcf_idrinfo {
	struct mutex lock;
	struct idr action_idr;
	struct net___2 *net;
};

struct tc_action_ops;

struct tc_cookie;

struct tc_action {
	const struct tc_action_ops *ops;
	__u32 type;
	__u32 order;
	struct tcf_idrinfo *idrinfo;
	u32 tcfa_index;
	refcount_t tcfa_refcnt;
	atomic_t tcfa_bindcnt;
	int tcfa_action;
	struct tcf_t tcfa_tm;
	struct gnet_stats_basic_packed tcfa_bstats;
	struct gnet_stats_basic_packed tcfa_bstats_hw;
	struct gnet_stats_queue tcfa_qstats;
	int: 32;
	struct net_rate_estimator *tcfa_rate_est;
	spinlock_t tcfa_lock;
	int: 32;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_basic_cpu *cpu_bstats_hw;
	struct gnet_stats_queue *cpu_qstats;
	struct tc_cookie *act_cookie;
	struct tcf_chain *goto_chain;
} __attribute__((packed));

typedef void (*tc_action_priv_destructor)(void *);

struct tc_action_ops {
	struct list_head head;
	char kind[16];
	enum tca_id id;
	size_t size;
	struct module___2 *owner;
	int (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
	int (*dump)(struct sk_buff *, struct tc_action *, int, int);
	void (*cleanup)(struct tc_action *);
	int (*lookup)(struct net___2 *, struct tc_action **, u32);
	int (*init)(struct net___2 *, struct nlattr *, struct nlattr *, struct tc_action **, int, int, bool, struct tcf_proto *, struct netlink_ext_ack *);
	int (*walk)(struct net___2 *, struct sk_buff *, struct netlink_callback *, int, const struct tc_action_ops *, struct netlink_ext_ack *);
	void (*stats_update)(struct tc_action *, u64, u32, u64, bool);
	size_t (*get_fill_size)(const struct tc_action *);
	struct net_device * (*get_dev)(const struct tc_action *, tc_action_priv_destructor *);
	struct psample_group * (*get_psample_group)(const struct tc_action *, tc_action_priv_destructor *);
};

struct tc_cookie {
	u8 *data;
	u32 len;
	struct callback_head rcu;
};

struct tcf_block_ext_info {
	enum flow_block_binder_type binder_type;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
	u32 block_index;
};

struct tcf_exts {
	__u32 type;
	int nr_actions;
	struct tc_action **actions;
	struct net___2 *net;
	int action;
	int police;
};

enum pedit_header_type {
	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
	__PEDIT_HDR_TYPE_MAX = 6,
};

enum pedit_cmd {
	TCA_PEDIT_KEY_EX_CMD_SET = 0,
	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
	__PEDIT_CMD_MAX = 2,
};

struct tc_pedit_key {
	__u32 mask;
	__u32 val;
	__u32 off;
	__u32 at;
	__u32 offmask;
	__u32 shift;
};

struct tcf_pedit_key_ex {
	enum pedit_header_type htype;
	enum pedit_cmd cmd;
};

struct tcf_pedit {
	struct tc_action common;
	unsigned char tcfp_nkeys;
	unsigned char tcfp_flags;
	struct tc_pedit_key *tcfp_keys;
	struct tcf_pedit_key_ex *tcfp_keys_ex;
};

struct tcf_mirred {
	struct tc_action common;
	int tcfm_eaction;
	bool tcfm_mac_header_xmit;
	struct net_device *tcfm_dev;
	struct list_head tcfm_list;
};

struct tcf_vlan_params {
	int tcfv_action;
	u16 tcfv_push_vid;
	__be16 tcfv_push_proto;
	u8 tcfv_push_prio;
	struct callback_head rcu;
};

struct tcf_vlan {
	struct tc_action common;
	struct tcf_vlan_params *vlan_p;
};

struct tcf_tunnel_key_params {
	struct callback_head rcu;
	int tcft_action;
	struct metadata_dst *tcft_enc_metadata;
};

struct tcf_tunnel_key {
	struct tc_action common;
	struct tcf_tunnel_key_params *params;
};

struct tcf_csum_params {
	u32 update_flags;
	struct callback_head rcu;
};

struct tcf_csum {
	struct tc_action common;
	struct tcf_csum_params *params;
};

struct tcf_gact {
	struct tc_action common;
	u16 tcfg_ptype;
	u16 tcfg_pval;
	int tcfg_paction;
	atomic_t packets;
};

struct tcf_police_params {
	int tcfp_result;
	u32 tcfp_ewma_rate;
	s64 tcfp_burst;
	u32 tcfp_mtu;
	s64 tcfp_mtu_ptoks;
	struct psched_ratecfg rate;
	bool rate_present;
	struct psched_ratecfg peak;
	bool peak_present;
	struct callback_head rcu;
};

struct tcf_police {
	struct tc_action common;
	struct tcf_police_params *params;
	long: 64;
	spinlock_t tcfp_lock;
	s64 tcfp_toks;
	s64 tcfp_ptoks;
	s64 tcfp_t_c;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcf_sample {
	struct tc_action common;
	u32 rate;
	bool truncate;
	u32 trunc_size;
	struct psample_group *psample_group;
	u32 psample_group_num;
	struct list_head tcfm_list;
};

struct tcf_skbedit_params {
	u32 flags;
	u32 priority;
	u32 mark;
	u32 mask;
	u16 queue_mapping;
	u16 ptype;
	struct callback_head rcu;
};

struct tcf_skbedit {
	struct tc_action common;
	struct tcf_skbedit_params *params;
};

struct nf_nat_range2 {
	unsigned int flags;
	union nf_inet_addr min_addr;
	union nf_inet_addr max_addr;
	union nf_conntrack_man_proto min_proto;
	union nf_conntrack_man_proto max_proto;
	union nf_conntrack_man_proto base_proto;
};

struct tcf_ct_params {
	struct nf_conn *tmpl;
	u16 zone;
	u32 mark;
	u32 mark_mask;
	u32 labels[4];
	u32 labels_mask[4];
	struct nf_nat_range2 range;
	bool ipv4_range;
	u16 ct_action;
	struct callback_head rcu;
};

struct tcf_ct {
	struct tc_action common;
	struct tcf_ct_params *params;
};

struct tcf_mpls_params {
	int tcfm_action;
	u32 tcfm_label;
	u8 tcfm_tc;
	u8 tcfm_ttl;
	u8 tcfm_bos;
	__be16 tcfm_proto;
	struct callback_head rcu;
};

struct tcf_mpls {
	struct tc_action common;
	struct tcf_mpls_params *mpls_p;
};

struct tcf_filter_chain_list_item {
	struct list_head list;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
};

struct tcf_net {
	spinlock_t idr_lock;
	struct idr idr;
};

struct tcf_block_owner_item {
	struct list_head list;
	struct Qdisc *q;
	enum flow_block_binder_type binder_type;
};

struct tcf_chain_info {
	struct tcf_proto **pprev;
	struct tcf_proto *next;
};

struct tcf_dump_args {
	struct tcf_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct tcf_block *block;
	struct Qdisc *q;
	u32 parent;
};

struct tcamsg {
	unsigned char tca_family;
	unsigned char tca__pad1;
	short unsigned int tca__pad2;
};

enum {
	TCA_ROOT_UNSPEC = 0,
	TCA_ROOT_TAB = 1,
	TCA_ROOT_FLAGS = 2,
	TCA_ROOT_COUNT = 3,
	TCA_ROOT_TIME_DELTA = 4,
	__TCA_ROOT_MAX = 5,
};

struct tc_action_net {
	struct tcf_idrinfo *idrinfo;
	const struct tc_action_ops *ops;
};

struct tc_fifo_qopt {
	__u32 limit;
};

enum {
	TCA_CGROUP_UNSPEC = 0,
	TCA_CGROUP_ACT = 1,
	TCA_CGROUP_POLICE = 2,
	TCA_CGROUP_EMATCHES = 3,
	__TCA_CGROUP_MAX = 4,
};

struct tcf_ematch_tree_hdr {
	__u16 nmatches;
	__u16 progid;
};

struct tcf_pkt_info {
	unsigned char *ptr;
	int nexthdr;
};

struct tcf_ematch_ops;

struct tcf_ematch {
	struct tcf_ematch_ops *ops;
	long unsigned int data;
	unsigned int datalen;
	u16 matchid;
	u16 flags;
	struct net___2 *net;
};

struct tcf_ematch_ops {
	int kind;
	int datalen;
	int (*change)(struct net___2 *, void *, int, struct tcf_ematch *);
	int (*match)(struct sk_buff *, struct tcf_ematch *, struct tcf_pkt_info *);
	void (*destroy)(struct tcf_ematch *);
	int (*dump)(struct sk_buff *, struct tcf_ematch *);
	struct module___2 *owner;
	struct list_head link;
};

struct tcf_ematch_tree {
	struct tcf_ematch_tree_hdr hdr;
	struct tcf_ematch *matches;
};

struct cls_cgroup_head {
	u32 handle;
	struct tcf_exts exts;
	struct tcf_ematch_tree ematches;
	struct tcf_proto *tp;
	struct rcu_work rwork;
};

enum {
	TCA_EMATCH_TREE_UNSPEC = 0,
	TCA_EMATCH_TREE_HDR = 1,
	TCA_EMATCH_TREE_LIST = 2,
	__TCA_EMATCH_TREE_MAX = 3,
};

struct tcf_ematch_hdr {
	__u16 matchid;
	__u16 kind;
	__u16 flags;
	__u16 pad;
};

struct sockaddr_nl {
	__kernel_sa_family_t nl_family;
	short unsigned int nl_pad;
	__u32 nl_pid;
	__u32 nl_groups;
};

struct nlmsgerr {
	int error;
	struct nlmsghdr msg;
};

enum nlmsgerr_attrs {
	NLMSGERR_ATTR_UNUSED = 0,
	NLMSGERR_ATTR_MSG = 1,
	NLMSGERR_ATTR_OFFS = 2,
	NLMSGERR_ATTR_COOKIE = 3,
	__NLMSGERR_ATTR_MAX = 4,
	NLMSGERR_ATTR_MAX = 3,
};

struct nl_pktinfo {
	__u32 group;
};

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED = 1,
};

enum netlink_skb_flags {
	NETLINK_SKB_DST = 8,
};

struct netlink_notify {
	struct net___2 *net;
	u32 portid;
	int protocol;
};

struct netlink_tap {
	struct net_device *dev;
	struct module___2 *module;
	struct list_head list;
};

struct netlink_sock {
	struct sock sk;
	u32 portid;
	u32 dst_portid;
	u32 dst_group;
	u32 flags;
	u32 subscriptions;
	u32 ngroups;
	long unsigned int *groups;
	long unsigned int state;
	size_t max_recvmsg_len;
	wait_queue_head_t wait;
	bool bound;
	bool cb_running;
	int dump_done_errno;
	struct netlink_callback cb;
	struct mutex *cb_mutex;
	struct mutex cb_def_mutex;
	void (*netlink_rcv)(struct sk_buff *);
	int (*netlink_bind)(struct net___2 *, int);
	void (*netlink_unbind)(struct net___2 *, int);
	struct module___2 *module;
	struct rhash_head node;
	struct callback_head rcu;
	struct work_struct work;
};

struct listeners;

struct netlink_table {
	struct rhashtable hash;
	struct hlist_head mc_list;
	struct listeners *listeners;
	unsigned int flags;
	unsigned int groups;
	struct mutex *cb_mutex;
	struct module___2 *module;
	int (*bind)(struct net___2 *, int);
	void (*unbind)(struct net___2 *, int);
	bool (*compare)(struct net___2 *, struct sock *);
	int registered;
};

struct listeners {
	struct callback_head rcu;
	long unsigned int masks[0];
};

struct netlink_tap_net {
	struct list_head netlink_tap_all;
	struct mutex netlink_tap_lock;
};

struct netlink_compare_arg {
	possible_net_t pnet;
	u32 portid;
};

struct netlink_broadcast_data {
	struct sock *exclude_sk;
	struct net___2 *net;
	u32 portid;
	u32 group;
	int failure;
	int delivery_failure;
	int congested;
	int delivered;
	gfp_t allocation;
	struct sk_buff *skb;
	struct sk_buff *skb2;
	int (*tx_filter)(struct sock *, struct sk_buff *, void *);
	void *tx_data;
};

struct netlink_set_err_data {
	struct sock *exclude_sk;
	u32 portid;
	u32 group;
	int code;
};

struct nl_seq_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
	int link;
};

struct bpf_iter__netlink {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct netlink_sock *sk;
	};
};

enum {
	CTRL_CMD_UNSPEC = 0,
	CTRL_CMD_NEWFAMILY = 1,
	CTRL_CMD_DELFAMILY = 2,
	CTRL_CMD_GETFAMILY = 3,
	CTRL_CMD_NEWOPS = 4,
	CTRL_CMD_DELOPS = 5,
	CTRL_CMD_GETOPS = 6,
	CTRL_CMD_NEWMCAST_GRP = 7,
	CTRL_CMD_DELMCAST_GRP = 8,
	CTRL_CMD_GETMCAST_GRP = 9,
	__CTRL_CMD_MAX = 10,
};

enum {
	CTRL_ATTR_UNSPEC = 0,
	CTRL_ATTR_FAMILY_ID = 1,
	CTRL_ATTR_FAMILY_NAME = 2,
	CTRL_ATTR_VERSION = 3,
	CTRL_ATTR_HDRSIZE = 4,
	CTRL_ATTR_MAXATTR = 5,
	CTRL_ATTR_OPS = 6,
	CTRL_ATTR_MCAST_GROUPS = 7,
	__CTRL_ATTR_MAX = 8,
};

enum {
	CTRL_ATTR_OP_UNSPEC = 0,
	CTRL_ATTR_OP_ID = 1,
	CTRL_ATTR_OP_FLAGS = 2,
	__CTRL_ATTR_OP_MAX = 3,
};

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
	CTRL_ATTR_MCAST_GRP_NAME = 1,
	CTRL_ATTR_MCAST_GRP_ID = 2,
	__CTRL_ATTR_MCAST_GRP_MAX = 3,
};

struct trace_event_raw_bpf_test_finish {
	struct trace_entry ent;
	int err;
	char __data[0];
};

struct trace_event_data_offsets_bpf_test_finish {};

typedef void (*btf_trace_bpf_test_finish)(void *, int *);

struct nf_hook_entries_rcu_head {
	struct callback_head head;
	void *allocation;
};

struct nf_conn;

enum nf_nat_manip_type;

struct nf_nat_hook {
	int (*parse_nat_setup)(struct nf_conn *, enum nf_nat_manip_type, const struct nlattr *);
	void (*decode_session)(struct sk_buff *, struct flowi *);
	unsigned int (*manip_pkt)(struct sk_buff *, struct nf_conn *, enum nf_nat_manip_type, enum ip_conntrack_dir);
};

struct nf_conntrack_tuple;

struct nf_ct_hook {
	int (*update)(struct net___2 *, struct sk_buff *);
	void (*destroy)(struct nf_conntrack *);
	bool (*get_tuple_skb)(struct nf_conntrack_tuple *, const struct sk_buff *);
};

struct nfnl_ct_hook {
	struct nf_conn * (*get_ct)(const struct sk_buff *, enum ip_conntrack_info *);
	size_t (*build_size)(const struct nf_conn *);
	int (*build)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, u_int16_t, u_int16_t);
	int (*parse)(const struct nlattr *, struct nf_conn *);
	int (*attach_expect)(const struct nlattr *, struct nf_conn *, u32, u32);
	void (*seq_adjust)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, s32);
};

struct nf_ipv6_ops {
	void (*route_input)(struct sk_buff *);
	int (*fragment)(struct net___2 *, struct sock *, struct sk_buff *, int (*)(struct net___2 *, struct sock *, struct sk_buff *));
	int (*reroute)(struct sk_buff *, const struct nf_queue_entry *);
};

struct nf_queue_entry {
	struct list_head list;
	struct sk_buff *skb;
	unsigned int id;
	unsigned int hook_index;
	struct nf_hook_state state;
	u16 size;
};

struct nf_loginfo {
	u_int8_t type;
	union {
		struct {
			u_int32_t copy_len;
			u_int16_t group;
			u_int16_t qthreshold;
			u_int16_t flags;
		} ulog;
		struct {
			u_int8_t level;
			u_int8_t logflags;
		} log;
	} u;
};

struct nf_log_buf {
	unsigned int count;
	char buf[1020];
};

struct nf_bridge_info {
	enum {
		BRNF_PROTO_UNCHANGED = 0,
		BRNF_PROTO_8021Q = 1,
		BRNF_PROTO_PPPOE = 2,
	} orig_proto: 8;
	u8 pkt_otherhost: 1;
	u8 in_prerouting: 1;
	u8 bridged_dnat: 1;
	__u16 frag_max_size;
	struct net_device *physindev;
	struct net_device *physoutdev;
	union {
		__be32 ipv4_daddr;
		struct in6_addr ipv6_daddr;
		char neigh_header[8];
	};
};

struct ip_rt_info {
	__be32 daddr;
	__be32 saddr;
	u_int8_t tos;
	u_int32_t mark;
};

struct ip6_rt_info {
	struct in6_addr daddr;
	struct in6_addr saddr;
	u_int32_t mark;
};

struct nf_sockopt_ops {
	struct list_head list;
	u_int8_t pf;
	int set_optmin;
	int set_optmax;
	int (*set)(struct sock *, int, void *, unsigned int);
	int (*compat_set)(struct sock *, int, void *, unsigned int);
	int get_optmin;
	int get_optmax;
	int (*get)(struct sock *, int, void *, int *);
	int (*compat_get)(struct sock *, int, void *, int *);
	struct module___2 *owner;
};

enum nfnetlink_groups {
	NFNLGRP_NONE = 0,
	NFNLGRP_CONNTRACK_NEW = 1,
	NFNLGRP_CONNTRACK_UPDATE = 2,
	NFNLGRP_CONNTRACK_DESTROY = 3,
	NFNLGRP_CONNTRACK_EXP_NEW = 4,
	NFNLGRP_CONNTRACK_EXP_UPDATE = 5,
	NFNLGRP_CONNTRACK_EXP_DESTROY = 6,
	NFNLGRP_NFTABLES = 7,
	NFNLGRP_ACCT_QUOTA = 8,
	NFNLGRP_NFTRACE = 9,
	__NFNLGRP_MAX = 10,
};

struct nfgenmsg {
	__u8 nfgen_family;
	__u8 version;
	__be16 res_id;
};

enum nfnl_batch_attributes {
	NFNL_BATCH_UNSPEC = 0,
	NFNL_BATCH_GENID = 1,
	__NFNL_BATCH_MAX = 2,
};

struct nfnl_callback {
	int (*call)(struct net___2 *, struct sock *, struct sk_buff *, const struct nlmsghdr *, const struct nlattr * const *, struct netlink_ext_ack *);
	int (*call_rcu)(struct net___2 *, struct sock *, struct sk_buff *, const struct nlmsghdr *, const struct nlattr * const *, struct netlink_ext_ack *);
	int (*call_batch)(struct net___2 *, struct sock *, struct sk_buff *, const struct nlmsghdr *, const struct nlattr * const *, struct netlink_ext_ack *);
	const struct nla_policy *policy;
	const u_int16_t attr_count;
};

enum nfnl_abort_action {
	NFNL_ABORT_NONE = 0,
	NFNL_ABORT_AUTOLOAD = 1,
	NFNL_ABORT_VALIDATE = 2,
};

struct nfnetlink_subsystem {
	const char *name;
	__u8 subsys_id;
	__u8 cb_count;
	const struct nfnl_callback *cb;
	struct module___2 *owner;
	int (*commit)(struct net___2 *, struct sk_buff *);
	int (*abort)(struct net___2 *, struct sk_buff *, enum nfnl_abort_action);
	void (*cleanup)(struct net___2 *);
	bool (*valid_genid)(struct net___2 *, u32);
};

struct nfnl_err {
	struct list_head head;
	struct nlmsghdr *nlh;
	int err;
	struct netlink_ext_ack extack;
};

enum {
	NFNL_BATCH_FAILURE = 1,
	NFNL_BATCH_DONE = 2,
	NFNL_BATCH_REPLAY = 4,
};

typedef unsigned int nf_hookfn___2(void *, struct sk_buff___2 *, const struct nf_hook_state *);

enum nft_registers {
	NFT_REG_VERDICT = 0,
	NFT_REG_1 = 1,
	NFT_REG_2 = 2,
	NFT_REG_3 = 3,
	NFT_REG_4 = 4,
	__NFT_REG_MAX = 5,
	NFT_REG32_00 = 8,
	NFT_REG32_01 = 9,
	NFT_REG32_02 = 10,
	NFT_REG32_03 = 11,
	NFT_REG32_04 = 12,
	NFT_REG32_05 = 13,
	NFT_REG32_06 = 14,
	NFT_REG32_07 = 15,
	NFT_REG32_08 = 16,
	NFT_REG32_09 = 17,
	NFT_REG32_10 = 18,
	NFT_REG32_11 = 19,
	NFT_REG32_12 = 20,
	NFT_REG32_13 = 21,
	NFT_REG32_14 = 22,
	NFT_REG32_15 = 23,
};

enum nft_verdicts {
	NFT_CONTINUE = 4294967295,
	NFT_BREAK = 4294967294,
	NFT_JUMP = 4294967293,
	NFT_GOTO = 4294967292,
	NFT_RETURN = 4294967291,
};

enum nft_payload_bases {
	NFT_PAYLOAD_LL_HEADER = 0,
	NFT_PAYLOAD_NETWORK_HEADER = 1,
	NFT_PAYLOAD_TRANSPORT_HEADER = 2,
};

enum nft_trace_types {
	NFT_TRACETYPE_UNSPEC = 0,
	NFT_TRACETYPE_POLICY = 1,
	NFT_TRACETYPE_RETURN = 2,
	NFT_TRACETYPE_RULE = 3,
	__NFT_TRACETYPE_MAX = 4,
};

struct xt_action_param;

struct xt_mtchk_param;

struct xt_mtdtor_param;

struct xt_match {
	struct list_head list;
	const char name[29];
	u_int8_t revision;
	bool (*match)(const struct sk_buff___2 *, struct xt_action_param *);
	int (*checkentry)(const struct xt_mtchk_param *);
	void (*destroy)(const struct xt_mtdtor_param *);
	void (*compat_from_user)(void *, const void *);
	int (*compat_to_user)(void *, const void *);
	struct module___2 *me;
	const char *table;
	unsigned int matchsize;
	unsigned int usersize;
	unsigned int compatsize;
	unsigned int hooks;
	short unsigned int proto;
	short unsigned int family;
};

struct xt_tgchk_param;

struct xt_tgdtor_param;

struct xt_target {
	struct list_head list;
	const char name[29];
	u_int8_t revision;
	unsigned int (*target)(struct sk_buff___2 *, const struct xt_action_param *);
	int (*checkentry)(const struct xt_tgchk_param *);
	void (*destroy)(const struct xt_tgdtor_param *);
	void (*compat_from_user)(void *, const void *);
	int (*compat_to_user)(void *, const void *);
	struct module___2 *me;
	const char *table;
	unsigned int targetsize;
	unsigned int usersize;
	unsigned int compatsize;
	unsigned int hooks;
	short unsigned int proto;
	short unsigned int family;
};

struct xt_action_param {
	union {
		const struct xt_match *match;
		const struct xt_target *target;
	};
	union {
		const void *matchinfo;
		const void *targinfo;
	};
	const struct nf_hook_state *state;
	int fragoff;
	unsigned int thoff;
	bool hotdrop;
};

struct xt_mtchk_param {
	struct net___2 *net;
	const char *table;
	const void *entryinfo;
	const struct xt_match *match;
	void *matchinfo;
	unsigned int hook_mask;
	u_int8_t family;
	bool nft_compat;
};

struct xt_mtdtor_param {
	struct net___2 *net;
	const struct xt_match *match;
	void *matchinfo;
	u_int8_t family;
};

struct xt_tgchk_param {
	struct net___2 *net;
	const char *table;
	const void *entryinfo;
	const struct xt_target *target;
	void *targinfo;
	unsigned int hook_mask;
	u_int8_t family;
	bool nft_compat;
};

struct xt_tgdtor_param {
	struct net___2 *net;
	const struct xt_target *target;
	void *targinfo;
	u_int8_t family;
};

enum flow_offload_tuple_dir {
	FLOW_OFFLOAD_DIR_ORIGINAL = 0,
	FLOW_OFFLOAD_DIR_REPLY = 1,
	FLOW_OFFLOAD_DIR_MAX = 2,
};

struct nft_pktinfo {
	struct sk_buff___2 *skb;
	bool tprot_set;
	u8 tprot;
	struct xt_action_param xt;
};

struct nft_chain;

struct nft_verdict {
	u32 code;
	struct nft_chain *chain;
};

struct nft_rule;

struct nft_table;

struct nft_chain {
	struct nft_rule **rules_gen_0;
	struct nft_rule **rules_gen_1;
	struct list_head rules;
	struct list_head list;
	struct rhlist_head rhlhead;
	struct nft_table *table;
	u64 handle;
	u32 use;
	u8 flags: 6;
	u8 genmask: 2;
	char *name;
	struct nft_rule **rules_next;
};

struct nft_data {
	union {
		u32 data[4];
		struct nft_verdict verdict;
	};
};

struct nft_regs {
	union {
		u32 data[20];
		struct nft_verdict verdict;
	};
};

struct nft_ctx {
	struct net___2 *net;
	struct nft_table *table;
	struct nft_chain *chain;
	const struct nlattr * const *nla;
	u32 portid;
	u32 seq;
	u16 flags;
	u8 family;
	u8 level;
	bool report;
};

struct nft_table {
	struct list_head list;
	struct rhltable chains_ht;
	struct list_head chains;
	struct list_head sets;
	struct list_head objects;
	struct list_head flowtables;
	u64 hgenerator;
	u64 handle;
	u32 use;
	u16 family: 6;
	u16 flags: 8;
	u16 genmask: 2;
	char *name;
};

struct nft_expr_ops;

struct nft_expr {
	const struct nft_expr_ops *ops;
	unsigned char data[0];
};

enum nft_set_extensions {
	NFT_SET_EXT_KEY = 0,
	NFT_SET_EXT_DATA = 1,
	NFT_SET_EXT_FLAGS = 2,
	NFT_SET_EXT_TIMEOUT = 3,
	NFT_SET_EXT_EXPIRATION = 4,
	NFT_SET_EXT_USERDATA = 5,
	NFT_SET_EXT_EXPR = 6,
	NFT_SET_EXT_OBJREF = 7,
	NFT_SET_EXT_NUM = 8,
};

struct nft_expr_type {
	const struct nft_expr_ops * (*select_ops)(const struct nft_ctx *, const struct nlattr * const *);
	void (*release_ops)(const struct nft_expr_ops *);
	const struct nft_expr_ops *ops;
	struct list_head list;
	const char *name;
	struct module___2 *owner;
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 family;
	u8 flags;
};

enum nft_trans_phase {
	NFT_TRANS_PREPARE = 0,
	NFT_TRANS_ABORT = 1,
	NFT_TRANS_COMMIT = 2,
	NFT_TRANS_RELEASE = 3,
};

struct nft_offload_ctx;

struct nft_flow_rule;

struct nft_expr_ops {
	void (*eval)(const struct nft_expr *, struct nft_regs *, const struct nft_pktinfo *);
	int (*clone)(struct nft_expr *, const struct nft_expr *);
	unsigned int size;
	int (*init)(const struct nft_ctx *, const struct nft_expr *, const struct nlattr * const *);
	void (*activate)(const struct nft_ctx *, const struct nft_expr *);
	void (*deactivate)(const struct nft_ctx *, const struct nft_expr *, enum nft_trans_phase);
	void (*destroy)(const struct nft_ctx *, const struct nft_expr *);
	void (*destroy_clone)(const struct nft_ctx *, const struct nft_expr *);
	int (*dump)(struct sk_buff___2 *, const struct nft_expr *);
	int (*validate)(const struct nft_ctx *, const struct nft_expr *, const struct nft_data **);
	bool (*gc)(struct net___2 *, const struct nft_expr *);
	int (*offload)(struct nft_offload_ctx *, struct nft_flow_rule *, const struct nft_expr *);
	bool (*offload_action)(const struct nft_expr *);
	const struct nft_expr_type *type;
	void *data;
};

struct nft_rule {
	struct list_head list;
	u64 handle: 42;
	u64 genmask: 2;
	u64 dlen: 12;
	u64 udata: 1;
	unsigned char data[0];
};

enum nft_chain_types {
	NFT_CHAIN_T_DEFAULT = 0,
	NFT_CHAIN_T_ROUTE = 1,
	NFT_CHAIN_T_NAT = 2,
	NFT_CHAIN_T_MAX = 3,
};

struct nft_chain_type {
	const char *name;
	enum nft_chain_types type;
	int family;
	struct module___2 *owner;
	unsigned int hook_mask;
	nf_hookfn___2 *hooks[5];
	int (*ops_register)(struct net___2 *, const struct nf_hook_ops *);
	void (*ops_unregister)(struct net___2 *, const struct nf_hook_ops *);
};

struct nft_stats {
	u64 bytes;
	u64 pkts;
	struct u64_stats_sync syncp;
};

struct nft_base_chain {
	struct nf_hook_ops ops;
	const struct nft_chain_type *type;
	u8 policy;
	u8 flags;
	struct nft_stats *stats;
	struct nft_chain chain;
	char dev_name[16];
	struct flow_block flow_block;
};

struct nft_object_hash_key {
	const char *name;
	const struct nft_table *table;
};

struct nft_object_ops;

struct nft_object {
	struct list_head list;
	struct rhlist_head rhlhead;
	struct nft_object_hash_key key;
	u32 genmask: 2;
	u32 use: 30;
	u64 handle;
	const struct nft_object_ops *ops;
	unsigned char data[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nft_object_type;

struct nft_object_ops {
	void (*eval)(struct nft_object *, struct nft_regs *, const struct nft_pktinfo *);
	unsigned int size;
	int (*init)(const struct nft_ctx *, const struct nlattr * const *, struct nft_object *);
	void (*destroy)(const struct nft_ctx *, struct nft_object *);
	int (*dump)(struct sk_buff___2 *, struct nft_object *, bool);
	void (*update)(struct nft_object *, struct nft_object *);
	const struct nft_object_type *type;
};

struct nft_object_type {
	const struct nft_object_ops * (*select_ops)(const struct nft_ctx *, const struct nlattr * const *);
	const struct nft_object_ops *ops;
	struct list_head list;
	u32 type;
	unsigned int maxattr;
	struct module___2 *owner;
	const struct nla_policy *policy;
};

struct nft_traceinfo {
	const struct nft_pktinfo *pkt;
	const struct nft_base_chain *basechain;
	const struct nft_chain *chain;
	const struct nft_rule *rule;
	const struct nft_verdict *verdict;
	enum nft_trace_types type;
	bool packet_dumped;
	bool trace;
};

struct nft_cmp_fast_expr {
	u32 data;
	enum nft_registers sreg: 8;
	u8 len;
};

struct nft_payload {
	enum nft_payload_bases base: 8;
	u8 offset;
	u8 len;
	enum nft_registers dreg: 8;
};

typedef void nf_logfn___2(struct net___2 *, u_int8_t, unsigned int, const struct sk_buff___2 *, const struct net_device___2 *, const struct net_device___2 *, const struct nf_loginfo *, const char *);

struct nft_jumpstack {
	const struct nft_chain *chain;
	struct nft_rule * const *rules;
};

enum nf_tables_msg_types {
	NFT_MSG_NEWTABLE = 0,
	NFT_MSG_GETTABLE = 1,
	NFT_MSG_DELTABLE = 2,
	NFT_MSG_NEWCHAIN = 3,
	NFT_MSG_GETCHAIN = 4,
	NFT_MSG_DELCHAIN = 5,
	NFT_MSG_NEWRULE = 6,
	NFT_MSG_GETRULE = 7,
	NFT_MSG_DELRULE = 8,
	NFT_MSG_NEWSET = 9,
	NFT_MSG_GETSET = 10,
	NFT_MSG_DELSET = 11,
	NFT_MSG_NEWSETELEM = 12,
	NFT_MSG_GETSETELEM = 13,
	NFT_MSG_DELSETELEM = 14,
	NFT_MSG_NEWGEN = 15,
	NFT_MSG_GETGEN = 16,
	NFT_MSG_TRACE = 17,
	NFT_MSG_NEWOBJ = 18,
	NFT_MSG_GETOBJ = 19,
	NFT_MSG_DELOBJ = 20,
	NFT_MSG_GETOBJ_RESET = 21,
	NFT_MSG_NEWFLOWTABLE = 22,
	NFT_MSG_GETFLOWTABLE = 23,
	NFT_MSG_DELFLOWTABLE = 24,
	NFT_MSG_MAX = 25,
};

enum nft_list_attributes {
	NFTA_LIST_UNSPEC = 0,
	NFTA_LIST_ELEM = 1,
	__NFTA_LIST_MAX = 2,
};

enum nft_hook_attributes {
	NFTA_HOOK_UNSPEC = 0,
	NFTA_HOOK_HOOKNUM = 1,
	NFTA_HOOK_PRIORITY = 2,
	NFTA_HOOK_DEV = 3,
	__NFTA_HOOK_MAX = 4,
};

enum nft_table_flags {
	NFT_TABLE_F_DORMANT = 1,
};

enum nft_table_attributes {
	NFTA_TABLE_UNSPEC = 0,
	NFTA_TABLE_NAME = 1,
	NFTA_TABLE_FLAGS = 2,
	NFTA_TABLE_USE = 3,
	NFTA_TABLE_HANDLE = 4,
	NFTA_TABLE_PAD = 5,
	__NFTA_TABLE_MAX = 6,
};

enum nft_chain_attributes {
	NFTA_CHAIN_UNSPEC = 0,
	NFTA_CHAIN_TABLE = 1,
	NFTA_CHAIN_HANDLE = 2,
	NFTA_CHAIN_NAME = 3,
	NFTA_CHAIN_HOOK = 4,
	NFTA_CHAIN_POLICY = 5,
	NFTA_CHAIN_USE = 6,
	NFTA_CHAIN_TYPE = 7,
	NFTA_CHAIN_COUNTERS = 8,
	NFTA_CHAIN_PAD = 9,
	NFTA_CHAIN_FLAGS = 10,
	__NFTA_CHAIN_MAX = 11,
};

enum nft_rule_attributes {
	NFTA_RULE_UNSPEC = 0,
	NFTA_RULE_TABLE = 1,
	NFTA_RULE_CHAIN = 2,
	NFTA_RULE_HANDLE = 3,
	NFTA_RULE_EXPRESSIONS = 4,
	NFTA_RULE_COMPAT = 5,
	NFTA_RULE_POSITION = 6,
	NFTA_RULE_USERDATA = 7,
	NFTA_RULE_PAD = 8,
	NFTA_RULE_ID = 9,
	NFTA_RULE_POSITION_ID = 10,
	__NFTA_RULE_MAX = 11,
};

enum nft_set_flags {
	NFT_SET_ANONYMOUS = 1,
	NFT_SET_CONSTANT = 2,
	NFT_SET_INTERVAL = 4,
	NFT_SET_MAP = 8,
	NFT_SET_TIMEOUT = 16,
	NFT_SET_EVAL = 32,
	NFT_SET_OBJECT = 64,
};

enum nft_set_policies {
	NFT_SET_POL_PERFORMANCE = 0,
	NFT_SET_POL_MEMORY = 1,
};

enum nft_set_desc_attributes {
	NFTA_SET_DESC_UNSPEC = 0,
	NFTA_SET_DESC_SIZE = 1,
	__NFTA_SET_DESC_MAX = 2,
};

enum nft_set_attributes {
	NFTA_SET_UNSPEC = 0,
	NFTA_SET_TABLE = 1,
	NFTA_SET_NAME = 2,
	NFTA_SET_FLAGS = 3,
	NFTA_SET_KEY_TYPE = 4,
	NFTA_SET_KEY_LEN = 5,
	NFTA_SET_DATA_TYPE = 6,
	NFTA_SET_DATA_LEN = 7,
	NFTA_SET_POLICY = 8,
	NFTA_SET_DESC = 9,
	NFTA_SET_ID = 10,
	NFTA_SET_TIMEOUT = 11,
	NFTA_SET_GC_INTERVAL = 12,
	NFTA_SET_USERDATA = 13,
	NFTA_SET_PAD = 14,
	NFTA_SET_OBJ_TYPE = 15,
	NFTA_SET_HANDLE = 16,
	__NFTA_SET_MAX = 17,
};

enum nft_set_elem_flags {
	NFT_SET_ELEM_INTERVAL_END = 1,
};

enum nft_set_elem_attributes {
	NFTA_SET_ELEM_UNSPEC = 0,
	NFTA_SET_ELEM_KEY = 1,
	NFTA_SET_ELEM_DATA = 2,
	NFTA_SET_ELEM_FLAGS = 3,
	NFTA_SET_ELEM_TIMEOUT = 4,
	NFTA_SET_ELEM_EXPIRATION = 5,
	NFTA_SET_ELEM_USERDATA = 6,
	NFTA_SET_ELEM_EXPR = 7,
	NFTA_SET_ELEM_PAD = 8,
	NFTA_SET_ELEM_OBJREF = 9,
	__NFTA_SET_ELEM_MAX = 10,
};

enum nft_set_elem_list_attributes {
	NFTA_SET_ELEM_LIST_UNSPEC = 0,
	NFTA_SET_ELEM_LIST_TABLE = 1,
	NFTA_SET_ELEM_LIST_SET = 2,
	NFTA_SET_ELEM_LIST_ELEMENTS = 3,
	NFTA_SET_ELEM_LIST_SET_ID = 4,
	__NFTA_SET_ELEM_LIST_MAX = 5,
};

enum nft_data_types {
	NFT_DATA_VALUE = 0,
	NFT_DATA_VERDICT = 4294967040,
};

enum nft_data_attributes {
	NFTA_DATA_UNSPEC = 0,
	NFTA_DATA_VALUE = 1,
	NFTA_DATA_VERDICT = 2,
	__NFTA_DATA_MAX = 3,
};

enum nft_verdict_attributes {
	NFTA_VERDICT_UNSPEC = 0,
	NFTA_VERDICT_CODE = 1,
	NFTA_VERDICT_CHAIN = 2,
	__NFTA_VERDICT_MAX = 3,
};

enum nft_expr_attributes {
	NFTA_EXPR_UNSPEC = 0,
	NFTA_EXPR_NAME = 1,
	NFTA_EXPR_DATA = 2,
	__NFTA_EXPR_MAX = 3,
};

enum nft_counter_attributes {
	NFTA_COUNTER_UNSPEC = 0,
	NFTA_COUNTER_BYTES = 1,
	NFTA_COUNTER_PACKETS = 2,
	NFTA_COUNTER_PAD = 3,
	__NFTA_COUNTER_MAX = 4,
};

enum nft_gen_attributes {
	NFTA_GEN_UNSPEC = 0,
	NFTA_GEN_ID = 1,
	NFTA_GEN_PROC_PID = 2,
	NFTA_GEN_PROC_NAME = 3,
	__NFTA_GEN_MAX = 4,
};

enum nft_object_attributes {
	NFTA_OBJ_UNSPEC = 0,
	NFTA_OBJ_TABLE = 1,
	NFTA_OBJ_NAME = 2,
	NFTA_OBJ_TYPE = 3,
	NFTA_OBJ_DATA = 4,
	NFTA_OBJ_USE = 5,
	NFTA_OBJ_HANDLE = 6,
	NFTA_OBJ_PAD = 7,
	__NFTA_OBJ_MAX = 8,
};

enum nft_flowtable_attributes {
	NFTA_FLOWTABLE_UNSPEC = 0,
	NFTA_FLOWTABLE_TABLE = 1,
	NFTA_FLOWTABLE_NAME = 2,
	NFTA_FLOWTABLE_HOOK = 3,
	NFTA_FLOWTABLE_USE = 4,
	NFTA_FLOWTABLE_HANDLE = 5,
	NFTA_FLOWTABLE_PAD = 6,
	__NFTA_FLOWTABLE_MAX = 7,
};

enum nft_flowtable_hook_attributes {
	NFTA_FLOWTABLE_HOOK_UNSPEC = 0,
	NFTA_FLOWTABLE_HOOK_NUM = 1,
	NFTA_FLOWTABLE_HOOK_PRIORITY = 2,
	NFTA_FLOWTABLE_HOOK_DEVS = 3,
	__NFTA_FLOWTABLE_HOOK_MAX = 4,
};

enum nft_devices_attributes {
	NFTA_DEVICE_UNSPEC = 0,
	NFTA_DEVICE_NAME = 1,
	__NFTA_DEVICE_MAX = 2,
};

struct nf_flowtable;

struct nf_flowtable_type {
	struct list_head list;
	int family;
	int (*init)(struct nf_flowtable *);
	void (*free)(struct nf_flowtable *);
	nf_hookfn *hook;
	struct module___2 *owner;
};

struct nf_flowtable {
	struct list_head list;
	struct rhashtable rhashtable;
	const struct nf_flowtable_type *type;
	struct delayed_work gc_work;
};

struct nft_data_desc {
	enum nft_data_types type;
	unsigned int len;
};

struct nft_userdata {
	u8 len;
	unsigned char data[0];
};

struct nft_set_elem {
	union {
		u32 buf[16];
		struct nft_data val;
	} key;
	void *priv;
};

struct nft_set;

struct nft_set_iter {
	u8 genmask;
	unsigned int count;
	unsigned int skip;
	int err;
	int (*fn)(const struct nft_ctx *, struct nft_set *, const struct nft_set_iter *, struct nft_set_elem *);
};

struct nft_set_ops;

struct nft_set {
	struct list_head list;
	struct list_head bindings;
	struct nft_table *table;
	possible_net_t net;
	char *name;
	u64 handle;
	u32 ktype;
	u32 dtype;
	u32 objtype;
	u32 size;
	u32 use;
	atomic_t nelems;
	u32 ndeact;
	u64 timeout;
	u32 gc_int;
	u16 policy;
	u16 udlen;
	unsigned char *udata;
	long: 64;
	const struct nft_set_ops *ops;
	u16 flags: 14;
	u16 genmask: 2;
	u8 klen;
	u8 dlen;
	int: 32;
	unsigned char data[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nft_set_desc {
	unsigned int klen;
	unsigned int dlen;
	unsigned int size;
};

enum nft_set_class {
	NFT_SET_CLASS_O_1 = 0,
	NFT_SET_CLASS_O_LOG_N = 1,
	NFT_SET_CLASS_O_N = 2,
};

struct nft_set_estimate {
	u64 size;
	enum nft_set_class lookup;
	enum nft_set_class space;
};

struct nft_set_ext;

struct nft_set_ops {
	bool (*lookup)(const struct net___2 *, const struct nft_set *, const u32 *, const struct nft_set_ext **);
	bool (*update)(struct nft_set *, const u32 *, void * (*)(struct nft_set *, const struct nft_expr *, struct nft_regs *), const struct nft_expr *, struct nft_regs *, const struct nft_set_ext **);
	bool (*delete)(const struct nft_set *, const u32 *);
	int (*insert)(const struct net___2 *, const struct nft_set *, const struct nft_set_elem *, struct nft_set_ext **);
	void (*activate)(const struct net___2 *, const struct nft_set *, const struct nft_set_elem *);
	void * (*deactivate)(const struct net___2 *, const struct nft_set *, const struct nft_set_elem *);
	bool (*flush)(const struct net___2 *, const struct nft_set *, void *);
	void (*remove)(const struct net___2 *, const struct nft_set *, const struct nft_set_elem *);
	void (*walk)(const struct nft_ctx *, struct nft_set *, struct nft_set_iter *);
	void * (*get)(const struct net___2 *, const struct nft_set *, const struct nft_set_elem *, unsigned int);
	u64 (*privsize)(const struct nlattr * const *, const struct nft_set_desc *);
	bool (*estimate)(const struct nft_set_desc *, u32, struct nft_set_estimate *);
	int (*init)(const struct nft_set *, const struct nft_set_desc *, const struct nlattr * const *);
	void (*destroy)(const struct nft_set *);
	void (*gc_init)(const struct nft_set *);
	unsigned int elemsize;
};

struct nft_set_ext {
	u8 genmask;
	u8 offset[8];
	char data[0];
};

struct nft_set_type {
	const struct nft_set_ops ops;
	struct list_head list;
	struct module___2 *owner;
	u32 features;
};

struct nft_set_binding {
	struct list_head list;
	const struct nft_chain *chain;
	u32 flags;
};

struct nft_set_ext_type {
	u8 len;
	u8 align;
};

struct nft_set_ext_tmpl {
	u16 len;
	u8 offset[8];
};

struct nft_set_gc_batch_head {
	struct callback_head rcu;
	const struct nft_set *set;
	unsigned int cnt;
};

struct nft_set_gc_batch {
	struct nft_set_gc_batch_head head;
	void *elems[508];
};

enum nft_offload_dep_type {
	NFT_OFFLOAD_DEP_UNSPEC = 0,
	NFT_OFFLOAD_DEP_NETWORK = 1,
	NFT_OFFLOAD_DEP_TRANSPORT = 2,
};

struct nft_offload_reg {
	u32 key;
	u32 len;
	u32 base_offset;
	u32 offset;
	struct nft_data data;
	struct nft_data mask;
};

struct nft_offload_ctx {
	struct {
		enum nft_offload_dep_type type;
		__be16 l3num;
		u8 protonum;
	} dep;
	unsigned int num_actions;
	struct net___2 *net;
	struct nft_offload_reg regs[24];
};

struct nft_flow_key {
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_control control;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
	long: 48;
};

struct nft_flow_match {
	struct flow_dissector dissector;
	int: 32;
	struct nft_flow_key key;
	struct nft_flow_key mask;
};

struct nft_flow_rule {
	__be16 proto;
	long: 48;
	struct nft_flow_match match;
	struct flow_rule *rule;
};

enum nft_chain_flags {
	NFT_BASE_CHAIN = 1,
	NFT_CHAIN_HW_OFFLOAD = 2,
};

struct nft_flowtable {
	struct list_head list;
	struct nft_table *table;
	char *name;
	int hooknum;
	int priority;
	int ops_len;
	u32 genmask: 2;
	u32 use: 30;
	u64 handle;
	long: 64;
	struct nf_hook_ops *ops;
	struct nf_flowtable data;
};

struct nft_trans {
	struct list_head list;
	int msg_type;
	bool put_net;
	struct nft_ctx ctx;
	char data[0];
};

struct nft_trans_rule {
	struct nft_rule *rule;
	struct nft_flow_rule *flow;
	u32 rule_id;
};

struct nft_trans_set {
	struct nft_set *set;
	u32 set_id;
	bool bound;
};

struct nft_trans_chain {
	bool update;
	char *name;
	struct nft_stats *stats;
	u8 policy;
};

struct nft_trans_table {
	bool update;
	bool enable;
};

struct nft_trans_elem {
	struct nft_set *set;
	struct nft_set_elem elem;
	bool bound;
};

struct nft_trans_obj {
	struct nft_object *obj;
	struct nft_object *newobj;
	bool update;
};

struct nft_trans_flowtable {
	struct nft_flowtable *flowtable;
};

struct nft_immediate_expr {
	struct nft_data data;
	enum nft_registers dreg: 8;
	u8 dlen;
};

enum {
	NFT_VALIDATE_SKIP = 0,
	NFT_VALIDATE_NEED = 1,
	NFT_VALIDATE_DO = 2,
};

struct nft_module_request {
	struct list_head list;
	char module[56];
	bool done;
};

struct nft_chain_hook {
	u32 num;
	s32 priority;
	const struct nft_chain_type *type;
	struct net_device *dev;
};

struct nft_rules_old {
	struct callback_head h;
	struct nft_rule **start;
};

struct nft_expr_info {
	const struct nft_expr_ops *ops;
	struct nlattr *tb[17];
};

struct nft_rule_dump_ctx {
	char *table;
	char *chain;
};

struct nft_set_dump_args {
	const struct netlink_callback *cb;
	struct nft_set_iter iter;
	struct sk_buff *skb;
};

struct nft_set_dump_ctx {
	const struct nft_set *set;
	struct nft_ctx ctx;
};

struct nft_obj_filter {
	char *table;
	u32 type;
};

struct nft_flowtable_filter {
	char *table;
};

enum {
	IP6_FH_F_FRAG = 1,
	IP6_FH_F_AUTH = 2,
	IP6_FH_F_SKIP_RH = 4,
};

enum nft_trace_attributes {
	NFTA_TRACE_UNSPEC = 0,
	NFTA_TRACE_TABLE = 1,
	NFTA_TRACE_CHAIN = 2,
	NFTA_TRACE_RULE_HANDLE = 3,
	NFTA_TRACE_TYPE = 4,
	NFTA_TRACE_VERDICT = 5,
	NFTA_TRACE_ID = 6,
	NFTA_TRACE_LL_HEADER = 7,
	NFTA_TRACE_NETWORK_HEADER = 8,
	NFTA_TRACE_TRANSPORT_HEADER = 9,
	NFTA_TRACE_IIF = 10,
	NFTA_TRACE_IIFTYPE = 11,
	NFTA_TRACE_OIF = 12,
	NFTA_TRACE_OIFTYPE = 13,
	NFTA_TRACE_MARK = 14,
	NFTA_TRACE_NFPROTO = 15,
	NFTA_TRACE_POLICY = 16,
	NFTA_TRACE_PAD = 17,
	__NFTA_TRACE_MAX = 18,
};

enum nft_immediate_attributes {
	NFTA_IMMEDIATE_UNSPEC = 0,
	NFTA_IMMEDIATE_DREG = 1,
	NFTA_IMMEDIATE_DATA = 2,
	__NFTA_IMMEDIATE_MAX = 3,
};

enum nft_cmp_ops {
	NFT_CMP_EQ = 0,
	NFT_CMP_NEQ = 1,
	NFT_CMP_LT = 2,
	NFT_CMP_LTE = 3,
	NFT_CMP_GT = 4,
	NFT_CMP_GTE = 5,
};

enum nft_cmp_attributes {
	NFTA_CMP_UNSPEC = 0,
	NFTA_CMP_SREG = 1,
	NFTA_CMP_OP = 2,
	NFTA_CMP_DATA = 3,
	__NFTA_CMP_MAX = 4,
};

struct nft_cmp_expr {
	struct nft_data data;
	enum nft_registers sreg: 8;
	u8 len;
	enum nft_cmp_ops op: 8;
};

enum nft_range_ops {
	NFT_RANGE_EQ = 0,
	NFT_RANGE_NEQ = 1,
};

enum nft_range_attributes {
	NFTA_RANGE_UNSPEC = 0,
	NFTA_RANGE_SREG = 1,
	NFTA_RANGE_OP = 2,
	NFTA_RANGE_FROM_DATA = 3,
	NFTA_RANGE_TO_DATA = 4,
	__NFTA_RANGE_MAX = 5,
};

struct nft_range_expr {
	struct nft_data data_from;
	struct nft_data data_to;
	enum nft_registers sreg: 8;
	u8 len;
	enum nft_range_ops op: 8;
};

enum nft_bitwise_attributes {
	NFTA_BITWISE_UNSPEC = 0,
	NFTA_BITWISE_SREG = 1,
	NFTA_BITWISE_DREG = 2,
	NFTA_BITWISE_LEN = 3,
	NFTA_BITWISE_MASK = 4,
	NFTA_BITWISE_XOR = 5,
	__NFTA_BITWISE_MAX = 6,
};

struct nft_bitwise {
	enum nft_registers sreg: 8;
	enum nft_registers dreg: 8;
	u8 len;
	struct nft_data mask;
	struct nft_data xor;
};

enum nft_byteorder_ops {
	NFT_BYTEORDER_NTOH = 0,
	NFT_BYTEORDER_HTON = 1,
};

enum nft_byteorder_attributes {
	NFTA_BYTEORDER_UNSPEC = 0,
	NFTA_BYTEORDER_SREG = 1,
	NFTA_BYTEORDER_DREG = 2,
	NFTA_BYTEORDER_OP = 3,
	NFTA_BYTEORDER_LEN = 4,
	NFTA_BYTEORDER_SIZE = 5,
	__NFTA_BYTEORDER_MAX = 6,
};

struct nft_byteorder {
	enum nft_registers sreg: 8;
	enum nft_registers dreg: 8;
	enum nft_byteorder_ops op: 8;
	u8 len;
	u8 size;
};

enum nft_payload_csum_types {
	NFT_PAYLOAD_CSUM_NONE = 0,
	NFT_PAYLOAD_CSUM_INET = 1,
};

enum nft_payload_csum_flags {
	NFT_PAYLOAD_L4CSUM_PSEUDOHDR = 1,
};

enum nft_payload_attributes {
	NFTA_PAYLOAD_UNSPEC = 0,
	NFTA_PAYLOAD_DREG = 1,
	NFTA_PAYLOAD_BASE = 2,
	NFTA_PAYLOAD_OFFSET = 3,
	NFTA_PAYLOAD_LEN = 4,
	NFTA_PAYLOAD_SREG = 5,
	NFTA_PAYLOAD_CSUM_TYPE = 6,
	NFTA_PAYLOAD_CSUM_OFFSET = 7,
	NFTA_PAYLOAD_CSUM_FLAGS = 8,
	__NFTA_PAYLOAD_MAX = 9,
};

struct nft_payload_set {
	enum nft_payload_bases base: 8;
	u8 offset;
	u8 len;
	enum nft_registers sreg: 8;
	u8 csum_type;
	u8 csum_offset;
	u8 csum_flags;
};

enum nft_lookup_flags {
	NFT_LOOKUP_F_INV = 1,
};

enum nft_lookup_attributes {
	NFTA_LOOKUP_UNSPEC = 0,
	NFTA_LOOKUP_SET = 1,
	NFTA_LOOKUP_SREG = 2,
	NFTA_LOOKUP_DREG = 3,
	NFTA_LOOKUP_SET_ID = 4,
	NFTA_LOOKUP_FLAGS = 5,
	__NFTA_LOOKUP_MAX = 6,
};

struct nft_lookup {
	struct nft_set *set;
	enum nft_registers sreg: 8;
	enum nft_registers dreg: 8;
	bool invert;
	struct nft_set_binding binding;
};

enum nft_dynset_ops {
	NFT_DYNSET_OP_ADD = 0,
	NFT_DYNSET_OP_UPDATE = 1,
	NFT_DYNSET_OP_DELETE = 2,
};

enum nft_dynset_flags {
	NFT_DYNSET_F_INV = 1,
};

enum nft_dynset_attributes {
	NFTA_DYNSET_UNSPEC = 0,
	NFTA_DYNSET_SET_NAME = 1,
	NFTA_DYNSET_SET_ID = 2,
	NFTA_DYNSET_OP = 3,
	NFTA_DYNSET_SREG_KEY = 4,
	NFTA_DYNSET_SREG_DATA = 5,
	NFTA_DYNSET_TIMEOUT = 6,
	NFTA_DYNSET_EXPR = 7,
	NFTA_DYNSET_PAD = 8,
	NFTA_DYNSET_FLAGS = 9,
	__NFTA_DYNSET_MAX = 10,
};

struct nft_dynset {
	struct nft_set *set;
	struct nft_set_ext_tmpl tmpl;
	enum nft_dynset_ops op: 8;
	enum nft_registers sreg_key: 8;
	enum nft_registers sreg_data: 8;
	bool invert;
	u64 timeout;
	struct nft_expr *expr;
	struct nft_set_binding binding;
};

enum nft_meta_keys {
	NFT_META_LEN = 0,
	NFT_META_PROTOCOL = 1,
	NFT_META_PRIORITY = 2,
	NFT_META_MARK = 3,
	NFT_META_IIF = 4,
	NFT_META_OIF = 5,
	NFT_META_IIFNAME = 6,
	NFT_META_OIFNAME = 7,
	NFT_META_IIFTYPE = 8,
	NFT_META_OIFTYPE = 9,
	NFT_META_SKUID = 10,
	NFT_META_SKGID = 11,
	NFT_META_NFTRACE = 12,
	NFT_META_RTCLASSID = 13,
	NFT_META_SECMARK = 14,
	NFT_META_NFPROTO = 15,
	NFT_META_L4PROTO = 16,
	NFT_META_BRI_IIFNAME = 17,
	NFT_META_BRI_OIFNAME = 18,
	NFT_META_PKTTYPE = 19,
	NFT_META_CPU = 20,
	NFT_META_IIFGROUP = 21,
	NFT_META_OIFGROUP = 22,
	NFT_META_CGROUP = 23,
	NFT_META_PRANDOM = 24,
	NFT_META_SECPATH = 25,
	NFT_META_IIFKIND = 26,
	NFT_META_OIFKIND = 27,
	NFT_META_BRI_IIFPVID = 28,
	NFT_META_BRI_IIFVPROTO = 29,
	NFT_META_TIME_NS = 30,
	NFT_META_TIME_DAY = 31,
	NFT_META_TIME_HOUR = 32,
};

enum nft_meta_attributes {
	NFTA_META_UNSPEC = 0,
	NFTA_META_DREG = 1,
	NFTA_META_KEY = 2,
	NFTA_META_SREG = 3,
	__NFTA_META_MAX = 4,
};

enum nft_secmark_attributes {
	NFTA_SECMARK_UNSPEC = 0,
	NFTA_SECMARK_CTX = 1,
	__NFTA_SECMARK_MAX = 2,
};

struct nft_meta {
	enum nft_meta_keys key: 8;
	union {
		enum nft_registers dreg: 8;
		enum nft_registers sreg: 8;
	};
};

struct nft_secmark {
	u32 secid;
	char *ctx;
};

enum nft_rt_keys {
	NFT_RT_CLASSID = 0,
	NFT_RT_NEXTHOP4 = 1,
	NFT_RT_NEXTHOP6 = 2,
	NFT_RT_TCPMSS = 3,
	NFT_RT_XFRM = 4,
	__NFT_RT_MAX = 5,
};

enum nft_rt_attributes {
	NFTA_RT_UNSPEC = 0,
	NFTA_RT_DREG = 1,
	NFTA_RT_KEY = 2,
	__NFTA_RT_MAX = 3,
};

struct nft_rt {
	enum nft_rt_keys key: 8;
	enum nft_registers dreg: 8;
};

enum nft_exthdr_flags {
	NFT_EXTHDR_F_PRESENT = 1,
};

enum nft_exthdr_op {
	NFT_EXTHDR_OP_IPV6 = 0,
	NFT_EXTHDR_OP_TCPOPT = 1,
	NFT_EXTHDR_OP_IPV4 = 2,
	__NFT_EXTHDR_OP_MAX = 3,
};

enum nft_exthdr_attributes {
	NFTA_EXTHDR_UNSPEC = 0,
	NFTA_EXTHDR_DREG = 1,
	NFTA_EXTHDR_TYPE = 2,
	NFTA_EXTHDR_OFFSET = 3,
	NFTA_EXTHDR_LEN = 4,
	NFTA_EXTHDR_FLAGS = 5,
	NFTA_EXTHDR_OP = 6,
	NFTA_EXTHDR_SREG = 7,
	__NFTA_EXTHDR_MAX = 8,
};

struct nft_exthdr {
	u8 type;
	u8 offset;
	u8 len;
	u8 op;
	enum nft_registers dreg: 8;
	enum nft_registers sreg: 8;
	u8 flags;
};

struct flow_stats {
	u64 pkts;
	u64 bytes;
	u64 lastused;
};

enum flow_cls_command {
	FLOW_CLS_REPLACE = 0,
	FLOW_CLS_DESTROY = 1,
	FLOW_CLS_STATS = 2,
	FLOW_CLS_TMPLT_CREATE = 3,
	FLOW_CLS_TMPLT_DESTROY = 4,
};

struct flow_cls_common_offload {
	u32 chain_index;
	__be16 protocol;
	u32 prio;
	struct netlink_ext_ack *extack;
};

struct flow_cls_offload {
	struct flow_cls_common_offload common;
	enum flow_cls_command command;
	long unsigned int cookie;
	struct flow_rule *rule;
	struct flow_stats stats;
	u32 classid;
};

struct xt_entry_match {
	union {
		struct {
			__u16 match_size;
			char name[29];
			__u8 revision;
		} user;
		struct {
			__u16 match_size;
			struct xt_match *match;
		} kernel;
		__u16 match_size;
	} u;
	unsigned char data[0];
};

struct xt_entry_target {
	union {
		struct {
			__u16 target_size;
			char name[29];
			__u8 revision;
		} user;
		struct {
			__u16 target_size;
			struct xt_target *target;
		} kernel;
		__u16 target_size;
	} u;
	unsigned char data[0];
};

struct xt_standard_target {
	struct xt_entry_target target;
	int verdict;
};

struct xt_error_target {
	struct xt_entry_target target;
	char errorname[30];
};

struct xt_counters {
	__u64 pcnt;
	__u64 bcnt;
};

struct xt_counters_info {
	char name[32];
	unsigned int num_counters;
	struct xt_counters counters[0];
};

struct xt_percpu_counter_alloc_state {
	unsigned int off;
	const char *mem;
};

struct compat_xt_entry_match {
	union {
		struct {
			u_int16_t match_size;
			char name[29];
			u_int8_t revision;
		} user;
		struct {
			u_int16_t match_size;
			compat_uptr_t match;
		} kernel;
		u_int16_t match_size;
	} u;
	unsigned char data[0];
};

struct compat_xt_entry_target {
	union {
		struct {
			u_int16_t target_size;
			char name[29];
			u_int8_t revision;
		} user;
		struct {
			u_int16_t target_size;
			compat_uptr_t target;
		} kernel;
		u_int16_t target_size;
	} u;
	unsigned char data[0];
};

struct compat_xt_counters {
	compat_u64 pcnt;
	compat_u64 bcnt;
};

struct compat_xt_counters_info {
	char name[32];
	compat_uint_t num_counters;
	struct compat_xt_counters counters[0];
} __attribute__((packed));

struct compat_delta {
	unsigned int offset;
	int delta;
};

struct xt_af {
	struct mutex mutex;
	struct list_head match;
	struct list_head target;
	struct mutex compat_mutex;
	struct compat_delta *compat_tab;
	unsigned int number;
	unsigned int cur;
};

struct compat_xt_standard_target {
	struct compat_xt_entry_target t;
	compat_uint_t verdict;
};

struct compat_xt_error_target {
	struct compat_xt_entry_target t;
	char errorname[30];
};

struct nf_mttg_trav {
	struct list_head *head;
	struct list_head *curr;
	uint8_t class;
};

enum {
	MTTG_TRAV_INIT = 0,
	MTTG_TRAV_NFP_UNSPEC = 1,
	MTTG_TRAV_NFP_SPEC = 2,
	MTTG_TRAV_DONE = 3,
};

struct xt_tcp {
	__u16 spts[2];
	__u16 dpts[2];
	__u8 option;
	__u8 flg_mask;
	__u8 flg_cmp;
	__u8 invflags;
};

struct xt_udp {
	__u16 spts[2];
	__u16 dpts[2];
	__u8 invflags;
};

struct ip_mreqn {
	struct in_addr imr_multiaddr;
	struct in_addr imr_address;
	int imr_ifindex;
};

struct rtmsg {
	unsigned char rtm_family;
	unsigned char rtm_dst_len;
	unsigned char rtm_src_len;
	unsigned char rtm_tos;
	unsigned char rtm_table;
	unsigned char rtm_protocol;
	unsigned char rtm_scope;
	unsigned char rtm_type;
	unsigned int rtm_flags;
};

struct rtvia {
	__kernel_sa_family_t rtvia_family;
	__u8 rtvia_addr[0];
};

struct ip_sf_list;

struct ip_mc_list {
	struct in_device *interface;
	__be32 multiaddr;
	unsigned int sfmode;
	struct ip_sf_list *sources;
	struct ip_sf_list *tomb;
	long unsigned int sfcount[2];
	union {
		struct ip_mc_list *next;
		struct ip_mc_list *next_rcu;
	};
	struct ip_mc_list *next_hash;
	struct timer_list timer;
	int users;
	refcount_t refcnt;
	spinlock_t lock;
	char tm_running;
	char reporter;
	char unsolicit_count;
	char loaded;
	unsigned char gsquery;
	unsigned char crcount;
	struct callback_head rcu;
};

struct ip_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	__be32 sl_addr[0];
};

struct ip_mc_socklist {
	struct ip_mc_socklist *next_rcu;
	struct ip_mreqn multi;
	unsigned int sfmode;
	struct ip_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ip_sf_list {
	struct ip_sf_list *sf_next;
	long unsigned int sf_count[2];
	__be32 sf_inaddr;
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ipv4_addr_key {
	__be32 addr;
	int vif;
};

struct inetpeer_addr {
	union {
		struct ipv4_addr_key a4;
		struct in6_addr a6;
		u32 key[4];
	};
	__u16 family;
};

struct inet_peer {
	struct rb_node rb_node;
	struct inetpeer_addr daddr;
	u32 metrics[17];
	u32 rate_tokens;
	u32 n_redirects;
	long unsigned int rate_last;
	union {
		struct {
			atomic_t rid;
		};
		struct callback_head rcu;
	};
	__u32 dtime;
	refcount_t refcnt;
};

struct uncached_list {
	spinlock_t lock;
	struct list_head head;
};

struct ip_rt_acct {
	__u32 o_bytes;
	__u32 o_packets;
	__u32 i_bytes;
	__u32 i_packets;
};

struct rt_cache_stat {
	unsigned int in_slow_tot;
	unsigned int in_slow_mc;
	unsigned int in_no_route;
	unsigned int in_brd;
	unsigned int in_martian_dst;
	unsigned int in_martian_src;
	unsigned int out_slow_tot;
	unsigned int out_slow_mc;
};

struct icmphdr {
	__u8 type;
	__u8 code;
	__sum16 checksum;
	union {
		struct {
			__be16 id;
			__be16 sequence;
		} echo;
		__be32 gateway;
		struct {
			__be16 __unused;
			__be16 mtu;
		} frag;
		__u8 reserved[4];
	} un;
};

struct fib_prop {
	int error;
	u8 scope;
};

struct net_offload {
	struct offload_callbacks callbacks;
	unsigned int flags;
};

struct raw_hashinfo {
	rwlock_t lock;
	struct hlist_head ht[256];
};

enum ip_defrag_users {
	IP_DEFRAG_LOCAL_DELIVER = 0,
	IP_DEFRAG_CALL_RA_CHAIN = 1,
	IP_DEFRAG_CONNTRACK_IN = 2,
	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
	IP_DEFRAG_CONNTRACK_OUT = 65538,
	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
	IP_DEFRAG_VS_IN = 196610,
	IP_DEFRAG_VS_OUT = 196611,
	IP_DEFRAG_VS_FWD = 196612,
	IP_DEFRAG_AF_PACKET = 196613,
	IP_DEFRAG_MACVLAN = 196614,
};

enum {
	INET_FRAG_FIRST_IN = 1,
	INET_FRAG_LAST_IN = 2,
	INET_FRAG_COMPLETE = 4,
	INET_FRAG_HASH_DEAD = 8,
};

struct ipq {
	struct inet_frag_queue q;
	u8 ecn;
	u16 max_df_size;
	int iif;
	unsigned int rid;
	struct inet_peer *peer;
};

struct ip_options_data {
	struct ip_options_rcu opt;
	char data[40];
};

struct ipcm_cookie {
	struct sockcm_cookie sockc;
	__be32 addr;
	int oif;
	struct ip_options_rcu *opt;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
};

struct ip_fraglist_iter {
	struct sk_buff *frag;
	struct iphdr *iph;
	int offset;
	unsigned int hlen;
};

struct ip_frag_state {
	bool DF;
	unsigned int hlen;
	unsigned int ll_rs;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	__be16 not_last_frag;
};

struct ip_reply_arg {
	struct kvec iov[1];
	int flags;
	__wsum csum;
	int csumoffset;
	int bound_dev_if;
	u8 tos;
	kuid_t uid;
};

struct ip_mreq_source {
	__be32 imr_multiaddr;
	__be32 imr_interface;
	__be32 imr_sourceaddr;
};

struct ip_msfilter {
	__be32 imsf_multiaddr;
	__be32 imsf_interface;
	__u32 imsf_fmode;
	__u32 imsf_numsrc;
	__be32 imsf_slist[1];
};

struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst;
	struct in_addr ipi_addr;
};

enum {
	BPFILTER_IPT_SO_SET_REPLACE = 64,
	BPFILTER_IPT_SO_SET_ADD_COUNTERS = 65,
	BPFILTER_IPT_SET_MAX = 66,
};

enum {
	BPFILTER_IPT_SO_GET_INFO = 64,
	BPFILTER_IPT_SO_GET_ENTRIES = 65,
	BPFILTER_IPT_SO_GET_REVISION_MATCH = 66,
	BPFILTER_IPT_SO_GET_REVISION_TARGET = 67,
	BPFILTER_IPT_GET_MAX = 68,
};

struct tcpvegas_info {
	__u32 tcpv_enabled;
	__u32 tcpv_rttcnt;
	__u32 tcpv_rtt;
	__u32 tcpv_minrtt;
};

struct tcp_dctcp_info {
	__u16 dctcp_enabled;
	__u16 dctcp_ce_state;
	__u32 dctcp_alpha;
	__u32 dctcp_ab_ecn;
	__u32 dctcp_ab_tot;
};

struct tcp_bbr_info {
	__u32 bbr_bw_lo;
	__u32 bbr_bw_hi;
	__u32 bbr_min_rtt;
	__u32 bbr_pacing_gain;
	__u32 bbr_cwnd_gain;
};

union tcp_cc_info {
	struct tcpvegas_info vegas;
	struct tcp_dctcp_info dctcp;
	struct tcp_bbr_info bbr;
};

enum {
	BPF_TCP_ESTABLISHED = 1,
	BPF_TCP_SYN_SENT = 2,
	BPF_TCP_SYN_RECV = 3,
	BPF_TCP_FIN_WAIT1 = 4,
	BPF_TCP_FIN_WAIT2 = 5,
	BPF_TCP_TIME_WAIT = 6,
	BPF_TCP_CLOSE = 7,
	BPF_TCP_CLOSE_WAIT = 8,
	BPF_TCP_LAST_ACK = 9,
	BPF_TCP_LISTEN = 10,
	BPF_TCP_CLOSING = 11,
	BPF_TCP_NEW_SYN_RECV = 12,
	BPF_TCP_MAX_STATES = 13,
};

enum {
	TCP_FLAG_CWR = 32768,
	TCP_FLAG_ECE = 16384,
	TCP_FLAG_URG = 8192,
	TCP_FLAG_ACK = 4096,
	TCP_FLAG_PSH = 2048,
	TCP_FLAG_RST = 1024,
	TCP_FLAG_SYN = 512,
	TCP_FLAG_FIN = 256,
	TCP_RESERVED_BITS = 15,
	TCP_DATA_OFFSET = 240,
};

struct tcp_fullnat_real_opt {
	__u32 real_ip;
	__u16 real_port;
};

struct tcp_repair_opt {
	__u32 opt_code;
	__u32 opt_val;
};

struct tcp_repair_window {
	__u32 snd_wl1;
	__u32 snd_wnd;
	__u32 max_window;
	__u32 rcv_wnd;
	__u32 rcv_wup;
};

enum {
	TCP_NO_QUEUE = 0,
	TCP_RECV_QUEUE = 1,
	TCP_SEND_QUEUE = 2,
	TCP_QUEUES_NR = 3,
};

struct tcp_info {
	__u8 tcpi_state;
	__u8 tcpi_ca_state;
	__u8 tcpi_retransmits;
	__u8 tcpi_probes;
	__u8 tcpi_backoff;
	__u8 tcpi_options;
	__u8 tcpi_snd_wscale: 4;
	__u8 tcpi_rcv_wscale: 4;
	__u8 tcpi_delivery_rate_app_limited: 1;
	__u32 tcpi_rto;
	__u32 tcpi_ato;
	__u32 tcpi_snd_mss;
	__u32 tcpi_rcv_mss;
	__u32 tcpi_unacked;
	__u32 tcpi_sacked;
	__u32 tcpi_lost;
	__u32 tcpi_retrans;
	__u32 tcpi_fackets;
	__u32 tcpi_last_data_sent;
	__u32 tcpi_last_ack_sent;
	__u32 tcpi_last_data_recv;
	__u32 tcpi_last_ack_recv;
	__u32 tcpi_pmtu;
	__u32 tcpi_rcv_ssthresh;
	__u32 tcpi_rtt;
	__u32 tcpi_rttvar;
	__u32 tcpi_snd_ssthresh;
	__u32 tcpi_snd_cwnd;
	__u32 tcpi_advmss;
	__u32 tcpi_reordering;
	__u32 tcpi_rcv_rtt;
	__u32 tcpi_rcv_space;
	__u32 tcpi_total_retrans;
	__u64 tcpi_pacing_rate;
	__u64 tcpi_max_pacing_rate;
	__u64 tcpi_bytes_acked;
	__u64 tcpi_bytes_received;
	__u32 tcpi_segs_out;
	__u32 tcpi_segs_in;
	__u32 tcpi_notsent_bytes;
	__u32 tcpi_min_rtt;
	__u32 tcpi_data_segs_in;
	__u32 tcpi_data_segs_out;
	__u64 tcpi_delivery_rate;
	__u64 tcpi_busy_time;
	__u64 tcpi_rwnd_limited;
	__u64 tcpi_sndbuf_limited;
	__u32 tcpi_delivered;
	__u32 tcpi_delivered_ce;
	__u64 tcpi_bytes_sent;
	__u64 tcpi_bytes_retrans;
	__u32 tcpi_dsack_dups;
	__u32 tcpi_reord_seen;
	__u32 tcpi_rcv_ooopack;
	__u32 tcpi_snd_wnd;
};

enum {
	TCP_NLA_PAD = 0,
	TCP_NLA_BUSY = 1,
	TCP_NLA_RWND_LIMITED = 2,
	TCP_NLA_SNDBUF_LIMITED = 3,
	TCP_NLA_DATA_SEGS_OUT = 4,
	TCP_NLA_TOTAL_RETRANS = 5,
	TCP_NLA_PACING_RATE = 6,
	TCP_NLA_DELIVERY_RATE = 7,
	TCP_NLA_SND_CWND = 8,
	TCP_NLA_REORDERING = 9,
	TCP_NLA_MIN_RTT = 10,
	TCP_NLA_RECUR_RETRANS = 11,
	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
	TCP_NLA_SNDQ_SIZE = 13,
	TCP_NLA_CA_STATE = 14,
	TCP_NLA_SND_SSTHRESH = 15,
	TCP_NLA_DELIVERED = 16,
	TCP_NLA_DELIVERED_CE = 17,
	TCP_NLA_BYTES_SENT = 18,
	TCP_NLA_BYTES_RETRANS = 19,
	TCP_NLA_DSACK_DUPS = 20,
	TCP_NLA_REORD_SEEN = 21,
	TCP_NLA_SRTT = 22,
};

struct tcp_zerocopy_receive {
	__u64 address;
	__u32 length;
	__u32 recv_skip_hint;
};

enum inet_csk_ack_state_t {
	ICSK_ACK_SCHED = 1,
	ICSK_ACK_TIMER = 2,
	ICSK_ACK_PUSHED = 4,
	ICSK_ACK_PUSHED2 = 8,
	ICSK_ACK_NOW = 16,
};

struct tcp_md5sig_pool {
	struct ahash_request *md5_req;
	void *scratch;
};

enum tcp_chrono {
	TCP_CHRONO_UNSPEC = 0,
	TCP_CHRONO_BUSY = 1,
	TCP_CHRONO_RWND_LIMITED = 2,
	TCP_CHRONO_SNDBUF_LIMITED = 3,
	__TCP_CHRONO_MAX = 4,
};

struct tcp_splice_state {
	struct pipe_inode_info *pipe;
	size_t len;
	unsigned int flags;
};

struct tcp_sack_block_wire {
	__be32 start_seq;
	__be32 end_seq;
};

struct mptcp_ext {
	union {
		u64 data_ack;
		u32 data_ack32;
	};
	u64 data_seq;
	u32 subflow_seq;
	u16 data_len;
	__sum16 csum;
	u8 use_map: 1;
	u8 dsn64: 1;
	u8 data_fin: 1;
	u8 use_ack: 1;
	u8 ack64: 1;
	u8 mpc_map: 1;
	u8 frozen: 1;
	u8 reset_transient: 1;
	u8 reset_reason: 4;
	u8 csum_reqd: 1;
};

enum tcp_queue {
	TCP_FRAG_IN_WRITE_QUEUE = 0,
	TCP_FRAG_IN_RTX_QUEUE = 1,
};

enum tcp_ca_ack_event_flags {
	CA_ACK_SLOWPATH = 1,
	CA_ACK_WIN_UPDATE = 2,
	CA_ACK_ECE = 4,
};

struct tcp_sacktag_state {
	u32 reord;
	u64 first_sackt;
	u64 last_sackt;
	struct rate_sample *rate;
	int flag;
	unsigned int mss_now;
};

enum pkt_hash_types {
	PKT_HASH_TYPE_NONE = 0,
	PKT_HASH_TYPE_L2 = 1,
	PKT_HASH_TYPE_L3 = 2,
	PKT_HASH_TYPE_L4 = 3,
};

enum {
	SOCK_OPS_RET_OK = 256,
	SOCK_OPS_RET_REJECT = 257,
};

enum tsq_flags {
	TSQF_THROTTLED = 1,
	TSQF_QUEUED = 2,
	TCPF_TSQ_DEFERRED = 4,
	TCPF_WRITE_TIMER_DEFERRED = 8,
	TCPF_DELACK_TIMER_DEFERRED = 16,
	TCPF_MTU_REDUCED_DEFERRED = 32,
};

struct mptcp_rm_list {
	u8 ids[8];
	u8 nr;
};

struct mptcp_addr_info {
	u8 id;
	sa_family_t family;
	__be16 port;
	union {
		struct in_addr addr;
		struct in6_addr addr6;
	};
};

struct mptcp_out_options {
	u16 suboptions;
	struct mptcp_rm_list rm_list;
	u8 join_id;
	u8 backup;
	u8 reset_reason: 4;
	u8 reset_transient: 1;
	u8 csum_reqd: 1;
	u8 allow_join_id0: 1;
	union {
		struct {
			u64 sndr_key;
			u64 rcvr_key;
			u64 data_seq;
			u32 subflow_seq;
			u16 data_len;
			__sum16 csum;
		};
		struct {
			struct mptcp_addr_info addr;
			u64 ahmac;
		};
		struct {
			struct mptcp_ext ext_copy;
			u64 fail_seq;
		};
		struct {
			u32 nonce;
			u32 token;
			u64 thmac;
			u8 hmac[20];
		};
	};
};

struct tcp_out_options {
	u16 options;
	u16 mss;
	u8 ws;
	u8 num_sack_blocks;
	u8 hash_size;
	__u8 *hash_location;
	__u32 tsval;
	__u32 tsecr;
	struct tcp_fastopen_cookie *fastopen_cookie;
	struct mptcp_out_options mptcp;
};

struct tsq_tasklet {
	struct tasklet_struct tasklet;
	struct list_head head;
};

struct tcp_md5sig {
	struct __kernel_sockaddr_storage tcpm_addr;
	__u8 tcpm_flags;
	__u8 tcpm_prefixlen;
	__u16 tcpm_keylen;
	__u32 __tcpm_pad;
	__u8 tcpm_key[80];
};

struct tcp_timewait_sock {
	struct inet_timewait_sock tw_sk;
	u32 tw_rcv_wnd;
	u32 tw_ts_offset;
	u32 tw_ts_recent;
	u32 tw_last_oow_ack_time;
	int tw_ts_recent_stamp;
	u32 tw_tx_delay;
	struct tcp_md5sig_key *tw_md5_key;
};

struct icmp_err {
	int errno;
	unsigned int fatal: 1;
};

enum tcp_tw_status {
	TCP_TW_SUCCESS = 0,
	TCP_TW_RST = 1,
	TCP_TW_ACK = 2,
	TCP_TW_SYN = 3,
};

struct tcp4_pseudohdr {
	__be32 saddr;
	__be32 daddr;
	__u8 pad;
	__u8 protocol;
	__be16 len;
};

enum tcp_seq_states {
	TCP_SEQ_STATE_LISTENING = 0,
	TCP_SEQ_STATE_ESTABLISHED = 1,
};

struct tcp_seq_afinfo {
	sa_family_t family;
};

struct tcp_iter_state {
	struct seq_net_private p;
	enum tcp_seq_states state;
	struct sock *syn_wait_sk;
	struct tcp_seq_afinfo *bpf_seq_afinfo;
	int bucket;
	int offset;
	int sbucket;
	int num;
	loff_t last_pos;
};

struct bpf_iter__tcp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct sock_common *sk_common;
	};
	uid_t uid;
};

enum tcp_metric_index {
	TCP_METRIC_RTT = 0,
	TCP_METRIC_RTTVAR = 1,
	TCP_METRIC_SSTHRESH = 2,
	TCP_METRIC_CWND = 3,
	TCP_METRIC_REORDERING = 4,
	TCP_METRIC_RTT_US = 5,
	TCP_METRIC_RTTVAR_US = 6,
	__TCP_METRIC_MAX = 7,
};

enum {
	TCP_METRICS_ATTR_UNSPEC = 0,
	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
	TCP_METRICS_ATTR_AGE = 3,
	TCP_METRICS_ATTR_TW_TSVAL = 4,
	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
	TCP_METRICS_ATTR_VALS = 6,
	TCP_METRICS_ATTR_FOPEN_MSS = 7,
	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
	TCP_METRICS_ATTR_PAD = 13,
	__TCP_METRICS_ATTR_MAX = 14,
};

enum {
	TCP_METRICS_CMD_UNSPEC = 0,
	TCP_METRICS_CMD_GET = 1,
	TCP_METRICS_CMD_DEL = 2,
	__TCP_METRICS_CMD_MAX = 3,
};

struct tcp_fastopen_metrics {
	u16 mss;
	u16 syn_loss: 10;
	u16 try_exp: 2;
	long unsigned int last_syn_loss;
	struct tcp_fastopen_cookie cookie;
};

struct tcp_metrics_block {
	struct tcp_metrics_block *tcpm_next;
	possible_net_t tcpm_net;
	struct inetpeer_addr tcpm_saddr;
	struct inetpeer_addr tcpm_daddr;
	long unsigned int tcpm_stamp;
	u32 tcpm_lock;
	u32 tcpm_vals[5];
	struct tcp_fastopen_metrics tcpm_fastopen;
	struct callback_head callback_head;
};

struct tcpm_hash_bucket {
	struct tcp_metrics_block *chain;
};

struct icmp_filter {
	__u32 data;
};

struct raw_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct raw_sock {
	struct inet_sock inet;
	struct icmp_filter filter;
	u32 ipmr_table;
};

struct raw_frag_vec {
	struct msghdr *msg;
	union {
		struct icmphdr icmph;
		char c[1];
	} hdr;
	int hlen;
};

struct ip_tunnel_encap {
	u16 type;
	u16 flags;
	__be16 sport;
	__be16 dport;
};

struct ip_tunnel_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
	int (*err_handler)(struct sk_buff *, u32);
};

struct udp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u16 cscov;
	__u8 partial_cov;
};

struct udp_dev_scratch {
	u32 _tsize_state;
	u16 len;
	bool is_linear;
	bool csum_unnecessary;
};

struct udp_seq_afinfo {
	sa_family_t family;
	struct udp_table *udp_table;
};

struct udp_iter_state {
	struct seq_net_private p;
	int bucket;
	struct udp_seq_afinfo *bpf_seq_afinfo;
};

struct bpf_iter__udp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct udp_sock *udp_sk;
	};
	uid_t uid;
	int: 32;
	int bucket;
};

struct inet_protosw {
	struct list_head list;
	short unsigned int type;
	short unsigned int protocol;
	struct proto *prot;
	const struct proto_ops *ops;
	unsigned char flags;
};

typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef struct sock * (*udp_lookup_t)(struct sk_buff *, __be16, __be16);

struct arpreq {
	struct sockaddr arp_pa;
	struct sockaddr arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
};

enum {
	AX25_VALUES_IPDEFMODE = 0,
	AX25_VALUES_AXDEFMODE = 1,
	AX25_VALUES_BACKOFF = 2,
	AX25_VALUES_CONMODE = 3,
	AX25_VALUES_WINDOW = 4,
	AX25_VALUES_EWINDOW = 5,
	AX25_VALUES_T1 = 6,
	AX25_VALUES_T2 = 7,
	AX25_VALUES_T3 = 8,
	AX25_VALUES_IDLE = 9,
	AX25_VALUES_N2 = 10,
	AX25_VALUES_PACLEN = 11,
	AX25_VALUES_PROTOCOL = 12,
	AX25_VALUES_DS_TIMEOUT = 13,
	AX25_MAX_VALUES = 14,
};

enum ip_conntrack_status {
	IPS_EXPECTED_BIT = 0,
	IPS_EXPECTED = 1,
	IPS_SEEN_REPLY_BIT = 1,
	IPS_SEEN_REPLY = 2,
	IPS_ASSURED_BIT = 2,
	IPS_ASSURED = 4,
	IPS_CONFIRMED_BIT = 3,
	IPS_CONFIRMED = 8,
	IPS_SRC_NAT_BIT = 4,
	IPS_SRC_NAT = 16,
	IPS_DST_NAT_BIT = 5,
	IPS_DST_NAT = 32,
	IPS_NAT_MASK = 48,
	IPS_SEQ_ADJUST_BIT = 6,
	IPS_SEQ_ADJUST = 64,
	IPS_SRC_NAT_DONE_BIT = 7,
	IPS_SRC_NAT_DONE = 128,
	IPS_DST_NAT_DONE_BIT = 8,
	IPS_DST_NAT_DONE = 256,
	IPS_NAT_DONE_MASK = 384,
	IPS_DYING_BIT = 9,
	IPS_DYING = 512,
	IPS_FIXED_TIMEOUT_BIT = 10,
	IPS_FIXED_TIMEOUT = 1024,
	IPS_TEMPLATE_BIT = 11,
	IPS_TEMPLATE = 2048,
	IPS_UNTRACKED_BIT = 12,
	IPS_UNTRACKED = 4096,
	IPS_HELPER_BIT = 13,
	IPS_HELPER = 8192,
	IPS_OFFLOAD_BIT = 14,
	IPS_OFFLOAD = 16384,
	IPS_UNCHANGEABLE_MASK = 19449,
	__IPS_MAX_BIT = 15,
};

enum {
	XFRM_LOOKUP_ICMP = 1,
	XFRM_LOOKUP_QUEUE = 2,
	XFRM_LOOKUP_KEEP_DST_REF = 4,
};

struct icmp_bxm {
	struct sk_buff *skb;
	int offset;
	int data_len;
	struct {
		struct icmphdr icmph;
		__be32 times[3];
	} data;
	int head_len;
	struct ip_options_data replyopts;
};

struct icmp_control {
	enum skb_drop_reason (*handler)(struct sk_buff *);
	short int error;
};

struct ifaddrmsg {
	__u8 ifa_family;
	__u8 ifa_prefixlen;
	__u8 ifa_flags;
	__u8 ifa_scope;
	__u32 ifa_index;
};

enum {
	IFA_UNSPEC = 0,
	IFA_ADDRESS = 1,
	IFA_LOCAL = 2,
	IFA_LABEL = 3,
	IFA_BROADCAST = 4,
	IFA_ANYCAST = 5,
	IFA_CACHEINFO = 6,
	IFA_MULTICAST = 7,
	IFA_FLAGS = 8,
	IFA_RT_PRIORITY = 9,
	IFA_TARGET_NETNSID = 10,
	__IFA_MAX = 11,
};

struct ifa_cacheinfo {
	__u32 ifa_prefered;
	__u32 ifa_valid;
	__u32 cstamp;
	__u32 tstamp;
};

enum {
	IFLA_INET_UNSPEC = 0,
	IFLA_INET_CONF = 1,
	__IFLA_INET_MAX = 2,
};

typedef int gifconf_func_t___2(struct net_device *, char *, int, int);

struct in_validator_info {
	__be32 ivi_addr;
	struct in_device *ivi_dev;
	struct netlink_ext_ack *extack;
};

struct netconfmsg {
	__u8 ncm_family;
};

enum {
	NETCONFA_UNSPEC = 0,
	NETCONFA_IFINDEX = 1,
	NETCONFA_FORWARDING = 2,
	NETCONFA_RP_FILTER = 3,
	NETCONFA_MC_FORWARDING = 4,
	NETCONFA_PROXY_NEIGH = 5,
	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
	NETCONFA_INPUT = 7,
	NETCONFA_BC_FORWARDING = 8,
	__NETCONFA_MAX = 9,
};

struct inet_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
};

struct devinet_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table devinet_vars[33];
};

struct pingv6_ops {
	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	int (*icmpv6_err_convert)(u8, u8, int *);
	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*ipv6_chk_addr)(struct net___2 *, const struct in6_addr *, const struct net_device *, int);
};

struct igmphdr {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
};

struct igmpv3_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	__be32 grec_mca;
	__be32 grec_src[0];
};

struct igmpv3_report {
	__u8 type;
	__u8 resv1;
	__sum16 csum;
	__be16 resv2;
	__be16 ngrec;
	struct igmpv3_grec grec[0];
};

struct igmpv3_query {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
	__u8 qrv: 3;
	__u8 suppress: 1;
	__u8 resv: 4;
	__u8 qqic;
	__be16 nsrcs;
	__be32 srcs[0];
};

struct igmp_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *in_dev;
};

struct igmp_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *idev;
	struct ip_mc_list *im;
};

struct fib_config {
	u8 fc_dst_len;
	u8 fc_tos;
	u8 fc_protocol;
	u8 fc_scope;
	u8 fc_type;
	u8 fc_gw_family;
	u32 fc_table;
	__be32 fc_dst;
	union {
		__be32 fc_gw4;
		struct in6_addr fc_gw6;
	};
	int fc_oif;
	u32 fc_flags;
	u32 fc_priority;
	__be32 fc_prefsrc;
	u32 fc_nh_id;
	struct nlattr *fc_mx;
	struct rtnexthop *fc_mp;
	int fc_mx_len;
	int fc_mp_len;
	u32 fc_flow;
	u32 fc_nlflags;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct fib_result_nl {
	__be32 fl_addr;
	u32 fl_mark;
	unsigned char fl_tos;
	unsigned char fl_scope;
	unsigned char tb_id_in;
	unsigned char tb_id;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	int err;
};

struct fib_dump_filter {
	u32 table_id;
	bool filter_set;
	bool dump_routes;
	bool dump_exceptions;
	unsigned char protocol;
	unsigned char rt_type;
	unsigned int flags;
	struct net_device *dev;
};

struct fib_nh_notifier_info {
	struct fib_notifier_info info;
	struct fib_nh *fib_nh;
};

struct fib_alias {
	struct hlist_node fa_list;
	struct fib_info *fa_info;
	u8 fa_tos;
	u8 fa_type;
	u8 fa_state;
	u8 fa_slen;
	u32 tb_id;
	s16 fa_default;
	struct callback_head rcu;
};

struct fib_entry_notifier_info {
	struct fib_notifier_info info;
	u32 dst;
	int dst_len;
	struct fib_info *fi;
	u8 tos;
	u8 type;
	u32 tb_id;
};

typedef unsigned int t_key;

struct key_vector {
	t_key key;
	unsigned char pos;
	unsigned char bits;
	unsigned char slen;
	union {
		struct hlist_head leaf;
		struct key_vector *tnode[0];
	};
};

struct tnode {
	struct callback_head rcu;
	t_key empty_children;
	t_key full_children;
	struct key_vector *parent;
	struct key_vector kv[1];
};

struct trie_use_stats {
	unsigned int gets;
	unsigned int backtrack;
	unsigned int semantic_match_passed;
	unsigned int semantic_match_miss;
	unsigned int null_node_hit;
	unsigned int resize_node_skipped;
};

struct trie_stat {
	unsigned int totdepth;
	unsigned int maxdepth;
	unsigned int tnodes;
	unsigned int leaves;
	unsigned int nullpointers;
	unsigned int prefixes;
	unsigned int nodesizes[32];
};

struct trie {
	struct key_vector kv[1];
	struct trie_use_stats *stats;
};

struct fib_trie_iter {
	struct seq_net_private p;
	struct fib_table *tb;
	struct key_vector *tnode;
	unsigned int index;
	unsigned int depth;
};

struct fib_route_iter {
	struct seq_net_private p;
	struct fib_table *main_tb;
	struct key_vector *tnode;
	loff_t pos;
	t_key key;
};

struct ipfrag_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	};
	struct sk_buff *next_frag;
	int frag_run_len;
};

struct icmpv6_echo {
	__be16 identifier;
	__be16 sequence;
};

struct icmpv6_nd_advt {
	__u32 reserved: 5;
	__u32 override: 1;
	__u32 solicited: 1;
	__u32 router: 1;
	__u32 reserved2: 24;
};

struct icmpv6_nd_ra {
	__u8 hop_limit;
	__u8 reserved: 3;
	__u8 router_pref: 2;
	__u8 home_agent: 1;
	__u8 other: 1;
	__u8 managed: 1;
	__be16 rt_lifetime;
};

struct icmp6hdr {
	__u8 icmp6_type;
	__u8 icmp6_code;
	__sum16 icmp6_cksum;
	union {
		__be32 un_data32[1];
		__be16 un_data16[2];
		__u8 un_data8[4];
		struct icmpv6_echo u_echo;
		struct icmpv6_nd_advt u_nd_advt;
		struct icmpv6_nd_ra u_nd_ra;
	} icmp6_dataun;
};

struct ping_iter_state {
	struct seq_net_private p;
	int bucket;
	sa_family_t family;
};

struct pingfakehdr {
	struct icmphdr icmph;
	struct msghdr *msg;
	sa_family_t family;
	__wsum wcheck;
};

struct ping_table {
	struct hlist_nulls_head hash[64];
	rwlock_t lock;
};

enum lwtunnel_ip_t {
	LWTUNNEL_IP_UNSPEC = 0,
	LWTUNNEL_IP_ID = 1,
	LWTUNNEL_IP_DST = 2,
	LWTUNNEL_IP_SRC = 3,
	LWTUNNEL_IP_TTL = 4,
	LWTUNNEL_IP_TOS = 5,
	LWTUNNEL_IP_FLAGS = 6,
	LWTUNNEL_IP_PAD = 7,
	__LWTUNNEL_IP_MAX = 8,
};

enum lwtunnel_ip6_t {
	LWTUNNEL_IP6_UNSPEC = 0,
	LWTUNNEL_IP6_ID = 1,
	LWTUNNEL_IP6_DST = 2,
	LWTUNNEL_IP6_SRC = 3,
	LWTUNNEL_IP6_HOPLIMIT = 4,
	LWTUNNEL_IP6_TC = 5,
	LWTUNNEL_IP6_FLAGS = 6,
	LWTUNNEL_IP6_PAD = 7,
	__LWTUNNEL_IP6_MAX = 8,
};

struct ip6_tnl_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
};

struct nhmsg {
	unsigned char nh_family;
	unsigned char nh_scope;
	unsigned char nh_protocol;
	unsigned char resvd;
	unsigned int nh_flags;
};

struct nexthop_grp {
	__u32 id;
	__u8 weight;
	__u8 resvd1;
	__u16 resvd2;
};

enum {
	NEXTHOP_GRP_TYPE_MPATH = 0,
	__NEXTHOP_GRP_TYPE_MAX = 1,
};

enum {
	NHA_UNSPEC = 0,
	NHA_ID = 1,
	NHA_GROUP = 2,
	NHA_GROUP_TYPE = 3,
	NHA_BLACKHOLE = 4,
	NHA_OIF = 5,
	NHA_GATEWAY = 6,
	NHA_ENCAP_TYPE = 7,
	NHA_ENCAP = 8,
	NHA_GROUPS = 9,
	NHA_MASTER = 10,
	__NHA_MAX = 11,
};

struct nh_config {
	u32 nh_id;
	u8 nh_family;
	u8 nh_protocol;
	u8 nh_blackhole;
	u32 nh_flags;
	int nh_ifindex;
	struct net_device *dev;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} gw;
	struct nlattr *nh_grp;
	u16 nh_grp_type;
	struct nlattr *nh_encap;
	u16 nh_encap_type;
	u32 nlflags;
	struct nl_info nlinfo;
};

struct bpfilter_umh_ops {
	struct umh_info info;
	struct mutex lock;
	int (*sockopt)(struct sock *, int, char *, unsigned int, bool);
	int (*start)();
	bool stop;
};

struct inet6_protocol {
	void (*early_demux)(struct sk_buff *);
	void (*early_demux_handler)(struct sk_buff *);
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	unsigned int flags;
};

struct fib4_rule {
	struct fib_rule common;
	u8 dst_len;
	u8 src_len;
	u8 tos;
	__be32 src;
	__be32 srcmask;
	__be32 dst;
	__be32 dstmask;
	u32 tclassid;
};

enum {
	PIM_TYPE_HELLO = 0,
	PIM_TYPE_REGISTER = 1,
	PIM_TYPE_REGISTER_STOP = 2,
	PIM_TYPE_JOIN_PRUNE = 3,
	PIM_TYPE_BOOTSTRAP = 4,
	PIM_TYPE_ASSERT = 5,
	PIM_TYPE_GRAFT = 6,
	PIM_TYPE_GRAFT_ACK = 7,
	PIM_TYPE_CANDIDATE_RP_ADV = 8,
};

struct pimreghdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
	__be32 flags;
};

typedef short unsigned int vifi_t;

struct vifctl {
	vifi_t vifc_vifi;
	unsigned char vifc_flags;
	unsigned char vifc_threshold;
	unsigned int vifc_rate_limit;
	union {
		struct in_addr vifc_lcl_addr;
		int vifc_lcl_ifindex;
	};
	struct in_addr vifc_rmt_addr;
};

struct mfcctl {
	struct in_addr mfcc_origin;
	struct in_addr mfcc_mcastgrp;
	vifi_t mfcc_parent;
	unsigned char mfcc_ttls[32];
	unsigned int mfcc_pkt_cnt;
	unsigned int mfcc_byte_cnt;
	unsigned int mfcc_wrong_if;
	int mfcc_expire;
};

struct sioc_sg_req {
	struct in_addr src;
	struct in_addr grp;
	long unsigned int pktcnt;
	long unsigned int bytecnt;
	long unsigned int wrong_if;
};

struct sioc_vif_req {
	vifi_t vifi;
	long unsigned int icount;
	long unsigned int ocount;
	long unsigned int ibytes;
	long unsigned int obytes;
};

struct igmpmsg {
	__u32 unused1;
	__u32 unused2;
	unsigned char im_msgtype;
	unsigned char im_mbz;
	unsigned char im_vif;
	unsigned char unused3;
	struct in_addr im_src;
	struct in_addr im_dst;
};

enum {
	IPMRA_TABLE_UNSPEC = 0,
	IPMRA_TABLE_ID = 1,
	IPMRA_TABLE_CACHE_RES_QUEUE_LEN = 2,
	IPMRA_TABLE_MROUTE_REG_VIF_NUM = 3,
	IPMRA_TABLE_MROUTE_DO_ASSERT = 4,
	IPMRA_TABLE_MROUTE_DO_PIM = 5,
	IPMRA_TABLE_VIFS = 6,
	IPMRA_TABLE_MROUTE_DO_WRVIFWHOLE = 7,
	__IPMRA_TABLE_MAX = 8,
};

enum {
	IPMRA_VIF_UNSPEC = 0,
	IPMRA_VIF = 1,
	__IPMRA_VIF_MAX = 2,
};

enum {
	IPMRA_VIFA_UNSPEC = 0,
	IPMRA_VIFA_IFINDEX = 1,
	IPMRA_VIFA_VIF_ID = 2,
	IPMRA_VIFA_FLAGS = 3,
	IPMRA_VIFA_BYTES_IN = 4,
	IPMRA_VIFA_BYTES_OUT = 5,
	IPMRA_VIFA_PACKETS_IN = 6,
	IPMRA_VIFA_PACKETS_OUT = 7,
	IPMRA_VIFA_LOCAL_ADDR = 8,
	IPMRA_VIFA_REMOTE_ADDR = 9,
	IPMRA_VIFA_PAD = 10,
	__IPMRA_VIFA_MAX = 11,
};

enum {
	IPMRA_CREPORT_UNSPEC = 0,
	IPMRA_CREPORT_MSGTYPE = 1,
	IPMRA_CREPORT_VIF_ID = 2,
	IPMRA_CREPORT_SRC_ADDR = 3,
	IPMRA_CREPORT_DST_ADDR = 4,
	IPMRA_CREPORT_PKT = 5,
	__IPMRA_CREPORT_MAX = 6,
};

struct vif_device {
	struct net_device *dev;
	long unsigned int bytes_in;
	long unsigned int bytes_out;
	long unsigned int pkt_in;
	long unsigned int pkt_out;
	long unsigned int rate_limit;
	unsigned char threshold;
	short unsigned int flags;
	int link;
	struct netdev_phys_item_id dev_parent_id;
	__be32 local;
	__be32 remote;
};

struct vif_entry_notifier_info {
	struct fib_notifier_info info;
	struct net_device *dev;
	short unsigned int vif_index;
	short unsigned int vif_flags;
	u32 tb_id;
};

enum {
	MFC_STATIC = 1,
	MFC_OFFLOAD = 2,
};

struct mr_mfc {
	struct rhlist_head mnode;
	short unsigned int mfc_parent;
	int mfc_flags;
	union {
		struct {
			long unsigned int expires;
			struct sk_buff_head unresolved;
		} unres;
		struct {
			long unsigned int last_assert;
			int minvif;
			int maxvif;
			long unsigned int bytes;
			long unsigned int pkt;
			long unsigned int wrong_if;
			long unsigned int lastuse;
			unsigned char ttls[32];
			refcount_t refcount;
		} res;
	} mfc_un;
	struct list_head list;
	struct callback_head rcu;
	void (*free)(struct callback_head *);
};

struct mfc_entry_notifier_info {
	struct fib_notifier_info info;
	struct mr_mfc *mfc;
	u32 tb_id;
};

struct mr_table_ops {
	const struct rhashtable_params *rht_params;
	void *cmparg_any;
};

struct mr_table {
	struct list_head list;
	possible_net_t net;
	struct mr_table_ops ops;
	u32 id;
	struct sock *mroute_sk;
	struct timer_list ipmr_expire_timer;
	struct list_head mfc_unres_queue;
	struct vif_device vif_table[32];
	struct rhltable mfc_hash;
	struct list_head mfc_cache_list;
	int maxvif;
	atomic_t cache_resolve_queue_len;
	bool mroute_do_assert;
	bool mroute_do_pim;
	bool mroute_do_wrvifwhole;
	int mroute_reg_vif_num;
};

struct mr_vif_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	int ct;
};

struct mr_mfc_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	struct list_head *cache;
	spinlock_t *lock;
};

struct mfc_cache_cmp_arg {
	__be32 mfc_mcastgrp;
	__be32 mfc_origin;
};

struct mfc_cache {
	struct mr_mfc _c;
	union {
		struct {
			__be32 mfc_mcastgrp;
			__be32 mfc_origin;
		};
		struct mfc_cache_cmp_arg cmparg;
	};
};

struct ip_tunnel_parm {
	char name[16];
	int link;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	struct iphdr iph;
};

struct ipmr_result {
	struct mr_table *mrt;
};

struct compat_sioc_sg_req {
	struct in_addr src;
	struct in_addr grp;
	compat_ulong_t pktcnt;
	compat_ulong_t bytecnt;
	compat_ulong_t wrong_if;
};

struct compat_sioc_vif_req {
	vifi_t vifi;
	compat_ulong_t icount;
	compat_ulong_t ocount;
	compat_ulong_t ibytes;
	compat_ulong_t obytes;
};

struct rta_mfc_stats {
	__u64 mfcs_packets;
	__u64 mfcs_bytes;
	__u64 mfcs_wrong_if;
};

struct bictcp {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 bic_origin_point;
	u32 bic_K;
	u32 delay_min;
	u32 epoch_start;
	u32 ack_cnt;
	u32 tcp_cwnd;
	u16 unused;
	u8 sample_cnt;
	u8 found;
	u32 round_start;
	u32 end_seq;
	u32 last_ack;
	u32 curr_rtt;
};

struct tls_rec {
	struct list_head list;
	int tx_ready;
	int tx_flags;
	struct sk_msg msg_plaintext;
	struct sk_msg msg_encrypted;
	struct scatterlist sg_aead_in[2];
	struct scatterlist sg_aead_out[2];
	char content_type;
	struct scatterlist sg_content_type;
	char aad_space[13];
	u8 iv_data[16];
	struct aead_request aead_req;
	u8 aead_req_ctx[0];
};

struct tx_work {
	struct delayed_work work;
	struct sock *sk;
};

struct tls_sw_context_tx {
	struct crypto_aead *aead_send;
	struct crypto_wait async_wait;
	struct tx_work tx_work;
	struct tls_rec *open_rec;
	struct list_head tx_list;
	atomic_t encrypt_pending;
	spinlock_t encrypt_compl_lock;
	int async_notify;
	int async_capable;
	long unsigned int tx_bitmask;
};

struct xfrm_policy_afinfo {
	struct dst_ops *dst_ops;
	struct dst_entry * (*dst_lookup)(struct net___2 *, int, int, const xfrm_address_t *, const xfrm_address_t *, u32);
	int (*get_saddr)(struct net___2 *, int, xfrm_address_t *, xfrm_address_t *, u32);
	int (*fill_dst)(struct xfrm_dst *, struct net_device *, const struct flowi *);
	struct dst_entry * (*blackhole_route)(struct net___2 *, struct dst_entry *);
};

struct xfrm_state_afinfo {
	u8 family;
	u8 proto;
	const struct xfrm_type_offload *type_offload_esp;
	const struct xfrm_type *type_esp;
	const struct xfrm_type *type_ipip;
	const struct xfrm_type *type_ipip6;
	const struct xfrm_type *type_comp;
	const struct xfrm_type *type_ah;
	const struct xfrm_type *type_routing;
	const struct xfrm_type *type_dstopts;
	int (*output)(struct net___2 *, struct sock *, struct sk_buff *);
	int (*output_finish)(struct sock *, struct sk_buff *);
	int (*extract_input)(struct xfrm_state *, struct sk_buff *);
	int (*extract_output)(struct xfrm_state *, struct sk_buff *);
	int (*transport_finish)(struct sk_buff *, int);
	void (*local_error)(struct sk_buff *, u32);
};

struct ip_tunnel;

struct ip6_tnl;

struct xfrm_tunnel_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	union {
		struct ip_tunnel *ip4;
		struct ip6_tnl *ip6;
	} tunnel;
};

struct xfrm_mode_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	__be16 id;
	__be16 frag_off;
	u8 ihl;
	u8 tos;
	u8 ttl;
	u8 protocol;
	u8 optlen;
	u8 flow_lbl[3];
};

struct xfrm_spi_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	unsigned int daddroff;
	unsigned int family;
	__be32 seq;
};

struct xfrm_input_afinfo {
	unsigned int family;
	int (*callback)(struct sk_buff *, u8, int);
};

struct xfrm4_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm4_protocol *next;
	int priority;
};

enum {
	XFRM_STATE_VOID = 0,
	XFRM_STATE_ACQ = 1,
	XFRM_STATE_VALID = 2,
	XFRM_STATE_ERROR = 3,
	XFRM_STATE_EXPIRED = 4,
	XFRM_STATE_DEAD = 5,
};

struct xfrm_if;

struct xfrm_if_cb {
	struct xfrm_if * (*decode_session)(struct sk_buff *, short unsigned int);
};

struct xfrm_if_parms {
	int link;
	u32 if_id;
};

struct xfrm_if {
	struct xfrm_if *next;
	struct net_device *dev;
	struct net___2 *net;
	struct xfrm_if_parms p;
	struct gro_cells gro_cells;
};

struct xfrm_policy_walk {
	struct xfrm_policy_walk_entry walk;
	u8 type;
	u32 seq;
};

struct xfrm_kmaddress {
	xfrm_address_t local;
	xfrm_address_t remote;
	u32 reserved;
	u16 family;
};

struct xfrm_migrate {
	xfrm_address_t old_daddr;
	xfrm_address_t old_saddr;
	xfrm_address_t new_daddr;
	xfrm_address_t new_saddr;
	u8 proto;
	u8 mode;
	u16 reserved;
	u32 reqid;
	u16 old_family;
	u16 new_family;
};

struct xfrmk_spdinfo {
	u32 incnt;
	u32 outcnt;
	u32 fwdcnt;
	u32 inscnt;
	u32 outscnt;
	u32 fwdscnt;
	u32 spdhcnt;
	u32 spdhmcnt;
};

struct ip6_mh {
	__u8 ip6mh_proto;
	__u8 ip6mh_hdrlen;
	__u8 ip6mh_type;
	__u8 ip6mh_reserved;
	__u16 ip6mh_cksum;
	__u8 data[0];
};

struct xfrm_flo {
	struct dst_entry *dst_orig;
	u8 flags;
};

struct xfrm_pol_inexact_node {
	struct rb_node node;
	union {
		xfrm_address_t addr;
		struct callback_head rcu;
	};
	u8 prefixlen;
	struct rb_root root;
	struct hlist_head hhead;
};

struct xfrm_pol_inexact_key {
	possible_net_t net;
	u32 if_id;
	u16 family;
	u8 dir;
	u8 type;
};

struct xfrm_pol_inexact_bin {
	struct xfrm_pol_inexact_key k;
	struct rhash_head head;
	struct hlist_head hhead;
	seqcount_t count;
	struct rb_root root_d;
	struct rb_root root_s;
	struct list_head inexact_bins;
	struct callback_head rcu;
};

enum xfrm_pol_inexact_candidate_type {
	XFRM_POL_CAND_BOTH = 0,
	XFRM_POL_CAND_SADDR = 1,
	XFRM_POL_CAND_DADDR = 2,
	XFRM_POL_CAND_ANY = 3,
	XFRM_POL_CAND_MAX = 4,
};

struct xfrm_pol_inexact_candidates {
	struct hlist_head *res[4];
};

enum {
	XFRM_MSG_BASE = 16,
	XFRM_MSG_NEWSA = 16,
	XFRM_MSG_DELSA = 17,
	XFRM_MSG_GETSA = 18,
	XFRM_MSG_NEWPOLICY = 19,
	XFRM_MSG_DELPOLICY = 20,
	XFRM_MSG_GETPOLICY = 21,
	XFRM_MSG_ALLOCSPI = 22,
	XFRM_MSG_ACQUIRE = 23,
	XFRM_MSG_EXPIRE = 24,
	XFRM_MSG_UPDPOLICY = 25,
	XFRM_MSG_UPDSA = 26,
	XFRM_MSG_POLEXPIRE = 27,
	XFRM_MSG_FLUSHSA = 28,
	XFRM_MSG_FLUSHPOLICY = 29,
	XFRM_MSG_NEWAE = 30,
	XFRM_MSG_GETAE = 31,
	XFRM_MSG_REPORT = 32,
	XFRM_MSG_MIGRATE = 33,
	XFRM_MSG_NEWSADINFO = 34,
	XFRM_MSG_GETSADINFO = 35,
	XFRM_MSG_NEWSPDINFO = 36,
	XFRM_MSG_GETSPDINFO = 37,
	XFRM_MSG_MAPPING = 38,
	__XFRM_MSG_MAX = 39,
};

struct xfrm_user_sec_ctx {
	__u16 len;
	__u16 exttype;
	__u8 ctx_alg;
	__u8 ctx_doi;
	__u16 ctx_len;
};

enum xfrm_ae_ftype_t {
	XFRM_AE_UNSPEC = 0,
	XFRM_AE_RTHR = 1,
	XFRM_AE_RVAL = 2,
	XFRM_AE_LVAL = 4,
	XFRM_AE_ETHR = 8,
	XFRM_AE_CR = 16,
	XFRM_AE_CE = 32,
	XFRM_AE_CU = 64,
	__XFRM_AE_MAX = 65,
};

enum xfrm_attr_type_t {
	XFRMA_UNSPEC = 0,
	XFRMA_ALG_AUTH = 1,
	XFRMA_ALG_CRYPT = 2,
	XFRMA_ALG_COMP = 3,
	XFRMA_ENCAP = 4,
	XFRMA_TMPL = 5,
	XFRMA_SA = 6,
	XFRMA_POLICY = 7,
	XFRMA_SEC_CTX = 8,
	XFRMA_LTIME_VAL = 9,
	XFRMA_REPLAY_VAL = 10,
	XFRMA_REPLAY_THRESH = 11,
	XFRMA_ETIMER_THRESH = 12,
	XFRMA_SRCADDR = 13,
	XFRMA_COADDR = 14,
	XFRMA_LASTUSED = 15,
	XFRMA_POLICY_TYPE = 16,
	XFRMA_MIGRATE = 17,
	XFRMA_ALG_AEAD = 18,
	XFRMA_KMADDRESS = 19,
	XFRMA_ALG_AUTH_TRUNC = 20,
	XFRMA_MARK = 21,
	XFRMA_TFCPAD = 22,
	XFRMA_REPLAY_ESN_VAL = 23,
	XFRMA_SA_EXTRA_FLAGS = 24,
	XFRMA_PROTO = 25,
	XFRMA_ADDRESS_FILTER = 26,
	XFRMA_PAD = 27,
	XFRMA_OFFLOAD_DEV = 28,
	XFRMA_SET_MARK = 29,
	XFRMA_SET_MARK_MASK = 30,
	XFRMA_IF_ID = 31,
	__XFRMA_MAX = 32,
};

enum xfrm_nlgroups {
	XFRMNLGRP_NONE = 0,
	XFRMNLGRP_ACQUIRE = 1,
	XFRMNLGRP_EXPIRE = 2,
	XFRMNLGRP_SA = 3,
	XFRMNLGRP_POLICY = 4,
	XFRMNLGRP_AEVENTS = 5,
	XFRMNLGRP_REPORT = 6,
	XFRMNLGRP_MIGRATE = 7,
	XFRMNLGRP_MAPPING = 8,
	__XFRMNLGRP_MAX = 9,
};

enum {
	XFRM_MODE_FLAG_TUNNEL = 1,
};

struct km_event {
	union {
		u32 hard;
		u32 proto;
		u32 byid;
		u32 aevent;
		u32 type;
	} data;
	u32 seq;
	u32 portid;
	u32 event;
	struct net___2 *net;
};

struct xfrm_mgr {
	struct list_head list;
	int (*notify)(struct xfrm_state *, const struct km_event *);
	int (*acquire)(struct xfrm_state *, struct xfrm_tmpl *, struct xfrm_policy *);
	struct xfrm_policy * (*compile_policy)(struct sock *, int, u8 *, int, int *);
	int (*new_mapping)(struct xfrm_state *, xfrm_address_t *, __be16);
	int (*notify_policy)(struct xfrm_policy *, int, const struct km_event *);
	int (*report)(struct net___2 *, u8, struct xfrm_selector *, xfrm_address_t *);
	int (*migrate)(const struct xfrm_selector *, u8, u8, const struct xfrm_migrate *, int, const struct xfrm_kmaddress *, const struct xfrm_encap_tmpl *);
	bool (*is_alive)(const struct km_event *);
};

struct xfrmk_sadinfo {
	u32 sadhcnt;
	u32 sadhmcnt;
	u32 sadcnt;
};

struct ip_beet_phdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 padlen;
	__u8 reserved;
};

struct ip_tunnel_6rd_parm {
	struct in6_addr prefix;
	__be32 relay_prefix;
	u16 prefixlen;
	u16 relay_prefixlen;
};

struct ip_tunnel_prl_entry;

struct ip_tunnel {
	struct ip_tunnel *next;
	struct hlist_node hash_node;
	struct net_device *dev;
	struct net___2 *net;
	long unsigned int err_time;
	int err_count;
	u32 i_seqno;
	u32 o_seqno;
	int tun_hlen;
	u32 index;
	u8 erspan_ver;
	u8 dir;
	u16 hwid;
	struct dst_cache dst_cache;
	struct ip_tunnel_parm parms;
	int mlink;
	int encap_hlen;
	int hlen;
	struct ip_tunnel_encap encap;
	struct ip_tunnel_6rd_parm ip6rd;
	struct ip_tunnel_prl_entry *prl;
	unsigned int prl_count;
	unsigned int ip_tnl_net_id;
	struct gro_cells gro_cells;
	__u32 fwmark;
	bool collect_md;
	bool ignore_df;
};

struct __ip6_tnl_parm {
	char name[16];
	int link;
	__u8 proto;
	__u8 encap_limit;
	__u8 hop_limit;
	bool collect_md;
	__be32 flowinfo;
	__u32 flags;
	struct in6_addr laddr;
	struct in6_addr raddr;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	__u32 fwmark;
	__u32 index;
	__u8 erspan_ver;
	__u8 dir;
	__u16 hwid;
};

struct ip6_tnl {
	struct ip6_tnl *next;
	struct net_device *dev;
	struct net___2 *net;
	struct __ip6_tnl_parm parms;
	struct flowi fl;
	struct dst_cache dst_cache;
	struct gro_cells gro_cells;
	int err_count;
	long unsigned int err_time;
	__u32 i_seqno;
	__u32 o_seqno;
	int hlen;
	int tun_hlen;
	int encap_hlen;
	struct ip_tunnel_encap encap;
	int mlink;
};

struct xfrm_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	union {
		struct {
			__u32 low;
			__u32 hi;
		} output;
		struct {
			__be32 low;
			__be32 hi;
		} input;
	} seq;
};

struct ip_tunnel_prl_entry {
	struct ip_tunnel_prl_entry *next;
	__be32 addr;
	u16 flags;
	struct callback_head callback_head;
};

struct xfrm_trans_tasklet {
	struct tasklet_struct tasklet;
	struct sk_buff_head queue;
};

struct xfrm_trans_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	int (*finish)(struct net___2 *, struct sock *, struct sk_buff *);
};

struct xfrm_user_offload {
	int ifindex;
	__u8 flags;
};

struct sadb_alg {
	__u8 sadb_alg_id;
	__u8 sadb_alg_ivlen;
	__u16 sadb_alg_minbits;
	__u16 sadb_alg_maxbits;
	__u16 sadb_alg_reserved;
};

struct xfrm_algo_aead_info {
	char *geniv;
	u16 icv_truncbits;
};

struct xfrm_algo_auth_info {
	u16 icv_truncbits;
	u16 icv_fullbits;
};

struct xfrm_algo_encr_info {
	char *geniv;
	u16 blockbits;
	u16 defkeybits;
};

struct xfrm_algo_comp_info {
	u16 threshold;
};

struct xfrm_algo_desc {
	char *name;
	char *compat;
	u8 available: 1;
	u8 pfkey_supported: 1;
	union {
		struct xfrm_algo_aead_info aead;
		struct xfrm_algo_auth_info auth;
		struct xfrm_algo_encr_info encr;
		struct xfrm_algo_comp_info comp;
	} uinfo;
	struct sadb_alg desc;
};

struct xfrm_algo_list {
	struct xfrm_algo_desc *algs;
	int entries;
	u32 type;
	u32 mask;
};

struct xfrm_aead_name {
	const char *name;
	int icvbits;
};

enum {
	XFRM_SHARE_ANY = 0,
	XFRM_SHARE_SESSION = 1,
	XFRM_SHARE_USER = 2,
	XFRM_SHARE_UNIQUE = 3,
};

struct xfrm_user_tmpl {
	struct xfrm_id id;
	__u16 family;
	xfrm_address_t saddr;
	__u32 reqid;
	__u8 mode;
	__u8 share;
	__u8 optional;
	__u32 aalgos;
	__u32 ealgos;
	__u32 calgos;
};

struct xfrm_userpolicy_type {
	__u8 type;
	__u16 reserved1;
	__u8 reserved2;
};

enum xfrm_sadattr_type_t {
	XFRMA_SAD_UNSPEC = 0,
	XFRMA_SAD_CNT = 1,
	XFRMA_SAD_HINFO = 2,
	__XFRMA_SAD_MAX = 3,
};

struct xfrmu_sadhinfo {
	__u32 sadhcnt;
	__u32 sadhmcnt;
};

enum xfrm_spdattr_type_t {
	XFRMA_SPD_UNSPEC = 0,
	XFRMA_SPD_INFO = 1,
	XFRMA_SPD_HINFO = 2,
	XFRMA_SPD_IPV4_HTHRESH = 3,
	XFRMA_SPD_IPV6_HTHRESH = 4,
	__XFRMA_SPD_MAX = 5,
};

struct xfrmu_spdinfo {
	__u32 incnt;
	__u32 outcnt;
	__u32 fwdcnt;
	__u32 inscnt;
	__u32 outscnt;
	__u32 fwdscnt;
};

struct xfrmu_spdhinfo {
	__u32 spdhcnt;
	__u32 spdhmcnt;
};

struct xfrmu_spdhthresh {
	__u8 lbits;
	__u8 rbits;
};

struct xfrm_usersa_info {
	struct xfrm_selector sel;
	struct xfrm_id id;
	xfrm_address_t saddr;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	struct xfrm_stats stats;
	__u32 seq;
	__u32 reqid;
	__u16 family;
	__u8 mode;
	__u8 replay_window;
	__u8 flags;
};

struct xfrm_usersa_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u16 family;
	__u8 proto;
};

struct xfrm_aevent_id {
	struct xfrm_usersa_id sa_id;
	xfrm_address_t saddr;
	__u32 flags;
	__u32 reqid;
};

struct xfrm_userspi_info {
	struct xfrm_usersa_info info;
	__u32 min;
	__u32 max;
};

struct xfrm_userpolicy_info {
	struct xfrm_selector sel;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	__u32 priority;
	__u32 index;
	__u8 dir;
	__u8 action;
	__u8 flags;
	__u8 share;
};

struct xfrm_userpolicy_id {
	struct xfrm_selector sel;
	__u32 index;
	__u8 dir;
};

struct xfrm_user_acquire {
	struct xfrm_id id;
	xfrm_address_t saddr;
	struct xfrm_selector sel;
	struct xfrm_userpolicy_info policy;
	__u32 aalgos;
	__u32 ealgos;
	__u32 calgos;
	__u32 seq;
};

struct xfrm_user_expire {
	struct xfrm_usersa_info state;
	__u8 hard;
};

struct xfrm_user_polexpire {
	struct xfrm_userpolicy_info pol;
	__u8 hard;
};

struct xfrm_usersa_flush {
	__u8 proto;
};

struct xfrm_user_report {
	__u8 proto;
	struct xfrm_selector sel;
};

struct xfrm_user_kmaddress {
	xfrm_address_t local;
	xfrm_address_t remote;
	__u32 reserved;
	__u16 family;
};

struct xfrm_user_migrate {
	xfrm_address_t old_daddr;
	xfrm_address_t old_saddr;
	xfrm_address_t new_daddr;
	xfrm_address_t new_saddr;
	__u8 proto;
	__u8 mode;
	__u16 reserved;
	__u32 reqid;
	__u16 old_family;
	__u16 new_family;
};

struct xfrm_user_mapping {
	struct xfrm_usersa_id id;
	__u32 reqid;
	xfrm_address_t old_saddr;
	xfrm_address_t new_saddr;
	__be16 old_sport;
	__be16 new_sport;
};

struct xfrm_dump_info {
	struct sk_buff *in_skb;
	struct sk_buff *out_skb;
	u32 nlmsg_seq;
	u16 nlmsg_flags;
};

struct xfrm_link {
	int (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *nla_pol;
	int nla_max;
};

struct unix_stream_read_state {
	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
	struct socket *socket;
	struct msghdr *msg;
	struct pipe_inode_info *pipe;
	size_t size;
	int flags;
	unsigned int splice_flags;
};

struct ipv6_params {
	__s32 disable_ipv6;
	__s32 autoconf;
};

enum flowlabel_reflect {
	FLOWLABEL_REFLECT_ESTABLISHED = 1,
	FLOWLABEL_REFLECT_TCP_RESET = 2,
	FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
};

struct ac6_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct ip6_fraglist_iter {
	struct ipv6hdr *tmp_hdr;
	struct sk_buff *frag;
	int offset;
	unsigned int hlen;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_frag_state {
	u8 *prevhdr;
	unsigned int hlen;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	int hroom;
	int troom;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_ra_chain {
	struct ip6_ra_chain *next;
	struct sock *sk;
	int sel;
	void (*destructor)(struct sock *);
};

struct ipcm6_cookie {
	struct sockcm_cookie sockc;
	__s16 hlimit;
	__s16 tclass;
	__s8 dontfrag;
	struct ipv6_txoptions *opt;
	__u16 gso_size;
};

enum {
	IFLA_INET6_UNSPEC = 0,
	IFLA_INET6_FLAGS = 1,
	IFLA_INET6_CONF = 2,
	IFLA_INET6_STATS = 3,
	IFLA_INET6_MCAST = 4,
	IFLA_INET6_CACHEINFO = 5,
	IFLA_INET6_ICMP6STATS = 6,
	IFLA_INET6_TOKEN = 7,
	IFLA_INET6_ADDR_GEN_MODE = 8,
	__IFLA_INET6_MAX = 9,
};

enum in6_addr_gen_mode {
	IN6_ADDR_GEN_MODE_EUI64 = 0,
	IN6_ADDR_GEN_MODE_NONE = 1,
	IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
	IN6_ADDR_GEN_MODE_RANDOM = 3,
};

struct ifla_cacheinfo {
	__u32 max_reasm_len;
	__u32 tstamp;
	__u32 reachable_time;
	__u32 retrans_time;
};

struct wpan_phy;

struct wpan_dev_header_ops;

struct wpan_dev {
	struct wpan_phy *wpan_phy;
	int iftype;
	struct list_head list;
	struct net_device *netdev;
	const struct wpan_dev_header_ops *header_ops;
	struct net_device *lowpan_dev;
	u32 identifier;
	__le16 pan_id;
	__le16 short_addr;
	__le64 extended_addr;
	atomic_t bsn;
	atomic_t dsn;
	u8 min_be;
	u8 max_be;
	u8 csma_retries;
	s8 frame_retries;
	bool lbt;
	bool promiscuous_mode;
	bool ackreq;
};

struct prefixmsg {
	unsigned char prefix_family;
	unsigned char prefix_pad1;
	short unsigned int prefix_pad2;
	int prefix_ifindex;
	unsigned char prefix_type;
	unsigned char prefix_len;
	unsigned char prefix_flags;
	unsigned char prefix_pad3;
};

enum {
	PREFIX_UNSPEC = 0,
	PREFIX_ADDRESS = 1,
	PREFIX_CACHEINFO = 2,
	__PREFIX_MAX = 3,
};

struct prefix_cacheinfo {
	__u32 preferred_time;
	__u32 valid_time;
};

struct in6_ifreq {
	struct in6_addr ifr6_addr;
	__u32 ifr6_prefixlen;
	int ifr6_ifindex;
};

enum {
	DEVCONF_FORWARDING = 0,
	DEVCONF_HOPLIMIT = 1,
	DEVCONF_MTU6 = 2,
	DEVCONF_ACCEPT_RA = 3,
	DEVCONF_ACCEPT_REDIRECTS = 4,
	DEVCONF_AUTOCONF = 5,
	DEVCONF_DAD_TRANSMITS = 6,
	DEVCONF_RTR_SOLICITS = 7,
	DEVCONF_RTR_SOLICIT_INTERVAL = 8,
	DEVCONF_RTR_SOLICIT_DELAY = 9,
	DEVCONF_USE_TEMPADDR = 10,
	DEVCONF_TEMP_VALID_LFT = 11,
	DEVCONF_TEMP_PREFERED_LFT = 12,
	DEVCONF_REGEN_MAX_RETRY = 13,
	DEVCONF_MAX_DESYNC_FACTOR = 14,
	DEVCONF_MAX_ADDRESSES = 15,
	DEVCONF_FORCE_MLD_VERSION = 16,
	DEVCONF_ACCEPT_RA_DEFRTR = 17,
	DEVCONF_ACCEPT_RA_PINFO = 18,
	DEVCONF_ACCEPT_RA_RTR_PREF = 19,
	DEVCONF_RTR_PROBE_INTERVAL = 20,
	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN = 21,
	DEVCONF_PROXY_NDP = 22,
	DEVCONF_OPTIMISTIC_DAD = 23,
	DEVCONF_ACCEPT_SOURCE_ROUTE = 24,
	DEVCONF_MC_FORWARDING = 25,
	DEVCONF_DISABLE_IPV6 = 26,
	DEVCONF_ACCEPT_DAD = 27,
	DEVCONF_FORCE_TLLAO = 28,
	DEVCONF_NDISC_NOTIFY = 29,
	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL = 30,
	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL = 31,
	DEVCONF_SUPPRESS_FRAG_NDISC = 32,
	DEVCONF_ACCEPT_RA_FROM_LOCAL = 33,
	DEVCONF_USE_OPTIMISTIC = 34,
	DEVCONF_ACCEPT_RA_MTU = 35,
	DEVCONF_STABLE_SECRET = 36,
	DEVCONF_USE_OIF_ADDRS_ONLY = 37,
	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT = 38,
	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 39,
	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 40,
	DEVCONF_DROP_UNSOLICITED_NA = 41,
	DEVCONF_KEEP_ADDR_ON_DOWN = 42,
	DEVCONF_RTR_SOLICIT_MAX_INTERVAL = 43,
	DEVCONF_SEG6_ENABLED = 44,
	DEVCONF_SEG6_REQUIRE_HMAC = 45,
	DEVCONF_ENHANCED_DAD = 46,
	DEVCONF_ADDR_GEN_MODE = 47,
	DEVCONF_DISABLE_POLICY = 48,
	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN = 49,
	DEVCONF_NDISC_TCLASS = 50,
	DEVCONF_MAX = 51,
};

enum {
	INET6_IFADDR_STATE_PREDAD = 0,
	INET6_IFADDR_STATE_DAD = 1,
	INET6_IFADDR_STATE_POSTDAD = 2,
	INET6_IFADDR_STATE_ERRDAD = 3,
	INET6_IFADDR_STATE_DEAD = 4,
};

enum nl802154_cca_modes {
	__NL802154_CCA_INVALID = 0,
	NL802154_CCA_ENERGY = 1,
	NL802154_CCA_CARRIER = 2,
	NL802154_CCA_ENERGY_CARRIER = 3,
	NL802154_CCA_ALOHA = 4,
	NL802154_CCA_UWB_SHR = 5,
	NL802154_CCA_UWB_MULTIPLEXED = 6,
	__NL802154_CCA_ATTR_AFTER_LAST = 7,
	NL802154_CCA_ATTR_MAX = 6,
};

enum nl802154_cca_opts {
	NL802154_CCA_OPT_ENERGY_CARRIER_AND = 0,
	NL802154_CCA_OPT_ENERGY_CARRIER_OR = 1,
	__NL802154_CCA_OPT_ATTR_AFTER_LAST = 2,
	NL802154_CCA_OPT_ATTR_MAX = 1,
};

enum nl802154_supported_bool_states {
	NL802154_SUPPORTED_BOOL_FALSE = 0,
	NL802154_SUPPORTED_BOOL_TRUE = 1,
	__NL802154_SUPPORTED_BOOL_INVALD = 2,
	NL802154_SUPPORTED_BOOL_BOTH = 3,
	__NL802154_SUPPORTED_BOOL_AFTER_LAST = 4,
	NL802154_SUPPORTED_BOOL_MAX = 3,
};

struct wpan_phy_supported {
	u32 channels[32];
	u32 cca_modes;
	u32 cca_opts;
	u32 iftypes;
	enum nl802154_supported_bool_states lbt;
	u8 min_minbe;
	u8 max_minbe;
	u8 min_maxbe;
	u8 max_maxbe;
	u8 min_csma_backoffs;
	u8 max_csma_backoffs;
	s8 min_frame_retries;
	s8 max_frame_retries;
	size_t tx_powers_size;
	size_t cca_ed_levels_size;
	const s32 *tx_powers;
	const s32 *cca_ed_levels;
};

struct wpan_phy_cca {
	enum nl802154_cca_modes mode;
	enum nl802154_cca_opts opt;
};

struct wpan_phy {
	const void *privid;
	u32 flags;
	u8 current_channel;
	u8 current_page;
	struct wpan_phy_supported supported;
	s32 transmit_power;
	struct wpan_phy_cca cca;
	__le64 perm_extended_addr;
	s32 cca_ed_level;
	u8 symbol_duration;
	u16 lifs_period;
	u16 sifs_period;
	struct device dev;
	possible_net_t _net;
	long: 64;
	long: 64;
	long: 64;
	char priv[0];
};

struct ieee802154_addr {
	u8 mode;
	__le16 pan_id;
	union {
		__le16 short_addr;
		__le64 extended_addr;
	};
};

struct wpan_dev_header_ops {
	int (*create)(struct sk_buff *, struct net_device *, const struct ieee802154_addr *, const struct ieee802154_addr *, unsigned int);
};

union fwnet_hwaddr {
	u8 u[16];
	struct {
		__be64 uniq_id;
		u8 max_rec;
		u8 sspd;
		__be16 fifo_hi;
		__be32 fifo_lo;
	} uc;
};

struct in6_validator_info {
	struct in6_addr i6vi_addr;
	struct inet6_dev *i6vi_dev;
	struct netlink_ext_ack *extack;
};

struct ifa6_config {
	const struct in6_addr *pfx;
	unsigned int plen;
	const struct in6_addr *peer_pfx;
	u32 rt_priority;
	u32 ifa_flags;
	u32 preferred_lft;
	u32 valid_lft;
	u16 scope;
};

enum cleanup_prefix_rt_t {
	CLEANUP_PREFIX_RT_NOP = 0,
	CLEANUP_PREFIX_RT_DEL = 1,
	CLEANUP_PREFIX_RT_EXPIRE = 2,
};

enum {
	IPV6_SADDR_RULE_INIT = 0,
	IPV6_SADDR_RULE_LOCAL = 1,
	IPV6_SADDR_RULE_SCOPE = 2,
	IPV6_SADDR_RULE_PREFERRED = 3,
	IPV6_SADDR_RULE_OIF = 4,
	IPV6_SADDR_RULE_LABEL = 5,
	IPV6_SADDR_RULE_PRIVACY = 6,
	IPV6_SADDR_RULE_ORCHID = 7,
	IPV6_SADDR_RULE_PREFIX = 8,
	IPV6_SADDR_RULE_NOT_OPTIMISTIC = 9,
	IPV6_SADDR_RULE_MAX = 10,
};

struct ipv6_saddr_score {
	int rule;
	int addr_type;
	struct inet6_ifaddr *ifa;
	long unsigned int scorebits[1];
	int scopedist;
	int matchlen;
};

struct ipv6_saddr_dst {
	const struct in6_addr *addr;
	int ifindex;
	int scope;
	int label;
	unsigned int prefs;
};

struct if6_iter_state {
	struct seq_net_private p;
	int bucket;
	int offset;
};

enum addr_type_t {
	UNICAST_ADDR = 0,
	MULTICAST_ADDR = 1,
	ANYCAST_ADDR = 2,
};

struct inet6_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
	enum addr_type_t type;
};

enum {
	DAD_PROCESS = 0,
	DAD_BEGIN = 1,
	DAD_ABORT = 2,
};

struct ifaddrlblmsg {
	__u8 ifal_family;
	__u8 __ifal_reserved;
	__u8 ifal_prefixlen;
	__u8 ifal_flags;
	__u32 ifal_index;
	__u32 ifal_seq;
};

enum {
	IFAL_ADDRESS = 1,
	IFAL_LABEL = 2,
	__IFAL_MAX = 3,
};

struct ip6addrlbl_entry {
	struct in6_addr prefix;
	int prefixlen;
	int ifindex;
	int addrtype;
	u32 label;
	struct hlist_node list;
	struct callback_head rcu;
};

struct ip6addrlbl_init_table {
	const struct in6_addr *prefix;
	int prefixlen;
	u32 label;
};

struct rd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	struct in6_addr dest;
	__u8 opt[0];
};

struct fib6_gc_args {
	int timeout;
	int more;
};

struct rt6_exception {
	struct hlist_node hlist;
	struct rt6_info *rt6i;
	long unsigned int stamp;
	struct callback_head rcu;
};

typedef struct rt6_info * (*pol_lookup_t)(struct net___2 *, struct fib6_table *, struct flowi6 *, const struct sk_buff *, int);

struct route_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved_l: 3;
	__u8 route_pref: 2;
	__u8 reserved_h: 3;
	__be32 lifetime;
	__u8 prefix[0];
};

struct rt6_rtnl_dump_arg {
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net___2 *net;
	struct fib_dump_filter filter;
};

struct netevent_redirect {
	struct dst_entry *old;
	struct dst_entry *new;
	struct neighbour *neigh;
	const void *daddr;
};

struct trace_event_raw_fib6_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[16];
	__u8 dst[16];
	u16 sport;
	u16 dport;
	u8 proto;
	u8 rt_type;
	u32 __data_loc_name;
	__u8 gw[16];
	char __data[0];
};

struct trace_event_data_offsets_fib6_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib6_table_lookup)(void *, const struct net___2 *, const struct fib6_result *, struct fib6_table *, const struct flowi6 *);

enum rt6_nud_state {
	RT6_NUD_FAIL_HARD = 4294967293,
	RT6_NUD_FAIL_PROBE = 4294967294,
	RT6_NUD_FAIL_DO_RR = 4294967295,
	RT6_NUD_SUCCEED = 1,
};

struct fib6_nh_dm_arg {
	struct net___2 *net;
	const struct in6_addr *saddr;
	int oif;
	int flags;
	struct fib6_nh *nh;
};

struct __rt6_probe_work {
	struct work_struct work;
	struct in6_addr target;
	struct net_device *dev;
};

struct fib6_nh_frl_arg {
	u32 flags;
	int oif;
	int strict;
	int *mpri;
	bool *do_rr;
	struct fib6_nh *nh;
};

struct fib6_nh_excptn_arg {
	struct rt6_info *rt;
	int plen;
};

struct fib6_nh_match_arg {
	const struct net_device *dev;
	const struct in6_addr *gw;
	struct fib6_nh *match;
};

struct fib6_nh_age_excptn_arg {
	struct fib6_gc_args *gc_args;
	long unsigned int now;
};

struct fib6_nh_rd_arg {
	struct fib6_result *res;
	struct flowi6 *fl6;
	const struct in6_addr *gw;
	struct rt6_info **ret;
};

struct ip6rd_flowi {
	struct flowi6 fl6;
	struct in6_addr gateway;
};

struct fib6_nh_del_cached_rt_arg {
	struct fib6_config *cfg;
	struct fib6_info *f6i;
};

struct arg_dev_net_ip {
	struct net_device *dev;
	struct net___2 *net;
	struct in6_addr *addr;
};

struct arg_netdev_event {
	const struct net_device *dev;
	union {
		unsigned char nh_flags;
		long unsigned int event;
	};
};

struct rt6_mtu_change_arg {
	struct net_device *dev;
	unsigned int mtu;
	struct fib6_info *f6i;
};

struct rt6_nh {
	struct fib6_info *fib6_info;
	struct fib6_config r_cfg;
	struct list_head next;
};

struct fib6_nh_exception_dump_walker {
	struct rt6_rtnl_dump_arg *dump;
	struct fib6_info *rt;
	unsigned int flags;
	unsigned int skip;
	unsigned int count;
};

enum fib6_walk_state {
	FWS_L = 0,
	FWS_R = 1,
	FWS_C = 2,
	FWS_U = 3,
};

struct fib6_walker {
	struct list_head lh;
	struct fib6_node *root;
	struct fib6_node *node;
	struct fib6_info *leaf;
	enum fib6_walk_state state;
	unsigned int skip;
	unsigned int count;
	unsigned int skip_in_node;
	int (*func)(struct fib6_walker *);
	void *args;
};

struct fib6_entry_notifier_info {
	struct fib_notifier_info info;
	struct fib6_info *rt;
	unsigned int nsiblings;
};

struct ipv6_route_iter {
	struct seq_net_private p;
	struct fib6_walker w;
	loff_t skip;
	struct fib6_table *tbl;
	int sernum;
};

struct bpf_iter__ipv6_route {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct fib6_info *rt;
	};
};

struct fib6_cleaner {
	struct fib6_walker w;
	struct net___2 *net;
	int (*func)(struct fib6_info *, void *);
	int sernum;
	void *arg;
	bool skip_notify;
};

enum {
	FIB6_NO_SERNUM_CHANGE = 0,
};

struct fib6_dump_arg {
	struct net___2 *net;
	struct notifier_block *nb;
};

struct fib6_nh_pcpu_arg {
	struct fib6_info *from;
	const struct fib6_table *table;
};

struct lookup_args {
	int offset;
	const struct in6_addr *addr;
};

struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;
	int ipv6mr_ifindex;
};

struct in6_flowlabel_req {
	struct in6_addr flr_dst;
	__be32 flr_label;
	__u8 flr_action;
	__u8 flr_share;
	__u16 flr_flags;
	__u16 flr_expires;
	__u16 flr_linger;
	__u32 __flr_pad;
};

struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;
	__u32 ip6m_mtu;
};

struct ipv6_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u8 first_segment;
	__u8 flags;
	__u16 tag;
	struct in6_addr segments[0];
};

struct nduseroptmsg {
	unsigned char nduseropt_family;
	unsigned char nduseropt_pad1;
	short unsigned int nduseropt_opts_len;
	int nduseropt_ifindex;
	__u8 nduseropt_icmp_type;
	__u8 nduseropt_icmp_code;
	short unsigned int nduseropt_pad2;
	unsigned int nduseropt_pad3;
};

enum {
	NDUSEROPT_UNSPEC = 0,
	NDUSEROPT_SRCADDR = 1,
	__NDUSEROPT_MAX = 2,
};

struct nd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	__u8 opt[0];
};

struct rs_msg {
	struct icmp6hdr icmph;
	__u8 opt[0];
};

struct ra_msg {
	struct icmp6hdr icmph;
	__be32 reachable_time;
	__be32 retrans_timer;
};

struct static_key_false_deferred {
	struct static_key_false key;
};

struct icmp6_filter {
	__u32 data[8];
};

struct raw6_sock {
	struct inet_sock inet;
	__u32 checksum;
	__u32 offset;
	struct icmp6_filter filter;
	__u32 ip6mr_table;
	struct ipv6_pinfo inet6;
};

typedef int mh_filter_t(struct sock *, struct sk_buff *);

struct raw6_frag_vec {
	struct msghdr *msg;
	int hlen;
	char c[4];
};

struct ipv6_destopt_hao {
	__u8 type;
	__u8 length;
	struct in6_addr addr;
} __attribute__((packed));

typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *, const struct inet6_skb_parm *);

struct icmpv6_msg {
	struct sk_buff *skb;
	int offset;
	uint8_t type;
};

struct icmp6_err {
	int err;
	int fatal;
};

struct mld_msg {
	struct icmp6hdr mld_hdr;
	struct in6_addr mld_mca;
};

struct mld2_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	struct in6_addr grec_mca;
	struct in6_addr grec_src[0];
};

struct mld2_report {
	struct icmp6hdr mld2r_hdr;
	struct mld2_grec mld2r_grec[0];
};

struct mld2_query {
	struct icmp6hdr mld2q_hdr;
	struct in6_addr mld2q_mca;
	__u8 mld2q_qrv: 3;
	__u8 mld2q_suppress: 1;
	__u8 mld2q_resv2: 4;
	__u8 mld2q_qqic;
	__be16 mld2q_nsrcs;
	struct in6_addr mld2q_srcs[0];
};

struct igmp6_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct igmp6_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
	struct ifmcaddr6 *im;
};

enum ip6_defrag_users {
	IP6_DEFRAG_LOCAL_DELIVER = 0,
	IP6_DEFRAG_CONNTRACK_IN = 1,
	__IP6_DEFRAG_CONNTRACK_IN = 65536,
	IP6_DEFRAG_CONNTRACK_OUT = 65537,
	__IP6_DEFRAG_CONNTRACK_OUT = 131072,
	IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 131073,
	__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 196608,
};

struct frag_queue {
	struct inet_frag_queue q;
	int iif;
	__u16 nhoffset;
	u8 ecn;
};

struct tcp6_pseudohdr {
	struct in6_addr saddr;
	struct in6_addr daddr;
	__be32 len;
	__be32 protocol;
};

struct rt0_hdr {
	struct ipv6_rt_hdr rt_hdr;
	__u32 reserved;
	struct in6_addr addr[0];
};

struct tlvtype_proc {
	int type;
	bool (*func)(struct sk_buff *, int);
};

struct ip6fl_iter_state {
	struct seq_net_private p;
	struct pid_namespace___2 *pid_ns;
	int bucket;
};

struct sr6_tlv {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

enum {
	SEG6_ATTR_UNSPEC = 0,
	SEG6_ATTR_DST = 1,
	SEG6_ATTR_DSTLEN = 2,
	SEG6_ATTR_HMACKEYID = 3,
	SEG6_ATTR_SECRET = 4,
	SEG6_ATTR_SECRETLEN = 5,
	SEG6_ATTR_ALGID = 6,
	SEG6_ATTR_HMACINFO = 7,
	__SEG6_ATTR_MAX = 8,
};

enum {
	SEG6_CMD_UNSPEC = 0,
	SEG6_CMD_SETHMAC = 1,
	SEG6_CMD_DUMPHMAC = 2,
	SEG6_CMD_SET_TUNSRC = 3,
	SEG6_CMD_GET_TUNSRC = 4,
	__SEG6_CMD_MAX = 5,
};

typedef short unsigned int mifi_t;

typedef __u32 if_mask;

struct if_set {
	if_mask ifs_bits[8];
};

struct mif6ctl {
	mifi_t mif6c_mifi;
	unsigned char mif6c_flags;
	unsigned char vifc_threshold;
	__u16 mif6c_pifi;
	unsigned int vifc_rate_limit;
};

struct mf6cctl {
	struct sockaddr_in6 mf6cc_origin;
	struct sockaddr_in6 mf6cc_mcastgrp;
	mifi_t mf6cc_parent;
	struct if_set mf6cc_ifset;
};

struct sioc_sg_req6 {
	struct sockaddr_in6 src;
	struct sockaddr_in6 grp;
	long unsigned int pktcnt;
	long unsigned int bytecnt;
	long unsigned int wrong_if;
};

struct sioc_mif_req6 {
	mifi_t mifi;
	long unsigned int icount;
	long unsigned int ocount;
	long unsigned int ibytes;
	long unsigned int obytes;
};

struct mrt6msg {
	__u8 im6_mbz;
	__u8 im6_msgtype;
	__u16 im6_mif;
	__u32 im6_pad;
	struct in6_addr im6_src;
	struct in6_addr im6_dst;
};

enum {
	IP6MRA_CREPORT_UNSPEC = 0,
	IP6MRA_CREPORT_MSGTYPE = 1,
	IP6MRA_CREPORT_MIF_ID = 2,
	IP6MRA_CREPORT_SRC_ADDR = 3,
	IP6MRA_CREPORT_DST_ADDR = 4,
	IP6MRA_CREPORT_PKT = 5,
	__IP6MRA_CREPORT_MAX = 6,
};

struct mfc6_cache_cmp_arg {
	struct in6_addr mf6c_mcastgrp;
	struct in6_addr mf6c_origin;
};

struct mfc6_cache {
	struct mr_mfc _c;
	union {
		struct {
			struct in6_addr mf6c_mcastgrp;
			struct in6_addr mf6c_origin;
		};
		struct mfc6_cache_cmp_arg cmparg;
	};
};

struct ip6mr_result {
	struct mr_table *mrt;
};

struct compat_sioc_sg_req6 {
	struct sockaddr_in6 src;
	struct sockaddr_in6 grp;
	compat_ulong_t pktcnt;
	compat_ulong_t bytecnt;
	compat_ulong_t wrong_if;
};

struct compat_sioc_mif_req6 {
	mifi_t mifi;
	compat_ulong_t icount;
	compat_ulong_t ocount;
	compat_ulong_t ibytes;
	compat_ulong_t obytes;
};

struct xfrm6_protocol {
	int (*handler)(struct sk_buff *);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	struct xfrm6_protocol *next;
	int priority;
};

struct br_input_skb_cb {
	struct net_device *brdev;
	u16 frag_max_size;
	u8 igmp;
	u8 mrouters_only: 1;
	u8 proxyarp_replied: 1;
	u8 src_port_isolated: 1;
	u8 vlan_filtered: 1;
	u8 br_netfilter_broute: 1;
};

struct nf_bridge_frag_data;

struct fib6_rule {
	struct fib_rule common;
	struct rt6key src;
	struct rt6key dst;
	u8 tclass;
};

struct sockaddr_pkt {
	short unsigned int spkt_family;
	unsigned char spkt_device[14];
	__be16 spkt_protocol;
};

struct sockaddr_ll {
	short unsigned int sll_family;
	__be16 sll_protocol;
	int sll_ifindex;
	short unsigned int sll_hatype;
	unsigned char sll_pkttype;
	unsigned char sll_halen;
	unsigned char sll_addr[8];
};

struct tpacket_stats {
	unsigned int tp_packets;
	unsigned int tp_drops;
};

struct tpacket_stats_v3 {
	unsigned int tp_packets;
	unsigned int tp_drops;
	unsigned int tp_freeze_q_cnt;
};

struct tpacket_rollover_stats {
	__u64 tp_all;
	__u64 tp_huge;
	__u64 tp_failed;
};

union tpacket_stats_u {
	struct tpacket_stats stats1;
	struct tpacket_stats_v3 stats3;
};

struct tpacket_auxdata {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
};

struct tpacket_hdr {
	long unsigned int tp_status;
	unsigned int tp_len;
	unsigned int tp_snaplen;
	short unsigned int tp_mac;
	short unsigned int tp_net;
	unsigned int tp_sec;
	unsigned int tp_usec;
};

struct tpacket2_hdr {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u8 tp_padding[4];
};

struct tpacket_hdr_variant1 {
	__u32 tp_rxhash;
	__u32 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u16 tp_padding;
};

struct tpacket3_hdr {
	__u32 tp_next_offset;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u32 tp_snaplen;
	__u32 tp_len;
	__u32 tp_status;
	__u16 tp_mac;
	__u16 tp_net;
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8 tp_padding[8];
};

struct tpacket_bd_ts {
	unsigned int ts_sec;
	union {
		unsigned int ts_usec;
		unsigned int ts_nsec;
	};
};

struct tpacket_hdr_v1 {
	__u32 block_status;
	__u32 num_pkts;
	__u32 offset_to_first_pkt;
	__u32 blk_len;
	__u64 seq_num;
	struct tpacket_bd_ts ts_first_pkt;
	struct tpacket_bd_ts ts_last_pkt;
};

union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};

enum tpacket_versions {
	TPACKET_V1 = 0,
	TPACKET_V2 = 1,
	TPACKET_V3 = 2,
};

struct tpacket_req {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
};

struct tpacket_req3 {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
	unsigned int tp_retire_blk_tov;
	unsigned int tp_sizeof_priv;
	unsigned int tp_feature_req_word;
};

union tpacket_req_u {
	struct tpacket_req req;
	struct tpacket_req3 req3;
};

struct virtio_net_hdr {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	__virtio16 csum_start;
	__virtio16 csum_offset;
};

struct packet_mclist {
	struct packet_mclist *next;
	int ifindex;
	int count;
	short unsigned int type;
	short unsigned int alen;
	unsigned char addr[32];
};

struct pgv;

struct tpacket_kbdq_core {
	struct pgv *pkbdq;
	unsigned int feature_req_word;
	unsigned int hdrlen;
	unsigned char reset_pending_on_curr_blk;
	unsigned char delete_blk_timer;
	short unsigned int kactive_blk_num;
	short unsigned int blk_sizeof_priv;
	short unsigned int last_kactive_blk_num;
	char *pkblk_start;
	char *pkblk_end;
	int kblk_size;
	unsigned int max_frame_len;
	unsigned int knum_blocks;
	uint64_t knxt_seq_num;
	char *prev;
	char *nxt_offset;
	struct sk_buff *skb;
	atomic_t blk_fill_in_prog;
	short unsigned int retire_blk_tov;
	short unsigned int version;
	long unsigned int tov_in_jiffies;
	struct timer_list retire_blk_timer;
};

struct pgv {
	char *buffer;
};

struct packet_ring_buffer {
	struct pgv *pg_vec;
	unsigned int head;
	unsigned int frames_per_block;
	unsigned int frame_size;
	unsigned int frame_max;
	unsigned int pg_vec_order;
	unsigned int pg_vec_pages;
	unsigned int pg_vec_len;
	unsigned int *pending_refcnt;
	union {
		long unsigned int *rx_owner_map;
		struct tpacket_kbdq_core prb_bdqc;
	};
};

struct packet_fanout {
	possible_net_t net;
	unsigned int num_members;
	u16 id;
	u8 type;
	u8 flags;
	union {
		atomic_t rr_cur;
		struct bpf_prog *bpf_prog;
	};
	struct list_head list;
	struct sock *arr[256];
	spinlock_t lock;
	refcount_t sk_ref;
	long: 64;
	long: 64;
	struct packet_type prot_hook;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_rollover {
	int sock;
	atomic_long_t num;
	atomic_long_t num_huge;
	atomic_long_t num_failed;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 history[16];
};

struct packet_sock {
	struct sock sk;
	struct packet_fanout *fanout;
	union tpacket_stats_u stats;
	struct packet_ring_buffer rx_ring;
	struct packet_ring_buffer tx_ring;
	int copy_thresh;
	spinlock_t bind_lock;
	struct mutex pg_vec_lock;
	unsigned int running;
	unsigned int auxdata: 1;
	unsigned int origdev: 1;
	unsigned int has_vnet_hdr: 1;
	unsigned int tp_loss: 1;
	unsigned int tp_tx_has_off: 1;
	int pressure;
	int ifindex;
	__be16 num;
	struct packet_rollover *rollover;
	struct packet_mclist *mclist;
	atomic_t mapped;
	enum tpacket_versions tp_version;
	unsigned int tp_hdrlen;
	unsigned int tp_reserve;
	unsigned int tp_tstamp;
	struct completion skb_completion;
	struct net_device *cached_dev;
	int (*xmit)(struct sk_buff *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct packet_type prot_hook;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t tp_drops;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_mreq_max {
	int mr_ifindex;
	short unsigned int mr_type;
	short unsigned int mr_alen;
	unsigned char mr_address[32];
};

union tpacket_uhdr {
	struct tpacket_hdr *h1;
	struct tpacket2_hdr *h2;
	struct tpacket3_hdr *h3;
	void *raw;
};

struct packet_skb_cb {
	union {
		struct sockaddr_pkt pkt;
		union {
			unsigned int origlen;
			struct sockaddr_ll ll;
		};
	} sa;
};

enum switchdev_notifier_type {
	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
	SWITCHDEV_FDB_DEL_TO_BRIDGE = 2,
	SWITCHDEV_FDB_ADD_TO_DEVICE = 3,
	SWITCHDEV_FDB_DEL_TO_DEVICE = 4,
	SWITCHDEV_FDB_OFFLOADED = 5,
	SWITCHDEV_PORT_OBJ_ADD = 6,
	SWITCHDEV_PORT_OBJ_DEL = 7,
	SWITCHDEV_PORT_ATTR_SET = 8,
	SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE = 9,
	SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE = 10,
	SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE = 11,
	SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE = 12,
	SWITCHDEV_VXLAN_FDB_OFFLOADED = 13,
};

struct switchdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct switchdev_notifier_fdb_info {
	struct switchdev_notifier_info info;
	const unsigned char *addr;
	u16 vid;
	u8 added_by_user: 1;
	u8 offloaded: 1;
};

enum br_boolopt_id {
	BR_BOOLOPT_NO_LL_LEARN = 0,
	BR_BOOLOPT_MAX = 1,
};

struct br_boolopt_multi {
	__u32 optval;
	__u32 optmask;
};

enum net_bridge_opts {
	BROPT_VLAN_ENABLED = 0,
	BROPT_VLAN_STATS_ENABLED = 1,
	BROPT_NF_CALL_IPTABLES = 2,
	BROPT_NF_CALL_IP6TABLES = 3,
	BROPT_NF_CALL_ARPTABLES = 4,
	BROPT_GROUP_ADDR_SET = 5,
	BROPT_MULTICAST_ENABLED = 6,
	BROPT_MULTICAST_QUERIER = 7,
	BROPT_MULTICAST_QUERY_USE_IFADDR = 8,
	BROPT_MULTICAST_STATS_ENABLED = 9,
	BROPT_HAS_IPV6_ADDR = 10,
	BROPT_NEIGH_SUPPRESS_ENABLED = 11,
	BROPT_MTU_SET_BY_USER = 12,
	BROPT_VLAN_STATS_PER_PORT = 13,
	BROPT_NO_LL_LEARN = 14,
	BROPT_VLAN_BRIDGE_BINDING = 15,
};

struct net_bridge_port_group {
	struct net_bridge_port *port;
	struct net_bridge_port_group *next;
	struct hlist_node mglist;
	struct callback_head rcu;
	struct timer_list timer;
	struct br_ip addr;
	unsigned char eth_addr[6];
	unsigned char flags;
};

struct net_bridge_mdb_entry {
	struct rhash_head rhnode;
	struct net_bridge *br;
	struct net_bridge_port_group *ports;
	struct callback_head rcu;
	struct timer_list timer;
	struct br_ip addr;
	bool host_joined;
	struct hlist_node mdb_node;
};

enum br_pkt_type {
	BR_PKT_UNICAST = 0,
	BR_PKT_MULTICAST = 1,
	BR_PKT_BROADCAST = 2,
};

struct nf_br_ops {
	int (*br_dev_xmit_hook)(struct sk_buff *);
};

struct __fdb_entry {
	__u8 mac_addr[6];
	__u8 port_no;
	__u8 is_local;
	__u32 ageing_timer_value;
	__u8 port_hi;
	__u8 pad0;
	__u16 unused;
};

struct br_vlan_stats {
	u64 rx_bytes;
	u64 rx_packets;
	u64 tx_bytes;
	u64 tx_packets;
	struct u64_stats_sync syncp;
};

struct br_tunnel_info {
	__be64 tunnel_id;
	struct metadata_dst *tunnel_dst;
};

struct net_bridge_vlan {
	struct rhash_head vnode;
	struct rhash_head tnode;
	u16 vid;
	u16 flags;
	u16 priv_flags;
	struct br_vlan_stats *stats;
	union {
		struct net_bridge *br;
		struct net_bridge_port *port;
	};
	union {
		refcount_t refcnt;
		struct net_bridge_vlan *brvlan;
	};
	struct br_tunnel_info tinfo;
	struct list_head vlist;
	struct callback_head rcu;
};

struct __bridge_info {
	__u64 designated_root;
	__u64 bridge_id;
	__u32 root_path_cost;
	__u32 max_age;
	__u32 hello_time;
	__u32 forward_delay;
	__u32 bridge_max_age;
	__u32 bridge_hello_time;
	__u32 bridge_forward_delay;
	__u8 topology_change;
	__u8 topology_change_detected;
	__u8 root_port;
	__u8 stp_enabled;
	__u32 ageing_time;
	__u32 gc_interval;
	__u32 hello_timer_value;
	__u32 tcn_timer_value;
	__u32 topology_change_timer_value;
	__u32 gc_timer_value;
};

struct __port_info {
	__u64 designated_root;
	__u64 designated_bridge;
	__u16 port_id;
	__u16 designated_port;
	__u32 path_cost;
	__u32 designated_cost;
	__u8 state;
	__u8 top_change_ack;
	__u8 config_pending;
	__u8 unused0;
	__u32 message_age_timer_value;
	__u32 forward_delay_timer_value;
	__u32 hold_timer_value;
};

enum switchdev_attr_id {
	SWITCHDEV_ATTR_ID_UNDEFINED = 0,
	SWITCHDEV_ATTR_ID_PORT_STP_STATE = 1,
	SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS = 2,
	SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS = 3,
	SWITCHDEV_ATTR_ID_PORT_MROUTER = 4,
	SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME = 5,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING = 6,
	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED = 7,
	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER = 8,
};

struct switchdev_attr {
	struct net_device *orig_dev;
	enum switchdev_attr_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
	union {
		u8 stp_state;
		long unsigned int brport_flags;
		bool mrouter;
		clock_t ageing_time;
		bool vlan_filtering;
		bool mc_disabled;
	} u;
};

struct br_config_bpdu {
	unsigned int topology_change: 1;
	unsigned int topology_change_ack: 1;
	bridge_id root;
	int root_path_cost;
	bridge_id bridge_id;
	port_id port_id;
	int message_age;
	int max_age;
	int hello_time;
	int forward_delay;
};

enum {
	IFLA_BR_UNSPEC = 0,
	IFLA_BR_FORWARD_DELAY = 1,
	IFLA_BR_HELLO_TIME = 2,
	IFLA_BR_MAX_AGE = 3,
	IFLA_BR_AGEING_TIME = 4,
	IFLA_BR_STP_STATE = 5,
	IFLA_BR_PRIORITY = 6,
	IFLA_BR_VLAN_FILTERING = 7,
	IFLA_BR_VLAN_PROTOCOL = 8,
	IFLA_BR_GROUP_FWD_MASK = 9,
	IFLA_BR_ROOT_ID = 10,
	IFLA_BR_BRIDGE_ID = 11,
	IFLA_BR_ROOT_PORT = 12,
	IFLA_BR_ROOT_PATH_COST = 13,
	IFLA_BR_TOPOLOGY_CHANGE = 14,
	IFLA_BR_TOPOLOGY_CHANGE_DETECTED = 15,
	IFLA_BR_HELLO_TIMER = 16,
	IFLA_BR_TCN_TIMER = 17,
	IFLA_BR_TOPOLOGY_CHANGE_TIMER = 18,
	IFLA_BR_GC_TIMER = 19,
	IFLA_BR_GROUP_ADDR = 20,
	IFLA_BR_FDB_FLUSH = 21,
	IFLA_BR_MCAST_ROUTER = 22,
	IFLA_BR_MCAST_SNOOPING = 23,
	IFLA_BR_MCAST_QUERY_USE_IFADDR = 24,
	IFLA_BR_MCAST_QUERIER = 25,
	IFLA_BR_MCAST_HASH_ELASTICITY = 26,
	IFLA_BR_MCAST_HASH_MAX = 27,
	IFLA_BR_MCAST_LAST_MEMBER_CNT = 28,
	IFLA_BR_MCAST_STARTUP_QUERY_CNT = 29,
	IFLA_BR_MCAST_LAST_MEMBER_INTVL = 30,
	IFLA_BR_MCAST_MEMBERSHIP_INTVL = 31,
	IFLA_BR_MCAST_QUERIER_INTVL = 32,
	IFLA_BR_MCAST_QUERY_INTVL = 33,
	IFLA_BR_MCAST_QUERY_RESPONSE_INTVL = 34,
	IFLA_BR_MCAST_STARTUP_QUERY_INTVL = 35,
	IFLA_BR_NF_CALL_IPTABLES = 36,
	IFLA_BR_NF_CALL_IP6TABLES = 37,
	IFLA_BR_NF_CALL_ARPTABLES = 38,
	IFLA_BR_VLAN_DEFAULT_PVID = 39,
	IFLA_BR_PAD = 40,
	IFLA_BR_VLAN_STATS_ENABLED = 41,
	IFLA_BR_MCAST_STATS_ENABLED = 42,
	IFLA_BR_MCAST_IGMP_VERSION = 43,
	IFLA_BR_MCAST_MLD_VERSION = 44,
	IFLA_BR_VLAN_STATS_PER_PORT = 45,
	IFLA_BR_MULTI_BOOLOPT = 46,
	__IFLA_BR_MAX = 47,
};

enum {
	LINK_XSTATS_TYPE_UNSPEC = 0,
	LINK_XSTATS_TYPE_BRIDGE = 1,
	LINK_XSTATS_TYPE_BOND = 2,
	__LINK_XSTATS_TYPE_MAX = 3,
};

struct bridge_vlan_info {
	__u16 flags;
	__u16 vid;
};

struct bridge_vlan_xstats {
	__u64 rx_bytes;
	__u64 rx_packets;
	__u64 tx_bytes;
	__u64 tx_packets;
	__u16 vid;
	__u16 flags;
	__u32 pad2;
};

enum {
	BRIDGE_XSTATS_UNSPEC = 0,
	BRIDGE_XSTATS_VLAN = 1,
	BRIDGE_XSTATS_MCAST = 2,
	BRIDGE_XSTATS_PAD = 3,
	__BRIDGE_XSTATS_MAX = 4,
};

enum {
	BR_GROUPFWD_STP = 1,
	BR_GROUPFWD_MACPAUSE = 2,
	BR_GROUPFWD_LACP = 4,
};

struct vtunnel_info {
	u32 tunid;
	u16 vid;
	u16 flags;
};

enum {
	IFLA_BRIDGE_VLAN_TUNNEL_UNSPEC = 0,
	IFLA_BRIDGE_VLAN_TUNNEL_ID = 1,
	IFLA_BRIDGE_VLAN_TUNNEL_VID = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_FLAGS = 3,
	__IFLA_BRIDGE_VLAN_TUNNEL_MAX = 4,
};

struct brport_attribute {
	struct attribute attr;
	ssize_t (*show)(struct net_bridge_port *, char *);
	int (*store)(struct net_bridge_port *, long unsigned int);
	int (*store_raw)(struct net_bridge_port *, char *);
};

struct pimhdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
};

enum {
	MDB_RTR_TYPE_DISABLED = 0,
	MDB_RTR_TYPE_TEMP_QUERY = 1,
	MDB_RTR_TYPE_PERM = 2,
	MDB_RTR_TYPE_TEMP = 3,
};

struct br_ip_list {
	struct list_head list;
	struct br_ip addr;
};

enum switchdev_obj_id {
	SWITCHDEV_OBJ_ID_UNDEFINED = 0,
	SWITCHDEV_OBJ_ID_PORT_VLAN = 1,
	SWITCHDEV_OBJ_ID_PORT_MDB = 2,
	SWITCHDEV_OBJ_ID_HOST_MDB = 3,
};

struct switchdev_obj {
	struct net_device *orig_dev;
	enum switchdev_obj_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
	long unsigned int kabi_reserved1;
	long unsigned int kabi_reserved2;
	long unsigned int kabi_reserved3;
	long unsigned int kabi_reserved4;
};

struct switchdev_obj_port_mdb {
	struct switchdev_obj obj;
	unsigned char addr[6];
	u16 vid;
};

enum {
	MDBA_UNSPEC = 0,
	MDBA_MDB = 1,
	MDBA_ROUTER = 2,
	__MDBA_MAX = 3,
};

enum {
	MDBA_MDB_UNSPEC = 0,
	MDBA_MDB_ENTRY = 1,
	__MDBA_MDB_MAX = 2,
};

enum {
	MDBA_MDB_ENTRY_UNSPEC = 0,
	MDBA_MDB_ENTRY_INFO = 1,
	__MDBA_MDB_ENTRY_MAX = 2,
};

enum {
	MDBA_MDB_EATTR_UNSPEC = 0,
	MDBA_MDB_EATTR_TIMER = 1,
	__MDBA_MDB_EATTR_MAX = 2,
};

enum {
	MDBA_ROUTER_UNSPEC = 0,
	MDBA_ROUTER_PORT = 1,
	__MDBA_ROUTER_MAX = 2,
};

enum {
	MDBA_ROUTER_PATTR_UNSPEC = 0,
	MDBA_ROUTER_PATTR_TIMER = 1,
	MDBA_ROUTER_PATTR_TYPE = 2,
	__MDBA_ROUTER_PATTR_MAX = 3,
};

struct br_port_msg {
	__u8 family;
	__u32 ifindex;
};

struct br_mdb_entry {
	__u32 ifindex;
	__u8 state;
	__u8 flags;
	__u16 vid;
	struct {
		union {
			__be32 ip4;
			struct in6_addr ip6;
		} u;
		__be16 proto;
	} addr;
};

enum {
	MDBA_SET_ENTRY_UNSPEC = 0,
	MDBA_SET_ENTRY = 1,
	__MDBA_SET_ENTRY_MAX = 2,
};

struct br_mdb_complete_info {
	struct net_bridge_port *port;
	struct br_ip ip;
};

enum vlan_flags {
	VLAN_FLAG_REORDER_HDR = 1,
	VLAN_FLAG_GVRP = 2,
	VLAN_FLAG_LOOSE_BINDING = 4,
	VLAN_FLAG_MVRP = 8,
	VLAN_FLAG_BRIDGE_BINDING = 16,
};

struct vlan_priority_tci_mapping {
	u32 priority;
	u16 vlan_qos;
	struct vlan_priority_tci_mapping *next;
};

struct vlan_dev_priv {
	unsigned int nr_ingress_mappings;
	u32 ingress_priority_map[8];
	unsigned int nr_egress_mappings;
	struct vlan_priority_tci_mapping *egress_priority_map[16];
	__be16 vlan_proto;
	u16 vlan_id;
	u16 flags;
	struct net_device *real_dev;
	unsigned char real_dev_addr[6];
	struct proc_dir_entry *dent;
	struct vlan_pcpu_stats *vlan_pcpu_stats;
	struct netpoll *netpoll;
};

enum {
	BR_VLFLAG_PER_PORT_STATS = 1,
	BR_VLFLAG_ADDED_BY_SWITCHDEV = 2,
};

struct br_vlan_bind_walk_data {
	u16 vid;
	struct net_device *result;
};

struct br_vlan_link_state_walk_data {
	struct net_bridge *br;
};

enum nf_br_hook_priorities {
	NF_BR_PRI_FIRST = 2147483648,
	NF_BR_PRI_NAT_DST_BRIDGED = 4294966996,
	NF_BR_PRI_FILTER_BRIDGED = 4294967096,
	NF_BR_PRI_BRNF = 0,
	NF_BR_PRI_NAT_DST_OTHER = 100,
	NF_BR_PRI_FILTER_OTHER = 200,
	NF_BR_PRI_NAT_SRC = 300,
	NF_BR_PRI_LAST = 2147483647,
};

struct brnf_net {
	bool enabled;
	struct ctl_table_header *ctl_hdr;
	int call_iptables;
	int call_ip6tables;
	int call_arptables;
	int filter_vlan_tagged;
	int filter_pppoe_tagged;
	int pass_vlan_indev;
};

struct brnf_frag_data {
	char mac[22];
	u8 encap_size;
	u8 size;
	u16 vlan_tci;
	__be16 vlan_proto;
};

struct strp_msg {
	int full_len;
	int offset;
};

struct _strp_msg {
	struct strp_msg strp;
	int accum_len;
};

struct vlan_group {
	unsigned int nr_vlan_devs;
	struct hlist_node hlist;
	struct net_device___2 **vlan_devices_arrays[16];
};

struct vlan_info {
	struct net_device___2 *real_dev;
	struct vlan_group grp;
	struct list_head vid_list;
	unsigned int nr_vids;
	struct callback_head rcu;
};

typedef struct sk_buff___2 * (*gro_receive_t___2)(struct list_head *, struct sk_buff___2 *);

enum vlan_protos {
	VLAN_PROTO_8021Q = 0,
	VLAN_PROTO_8021AD = 1,
	VLAN_PROTO_NUM = 2,
};

struct vlan_vid_info {
	struct list_head list;
	__be16 proto;
	u16 vid;
	int refcount;
};

enum vlan_ioctl_cmds {
	ADD_VLAN_CMD = 0,
	DEL_VLAN_CMD = 1,
	SET_VLAN_INGRESS_PRIORITY_CMD = 2,
	SET_VLAN_EGRESS_PRIORITY_CMD = 3,
	GET_VLAN_INGRESS_PRIORITY_CMD = 4,
	GET_VLAN_EGRESS_PRIORITY_CMD = 5,
	SET_VLAN_NAME_TYPE_CMD = 6,
	SET_VLAN_FLAG_CMD = 7,
	GET_VLAN_REALDEV_NAME_CMD = 8,
	GET_VLAN_VID_CMD = 9,
};

enum vlan_name_types {
	VLAN_NAME_TYPE_PLUS_VID = 0,
	VLAN_NAME_TYPE_RAW_PLUS_VID = 1,
	VLAN_NAME_TYPE_PLUS_VID_NO_PAD = 2,
	VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD = 3,
	VLAN_NAME_TYPE_HIGHEST = 4,
};

struct vlan_ioctl_args {
	int cmd;
	char device1[24];
	union {
		char device2[24];
		int VID;
		unsigned int skb_priority;
		unsigned int name_type;
		unsigned int bind_type;
		unsigned int flag;
	} u;
	short int vlan_qos;
};

struct vlan_net {
	struct proc_dir_entry *proc_vlan_dir;
	struct proc_dir_entry *proc_vlan_conf;
	short unsigned int name_type;
};

enum {
	IFLA_VLAN_UNSPEC = 0,
	IFLA_VLAN_ID = 1,
	IFLA_VLAN_FLAGS = 2,
	IFLA_VLAN_EGRESS_QOS = 3,
	IFLA_VLAN_INGRESS_QOS = 4,
	IFLA_VLAN_PROTOCOL = 5,
	__IFLA_VLAN_MAX = 6,
};

struct ifla_vlan_flags {
	__u32 flags;
	__u32 mask;
};

enum {
	IFLA_VLAN_QOS_UNSPEC = 0,
	IFLA_VLAN_QOS_MAPPING = 1,
	__IFLA_VLAN_QOS_MAX = 2,
};

struct ifla_vlan_qos_mapping {
	__u32 from;
	__u32 to;
};

enum gvrp_attributes {
	GVRP_ATTR_INVALID = 0,
	GVRP_ATTR_VID = 1,
	__GVRP_ATTR_MAX = 2,
};

enum mvrp_attributes {
	MVRP_ATTR_INVALID = 0,
	MVRP_ATTR_VID = 1,
	__MVRP_ATTR_MAX = 2,
};

enum p9_msg_t {
	P9_TLERROR = 6,
	P9_RLERROR = 7,
	P9_TSTATFS = 8,
	P9_RSTATFS = 9,
	P9_TLOPEN = 12,
	P9_RLOPEN = 13,
	P9_TLCREATE = 14,
	P9_RLCREATE = 15,
	P9_TSYMLINK = 16,
	P9_RSYMLINK = 17,
	P9_TMKNOD = 18,
	P9_RMKNOD = 19,
	P9_TRENAME = 20,
	P9_RRENAME = 21,
	P9_TREADLINK = 22,
	P9_RREADLINK = 23,
	P9_TGETATTR = 24,
	P9_RGETATTR = 25,
	P9_TSETATTR = 26,
	P9_RSETATTR = 27,
	P9_TXATTRWALK = 30,
	P9_RXATTRWALK = 31,
	P9_TXATTRCREATE = 32,
	P9_RXATTRCREATE = 33,
	P9_TREADDIR = 40,
	P9_RREADDIR = 41,
	P9_TFSYNC = 50,
	P9_RFSYNC = 51,
	P9_TLOCK = 52,
	P9_RLOCK = 53,
	P9_TGETLOCK = 54,
	P9_RGETLOCK = 55,
	P9_TLINK = 70,
	P9_RLINK = 71,
	P9_TMKDIR = 72,
	P9_RMKDIR = 73,
	P9_TRENAMEAT = 74,
	P9_RRENAMEAT = 75,
	P9_TUNLINKAT = 76,
	P9_RUNLINKAT = 77,
	P9_TVERSION = 100,
	P9_RVERSION = 101,
	P9_TAUTH = 102,
	P9_RAUTH = 103,
	P9_TATTACH = 104,
	P9_RATTACH = 105,
	P9_TERROR = 106,
	P9_RERROR = 107,
	P9_TFLUSH = 108,
	P9_RFLUSH = 109,
	P9_TWALK = 110,
	P9_RWALK = 111,
	P9_TOPEN = 112,
	P9_ROPEN = 113,
	P9_TCREATE = 114,
	P9_RCREATE = 115,
	P9_TREAD = 116,
	P9_RREAD = 117,
	P9_TWRITE = 118,
	P9_RWRITE = 119,
	P9_TCLUNK = 120,
	P9_RCLUNK = 121,
	P9_TREMOVE = 122,
	P9_RREMOVE = 123,
	P9_TSTAT = 124,
	P9_RSTAT = 125,
	P9_TWSTAT = 126,
	P9_RWSTAT = 127,
};

enum p9_proto_versions {
	p9_proto_legacy = 0,
	p9_proto_2000u = 1,
	p9_proto_2000L = 2,
};

enum p9_req_status_t {
	REQ_STATUS_ALLOC = 0,
	REQ_STATUS_UNSENT = 1,
	REQ_STATUS_SENT = 2,
	REQ_STATUS_RCVD = 3,
	REQ_STATUS_FLSHD = 4,
	REQ_STATUS_ERROR = 5,
};

struct trace_event_raw_9p_client_req {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	char __data[0];
};

struct trace_event_raw_9p_client_res {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	__u32 err;
	char __data[0];
};

struct trace_event_raw_9p_protocol_dump {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u16 tag;
	unsigned char line[32];
	char __data[0];
};

struct trace_event_data_offsets_9p_client_req {};

struct trace_event_data_offsets_9p_client_res {};

struct trace_event_data_offsets_9p_protocol_dump {};

typedef void (*btf_trace_9p_client_req)(void *, struct p9_client *, int8_t, int);

typedef void (*btf_trace_9p_client_res)(void *, struct p9_client *, int8_t, int, int);

typedef void (*btf_trace_9p_protocol_dump)(void *, struct p9_client *, struct p9_fcall *);

enum {
	Opt_msize = 0,
	Opt_trans = 1,
	Opt_legacy = 2,
	Opt_version = 3,
	Opt_err___11 = 4,
};

struct errormap {
	char *name;
	int val;
	int namelen;
	struct hlist_node list;
};

struct p9_fd_opts {
	int rfd;
	int wfd;
	u16 port;
	bool privport;
};

enum {
	Opt_port = 0,
	Opt_rfdno = 1,
	Opt_wfdno = 2,
	Opt_err___12 = 3,
	Opt_privport = 4,
};

enum {
	Rworksched = 1,
	Rpending = 2,
	Wworksched = 4,
	Wpending = 8,
};

struct p9_conn;

struct p9_poll_wait {
	struct p9_conn *conn;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_addr;
};

struct p9_conn {
	struct list_head mux_list;
	struct p9_client *client;
	int err;
	struct list_head req_list;
	struct list_head unsent_req_list;
	struct p9_req_t *rreq;
	struct p9_req_t *wreq;
	char tmp_buf[7];
	struct p9_fcall rc;
	int wpos;
	int wsize;
	char *wbuf;
	struct list_head poll_pending_link;
	struct p9_poll_wait poll_wait[2];
	poll_table pt;
	struct work_struct rq;
	struct work_struct wq;
	long unsigned int wsched;
};

struct p9_trans_fd {
	struct file___2 *rd;
	struct file___2 *wr;
	struct p9_conn conn;
};

struct virtio_9p_config {
	__u16 tag_len;
	__u8 tag[0];
};

struct virtio_chan {
	bool inuse;
	spinlock_t lock;
	struct p9_client *client;
	struct virtio_device *vdev;
	struct virtqueue *vq;
	int ring_bufs_avail;
	wait_queue_head_t *vc_wq;
	long unsigned int p9_max_pages;
	struct scatterlist sg[128];
	char *tag;
	struct list_head chan_list;
};

struct dcbmsg {
	__u8 dcb_family;
	__u8 cmd;
	__u16 dcb_pad;
};

enum dcbnl_commands {
	DCB_CMD_UNDEFINED = 0,
	DCB_CMD_GSTATE = 1,
	DCB_CMD_SSTATE = 2,
	DCB_CMD_PGTX_GCFG = 3,
	DCB_CMD_PGTX_SCFG = 4,
	DCB_CMD_PGRX_GCFG = 5,
	DCB_CMD_PGRX_SCFG = 6,
	DCB_CMD_PFC_GCFG = 7,
	DCB_CMD_PFC_SCFG = 8,
	DCB_CMD_SET_ALL = 9,
	DCB_CMD_GPERM_HWADDR = 10,
	DCB_CMD_GCAP = 11,
	DCB_CMD_GNUMTCS = 12,
	DCB_CMD_SNUMTCS = 13,
	DCB_CMD_PFC_GSTATE = 14,
	DCB_CMD_PFC_SSTATE = 15,
	DCB_CMD_BCN_GCFG = 16,
	DCB_CMD_BCN_SCFG = 17,
	DCB_CMD_GAPP = 18,
	DCB_CMD_SAPP = 19,
	DCB_CMD_IEEE_SET = 20,
	DCB_CMD_IEEE_GET = 21,
	DCB_CMD_GDCBX = 22,
	DCB_CMD_SDCBX = 23,
	DCB_CMD_GFEATCFG = 24,
	DCB_CMD_SFEATCFG = 25,
	DCB_CMD_CEE_GET = 26,
	DCB_CMD_IEEE_DEL = 27,
	__DCB_CMD_ENUM_MAX = 28,
	DCB_CMD_MAX = 27,
};

enum dcbnl_attrs {
	DCB_ATTR_UNDEFINED = 0,
	DCB_ATTR_IFNAME = 1,
	DCB_ATTR_STATE = 2,
	DCB_ATTR_PFC_STATE = 3,
	DCB_ATTR_PFC_CFG = 4,
	DCB_ATTR_NUM_TC = 5,
	DCB_ATTR_PG_CFG = 6,
	DCB_ATTR_SET_ALL = 7,
	DCB_ATTR_PERM_HWADDR = 8,
	DCB_ATTR_CAP = 9,
	DCB_ATTR_NUMTCS = 10,
	DCB_ATTR_BCN = 11,
	DCB_ATTR_APP = 12,
	DCB_ATTR_IEEE = 13,
	DCB_ATTR_DCBX = 14,
	DCB_ATTR_FEATCFG = 15,
	DCB_ATTR_CEE = 16,
	__DCB_ATTR_ENUM_MAX = 17,
	DCB_ATTR_MAX = 16,
};

enum ieee_attrs {
	DCB_ATTR_IEEE_UNSPEC = 0,
	DCB_ATTR_IEEE_ETS = 1,
	DCB_ATTR_IEEE_PFC = 2,
	DCB_ATTR_IEEE_APP_TABLE = 3,
	DCB_ATTR_IEEE_PEER_ETS = 4,
	DCB_ATTR_IEEE_PEER_PFC = 5,
	DCB_ATTR_IEEE_PEER_APP = 6,
	DCB_ATTR_IEEE_MAXRATE = 7,
	DCB_ATTR_IEEE_QCN = 8,
	DCB_ATTR_IEEE_QCN_STATS = 9,
	DCB_ATTR_DCB_BUFFER = 10,
	__DCB_ATTR_IEEE_MAX = 11,
};

enum ieee_attrs_app {
	DCB_ATTR_IEEE_APP_UNSPEC = 0,
	DCB_ATTR_IEEE_APP = 1,
	__DCB_ATTR_IEEE_APP_MAX = 2,
};

enum cee_attrs {
	DCB_ATTR_CEE_UNSPEC = 0,
	DCB_ATTR_CEE_PEER_PG = 1,
	DCB_ATTR_CEE_PEER_PFC = 2,
	DCB_ATTR_CEE_PEER_APP_TABLE = 3,
	DCB_ATTR_CEE_TX_PG = 4,
	DCB_ATTR_CEE_RX_PG = 5,
	DCB_ATTR_CEE_PFC = 6,
	DCB_ATTR_CEE_APP_TABLE = 7,
	DCB_ATTR_CEE_FEAT = 8,
	__DCB_ATTR_CEE_MAX = 9,
};

enum peer_app_attr {
	DCB_ATTR_CEE_PEER_APP_UNSPEC = 0,
	DCB_ATTR_CEE_PEER_APP_INFO = 1,
	DCB_ATTR_CEE_PEER_APP = 2,
	__DCB_ATTR_CEE_PEER_APP_MAX = 3,
};

enum dcbnl_pfc_up_attrs {
	DCB_PFC_UP_ATTR_UNDEFINED = 0,
	DCB_PFC_UP_ATTR_0 = 1,
	DCB_PFC_UP_ATTR_1 = 2,
	DCB_PFC_UP_ATTR_2 = 3,
	DCB_PFC_UP_ATTR_3 = 4,
	DCB_PFC_UP_ATTR_4 = 5,
	DCB_PFC_UP_ATTR_5 = 6,
	DCB_PFC_UP_ATTR_6 = 7,
	DCB_PFC_UP_ATTR_7 = 8,
	DCB_PFC_UP_ATTR_ALL = 9,
	__DCB_PFC_UP_ATTR_ENUM_MAX = 10,
	DCB_PFC_UP_ATTR_MAX = 9,
};

enum dcbnl_pg_attrs {
	DCB_PG_ATTR_UNDEFINED = 0,
	DCB_PG_ATTR_TC_0 = 1,
	DCB_PG_ATTR_TC_1 = 2,
	DCB_PG_ATTR_TC_2 = 3,
	DCB_PG_ATTR_TC_3 = 4,
	DCB_PG_ATTR_TC_4 = 5,
	DCB_PG_ATTR_TC_5 = 6,
	DCB_PG_ATTR_TC_6 = 7,
	DCB_PG_ATTR_TC_7 = 8,
	DCB_PG_ATTR_TC_MAX = 9,
	DCB_PG_ATTR_TC_ALL = 10,
	DCB_PG_ATTR_BW_ID_0 = 11,
	DCB_PG_ATTR_BW_ID_1 = 12,
	DCB_PG_ATTR_BW_ID_2 = 13,
	DCB_PG_ATTR_BW_ID_3 = 14,
	DCB_PG_ATTR_BW_ID_4 = 15,
	DCB_PG_ATTR_BW_ID_5 = 16,
	DCB_PG_ATTR_BW_ID_6 = 17,
	DCB_PG_ATTR_BW_ID_7 = 18,
	DCB_PG_ATTR_BW_ID_MAX = 19,
	DCB_PG_ATTR_BW_ID_ALL = 20,
	__DCB_PG_ATTR_ENUM_MAX = 21,
	DCB_PG_ATTR_MAX = 20,
};

enum dcbnl_tc_attrs {
	DCB_TC_ATTR_PARAM_UNDEFINED = 0,
	DCB_TC_ATTR_PARAM_PGID = 1,
	DCB_TC_ATTR_PARAM_UP_MAPPING = 2,
	DCB_TC_ATTR_PARAM_STRICT_PRIO = 3,
	DCB_TC_ATTR_PARAM_BW_PCT = 4,
	DCB_TC_ATTR_PARAM_ALL = 5,
	__DCB_TC_ATTR_PARAM_ENUM_MAX = 6,
	DCB_TC_ATTR_PARAM_MAX = 5,
};

enum dcbnl_cap_attrs {
	DCB_CAP_ATTR_UNDEFINED = 0,
	DCB_CAP_ATTR_ALL = 1,
	DCB_CAP_ATTR_PG = 2,
	DCB_CAP_ATTR_PFC = 3,
	DCB_CAP_ATTR_UP2TC = 4,
	DCB_CAP_ATTR_PG_TCS = 5,
	DCB_CAP_ATTR_PFC_TCS = 6,
	DCB_CAP_ATTR_GSP = 7,
	DCB_CAP_ATTR_BCN = 8,
	DCB_CAP_ATTR_DCBX = 9,
	__DCB_CAP_ATTR_ENUM_MAX = 10,
	DCB_CAP_ATTR_MAX = 9,
};

enum dcbnl_numtcs_attrs {
	DCB_NUMTCS_ATTR_UNDEFINED = 0,
	DCB_NUMTCS_ATTR_ALL = 1,
	DCB_NUMTCS_ATTR_PG = 2,
	DCB_NUMTCS_ATTR_PFC = 3,
	__DCB_NUMTCS_ATTR_ENUM_MAX = 4,
	DCB_NUMTCS_ATTR_MAX = 3,
};

enum dcbnl_bcn_attrs {
	DCB_BCN_ATTR_UNDEFINED = 0,
	DCB_BCN_ATTR_RP_0 = 1,
	DCB_BCN_ATTR_RP_1 = 2,
	DCB_BCN_ATTR_RP_2 = 3,
	DCB_BCN_ATTR_RP_3 = 4,
	DCB_BCN_ATTR_RP_4 = 5,
	DCB_BCN_ATTR_RP_5 = 6,
	DCB_BCN_ATTR_RP_6 = 7,
	DCB_BCN_ATTR_RP_7 = 8,
	DCB_BCN_ATTR_RP_ALL = 9,
	DCB_BCN_ATTR_BCNA_0 = 10,
	DCB_BCN_ATTR_BCNA_1 = 11,
	DCB_BCN_ATTR_ALPHA = 12,
	DCB_BCN_ATTR_BETA = 13,
	DCB_BCN_ATTR_GD = 14,
	DCB_BCN_ATTR_GI = 15,
	DCB_BCN_ATTR_TMAX = 16,
	DCB_BCN_ATTR_TD = 17,
	DCB_BCN_ATTR_RMIN = 18,
	DCB_BCN_ATTR_W = 19,
	DCB_BCN_ATTR_RD = 20,
	DCB_BCN_ATTR_RU = 21,
	DCB_BCN_ATTR_WRTT = 22,
	DCB_BCN_ATTR_RI = 23,
	DCB_BCN_ATTR_C = 24,
	DCB_BCN_ATTR_ALL = 25,
	__DCB_BCN_ATTR_ENUM_MAX = 26,
	DCB_BCN_ATTR_MAX = 25,
};

enum dcb_general_attr_values {
	DCB_ATTR_VALUE_UNDEFINED = 255,
};

enum dcbnl_app_attrs {
	DCB_APP_ATTR_UNDEFINED = 0,
	DCB_APP_ATTR_IDTYPE = 1,
	DCB_APP_ATTR_ID = 2,
	DCB_APP_ATTR_PRIORITY = 3,
	__DCB_APP_ATTR_ENUM_MAX = 4,
	DCB_APP_ATTR_MAX = 3,
};

enum dcbnl_featcfg_attrs {
	DCB_FEATCFG_ATTR_UNDEFINED = 0,
	DCB_FEATCFG_ATTR_ALL = 1,
	DCB_FEATCFG_ATTR_PG = 2,
	DCB_FEATCFG_ATTR_PFC = 3,
	DCB_FEATCFG_ATTR_APP = 4,
	__DCB_FEATCFG_ATTR_ENUM_MAX = 5,
	DCB_FEATCFG_ATTR_MAX = 4,
};

struct dcb_ieee_app_prio_map {
	u64 map[8];
};

struct dcb_ieee_app_dscp_map {
	u8 map[64];
};

enum dcbevent_notif_type {
	DCB_APP_EVENT = 1,
};

struct reply_func {
	int type;
	int (*cb)(struct net_device *, struct nlmsghdr *, u32, struct nlattr **, struct sk_buff *);
};

enum dns_payload_content_type {
	DNS_PAYLOAD_IS_SERVER_LIST = 0,
};

struct dns_payload_header {
	__u8 zero;
	__u8 content;
	__u8 version;
};

enum {
	dns_key_data = 0,
	dns_key_error = 1,
};

struct sockaddr_xdp {
	__u16 sxdp_family;
	__u16 sxdp_flags;
	__u32 sxdp_ifindex;
	__u32 sxdp_queue_id;
	__u32 sxdp_shared_umem_fd;
};

struct xdp_ring_offset {
	__u64 producer;
	__u64 consumer;
	__u64 desc;
	__u64 flags;
};

struct xdp_mmap_offsets {
	struct xdp_ring_offset rx;
	struct xdp_ring_offset tx;
	struct xdp_ring_offset fr;
	struct xdp_ring_offset cr;
};

struct xdp_umem_reg {
	__u64 addr;
	__u64 len;
	__u32 chunk_size;
	__u32 headroom;
	__u32 flags;
};

struct xdp_statistics {
	__u64 rx_dropped;
	__u64 rx_invalid_descs;
	__u64 tx_invalid_descs;
};

struct xdp_options {
	__u32 flags;
};

struct xdp_desc {
	__u64 addr;
	__u32 len;
	__u32 options;
};

struct xdp_ring;

struct xsk_queue {
	u64 chunk_mask;
	u64 size;
	u32 ring_mask;
	u32 nentries;
	u32 prod_head;
	u32 prod_tail;
	u32 cons_head;
	u32 cons_tail;
	struct xdp_ring *ring;
	u64 invalid_descs;
};

struct xdp_ring {
	u32 producer;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 consumer;
	u32 flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_rxtx_ring {
	struct xdp_ring ptrs;
	struct xdp_desc desc[0];
};

struct xdp_umem_ring {
	struct xdp_ring ptrs;
	u64 desc[0];
};

struct xdp_ring_offset_v1 {
	__u64 producer;
	__u64 consumer;
	__u64 desc;
};

struct xdp_mmap_offsets_v1 {
	struct xdp_ring_offset_v1 rx;
	struct xdp_ring_offset_v1 tx;
	struct xdp_ring_offset_v1 fr;
	struct xdp_ring_offset_v1 cr;
};

struct mptcp_mib {
	long unsigned int mibs[47];
};

struct mptcp_options_received {
	u64 sndr_key;
	u64 rcvr_key;
	u64 data_ack;
	u64 data_seq;
	u32 subflow_seq;
	u16 data_len;
	__sum16 csum;
	u16 suboptions;
	u32 token;
	u32 nonce;
	u16 use_map: 1;
	u16 dsn64: 1;
	u16 data_fin: 1;
	u16 use_ack: 1;
	u16 ack64: 1;
	u16 mpc_map: 1;
	u16 reset_reason: 4;
	u16 reset_transient: 1;
	u16 echo: 1;
	u16 backup: 1;
	u16 deny_join_id0: 1;
	u16 __unused: 2;
	u8 join_id;
	u64 thmac;
	u8 hmac[20];
	struct mptcp_addr_info addr;
	struct mptcp_rm_list rm_list;
	u64 ahmac;
	u64 fail_seq;
};

enum mptcp_event_type {
	MPTCP_EVENT_UNSPEC = 0,
	MPTCP_EVENT_CREATED = 1,
	MPTCP_EVENT_ESTABLISHED = 2,
	MPTCP_EVENT_CLOSED = 3,
	MPTCP_EVENT_ANNOUNCED = 6,
	MPTCP_EVENT_REMOVED = 7,
	MPTCP_EVENT_SUB_ESTABLISHED = 10,
	MPTCP_EVENT_SUB_CLOSED = 11,
	MPTCP_EVENT_SUB_PRIORITY = 13,
};

struct mptcp_pm_data {
	struct mptcp_addr_info local;
	struct mptcp_addr_info remote;
	struct list_head anno_list;
	spinlock_t lock;
	u8 addr_signal;
	bool server_side;
	bool work_pending;
	bool accept_addr;
	bool accept_subflow;
	bool remote_deny_join_id0;
	u8 add_addr_signaled;
	u8 add_addr_accepted;
	u8 local_addr_used;
	u8 subflows;
	u8 status;
	long unsigned int id_avail_bitmap[4];
	struct mptcp_rm_list rm_list_tx;
	struct mptcp_rm_list rm_list_rx;
};

struct mptcp_data_frag {
	struct list_head list;
	u64 data_seq;
	u16 data_len;
	u16 offset;
	u16 overhead;
	u16 already_sent;
	struct page *page;
};

struct mptcp_sock {
	struct inet_connection_sock sk;
	u64 local_key;
	u64 remote_key;
	u64 write_seq;
	u64 snd_nxt;
	u64 ack_seq;
	u64 rcv_wnd_sent;
	u64 copied_seq;
	u64 rcv_data_fin_seq;
	int rmem_fwd_alloc;
	struct sock *last_snd;
	int snd_burst;
	int old_wspace;
	u64 recovery_snd_nxt;
	u64 snd_una;
	u64 wnd_end;
	atomic_t subflow_count;
	long unsigned int timer_ival;
	u32 token;
	int rmem_released;
	long unsigned int flags;
	long unsigned int cb_flags;
	long unsigned int push_pending;
	bool recovery;
	bool can_ack;
	bool fully_established;
	bool rcv_data_fin;
	bool snd_data_fin_enable;
	bool rcv_fastclose;
	bool use_64bit_ack;
	bool csum_enabled;
	u8 recvmsg_inq: 1;
	u8 cork: 1;
	u8 nodelay: 1;
	struct work_struct work;
	struct sk_buff *ooo_last_skb;
	struct rb_root out_of_order_queue;
	struct sk_buff_head receive_queue;
	struct list_head conn_list;
	struct list_head rtx_queue;
	struct mptcp_data_frag *first_pending;
	struct list_head join_list;
	struct hlist_node all_list;
	struct socket *subflow;
	struct sock *first;
	struct mptcp_pm_data pm;
	struct {
		u32 space;
		u32 copied;
		u64 time;
		u64 rtt_us;
	} rcvq_space;
	u32 setsockopt_seq;
	char ca_name[16];
	struct mptcp_sock *dl_next;
};

struct mptcp_subflow_request_sock {
	struct tcp_request_sock sk;
	u16 mp_capable: 1;
	u16 mp_join: 1;
	u16 backup: 1;
	u16 csum_reqd: 1;
	u16 allow_join_id0: 1;
	u8 local_id;
	u8 remote_id;
	u64 local_key;
	u64 idsn;
	u32 token;
	u32 ssn_offset;
	u64 thmac;
	u32 local_nonce;
	u32 remote_nonce;
	struct mptcp_sock *msk;
	struct hlist_nulls_node token_node;
};

enum mptcp_data_avail {
	MPTCP_SUBFLOW_NODATA = 0,
	MPTCP_SUBFLOW_DATA_AVAIL = 1,
};

struct mptcp_delegated_action {
	struct napi_struct napi;
	struct list_head head;
};

struct mptcp_subflow_context {
	struct list_head node;
	union {
		struct {
			long unsigned int avg_pacing_rate;
			u64 local_key;
			u64 remote_key;
			u64 idsn;
			u64 map_seq;
			u32 snd_isn;
			u32 token;
			u32 rel_write_seq;
			u32 map_subflow_seq;
			u32 ssn_offset;
			u32 map_data_len;
			__wsum map_data_csum;
			u32 map_csum_len;
			u32 request_mptcp: 1;
			u32 request_join: 1;
			u32 request_bkup: 1;
			u32 mp_capable: 1;
			u32 mp_join: 1;
			u32 fully_established: 1;
			u32 pm_notified: 1;
			u32 conn_finished: 1;
			u32 map_valid: 1;
			u32 map_csum_reqd: 1;
			u32 map_data_fin: 1;
			u32 mpc_map: 1;
			u32 backup: 1;
			u32 send_mp_prio: 1;
			u32 send_mp_fail: 1;
			u32 send_fastclose: 1;
			u32 rx_eof: 1;
			u32 can_ack: 1;
			u32 disposable: 1;
			u32 stale: 1;
			u32 local_id_valid: 1;
			u32 valid_csum_seen: 1;
			enum mptcp_data_avail data_avail;
			u32 remote_nonce;
			u64 thmac;
			u32 local_nonce;
			u32 remote_token;
			u8 hmac[20];
			u8 local_id;
			u8 remote_id;
			u8 reset_seen: 1;
			u8 reset_transient: 1;
			u8 reset_reason: 4;
			u8 stale_count;
			long int delegated_status;
		};
		struct {
			long unsigned int avg_pacing_rate;
			u64 local_key;
			u64 remote_key;
			u64 idsn;
			u64 map_seq;
			u32 snd_isn;
			u32 token;
			u32 rel_write_seq;
			u32 map_subflow_seq;
			u32 ssn_offset;
			u32 map_data_len;
			__wsum map_data_csum;
			u32 map_csum_len;
			u32 request_mptcp: 1;
			u32 request_join: 1;
			u32 request_bkup: 1;
			u32 mp_capable: 1;
			u32 mp_join: 1;
			u32 fully_established: 1;
			u32 pm_notified: 1;
			u32 conn_finished: 1;
			u32 map_valid: 1;
			u32 map_csum_reqd: 1;
			u32 map_data_fin: 1;
			u32 mpc_map: 1;
			u32 backup: 1;
			u32 send_mp_prio: 1;
			u32 send_mp_fail: 1;
			u32 send_fastclose: 1;
			u32 rx_eof: 1;
			u32 can_ack: 1;
			u32 disposable: 1;
			u32 stale: 1;
			u32 local_id_valid: 1;
			u32 valid_csum_seen: 1;
			enum mptcp_data_avail data_avail;
			u32 remote_nonce;
			u64 thmac;
			u32 local_nonce;
			u32 remote_token;
			u8 hmac[20];
			u8 local_id;
			u8 remote_id;
			u8 reset_seen: 1;
			u8 reset_transient: 1;
			u8 reset_reason: 4;
			u8 stale_count;
			long int delegated_status;
		} reset;
	};
	struct list_head delegated_node;
	u32 setsockopt_seq;
	u32 stale_rcv_tstamp;
	struct sock *tcp_sock;
	struct sock *conn;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	void (*tcp_state_change)(struct sock *);
	void (*tcp_error_report)(struct sock *);
	struct callback_head rcu;
};

enum linux_mptcp_mib_field {
	MPTCP_MIB_NUM = 0,
	MPTCP_MIB_MPCAPABLEPASSIVE = 1,
	MPTCP_MIB_MPCAPABLEACTIVE = 2,
	MPTCP_MIB_MPCAPABLEACTIVEACK = 3,
	MPTCP_MIB_MPCAPABLEPASSIVEACK = 4,
	MPTCP_MIB_MPCAPABLEPASSIVEFALLBACK = 5,
	MPTCP_MIB_MPCAPABLEACTIVEFALLBACK = 6,
	MPTCP_MIB_TOKENFALLBACKINIT = 7,
	MPTCP_MIB_RETRANSSEGS = 8,
	MPTCP_MIB_JOINNOTOKEN = 9,
	MPTCP_MIB_JOINSYNRX = 10,
	MPTCP_MIB_JOINSYNACKRX = 11,
	MPTCP_MIB_JOINSYNACKMAC = 12,
	MPTCP_MIB_JOINACKRX = 13,
	MPTCP_MIB_JOINACKMAC = 14,
	MPTCP_MIB_DSSNOMATCH = 15,
	MPTCP_MIB_INFINITEMAPRX = 16,
	MPTCP_MIB_DSSTCPMISMATCH = 17,
	MPTCP_MIB_DATACSUMERR = 18,
	MPTCP_MIB_OFOQUEUETAIL = 19,
	MPTCP_MIB_OFOQUEUE = 20,
	MPTCP_MIB_OFOMERGE = 21,
	MPTCP_MIB_NODSSWINDOW = 22,
	MPTCP_MIB_DUPDATA = 23,
	MPTCP_MIB_ADDADDR = 24,
	MPTCP_MIB_ECHOADD = 25,
	MPTCP_MIB_PORTADD = 26,
	MPTCP_MIB_ADDADDRDROP = 27,
	MPTCP_MIB_JOINPORTSYNRX = 28,
	MPTCP_MIB_JOINPORTSYNACKRX = 29,
	MPTCP_MIB_JOINPORTACKRX = 30,
	MPTCP_MIB_MISMATCHPORTSYNRX = 31,
	MPTCP_MIB_MISMATCHPORTACKRX = 32,
	MPTCP_MIB_RMADDR = 33,
	MPTCP_MIB_RMADDRDROP = 34,
	MPTCP_MIB_RMSUBFLOW = 35,
	MPTCP_MIB_MPPRIOTX = 36,
	MPTCP_MIB_MPPRIORX = 37,
	MPTCP_MIB_MPFAILTX = 38,
	MPTCP_MIB_MPFAILRX = 39,
	MPTCP_MIB_MPFASTCLOSETX = 40,
	MPTCP_MIB_MPFASTCLOSERX = 41,
	MPTCP_MIB_MPRSTTX = 42,
	MPTCP_MIB_MPRSTRX = 43,
	MPTCP_MIB_RCVPRUNED = 44,
	MPTCP_MIB_SUBFLOWSTALE = 45,
	MPTCP_MIB_SUBFLOWRECOVER = 46,
	__MPTCP_MIB_MAX = 47,
};

struct trace_event_raw_mptcp_subflow_get_send {
	struct trace_entry ent;
	bool active;
	bool free;
	u32 snd_wnd;
	u32 pace;
	u8 backup;
	u64 ratio;
	char __data[0];
};

struct trace_event_raw_mptcp_dump_mpext {
	struct trace_entry ent;
	u64 data_ack;
	u64 data_seq;
	u32 subflow_seq;
	u16 data_len;
	u16 csum;
	u8 use_map;
	u8 dsn64;
	u8 data_fin;
	u8 use_ack;
	u8 ack64;
	u8 mpc_map;
	u8 frozen;
	u8 reset_transient;
	u8 reset_reason;
	u8 csum_reqd;
	char __data[0];
};

struct trace_event_raw_ack_update_msk {
	struct trace_entry ent;
	u64 data_ack;
	u64 old_snd_una;
	u64 new_snd_una;
	u64 new_wnd_end;
	u64 msk_wnd_end;
	char __data[0];
};

struct trace_event_raw_subflow_check_data_avail {
	struct trace_entry ent;
	u8 status;
	const void *skb;
	char __data[0];
};

struct trace_event_data_offsets_mptcp_subflow_get_send {};

struct trace_event_data_offsets_mptcp_dump_mpext {};

struct trace_event_data_offsets_ack_update_msk {};

struct trace_event_data_offsets_subflow_check_data_avail {};

typedef void (*btf_trace_mptcp_subflow_get_send)(void *, struct mptcp_subflow_context *);

typedef void (*btf_trace_mptcp_sendmsg_frag)(void *, struct mptcp_ext *);

typedef void (*btf_trace_get_mapping_status)(void *, struct mptcp_ext *);

typedef void (*btf_trace_ack_update_msk)(void *, u64, u64, u64, u64, u64);

typedef void (*btf_trace_subflow_check_data_avail)(void *, __u8, struct sk_buff *);

struct mptcp_skb_cb {
	u64 map_seq;
	u64 end_seq;
	u32 offset;
	u8 has_rxtstamp: 1;
};

enum {
	MPTCP_CMSG_TS = 1,
	MPTCP_CMSG_INQ = 2,
};

struct mptcp_sendmsg_info {
	int mss_now;
	int size_goal;
	u16 limit;
	u16 sent;
	unsigned int flags;
	bool data_lock_held;
};

struct subflow_send_info {
	struct sock *ssk;
	u64 linger_time;
};

enum mapping_status {
	MAPPING_OK = 0,
	MAPPING_INVALID = 1,
	MAPPING_EMPTY = 2,
	MAPPING_DATA_FIN = 3,
	MAPPING_DUMMY = 4,
};

enum mptcp_addr_signal_status {
	MPTCP_ADD_ADDR_SIGNAL = 0,
	MPTCP_ADD_ADDR_ECHO = 1,
	MPTCP_RM_ADDR_SIGNAL = 2,
};

struct csum_pseudo_header {
	__be64 data_seq;
	__be32 subflow_seq;
	__be16 data_len;
	__sum16 csum;
};

struct mptcp_pm_add_entry;

struct token_bucket {
	spinlock_t lock;
	int chain_len;
	struct hlist_nulls_head req_chain;
	struct hlist_nulls_head msk_chain;
};

struct mptcp_iter_state {
	struct seq_net_private p;
	int num;
};

struct mptcp_seq_afinfo {
	sa_family_t family;
};

struct mptcp_pernet {
	struct ctl_table_header *ctl_table_hdr;
	unsigned int add_addr_timeout;
	unsigned int stale_loss_cnt;
	int mptcp_enabled;
	int checksum_enabled;
	int allow_join_initial_addr_port;
	int tcp_enabled;
	int dup_addr;
};

enum mptcp_pm_status {
	MPTCP_PM_ADD_ADDR_RECEIVED = 0,
	MPTCP_PM_ADD_ADDR_SEND_ACK = 1,
	MPTCP_PM_RM_ADDR_RECEIVED = 2,
	MPTCP_PM_ESTABLISHED = 3,
	MPTCP_PM_SUBFLOW_ESTABLISHED = 4,
	MPTCP_PM_ALREADY_ESTABLISHED = 5,
	MPTCP_PM_MPC_ENDPOINT_ACCOUNTED = 6,
};

enum {
	INET_ULP_INFO_UNSPEC = 0,
	INET_ULP_INFO_NAME = 1,
	INET_ULP_INFO_TLS = 2,
	INET_ULP_INFO_MPTCP = 3,
	__INET_ULP_INFO_MAX = 4,
};

enum {
	MPTCP_SUBFLOW_ATTR_UNSPEC = 0,
	MPTCP_SUBFLOW_ATTR_TOKEN_REM = 1,
	MPTCP_SUBFLOW_ATTR_TOKEN_LOC = 2,
	MPTCP_SUBFLOW_ATTR_RELWRITE_SEQ = 3,
	MPTCP_SUBFLOW_ATTR_MAP_SEQ = 4,
	MPTCP_SUBFLOW_ATTR_MAP_SFSEQ = 5,
	MPTCP_SUBFLOW_ATTR_SSN_OFFSET = 6,
	MPTCP_SUBFLOW_ATTR_MAP_DATALEN = 7,
	MPTCP_SUBFLOW_ATTR_FLAGS = 8,
	MPTCP_SUBFLOW_ATTR_ID_REM = 9,
	MPTCP_SUBFLOW_ATTR_ID_LOC = 10,
	MPTCP_SUBFLOW_ATTR_PAD = 11,
	__MPTCP_SUBFLOW_ATTR_MAX = 12,
};

enum {
	MPTCP_PM_ATTR_UNSPEC = 0,
	MPTCP_PM_ATTR_ADDR = 1,
	MPTCP_PM_ATTR_RCV_ADD_ADDRS = 2,
	MPTCP_PM_ATTR_SUBFLOWS = 3,
	__MPTCP_PM_ATTR_MAX = 4,
};

enum {
	MPTCP_PM_ADDR_ATTR_UNSPEC = 0,
	MPTCP_PM_ADDR_ATTR_FAMILY = 1,
	MPTCP_PM_ADDR_ATTR_ID = 2,
	MPTCP_PM_ADDR_ATTR_ADDR4 = 3,
	MPTCP_PM_ADDR_ATTR_ADDR6 = 4,
	MPTCP_PM_ADDR_ATTR_PORT = 5,
	MPTCP_PM_ADDR_ATTR_FLAGS = 6,
	MPTCP_PM_ADDR_ATTR_IF_IDX = 7,
	__MPTCP_PM_ADDR_ATTR_MAX = 8,
};

enum {
	MPTCP_PM_CMD_UNSPEC = 0,
	MPTCP_PM_CMD_ADD_ADDR = 1,
	MPTCP_PM_CMD_DEL_ADDR = 2,
	MPTCP_PM_CMD_GET_ADDR = 3,
	MPTCP_PM_CMD_FLUSH_ADDRS = 4,
	MPTCP_PM_CMD_SET_LIMITS = 5,
	MPTCP_PM_CMD_GET_LIMITS = 6,
	MPTCP_PM_CMD_SET_FLAGS = 7,
	__MPTCP_PM_CMD_AFTER_LAST = 8,
};

enum mptcp_event_attr {
	MPTCP_ATTR_UNSPEC = 0,
	MPTCP_ATTR_TOKEN = 1,
	MPTCP_ATTR_FAMILY = 2,
	MPTCP_ATTR_LOC_ID = 3,
	MPTCP_ATTR_REM_ID = 4,
	MPTCP_ATTR_SADDR4 = 5,
	MPTCP_ATTR_SADDR6 = 6,
	MPTCP_ATTR_DADDR4 = 7,
	MPTCP_ATTR_DADDR6 = 8,
	MPTCP_ATTR_SPORT = 9,
	MPTCP_ATTR_DPORT = 10,
	MPTCP_ATTR_BACKUP = 11,
	MPTCP_ATTR_ERROR = 12,
	MPTCP_ATTR_FLAGS = 13,
	MPTCP_ATTR_TIMEOUT = 14,
	MPTCP_ATTR_IF_IDX = 15,
	MPTCP_ATTR_RESET_REASON = 16,
	MPTCP_ATTR_RESET_FLAGS = 17,
	__MPTCP_ATTR_AFTER_LAST = 18,
};

struct mptcp_pm_addr_entry {
	struct list_head list;
	struct mptcp_addr_info addr;
	u8 flags;
	int ifindex;
	struct socket *lsk;
};

struct mptcp_pm_add_entry {
	struct list_head list;
	struct mptcp_addr_info addr;
	struct timer_list add_timer;
	struct mptcp_sock *sock;
	u8 retrans_times;
};

struct pm_nl_pernet {
	spinlock_t lock;
	struct list_head local_addr_list;
	unsigned int addrs;
	unsigned int stale_loss_cnt;
	unsigned int add_addr_signal_max;
	unsigned int add_addr_accept_max;
	unsigned int local_addr_max;
	unsigned int subflows_max;
	unsigned int next_id;
	long unsigned int id_bitmap[4];
};

struct mptcp_info {
	__u8 mptcpi_subflows;
	__u8 mptcpi_add_addr_signal;
	__u8 mptcpi_add_addr_accepted;
	__u8 mptcpi_subflows_max;
	__u8 mptcpi_add_addr_signal_max;
	__u8 mptcpi_add_addr_accepted_max;
	__u32 mptcpi_flags;
	__u32 mptcpi_token;
	__u64 mptcpi_write_seq;
	__u64 mptcpi_snd_una;
	__u64 mptcpi_rcv_nxt;
	__u8 mptcpi_local_addr_used;
	__u8 mptcpi_local_addr_max;
	__u8 mptcpi_csum_enabled;
};

struct mptcp_subflow_data {
	__u32 size_subflow_data;
	__u32 num_subflows;
	__u32 size_kernel;
	__u32 size_user;
};

struct mptcp_subflow_addrs {
	union {
		__kernel_sa_family_t sa_family;
		struct sockaddr sa_local;
		struct sockaddr_in sin_local;
		struct sockaddr_in6 sin6_local;
		struct __kernel_sockaddr_storage ss_local;
	};
	union {
		struct sockaddr sa_remote;
		struct sockaddr_in sin_remote;
		struct sockaddr_in6 sin6_remote;
		struct __kernel_sockaddr_storage ss_remote;
	};
};

struct join_entry {
	u32 token;
	u32 remote_nonce;
	u32 local_nonce;
	u8 join_id;
	u8 local_id;
	u8 backup;
	u8 valid;
};

struct warn_args;

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

struct rc {
	long int (*fill)(void *, long unsigned int);
	uint8_t *ptr;
	uint8_t *buffer;
	uint8_t *buffer_end;
	long int buffer_size;
	uint32_t code;
	uint32_t range;
	uint32_t bound;
	void (*error)(char *);
};

struct lzma_header {
	uint8_t pos;
	uint32_t dict_size;
	uint64_t dst_size;
} __attribute__((packed));

struct writer {
	uint8_t *buffer;
	uint8_t previous_byte;
	size_t buffer_pos;
	int bufsize;
	size_t global_pos;
	long int (*flush)(void *, long unsigned int);
	struct lzma_header *header;
};

struct cstate {
	int state;
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
};

enum cpio_fields {
	C_MAGIC = 0,
	C_INO = 1,
	C_MODE = 2,
	C_UID = 3,
	C_GID = 4,
	C_NLINK = 5,
	C_MTIME = 6,
	C_FILESIZE = 7,
	C_MAJ = 8,
	C_MIN = 9,
	C_RMAJ = 10,
	C_RMIN = 11,
	C_NAMESIZE = 12,
	C_CHKSUM = 13,
	C_NFIELDS = 14,
};

struct fprop_local_single {
	long unsigned int events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct ida_bitmap {
	long unsigned int bitmap[16];
};

struct klist_waiter {
	struct list_head list;
	struct klist_node *node;
	struct task_struct___2 *process;
	int woken;
};

struct uevent_sock {
	struct list_head list;
	struct sock *sk;
};

struct radix_tree_preload {
	unsigned int nr;
	struct xa_node *nodes;
};

typedef struct {
	long unsigned int key[2];
} hsiphash_key_t;

enum format_type {
	FORMAT_TYPE_NONE = 0,
	FORMAT_TYPE_WIDTH = 1,
	FORMAT_TYPE_PRECISION = 2,
	FORMAT_TYPE_CHAR = 3,
	FORMAT_TYPE_STR = 4,
	FORMAT_TYPE_PTR = 5,
	FORMAT_TYPE_PERCENT_CHAR = 6,
	FORMAT_TYPE_INVALID = 7,
	FORMAT_TYPE_LONG_LONG = 8,
	FORMAT_TYPE_ULONG = 9,
	FORMAT_TYPE_LONG = 10,
	FORMAT_TYPE_UBYTE = 11,
	FORMAT_TYPE_BYTE = 12,
	FORMAT_TYPE_USHORT = 13,
	FORMAT_TYPE_SHORT = 14,
	FORMAT_TYPE_UINT = 15,
	FORMAT_TYPE_INT = 16,
	FORMAT_TYPE_SIZE_T = 17,
	FORMAT_TYPE_PTRDIFF = 18,
};

struct printf_spec {
	unsigned int type: 8;
	int field_width: 24;
	unsigned int flags: 8;
	unsigned int base: 8;
	int precision: 16;
};

struct xa_limit {
	u32 max;
	u32 min;
};

enum {
	st_wordstart = 0,
	st_wordcmp = 1,
	st_wordskip = 2,
	st_bufcpy = 3,
};

enum {
	st_wordstart___2 = 0,
	st_wordcmp___2 = 1,
	st_wordskip___2 = 2,
};

struct in6_addr;

enum reg_type {
	REG_TYPE_RM = 0,
	REG_TYPE_INDEX = 1,
	REG_TYPE_BASE = 2,
};

struct ip_esp_hdr {
	__be32 spi;
	__be32 seq_no;		/* Sequence number */
	__u8  enc_data[0];	/* Variable len but >=8. Mind the 64 bit alignment! */
};

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute pop
#endif

#endif /* __VMLINUX_H__ */
